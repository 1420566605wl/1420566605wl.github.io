<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>多走几步</title>
  
  <subtitle>多走几步</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-11T05:54:01.191Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>wl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术栈-wl</title>
    <link href="http://example.com/2020/10/11/%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%8A%80%E6%9C%AF%E6%A0%88-wl/"/>
    <id>http://example.com/2020/10/11/%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%8A%80%E6%9C%AF%E6%A0%88-wl/</id>
    <published>2020-10-11T05:44:13.000Z</published>
    <updated>2020-10-11T05:54:01.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><p><a href="">Data structure</a></p></li><li><p><a href="">Python</a></p></li><li><p><a href="">Golang</a></p></li><li><p><a href="">Web</a></p></li><li><p><a href="">Testing</a></p></li><li><p><a href="">Linux</a></p></li><li><p><a href="">Docker</a></p></li><li><p><a href="">Jenkins</a></p></li><li><p><a href="">elk</a></p></li><li><p><a href="">MySQL</a></p></li><li><p><a href="">redis</a></p></li><li><p><a href="">More</a></p></li><li><p><a href="https://1420566605wl.github.io/">返回首页</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;Data structure&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;Pyt</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/10/02/%E7%88%AC%E8%99%AB/Python%20-%20requests%20-%20%E5%90%AC%E9%9B%A8%E5%8D%B1%E6%A5%BC%20-%20%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E7%BD%91%E4%B8%8A%E5%AE%B6%E5%9B%AD/"/>
    <id>http://example.com/2020/10/02/%E7%88%AC%E8%99%AB/Python%20-%20requests%20-%20%E5%90%AC%E9%9B%A8%E5%8D%B1%E6%A5%BC%20-%20%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E7%BD%91%E4%B8%8A%E5%AE%B6%E5%9B%AD/</id>
    <published>2020-10-02T05:34:10.019Z</published>
    <updated>2020-10-02T05:34:10.020Z</updated>
    
    <content type="html"><![CDATA[    <a name="top"></a>    <div id="top_nav" class="navbar navbar-custom">        <nav id="nav_main" class="navbar-main">            <ul id="nav_left" class="navbar-list navbar-left">                <li class="navbar-branding">                    <a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo"></a>                </li>                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>            </ul>            <ul id="nav_right" class="navbar-list navbar-right">                <li>                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3">                        <button type="submit" id="zzk_search_button">                            <img src="/images/aggsite/search.svg" alt="搜索">                        </button>                    </form>                </li>                <li id="navbar_login_status" class="navbar-list">                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客">                    </a>                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=oS4PkibyMjZ9rGD5XAcLt99uW_s76Javy2up4dbnZNY" alt="短消息">                        <span id="msg_count" style="display: none"></span>                    </a>                    <div id="user_info" class="navbar-user-info dropdown">                        <a class="dropdown-button" href="https://home.cnblogs.com/">                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像">                        </a>                        <div class="dropdown-menu">                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>                            <a href="https://home.cnblogs.com/">我的园子</a>                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>                            <a href="javascript:void(0)" onclick="logout();">退出登录</a>                        </div>                    </div>                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signin/?returnUrl=https://www.cnblogs.com/">登录</a>                </li>            </ul>        </nav>    </div>        <!--done--><div id="home"><div id="header"><div id="blogTitle">        <a id="lnkBlogLogo" href="https://www.cnblogs.com/Neeo/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页"></a><!--done--><h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/Neeo/">仰望星空,脚踏实地</a></h1><h2></h2></div><!--end: blogTitle 博客的标题和副标题 --><div id="navigator"><ul id="navList"><li></li><li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/Neeo/">首页</a></li><li></li><li></li><li><!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li><li><a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">管理</a></li></ul><div class="blogStats"><span id="stats_post_count">随笔 - 1&nbsp; </span><span id="stats_article_count">文章 - 444&nbsp; </span><span id="stats-comment_count">评论 - 33</span></div><!--end: blogStats --></div><!--end: navigator 博客导航栏 --></div><!--end: header 头部 --><div id="main"><div id="mainContent"><div class="forFlow"><div id="post_detail">    <!--done-->    <div id="topics">        <div class="post">            <h1 class="postTitle">                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Neeo/articles/11511087.html">    <span>Python - requests</span>    </a>            </h1>            <div class="clear"></div>            <div class="postBody">                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">    <p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#about">About</a></li><li><a href="#requestsrequest">requests.request()</a><ul><li><a href="#请求接受的参数">请求接受的参数</a></li><li><a href="#响应对象支持的属性">响应对象支持的属性</a></li></ul></li><li><a href="#requestsget">requests.get()</a><ul><li><a href="#params参数">params参数</a></li><li><a href="#headers">headers</a></li><li><a href="#cookies">cookies</a></li><li><a href="#文件下载">文件下载</a></li></ul></li><li><a href="#requestspost">requests.post()</a><ul><li><a href="#data参数">data参数</a></li><li><a href="#文件上传">文件上传</a></li><li><a href="#json参数">json参数</a></li></ul></li><li><a href="#requestshead">requests.head()</a></li><li><a href="#requestsput">requests.put()</a></li><li><a href="#requestspatch">requests.patch()</a></li><li><a href="#requestsdelete">requests.delete()</a></li><li><a href="#requestssession">requests.Session()</a></li><li><a href="#证书验证">证书验证</a></li><li><a href="#代理设置">代理设置</a></li><li><a href="#超时">超时</a></li><li><a href="#认证设置">认证设置</a></li><li><a href="#异常处理">异常处理</a></li></ul></div><p></p><ul><li><a href="https://www.cnblogs.com/Neeo/p/10864123.html#python">返回Python目录</a></li><li><a href="https://www.cnblogs.com/Neeo/p/10864123.html#testing">返回测试目录</a></li><li><a href="https://www.cnblogs.com/Neeo">返回随笔首页</a></li></ul><h1 id="about">About</h1><blockquote><p>环境：win10 + Python3.6</p></blockquote><p>requests库是Python语言编写，基于urllib，采用Apache2 Licensed开源协议的HTTP库。<br><img src="https://img2018.cnblogs.com/blog/1168165/202001/1168165-20200116160640019-3882704.png" alt="" loading="lazy"><br>它相对于urllib更加方便，大大节约了代码量，完全满足了HTTP测试相关需求。</p><blockquote><p>关于urllib：<a href="https://www.cnblogs.com/Neeo/articles/11520952.html">https://www.cnblogs.com/Neeo/articles/11520952.html</a></p></blockquote><p><strong>安装</strong></p><pre><code>pip install requestspip install -i https://pypi.doubanio.com/simple/ requests</code></pre><p>使用之前需引入。</p><p><strong>测试安装是否成功</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import requests   # 回车不报错就算安装成功response = requests.get("https://www.baidu.com")print(response.status_code)  # 200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有网的情况下，返回了200表示安装成功。</p><p><strong>requests库的主要方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>requests.request()</td><td>构造一个请求，支持以下各种方法</td></tr><tr><td>requests.get()</td><td>获取html的主要方法</td></tr><tr><td>requests.head()</td><td>获取html头部信息的主要方法</td></tr><tr><td>requests.post()</td><td>向html网页提交post请求的方法</td></tr><tr><td>requests.put()</td><td>向html网页提交put请求的方法</td></tr><tr><td>requests.patch()</td><td>向html提交局部修改的请求</td></tr><tr><td>requests.delete()</td><td>向html提交删除请求</td></tr><tr><td>requests.Session()</td><td>session相关</td></tr></tbody></table><p>我们一起来看看都是怎么玩儿的。</p><h1 id="requestsrequest">requests.request()</h1><p>这一节非常的重要！！！能用到的参数、基本都在这节展开。</p><h2 id="请求接受的参数">请求接受的参数</h2><p>requests.request(method, url, **kwargs)类能够构造一个请求，支持不同的请求方式。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.request(method='get', url='https://www.baidu.com')print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>request类中来看看几个参数：</p><ul><li>method：请求方式。</li><li>url：请求URL。</li><li>**kwargs：<ul><li>params：字典或者字节序列，作为参数增加到url中，使用这个参数可以把一些键值对以<code>k1=v1&amp;k2=v2</code>的模式增加到url中，get请求中用的较多。</li><li>data：字典、字节序列或者文件对象，重点作为向服务器提供或提交资源，作为请求的请求体，与params不同放在url上不同。它也可以接受一个字符串对象。</li><li>json：json格式的数据，可以向服务器提交json类型的数据。</li><li>headers：字典，定义请求的请求头，比如可以headers字典定义user agent。</li><li>cookies：字典或者CookieJar。</li><li>auth：元组，用来支持HTTP认证功能。</li><li>files：字典，用来向服务器传输文件。</li><li>timeout：指定超时时间。</li><li>proxies：字典，设置代理服务器。</li><li>allow_redirects：开关，是否允许对URL进行重定向，默认为True。</li><li>stream：开关，是否对获取内容进行立即下载，默认为False，也就是立即下载。这里需要说明的，stream一般应用于流式请求，比如说下载大文件，不可能一次请求就把整个文件都下载了，不现实，这种情况下，就要设置<code>stream=True</code>，requests无法将连接释放回连接池，除非下载完了所有数据，或者调用了response.close。</li><li>verify：开关，用于SSL证书认证，默认为True。</li><li>cert：用于设置保存本地SSL证书路径。</li></ul></li></ul><blockquote><p>流式请求，指的不是请求是流，而是请求返回的数据流，返回一点取一点，而普通的请求是返回完毕你再取内容。</p></blockquote><h2 id="响应对象支持的属性">响应对象支持的属性</h2><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.request(method='get', url='http://www.httpbin.org/get')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当一个请求被发送后，会有一个response响应。requests同样为这个response赋予了相关方法：</p><ul><li>response：响应对象。</li><li>response.status_code：请求返回状态码。</li><li>response.text：字符串形式的响应内容。</li><li>response.json()：返回响应的是json类型的数据，如果响应的类型不是json，则抛出<code>ValueError </code>。</li><li>response.content：二进制的响应内容。</li><li>response.iter_content(chunk_size)：生成器，在<code>stream=True</code>的情况下，当遍历生成器时，以块的形式返回，也就是一块一块的遍历要下载的内容。避免了遇到大文件一次性的将内容读取到内存中的弊端，如果<code>stream=False</code>，全部数据作为一个块返回。chunk_size参数指定块大小。</li><li>response.iter_lines()：生成器，当<code>stream=True</code>时，迭代响应数据，每次一行，也就是一行一行的遍历要下载的内容。同样避免了大文件一次性写入到内存中的问题。当然，该方法不安全。至于为啥不安全，咱也不知道，咱也不敢问，主要是<a href="https://2.python-requests.org//zh_CN/latest/api.html">官网</a>上没说！经查，如果多次调用该方法，iter_lines不保证重新进入时的安全性，因此可能会导致部分收到的数据丢失。</li><li>response.cookies：响应中的cookie信息。</li><li>response.cookies.get_dict()：以字典的形式返回cookies信息。</li><li>response.cookies.items()：以列表的形式返回cookies信息。</li><li>response.headers：响应头字典。取其中的指定key，<code>response.headers.get('Content-Type',  '哎呀，没取到！')</code></li><li>response.reqeust：请求类型。</li><li>response.url：请求的URL。</li><li>response.reason：响应HTTP状态的文本原因。</li><li>response.encoding：响应结果的编码方式。</li><li>response.encoding = “gbk”：修该响应编码方式，比如说响应结果的编码是utf-8，通过这么<code>response.encoding = “gbk”</code>指定为gbk。</li><li>response.apparent_encoding：根据响应字节流中去chardet库中匹配，返回编码方式，并不保证100%准确。</li><li>response.history：以列表的形式返回请求记录。列表内的请求以最老到最新排序。</li></ul><blockquote><p>see also：<a href="https://www.cnblogs.com/Neeo/articles/10835898.html#http%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81">HTTP协议状态码</a> | <a href="https://www.cnblogs.com/Neeo/articles/11528011.html">chardet</a></p></blockquote><h1 id="requestsget">requests.get()</h1><p><code>requests.get(url, params=None, **kwargs)</code>发送<code>GET</code>请求。相关参数：</p><ul><li>url，请求的URL。</li><li>params参数： 可选url中的额外参数，字典或者字节流格式。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><h2 id="params参数">params参数</h2><p>get请求难免会带一些额外的参数<code>K1=V1&amp;K2=V2</code>。</p><p>我们可以手动的拼接：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.get(url='http://www.httpbin.org/get?k1=v1&amp;k2=v2')print(response.url)  # http://www.httpbin.org/get?k1=v1&amp;k2=v2print(response.json().get('args'))  # {'k1': 'v1', 'k2': 'v2'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然没问题，但是稍显麻烦。</p><p>现在，我们可以使用params参数来解决这个问题。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsparams = {"user": "张开", "pwd": "666"}response = requests.get(url='http://www.httpbin.org/get', params=params)print(response.url)  # http://www.httpbin.org/get?user=%E5%BC%A0%E5%BC%80&amp;pwd=666print(response.json().get('args'))  # {'pwd': '666', 'user': '张开'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="headers">headers</h2><p>再来看，<code>GET</code>请求中如何携带headers。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsheaders = {"user-agent": UserAgent().random}response = requests.get(url='http://www.httpbin.org/get', headers=headers)print(response.json()['headers']['User-Agent'])  # Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-TW) AppleWebKit/533.19.4 (KHTML, like Gecko) Version/5.0.2 Safari/533.18.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于 fake_useragent：<a href="https://www.cnblogs.com/Neeo/articles/11525001.html">https://www.cnblogs.com/Neeo/articles/11525001.html</a></p></blockquote><h2 id="cookies">cookies</h2><p>来看，requests模块如何携带cookis参数。</p><pre class="line-numbers language-language-python"><code class="language-language-python"># 1. 登录,获取cookies值data = {    "userName": "=admin",    "password": "1234"}response = requests.post(url="http://www.neeo.cc:6002/pinter/bank/api/login", data=data)print(response.json())print(response.cookies)print(response.cookies.get_dict())# 2. 在需要cookies验证的时候，携带上刚才获取到的cookies值response = requests.get(url='http://www.neeo.cc:6002/pinter/bank/api/query?userName=admin', cookies=response.cookies.get_dict())print(response.status_code)print(response.json())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件下载">文件下载</h2><p>如果你访问的是一个小文件，或者图片之类的，我们可以直接写入到本地就完了，也就是不用管<code>stream</code>，让它默认为False即可。</p><p>来个美女图片提提神！</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsimport webbrowserurl = 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1568638318957&amp;di=1d7f37e7caece1c39af05b624f42f0a7&amp;imgtype=0&amp;src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201501%2F17%2F20150117224236_vYFmL.jpeg'response = requests.get(url=url)f = open('a.jpeg', 'wb')f.write(response.content)f.close()webbrowser.open('a.jpeg')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>过瘾不？</p><p>那要是下载大文件，可就不能这么干了：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsimport webbrowserurl = 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1568638318957&amp;di=1d7f37e7caece1c39af05b624f42f0a7&amp;imgtype=0&amp;src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201501%2F17%2F20150117224236_vYFmL.jpeg'response = requests.get(url=url, stream=True)with open('a.jpeg', 'wb') as f:    for chunk in response.iter_content(chunk_size=256):        f.write(chunk)webbrowser.open('a.jpeg')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>response.iter_content(chunk_size=256)</code>一块一块下载，并且可以指定chunk_size大小。</p><p>当然，也可以使用<code>response.iter_lines</code>一行一行遍历下载，但是官网说不安全，所以，忘掉它吧。</p><h1 id="requestspost">requests.post()</h1><p><code>requests.post(url, data=None, json=None, **kwargs)</code>发送<code>POST</code>请求，相关参数：</p><ul><li>url：请求的URL。</li><li>data：可选参数，请求中携带表单编码的字典、bytes或者文件对象。</li><li>json：请求中携带json类型的数据。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><p>在post请求中，data与json既可以是str类型，也可以是dict类型。</p><p>区别：</p><p>1、不管json是str还是dict，如果不指定headers中的content-type，默认为application/json</p><p>2、data为dict时，如果不指定content-type，默认为application/x-www-form-urlencoded，相当于普通form表单提交的形式</p><p>3、data为str时，如果不指定content-type，默认为application/json</p><p>4、用data参数提交数据时，request.body的内容则为<code>a=1&amp;b=2</code>的这种形式，用json参数提交数据时，request.body的内容则为<code>'{"a": 1, "b": 2}'</code>的这种形式</p><p>实际应用时候，需要根据后端服务处理的方式来确定</p><h2 id="data参数">data参数</h2><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://www.httpbin.org/post'# data为字典data_dict = {"k1": "v1"}response = requests.post(url=url, data=data_dict)print(response.json())# data为字符串data_str = "abc"response = requests.post(url=url, data=data_str)print(response.json(), type(response.json()['data']))# data为文件对象file = open('a.jpg', 'rb')response = requests.post(url=url, data=file)print(response.json())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的基于data参数上传文件，不如使用专门的<code>files</code>参数来的合适。</p><h2 id="文件上传">文件上传</h2><p>基于<code>POST</code>请求的文件上传，使用<code>files</code>参数。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsfile = {"file": open('a.jpg', 'rb')}response = requests.post('http://www.httpbin.org/post', files=file)print(response.json())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="json参数">json参数</h2><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://www.httpbin.org/post'response = requests.post(url=url, json={"user": "zhangkai"})print(response.json())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="requestshead">requests.head()</h1><p><code>requests.head(url, **kwargs)</code>发送<code>HEAD</code>请求，相关参数：</p><ul><li>url：请求URL。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://httpbin.org/get'response = requests.head(url=url)print(response.headers)'''{    'Access-Control-Allow-Credentials': 'true',     'Access-Control-Allow-Origin': '*',     'Content-Encoding': 'gzip',     'Content-Type': 'application/json',     'Date': 'Mon, 16 Sep 2019 10:58:07 GMT',     'Referrer-Policy': 'no-referrer-when-downgrade',     'Server': 'nginx',     'X-Content-Type-Options': 'nosniff',     'X-Frame-Options': 'DENY',     'X-XSS-Protection': '1; mode=block',     'Connection': 'keep-alive'}'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>requests.head(url, **kwargs)</code>的优点就是以较少的流量获得响应头信息，也可以用在分页中。</p><h1 id="requestsput">requests.put()</h1><p><code>requests.put(url, data=None, **kwargs)</code>发送<code>PUT</code>请求，相关参数：</p><ul><li>url：请求URL。</li><li>data：可选参数，请求中携带表单编码的字典、bytes或者文件对象。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://www.httpbin.org/put'data_dict = {"k1": "v1"}response = requests.put(url=url, data=data_dict)print(response.json())'''{    'args': {},     'data': '',     'files': {},     'form': {'k1': 'v1'},     'headers': {        'Accept': '*/*',         'Accept-Encoding': 'gzip, deflate',         'Content-Length': '5',         'Content-Type': 'application/x-www-form-urlencoded',         'Host': 'www.httpbin.org',         'User-Agent': 'python-requests/2.19.1'    },     'json': None,     'origin': '1.202.184.14, 1.202.184.14',     'url': 'https://www.httpbin.org/put'}'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="requestspatch">requests.patch()</h1><p><code>requests.patch(url, data=None, **kwargs)</code>发送<code>PATCH</code>请求，相关参数：</p><ul><li>url：请求URL。</li><li>data：可选参数，请求中携带表单编码的字典、bytes或者文件对象。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://www.httpbin.org/patch'data_dict = {"k1": "v1"}response = requests.patch(url=url, data=data_dict)print(response.json())'''{       'args': {},     'data': '',     'files': {},     'form': {'k1': 'v1'},     'headers': {        'Accept': '*/*',         'Accept-Encoding': 'gzip, deflate',         'Content-Length': '5',         'Content-Type': 'application/x-www-form-urlencoded',         'Host': 'www.httpbin.org',         'User-Agent': 'python-requests/2.19.1'    },     'json': None,     'origin': '1.202.184.14, 1.202.184.14',     'url': 'https://www.httpbin.org/patch'}'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在requests中，<code>PATCH</code>请求和<code>PUT</code>类似。而区别：</p><ul><li><code>PATCH</code>是对<code>PUT</code>方法的补充，用来对已知资源进行局部更新。</li><li><code>PATCH</code>相比<code>PUT</code>更加节省带宽。</li></ul><h1 id="requestsdelete">requests.delete()</h1><p><code>requests.head(url, **kwargs)</code>发送<code>DELETE</code>请求，相关参数：</p><ul><li>url：请求URL。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">import requeststest_url = 'https://api.github.com'def get_url(url):    return '/'.join([test_url,url])email = '24xxxxx48@qq.com'def delete_email():    r = requests.delete(get_url('user/emails'),json = email ,auth=('username','password'))    print(r.status_code)    print(r.text)    print(r.request.headers)delete_email()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将email，用户名，密码，换成自己的GitHub的。</p><h1 id="requestssession">requests.Session()</h1><p><code>requests.Session()</code>可以用来帮我们保持会话。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestssession = requests.Session()session.get('http://www.httpbin.org/cookies/set/username/root')response = session.get('http://www.httpbin.org/cookies')print(response.json())  # {'cookies': {'username': 'root'}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="证书验证">证书验证</h1><p>在之前，这个知识点还能拿12306网站举例的时候.....</p><p>如果你请求的<code>https</code>协议的网址，那么人家网站首先会检测你的证书是否是合法的，如果不合法，会抛出<code>SSLError</code>。怎么处理呢。</p><p>证书验证这里，有两种方式处理。第一种就是使用<code>verify</code>，是否进行证书校验，默认是True。我们选择不校验。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.get(url='https://www.12306.cn', verify=False)print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但有的时候，会有一个<code>Warnning</code>警告，建议你加证书验证。</p><p>我们可以选择忽略这个警告：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsfrom requests.packages import urllib3urllib3.disable_warnings()response = requests.get(url='https://www.12306.cn', verify=False)print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以选择提供一个CA证书：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.get(url='https://www.12306.cn', cert=('/path/server.crt', 'path/key'))print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，我们没有什么CA证书，这就看个热闹吧。</p><h1 id="代理设置">代理设置</h1><p>代理：就是你访问一个网站，其实并不是你直接访问的，而是你发请求给A机器，A机器取请求B机器。B返回给A，A再返回给你。代理就是中间人的意思。为什么需要代理？因为：反爬虫网站一般使用IP来识别一个机器。老是一个IP在不停访问网站，该网站就会把这个IP拉入黑名单，不允许访问。这时，就需要很多IP再扰乱反爬虫工具的思维，避免封IP。</p><p><strong>普通代理</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsproxies = {    "http": "http://10.10.1.10:3128",    "https": "https://10.10.1.10:1080",}response = requests.get(url='https://www.12306.cn', proxies=proxies)print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代理需要用户名和密码</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsproxies = {    "http": "http://user:password@10.10.1.10:3128",}response = requests.get(url='https://www.12306.cn', proxies=proxies)print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持sock代理</strong></p><p>想要支持sock代理，那么首先要下载：</p><pre><code>pip install requests[socks]</code></pre><p>完事在用：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsproxies = {    'http': 'socks5://user:pass@host:port',    'https': 'socks5://user:pass@host:port'}respone=requests.get('https://www.12306.cn',proxies=proxies)print(respone.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="超时">超时</h1><p>超时，在规定的时间无响应。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsrespone=requests.get('https://www.12306.cn', timeout=0.0001)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="认证设置">认证设置</h1><p>有些网站，会弹出一个提示框，要求你输入用户名和密码。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsfrom requests.auth import HTTPBasicAuthresponse = requests.get(url='https://www.12306.cn', auth=HTTPBasicAuth(username='user', password='123'))print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>HTTPBasicAuth</code>的简写形式：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.get(url='https://www.12306.cn', auth=('user', '123'))print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="异常处理">异常处理</h1><p>异常处理相关异常类主要在<code>requests.exceptions</code>下，可以根据需求去翻看源码。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsfrom requests.exceptions import ReadTimeout, ConnectionError, RequestExceptiontry:    # RequestException    # response = requests.get(url='https://www.12306.com')    # ReadTimeout    # response = requests.get(url='https://www.12306.cn', timeout=0.01)    # ConnectionError ,断网演示...    response = requests.get(url='https://xueqiu.com/stock/f10/finmainindex.json')    # print(response.status_code)except ReadTimeout as e:    print('ReadTimeout:', e)except ConnectionError as e:    print('ConnectionError:', e)except RequestException as e:    print('RequestException:', e)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr color="purple">欢迎斧正，that's allsee also：[Requests: 让 HTTP 服务人类](http://2.python-requests.org/zh_CN/latest/index.html#requests-http) | <https: www.cnblogs.com="" linhaifeng="" articles="" 7785043.html=""> | <https: 2.python-requests.org="" en="" master=""> | [urllib](<https: www.cnblogs.com="" neeo="" articles="" 11520952.html="">) | [requests模块 - egon](https://www.cnblogs.com/linhaifeng/articles/7785043.html) | [python3 requests详解](<https: blog.csdn.net="" pittpakk="" article="" details="" 81218566="">) | [Python爬虫系列（三）：requests高级耍法](<https: www.jianshu.com="" p="" 9ccebab67cc1="">) | [requests库入门08-delete请求](https://www.cnblogs.com/myal/p/9337384.html) | [请求接口时params和data的区别](https://blog.csdn.net/weixin_34130269/article/details/93193952) | [python request.post请求data参数与json参数的区别](https://blog.csdn.net/u011498011/article/details/96300354)</https:></https:></https:></https:></https:></div><div id="MySignature"></div><div class="clear"></div><div id="blog_post_info_block">    <div id="blog_post_info"></div>    <div class="clear"></div>    <div id="post_next_prev"></div></div>            </div>            <div class="postDesc">posted @ <span id="post-date">2019-09-16 22:37</span>&nbsp;<a href="https://www.cnblogs.com/Neeo/">听雨危楼</a>&nbsp;阅读(<span id="post_view_count">1538</span>)&nbsp;评论(<span id="post_comment_count">1</span>)&nbsp;<a href="https://i.cnblogs.com/EditArticles.aspx?postid=11511087" rel="nofollow">编辑</a>&nbsp;<a href="javascript:void(0)" onclick="AddToWz(11511087);return false;">收藏</a></div>        </div>            </div><!--end: topics 文章、评论容器--></div><script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script><script>markdown_highlight();</script><script>    var allowComments = true, cb_blogId = 356352, cb_blogApp = 'Neeo', cb_blogUserGuid = 'd9c29d9f-8210-4711-e20c-08d49c350eca';    var cb_entryId = 11511087, cb_entryCreatedDate = '2019-09-16 22:37', cb_postType = 2;    loadViewCount(cb_entryId);</script><a name="!comments"></a><div id="blog-comments-placeholder"></div><script>    var commentManager = new blogCommentManager();    commentManager.renderComments(0);</script><div id="comment_form" class="commentform">    <a name="commentform"></a>    <div id="divCommentShow"></div>    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>    <div id="comment_form_container"></div>    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>    <div id="ad_t2"></div>    <div id="opt_under_post"></div>    <div id="cnblogs_c1" class="c_ad_block">        <div id="div-gpt-ad-1592365906576-0" style="width: 300px; height: 250px;"></div>    </div>    <div id="under_post_news"></div>    <div id="cnblogs_c2" class="c_ad_block">        <div id="div-gpt-ad-1592366332455-0" style="width: 468px; height: 60px;"></div>    </div>    <div id="under_post_kb"></div>    <div id="HistoryToday" class="c_ad_block"></div>    <script type="text/javascript">        fixPostBody();        deliverBigBanner();setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverT2();        deliverC1C2();        loadNewsAndKb();        loadBlogSignature();LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);        loadOptUnderPost();        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);    </script></div></div><!--end: forFlow --></div><!--end: mainContent 主体内容容器--><div id="sideBar"><div id="sideBarMain"><div id="sidebar_news" class="newsItem">            <script>loadBlogNews();</script></div><div id="sidebar_ad"></div><div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script><div id="leftcontentcontainer"><div id="blog-sidecolumn"></div>                    <script>loadBlogSideColumn();</script></div></div><!--end: sideBarMain --></div><!--end: sideBar 侧边栏容器 --><div class="clear"></div></div><!--end: main --><div class="clear"></div><div id="footer"><!--done-->Copyright © 2020 听雨危楼<br><span id="poweredby">Powered by .NET Core on Kubernetes</span></div><!--end: footer --></div><!--end: home 自定义的最大容器 -->        <script>    var _hmt = _hmt || [];    (function() {      var hm = document.createElement("script");      hm.src = "https://hm.baidu.com/hm.js?39b794a97f47c65b6b2e4e1741dcba38";      var s = document.getElementsByTagName("script")[0];      s.parentNode.insertBefore(hm, s);    })();    </script><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">
    &lt;a name=&quot;top&quot;&gt;&lt;/a&gt;
    &lt;div id=&quot;top_nav&quot; class=&quot;navbar navbar-custom&quot;&gt;
        &lt;nav id=&quot;nav_main&quot; class=&quot;navbar-main&quot;&gt;
            &lt;ul </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/10/02/%E7%88%AC%E8%99%AB/Python%20-%20urllib%20-%20%E5%90%AC%E9%9B%A8%E5%8D%B1%E6%A5%BC%20-%20%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E7%BD%91%E4%B8%8A%E5%AE%B6%E5%9B%AD/"/>
    <id>http://example.com/2020/10/02/%E7%88%AC%E8%99%AB/Python%20-%20urllib%20-%20%E5%90%AC%E9%9B%A8%E5%8D%B1%E6%A5%BC%20-%20%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E7%BD%91%E4%B8%8A%E5%AE%B6%E5%9B%AD/</id>
    <published>2020-10-02T05:33:13.095Z</published>
    <updated>2020-10-02T05:33:13.096Z</updated>
    
    <content type="html"><![CDATA[    <a name="top"></a>    <div id="top_nav" class="navbar navbar-custom">        <nav id="nav_main" class="navbar-main">            <ul id="nav_left" class="navbar-list navbar-left">                <li class="navbar-branding">                    <a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo"></a>                </li>                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>            </ul>            <ul id="nav_right" class="navbar-list navbar-right">                <li>                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3">                        <button type="submit" id="zzk_search_button">                            <img src="/images/aggsite/search.svg" alt="搜索">                        </button>                    </form>                </li>                <li id="navbar_login_status" class="navbar-list">                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客">                    </a>                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=oS4PkibyMjZ9rGD5XAcLt99uW_s76Javy2up4dbnZNY" alt="短消息">                        <span id="msg_count" style="display: none"></span>                    </a>                    <div id="user_info" class="navbar-user-info dropdown">                        <a class="dropdown-button" href="https://home.cnblogs.com/">                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像">                        </a>                        <div class="dropdown-menu">                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>                            <a href="https://home.cnblogs.com/">我的园子</a>                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>                            <a href="javascript:void(0)" onclick="logout();">退出登录</a>                        </div>                    </div>                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signin/?returnUrl=https://www.cnblogs.com/">登录</a>                </li>            </ul>        </nav>    </div>        <!--done--><div id="home"><div id="header"><div id="blogTitle">        <a id="lnkBlogLogo" href="https://www.cnblogs.com/Neeo/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页"></a><!--done--><h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/Neeo/">仰望星空,脚踏实地</a></h1><h2></h2></div><!--end: blogTitle 博客的标题和副标题 --><div id="navigator"><ul id="navList"><li></li><li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/Neeo/">首页</a></li><li></li><li></li><li><!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li><li><a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">管理</a></li></ul><div class="blogStats"><span id="stats_post_count">随笔 - 1&nbsp; </span><span id="stats_article_count">文章 - 444&nbsp; </span><span id="stats-comment_count">评论 - 33</span></div><!--end: blogStats --></div><!--end: navigator 博客导航栏 --></div><!--end: header 头部 --><div id="main"><div id="mainContent"><div class="forFlow"><div id="post_detail">    <!--done-->    <div id="topics">        <div class="post">            <h1 class="postTitle">                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Neeo/articles/11520952.html">    <span>Python - urllib</span>    </a>            </h1>            <div class="clear"></div>            <div class="postBody">                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">    <p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#about">About</a></li><li><a href="#urllib、urllib2、urllib3傻傻分不清楚">urllib、urllib2、urllib3傻傻分不清楚</a></li><li><a href="#urllibrequest">urllib.request</a><ul><li><a href="#请求">请求</a></li><li><a href="#响应">响应</a></li><li><a href="#request对象">request对象</a></li><li><a href="#cookie">Cookie</a></li><li><a href="#代理">代理</a></li><li><a href="#下载">下载</a></li></ul></li><li><a href="#urlliberror">urllib.error</a></li><li><a href="#urllibparse">urllib.parse</a></li><li><a href="#urllibrobotparser">urllib.robotparser</a><ul><li><a href="#robots协议">Robots协议</a></li><li><a href="#robotfileparser">RobotFileParser</a></li></ul></li></ul></div><p></p><ul><li><a href="https://www.cnblogs.com/Neeo/p/10864123.html#python">返回上一页</a></li></ul><h1 id="about">About</h1><p>urllib是Python内置的HTTP请求库。urllib 模块提供的上层接口，使访问 www 和 ftp 上的数据就像访问本地文件一样，并且它也是requests的底层库。</p><p>其中包括4个主要模块：</p><ul><li>urllib.request：请求模块。</li><li>urllib.error：异常处理模块。</li><li>urllib.parse：URL解析模块。</li><li>urllib.robotparser：robots.txt解析模块。</li></ul><p>这里以Python3.6为例。</p><h1 id="urllib、urllib2、urllib3傻傻分不清楚">urllib、urllib2、urllib3傻傻分不清楚</h1><p>在Python2.x中，分为urllib和urllib2，简单来说，urllib2是urllib的增强版，但urllib中的函数又比urllib2多一些，对于简单的下载之类的，urllib绰绰有余，如果涉及到实现HTTP身份验证或者cookie或者扩展编写自定义协议，urllib2更好一些。</p><ul><li><p>urllib支持设置编码的函数urllib.urlencode，在模拟登陆的时候经常需要传递经过post编码之后的参数，如果不想使用第三方库完成模拟登录，就必须使用到标准库中的urllib。urllib提供一些比较原始基础的方法而urllib2并没有，比如urllib中的urlencode方法用来GET查询字符串的产生。</p></li><li><p>urllib2比较有优势的地方在于urllib2.openurl中可以接受一个Request类的实例来设置Request参数，来修改/设置Header头从而达到控制HTTP Request的header部分的目的，也可以修改用户代理,设置cookie等，但urllib仅可以接受URL。这就意味着，如果你访问一个网站想更改User Agent(可以伪装你的浏览器)，你就需要使用urllib2。</p></li><li><p>urllib2模块没有加入urllib.urlretrieve函数以及urllib.quote等一系列quote和unquote功能，这个时候就需要urllib的辅助。</p></li></ul><p>因此，在Python2.x中，这两个库可以搭配使用。<br>而urllib3则是增加了连接池等功能，两者互相都有补充的部分。<br>那么Python3.x中呢，urllib和urllib2都合并到了urllib中了，所以，啥也别想了，Python3.x即将一统江湖，所以，我们还是踏实儿的学习Python3.x下的urllib吧。</p><p>再来看看Python2.x和Python3.x的区别。<br>在Python2.x中，<code>urlopen</code>方法在urllib下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib2response = urllib2.urlopen()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在Python3.x中，<code>urlopen</code>方法就移动到了<code>urllib.request</code>下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="urllibrequest">urllib.request</h1><h2 id="请求">请求</h2><p>先来看urllib怎么发送请求。</p><p><strong>发送get请求</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllibresponse = urllib.request.urlopen('http://www.baidu.com')# 获取bytes类型的数据# print(response.read())# 想要获取到字符串类型的数据，需要使用 decode 转码为字符串print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>发送post请求</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.parsedata = bytes(urllib.parse.urlencode({'world': 'hello'}), encoding='utf-8')response = urllib.request.urlopen(url='http://httpbin.org/post', data=data)print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，需要了解一个<code>http://httpbin.org</code>这个网站，HTTPBin是以Python+Flask写的一款工具，它包含了各类的HTTP场景，且每个接口一定都有返回。</p><p>data参数需要字节类型的数据，所以，我们首先用bytes转码，然后将我们的字典使用<code>urllib.parse.urlencode</code>并指定编码方式完成编码。</p><p>另外，data参数用来控制请求方式，如果请求中有data则是post请求，否则为get请求。</p><p><strong>timeout</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import socketimport urllib.requestimport urllib.errortry:    # 没有超时，正常返回json格式的内容    # response = urllib.request.urlopen(url='http://www.httpbin.org/get', timeout=2)    # 超时会抛出异常，由异常语句捕获    response = urllib.request.urlopen(url='http://www.httpbin.org/get', timeout=0.1)    print(response.read().decode('utf-8'))except urllib.error.URLError as e:    # print(e)  # <urlopen error="" timed="" out="">    if isinstance(e.reason, socket.timeout):        print(e.reason)  # timed out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></urlopen></code></pre><p><code>e.reason</code>为错误原因。<code>timeout</code>单位是秒。</p><h2 id="响应">响应</h2><p>现在来研究urlopen返回对象提供的方法：</p><ul><li>read()，readline()，readlines()，fileno(), close()：这些方法与文件对象一样。</li><li>info()：返回一个httplibHTTPMessage对象，表示远程服务器返回的头信息。</li><li>getcode()：返回HTTP状态码。</li><li>geturl()：返回请求的url。</li></ul><p><strong>响应类型</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen(url='http://www.httpbin.org/get')print(response)  # <http.client.httpresponse object="" at="" 0x07b65270="">print(type(response))  # <class 'http.client.httpresponse'=""><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></class></http.client.httpresponse></code></pre><p><strong>状态码</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen(url='http://www.httpbin.org/get')print(response.status)  # 200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>响应头</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen(url='http://www.httpbin.org/get')print(response.headers)  print(response.getheaders())  # 列表类型的响应头print(response.getheader('Server', None))  # 获取特定的响应头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>响应体</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen(url='http://www.httpbin.org')# print(response.read())print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之前说过，urllib获取到的内容是字节形式，我们通过read读出来之后需要使用decode解码。</p><h2 id="request对象">request对象</h2><p>上面我们发送一些简单的请求没问题，但是复杂的请求（比如带headers）就力有不逮了。这个时候，我们需要学习一个<code>Request</code>来定制复杂的请求参数了。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestrequest = urllib.request.Request(url='http://www.httpbin.org')response = urllib.request.urlopen(request)print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们使用<code>urllib.request.Request</code>来构建一个request对象，然后传给<code>urlopen</code>即可。</p><p>再来看一个复杂点的带headers。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.parse# 指定urlurl='http://www.httpbin.org/post'# 自定义headersheaders = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36"}# 自定义data参数并编码为bytes类型data_dict = {"username": "zhangkai"}data = bytes(urllib.parse.urlencode(data_dict), encoding='utf-8')# 使用urllib.request.Request构造request对象request = urllib.request.Request(url=url, data=data, headers=headers, method='POST')# 将request对象交给urlopen发请求去吧response = urllib.request.urlopen(request)print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看一个<code>add_headers</code>方法。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.parseurl='http://www.httpbin.org/post'# 这里跟上面的示例区别就是不在单独指定headers字典# headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36"}data_dict = {"username": "zhangkai"}data = bytes(urllib.parse.urlencode(data_dict), encoding='utf-8')request = urllib.request.Request(url=url, data=data, method='POST')# 而是使用构造好的request对象下面的add_header方法添加header，换汤不换药....request.add_header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36")response = urllib.request.urlopen(request)print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>add_header</code>方法作为添加headers的补充方式，如果有多个header键值对，可以使用for循环一一添加进去.....</p><p>会了构造request对象，我们基本能应付大部分的网站了。</p><p>再来看看更复杂的一些用法，以应对更多的复杂环境，比如携带cookie什么的。</p><h2 id="cookie">Cookie</h2><p><strong>获取cookie</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport http.cookiejar# 声明 cookiejar 对象cookie = http.cookiejar.CookieJar()# 使用handler处理cookie对象handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)# 当opener.open发送请求response = opener.open('http://www.baidu.com')# 当response有了结果之后，会自动将cookie信息保存到上面声明的cookie对象中去print(cookie)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code> http.cookiejar</code>提供一个永久性的cookie对象。并且<code>cookiejar</code>有3个子类：</p><ul><li>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。</li><li>FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。</li><li>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</li><li>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</li></ul><p>大多数情况下，我们只用<code>CookieJar()</code>，如果需要和本地文件交互，就用 <code>MozillaCookjar()</code> 或 <code>LWPCookieJar()</code></p><p>补充：libwww-perl集合是一组Perl模块，它为万维网提供简单而一致的应用程序编程接口。该库的主要重点是提供允许您编写WWW客户端的类和函数。</p><p><strong>将cookie写入文件</strong></p><p>我们知道cookie是保持登录会话信息的凭证，那么在获取到cookie后写入本地，在cookie失效前，后续访问再读取本地文件，并在请求中携带，以达到继续保持登录信息的状态。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport http.cookiejar'''写入cookie对象到本地'''url = 'http://www.baidu.com'file_name = 'cookie.txt'# 这里将cookie信息处理成火狐浏览器cookie格式cookie = http.cookiejar.MozillaCookieJar(file_name)# LWPCookieJar格式cookie# cookie = http.cookiejar.LWPCookieJar(file_name)# 使用handler处理cookie对象handler = urllib.request.HTTPCookieProcessor(cookie1)opener = urllib.request.build_opener(handler)response1 = opener.open(url)# 将cookie信息保存到本地文件cookie1.save(ignore_discard=True, ignore_expires=True)'''读取本地cookie信息'''# 以什么格式保存，就以什么格式读出来，这里都用MozillaCookieJarcookie2 = http.cookiejar.MozillaCookieJar()# 使用load方法从本地读取cookie信息cookie2.load(file_name, ignore_discard=True, ignore_expires=True)# 放到handle中handler = urllib.request.HTTPCookieProcessor(cookie2)opener = urllib.request.build_opener(handler)response2 = opener.open(url)print(response2.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>save</code>和<code>load</code>中，有两个参数需要说明：</p><ul><li>ignore_discard：保存cookie，即使设置为丢弃的cookie也保存。</li><li>ignore_expires：如果cookie已过期也要保存到文件，并且如果文件存在则覆盖。后续可以使用<code>load</code>或者<code>revert</code>方法恢复保存的文件。</li></ul><h2 id="代理">代理</h2><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.request# 调用ProxyHandler 代理ip的形式是字典# 付费代理# money_proxy = {"协议":"username:pwd@ip:port"}proxy_handler = urllib.request.ProxyHandler({'sock5': 'localhost:1080'})# 使用build_opener构建opener对象opener = urllib.request.build_opener(proxy_handler)# 调用opener的open方法向指定url发请求response = opener.open('http://www.httpbin.org/get')print(response.read().decode('utf-8'))'''{  "args": {},   "headers": {    "Accept-Encoding": "identity",     "Host": "www.httpbin.org",     "User-Agent": "Python-urllib/3.6"  },   "origin": "124.64.16.181, 124.64.16.181",   "url": "https://www.httpbin.org/get"}'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>{'sock5': 'localhost:1080'}</code>中<code>sock5</code>是协议，<code>localhost:1080</code>是走本地的1080端口。</p><p>其实<code>urlopen</code>在内部也是调用了<code>opener.open</code>方法发送请求。</p><p>另外，返回结果<code>origin</code>是访问IP，而这个IP正好是我们使用的代理IP。</p><h2 id="下载">下载</h2><p>我们可以使用urllib下载图片，文件等到本地。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requesturl = 'http://n.sinaimg.cn/news/1_img/upload/cf3881ab/69/w1000h669/20190912/bed4-iepyyhh6925213.jpg' filename = 'a.jpg'# 使用urlretrieve进行下载操作urllib.request.urlretrieve(url=url, filename=filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，我们还可以使用<code>urllib.urlcleanup()</code>来清除<code>urllib.urlretrieve</code>所产生的缓存。</p><h1 id="urlliberror">urllib.error</h1><p>urllib中的异常处理有3个：</p><ul><li><code>urllib.error.URLError</code>：捕获关于url的错误，只有一个返回方法reason，错误原因。</li><li><code>urllib.error.HTTPError</code>：捕获关于http的错误，有3个返回方法。code，http中定义的http状态码；reason，错误原因；headers，响应头。</li><li><code>urllib.error.ContentTooShortError</code>：当<code>urlretrieve</code>检测到下载数据量小于预期时，会引发此异常。</li></ul><p><strong>urllib.error.URLError</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.errortry:    # 这里将 cnblogs 写成 cnblogsww    # response = urllib.request.urlopen(url='https://www.cnblogsww.com/Neeo/p/1083589221.html')    print(response.read().decode('utf-8'))except urllib.error.ContentTooShortError as e:    print('ContentTooShortError: ', e.reason)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>urllib.error.HTTPError</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.errortry:    headers = {        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36"}    # 不存在的 103048922222.html    response = urllib.request.urlopen(url='https://www.cnblogs.com/Neeo/p/103048922222.html')    print(response.read())except urllib.error.HTTPError as e:    print('HTTPError: ', e.reason, e.headers, e.code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>urllib.error.ContentTooShortError</strong></p><p>这个错误比较重要，因为我们在下载文件时，很可能会因为各种原因导致下载没有完成就失败了。这个时候，我们就可以使用<code>ContentTooShortError</code>来捕捉错误从新下载。如果重新下载还是下载失败，可以考虑使用递归，下载失败就重新下，直到下载成功。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.errortry:    url = 'http://n.sinaimg.cn/news/1_img/upload/cf3881ab/69/w1000h669/20190912/bed4-iepyyhh6925213.jpg'    filename = 'a.jpg'    urllib.request.urlretrieve(url=url, filename=filename)except urllib.error.ContentTooShortError as e:    print('ContentTooShortError: ', e.reason)    # 如果下载失败，就重新下载    urllib.request.urlretrieve(url=url, filename=filename)        def get_file(url, filename):""" 使用递归进行重新下载，直到下载成功为止 """    try:        urllib.request.urlretrieve(url=url, filename=filename)        print('download done ......')    except urllib.error.ContentTooShortError:        get_file(url, filename)url = "http://n.sinaimg.cn/news/1_img/upload/cf3881ab/69/w1000h669/20190912/bed4-iepyyhh6925213.jpg"filename = 'a.jpg'get_file(url, filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="urllibparse">urllib.parse</h1><p><code>urllib.parse</code>定义了URL的标准接口，实现对于URL的各种操作，包括解析、合并、编码、解码，使用之前需导入。</p><p><strong>urllib.parse.urlparse</strong></p><p><code>urllib.parse.urlparse</code>以元组的形式返回URL解析后的6个组件。对应的URL结构一般是这样的：</p><pre><code>scheme://netloc/path;parameters?query#fragment</code></pre><p>每个元组项都是一个字符串，也可能是空的。</p><p>返回的元组中：</p><ul><li>scheme：协议。</li><li>netloc：域名。</li><li>path：路径。</li><li>params：参数。</li><li>query：查询条件，一般用于个get请求的URL。</li><li>fragment：锚点。</li></ul><p>基本使用：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseurllib.parse.urlparse(url, scheme='', allow_fragments=True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>url：待解析的url</li><li>scheme：协议，如果URL中没有协议，则使用该参数设置协议，如果有协议，该参数不生效</li><li>allow_fragments:是否忽略锚点，默认为True，表示表示不忽略，False表示忽略</li></ul><p>示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseresult = urllib.parse.urlparse('https://www.cnblogs.com/Neeo/p/10864123.html?k1=v1#python')print(result)'''ParseResult(scheme='https', netloc='www.cnblogs.com', path='/Neeo/p/10864123.html', params='', query='k1=v1', fragment='python')'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>urllib.parse.urlunparse</strong></p><p>与<code>urlparse</code>相反，<code>urllib.parse.urlunparse</code>用来构造URL。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseurl_components = ['https', 'www.cnblogs.com', '/Neeo/p/10864123.html', '', '', 'python']result = urllib.parse.urlunparse(url_components)print(result)  # https://www.cnblogs.com/Neeo/p/10864123.html#python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>url_components</code>中，顺序必须遵循：</p><pre><code>scheme, netloc, url, params, query, fragment</code></pre><p>也就是6个选项都要有值，如果没有也要填充空字符串占位。</p><p><strong>urllib.parse.urljoin</strong></p><p><code>urllib.parse.urljoin</code>用来拼接URL。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parse# 将两个url拼接成一个完整的url，base_url + sub_urlprint(urllib.parse.urljoin('https://www.cnbogs.com', '/Neeo/p/10864123.html'))# 如果每个参数中都有相应的参数的话，比如都有协议，那么将以后面的为准print(urllib.parse.urljoin('https://www.cnbogs.com', 'http://www.baidu.com/Neeo/p/10864123.html'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，<code>urljoin</code>方法只能接受两个url参数：</p><pre><code>urljoin(base, url, allow_fragments=True)</code></pre><p>别意淫它能跟<code>os.path.join</code>一样可劲儿的往后拼！</p><p><strong>urllib.parse.urlencode</strong></p><p><code>urllib.parse.urlencode</code>将字典类型的参数序列化为url编码后的字符串，常用来构造get/post请求的参数<code>k1=v1&amp;k2=v2</code>。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseparams = {"k1": "v1", "k2": "v2"}encode_params = urllib.parse.urlencode(params)print('https://www.baidu.com?' + encode_params)  # https://www.baidu.com?k1=v1&amp;k2=v2# 这里用urljoin不好使, 它在处理base url时会将 ? 干掉print(urllib.parse.urljoin('https://www.baidu.com', encode_params))  # https://www.baidu.com/k1=v1&amp;k2=v2# 或者你继续使用拼接....好蛋疼print(urllib.parse.urljoin('https://www.baidu.com', '?' + encode_params))  # https://www.baidu.com?k1=v1&amp;k2=v2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>urllib.parse.quote系列</strong></p><p>按照标准，URL只允许一部分ASCII字符（数字字母和部分符号）,其他的字符如汉字是不符合URL标准的。所以在使用URL的时候，要进行URL编码。</p><p>urllib提供了<code>urllib.parse.quote</code>和<code>urllib.parse.quote_plus</code>进行URL编码。</p><p>而<code>urllib.parse.quote_plus</code>比<code>urllib.parse.quote</code>更近一步，会对<code>/</code>符号进行编码。</p><p>而<code>urllib.parse.unquote</code>和<code>urllib.parse.unquote_plus</code>则是将编码后的URL进行还原。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseurl = 'https://www.baidu.com/s?&amp;wd=张开'result = urllib.parse.quote(url)print(result)  # https%3A//www.baidu.com/s%3F%26wd%3D%E5%BC%A0%E5%BC%80result_plus = urllib.parse.quote_plus(url)print(result_plus)  # https%3A%2F%2Fwww.baidu.com%2Fs%3F%26wd%3D%E5%BC%A0%E5%BC%80un_result = urllib.parse.unquote(result)print(un_result)  # https://www.baidu.com/s?&amp;wd=张开un_result_plus = urllib.parse.unquote_plus(result_plus)print(un_result_plus)  # https://www.baidu.com/s?&amp;wd=张开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="urllibrobotparser">urllib.robotparser</h1><p>我们可以利用<code>urllib.robotparser</code>对爬取网站的Robots协议进行分析。</p><p>那问题来了，什么是Robots协议？</p><h2 id="robots协议">Robots协议</h2><p>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。robots.txt文件是一个文本文件，放在站点的根目录下。</p><p>当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p><p><strong>禁止所有爬虫访问任何内容</strong></p><pre><code>User-Agent:  *Disallow:  /</code></pre><p><strong>允许所有爬虫访问任何内容</strong></p><pre><code>User-Agent:  *Disallow: </code></pre><p><strong>允许某些爬虫访问某些目录</strong></p><pre><code>User-agent:  BaiduspiderAllow:  /articleAllow:  /oshtmlDisallow:  /product/Disallow:  /User-Agent:  GooglebotAllow:  /articleAllow:  /oshtmlAllow:  /productAllow:  /spuAllow:  /dianpuAllow:  /overseaAllow:  /listDisallow:  /User-Agent:  *Disallow:  /</code></pre><p><strong>关于爬虫名称</strong></p><table><thead><tr><th>爬虫名称</th><th>所属公司</th><th>网址</th></tr></thead><tbody><tr><td>Baiduspider</td><td>百度</td><td><a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td>Googlebot</td><td>谷歌</td><td><a href="http://www.google.com/">www.google.com</a></td></tr><tr><td>Bingbot</td><td>微软必应</td><td>cn.bing.com</td></tr><tr><td>360Spider</td><td>360搜索</td><td><a href="http://www.so.com/">www.so.com</a></td></tr><tr><td>Yisouspider</td><td>神马搜索</td><td><a href="http://m.sm.cn/">http://m.sm.cn/</a></td></tr><tr><td>Sogouspider</td><td>搜狗搜索</td><td><a href="https://www.sogou.com/">https://www.sogou.com/</a></td></tr><tr><td>Yahoo! Slurp</td><td>雅虎</td><td><a href="https://www.yahoo.com/">https://www.yahoo.com/</a></td></tr></tbody></table><h2 id="robotfileparser">RobotFileParser</h2><p>robotpaser模块提供RobotFileParser类来解析robots.txt文件，判断是否允许爬取网站的某一目录。</p><p>在实例化类时传入robots.txt。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.robotparserresponse = urllib.robotparser.RobotFileParser(url='https://www.zhihu.com/robots.txt')response.read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者通过实例化对象调用<code>set_url</code>方法传入robots.txt。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.robotparserresponse = urllib.robotparser.RobotFileParser()response.set_url('https://www.zhihu.com/robots.txt')response.read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>whatever，都需要使用<code>response.read()</code>读出来，不然后面解析不到。</p><p>常用方法：</p><ul><li>set_url(url)：用来设置 robots.txt 文件链接，如果在初次实例化 RobotFileParser 类的时候传入了 url 参数，那么就不需要再次调用此方法设置了。</li><li>read()：读取 robots.txt 文件并将读取结果交给 parse() 解析器进行解析。</li><li>parse(lines)：用来解析 robots.txt 文件内容，分析传入的某些行的协议内容。</li><li>can_fetch(useragent, url)：需要两个参数，User-Agent、所要抓取的 URL 链接，返回此搜索引擎是否允许抓取此 URL，返回结果为 True、False。</li><li>mtime()：返回上次抓取分析 robots.txt 文件的时间，这对于需要对 robots.txt 进行定期检查更新的长时间运行的网络爬虫非常有用 。</li><li>modified()：同样的对于长时间分析和抓取的搜索爬虫很有帮助，将当前时间设置为上次抓取和分析 robots.txt 的时间。</li><li>crawl_delay(useragent)：返回抓取延迟时间的值，从相应的 User-Agent 的 robots.txt 返回 Crawl-delay 参数的值。 如果没有这样的参数，或者它不适用于指定的 User-Agent，或者此参数的 robots.txt 条目语法无效，则返回 None。</li><li>request_rate(useragent)：从robots.txt返回Request-rate参数的内容，作为命名元组RequestRate（requests，seconds）。 如果没有这样的参数，或者它不适用于指定的useragent，或者此参数的robots.txt条目语法无效，则返回None。（Python3.6新增方法）</li></ul><p>示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.robotparserresponse = urllib.robotparser.RobotFileParser(url='https://www.zhihu.com/robots.txt')# 要有读操作response.read()# 判断某一个网址是否能爬取print(response.can_fetch('Googlebot', 'https://www.zhihu.com/question/268464407/answer/804631692'))  # Trueprint(response.can_fetch('*', 'https://www.zhihu.com/question/268464407/answer/804631692'))  # False# 返回上一次抓取分析 robots.txt 的时间print(response.mtime())  # 1568542822.1876643# 将当前时间设置为上次抓取和分析 robots.txt 的时间response.modified()# 返回 robots.txt 文件对请求频率的限制print(response.request_rate('MSNBot').requests)  # 1print(response.request_rate('*'))  # None# 返回 robots.txt 文件对抓取延迟限制print(response.crawl_delay('*'))  # Noneprint(response.crawl_delay('MSNBot'))  # 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用parser方法读取和分析robots.txt。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.robotparserimport urllib.request# 实例化 RobotFileParser 对象response = urllib.robotparser.RobotFileParser()# 使用parser读取 robots.txt 文件result = urllib.request.urlopen('https://www.zhihu.com/robots.txt').read().decode('utf-8').split('\n')response.parse(result)# 判断url是否可爬取print(response.can_fetch('Googlebot', 'https://www.zhihu.com/question/268464407/answer/804631692'))  # Trueprint(response.can_fetch('*', 'https://www.zhihu.com/question/268464407/answer/804631692'))  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr color="purple">欢迎斧正，that's allsee also：[http://www.httpbin.org/](<http: www.httpbin.org="">) | [使用HTTPBin测试HTTP库](<https: www.jianshu.com="" p="" 00db00cd287d="">) | [urllib  — URL handling modules](https://docs.python.org/3/library/urllib.html#module-urllib) | [http://www.66ip.cn/](http://www.66ip.cn/) | [HTTP模块](https://docs.python.org/3/library/http.html#module-http) | [使用ip付费的代理是遇到http.client.RemoteDisconnected: Remote end closed connection without response 解决方法](https://blog.csdn.net/lovlu18/article/details/79921885) | [http.cookiejar库之CookieJar](https://blog.csdn.net/levon2018/article/details/80558108) |[libwww-perl](https://github.com/libwww-perl/libwww-perl) | [爬虫保存cookies时重要的两个参数（ignore_discard和ignore_expires）的作用](https://blog.csdn.net/qq_33472765/article/details/80738923) | [http.cookiejar- HTTP客户端的Cookie处理](https://docs.python.org/3/library/http.cookiejar.html#module-http.cookiejar) | [[python]解决urllib.urlretrieve()下载不完全的问题](https://blog.csdn.net/Innovation_Z/article/details/51106601) | [urllib.parse模块使用](<https: www.jianshu.com="" p="" e7d87e1ed38c="">) | [4. Urllib -- urllib.robotparser](<https: www.jianshu.com="" p="" 21fc41453784="">) | [urllib.robotparser- robots.txt的解析器](<https: docs.python.org="" dev="" library="" urllib.robotparser.html#module-urllib.robotparser="">) | [urllib模块中的方法](<https: www.cnblogs.com="" sysu-blackbear="" p="" 3629420.html="">) | [python中quote函数是什么意思，怎么用](<https: zhidao.baidu.com="" question="" 1047750056353229099.html="">)</https:></https:></https:></https:></https:></https:></http:></div><div id="MySignature"></div><div class="clear"></div><div id="blog_post_info_block">    <div id="blog_post_info"></div>    <div class="clear"></div>    <div id="post_next_prev"></div></div>            </div>            <div class="postDesc">posted @ <span id="post-date">2019-09-15 01:14</span>&nbsp;<a href="https://www.cnblogs.com/Neeo/">听雨危楼</a>&nbsp;阅读(<span id="post_view_count">490</span>)&nbsp;评论(<span id="post_comment_count">0</span>)&nbsp;<a href="https://i.cnblogs.com/EditArticles.aspx?postid=11520952" rel="nofollow">编辑</a>&nbsp;<a href="javascript:void(0)" onclick="AddToWz(11520952);return false;">收藏</a></div>        </div>            </div><!--end: topics 文章、评论容器--></div><script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script><script>markdown_highlight();</script><script>    var allowComments = true, cb_blogId = 356352, cb_blogApp = 'Neeo', cb_blogUserGuid = 'd9c29d9f-8210-4711-e20c-08d49c350eca';    var cb_entryId = 11520952, cb_entryCreatedDate = '2019-09-15 01:14', cb_postType = 2;    loadViewCount(cb_entryId);</script><a name="!comments"></a><div id="blog-comments-placeholder"></div><script>    var commentManager = new blogCommentManager();    commentManager.renderComments(0);</script><div id="comment_form" class="commentform">    <a name="commentform"></a>    <div id="divCommentShow"></div>    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>    <div id="comment_form_container"></div>    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>    <div id="ad_t2"></div>    <div id="opt_under_post"></div>    <div id="cnblogs_c1" class="c_ad_block">        <div id="div-gpt-ad-1592365906576-0" style="width: 300px; height: 250px;"></div>    </div>    <div id="under_post_news"></div>    <div id="cnblogs_c2" class="c_ad_block">        <div id="div-gpt-ad-1592366332455-0" style="width: 468px; height: 60px;"></div>    </div>    <div id="under_post_kb"></div>    <div id="HistoryToday" class="c_ad_block"></div>    <script type="text/javascript">        fixPostBody();        deliverBigBanner();setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverT2();        deliverC1C2();        loadNewsAndKb();        loadBlogSignature();LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);        loadOptUnderPost();        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);    </script></div></div><!--end: forFlow --></div><!--end: mainContent 主体内容容器--><div id="sideBar"><div id="sideBarMain"><div id="sidebar_news" class="newsItem">            <script>loadBlogNews();</script></div><div id="sidebar_ad"></div><div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script><div id="leftcontentcontainer"><div id="blog-sidecolumn"></div>                    <script>loadBlogSideColumn();</script></div></div><!--end: sideBarMain --></div><!--end: sideBar 侧边栏容器 --><div class="clear"></div></div><!--end: main --><div class="clear"></div><div id="footer"><!--done-->Copyright © 2020 听雨危楼<br><span id="poweredby">Powered by .NET Core on Kubernetes</span></div><!--end: footer --></div><!--end: home 自定义的最大容器 -->    <script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">
    &lt;a name=&quot;top&quot;&gt;&lt;/a&gt;
    &lt;div id=&quot;top_nav&quot; class=&quot;navbar navbar-custom&quot;&gt;
        &lt;nav id=&quot;nav_main&quot; class=&quot;navbar-main&quot;&gt;
            &lt;ul </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/10/02/pep8/"/>
    <id>http://example.com/2020/10/02/pep8/</id>
    <published>2020-10-02T05:10:26.984Z</published>
    <updated>2020-10-02T05:18:18.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p><a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a>规范建议四个空格为语句的缩进块.</p><p>如果要是想让代码往右侧缩进4个，就<code>Tab</code>一次就行了；要是让代码往左侧缩进4个空格，就<code>Shift + Tab</code>就完了.</p><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>Python不建议使用分号！除此之外，也不要用分号连接两条命令</p><h2 id="不要中文符号"><a href="#不要中文符号" class="headerlink" title="不要中文符号"></a>不要中文符号</h2><p>使用<strong>英文状态下</strong>的符号</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>当行注释#xxx</p><p>多行注释 “””  xxx  “””</p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>单引号双引号都一样</p><pre><code>str = "xx'xxxx'"  </code></pre><h2 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h2><p>不超过80字符</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缩进&quot;&gt;&lt;a href=&quot;#缩进&quot; class=&quot;headerlink&quot; title=&quot;缩进&quot;&gt;&lt;/a&gt;缩进&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/&quot;&gt;PEP8&lt;/a&gt;规范建议四个空格为语</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/10/02/pycharm/pycharm%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://example.com/2020/10/02/pycharm/pycharm%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-10-02T05:08:12.217Z</published>
    <updated>2020-10-02T05:08:44.037Z</updated>
    
    <content type="html"><![CDATA[<p><strong>常用类</strong><br>Alt + #[0-9]打开相应的工具窗口<br>Ctrl + Alt + Y同步<br>Ctrl + Shift + F12最大化编辑开关<br>Alt + Shift + F添加到最喜欢<br>Alt + Shift + I根据配置检查当前文件<br>Ctrl + BackQuote(’)快速切换当前计划<br>Ctrl + Alt + S　打开设置页<br>Ctrl + Shift + A查找编辑器里所有的动作<br>Ctrl + Tab在窗口间进行切换<br>Ctrl + Space 基本的代码完成（类、方法、属性）<br>Ctrl + Alt + Space 类名完成<br>Ctrl + Shift + Enter 语句完成<br>Ctrl + P 参数信息（在方法中调用参数）<br>Ctrl + Q 快速查看文档<br>Shift + F1 外部文档<br>Ctrl + 鼠标 简介<br>Ctrl + F1 显示错误描述或警告信息<br>Alt + Insert 自动生成代码<br>Ctrl + O 重新方法<br>Ctrl + Alt + T 选中<br>Ctrl + / 行注释<br>Ctrl + Shift + / 块注释<br>Ctrl + W 选中增加的代码块<br>Ctrl + Shift + W 回到之前状态<br>Ctrl + Shift + ]/[ 选定代码块结束、开始<br>Alt + Enter 快速修正<br>Ctrl + Alt + L 代码格式化<br>Ctrl + Alt + O 优化导入<br>Ctrl + Alt + I 自动缩进<br>Tab / Shift + Tab 缩进、不缩进当前行<br>Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板<br>Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板<br>Ctrl+V/Shift+Insert 从剪贴板粘贴<br>Ctrl + Shift + V 从最近的缓冲区粘贴<br>Ctrl + D 复制选定的区域或行<br>Ctrl + Y 删除选定的行<br>Ctrl + Shift + J 添加智能线<br>Ctrl + Enter 智能线切割<br>Shift + Enter 另起一行<br>Ctrl + Shift + U 在选定的区域或代码块间切换<br>Ctrl + Delete 删除到字符结束<br>Ctrl + Backspace 删除到字符开始<br>Ctrl + Numpad+/- 展开折叠代码块<br>Ctrl + Numpad+ 全部展开<br>Ctrl + Numpad- 全部折叠<br>Ctrl + F4 关闭运行的选项卡</p><p><strong>运行类</strong><br>Alt + Shift + F10 运行模式配置<br>Alt + Shift + F9 调试模式配置<br>Shift + F10 运行<br>Shift + F9 调试<br>Ctrl + Shift + F10 运行编辑器配置<br>Ctrl + Alt + R 运行manage.py任务</p><p><strong>调试类</strong><br>F8 跳过<br>F7 进入<br>Shift + F8 退出<br>Alt + F9 运行游标<br>Alt + F8 验证表达式<br>Ctrl + Alt + F8 快速验证表达式<br>F9 恢复程序<br>Ctrl + F8 断点开关<br>Ctrl + Shift + F8 查看断点</p><p><strong>导航类</strong><br>Ctrl + N 跳转到类<br>Ctrl + Shift + N 跳转到符号<br>Alt + Right/Left 跳转到下一个、前一个编辑的选项卡<br>F12 回到先前的工具窗口<br>Esc 从工具窗口回到编辑窗口<br>Shift + Esc 隐藏运行的、最近运行的窗口<br>Ctrl + Shift + F4 关闭主动运行的选项卡<br>Ctrl + G 查看当前行号、字符号<br>Ctrl + E 当前文件弹出<br>Ctrl+Alt+Left/Right 后退、前进<br>Ctrl+Shift+Backspace 导航到最近编辑区域<br>Alt + F1 查找当前文件或标识<br>Ctrl+B / Ctrl+Click 跳转到声明<br>Ctrl + Alt + B 跳转到实现<br>Ctrl + Shift + I查看快速定义<br>Ctrl + Shift + B跳转到类型声明<br>Ctrl + U跳转到父方法、父类<br>Alt + Up/Down跳转到上一个、下一个方法<br>Ctrl + ]/[跳转到代码块结束、开始<br>Ctrl + F12弹出文件结构<br>Ctrl + H类型层次结构<br>Ctrl + Shift + H方法层次结构<br>Ctrl + Alt + H调用层次结构<br>F2 / Shift + F2下一条、前一条高亮的错误<br>F4 / Ctrl + Enter编辑资源、查看资源<br>Alt + Home显示导航条F11书签开关<br>Ctrl + Shift + F11书签助记开关<br>Ctrl + #[0-9]跳转到标识的书签<br>Shift + F11显示书签</p><p><strong>查找/替换类</strong><br>F3 下一个<br>Shift + F3 前一个<br>Ctrl + R 替换<br>Ctrl + Shift + F 全局查找<br>Ctrl + Shift + R 全局替换</p><p><strong>搜索类</strong></p><p>Alt + F7/Ctrl + F7文件中查询用法<br>Ctrl + Shift + F7文件中用法高亮显示<br>Ctrl + Alt + F7显示用法</p><p><strong>重构类</strong></p><p>F5复制F6剪切<br>Alt + Delete安全删除<br>Shift + F6重命名<br>Ctrl + F6更改签名<br>Ctrl + Alt + N内联<br>Ctrl + Alt + M提取方法<br>Ctrl + Alt + V提取属性<br>Ctrl + Alt + F提取字段<br>Ctrl + Alt + C提取常量<br>Ctrl + Alt + P提取参数</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;常用类&lt;/strong&gt;&lt;br&gt;Alt + #[0-9]打开相应的工具窗口&lt;br&gt;Ctrl + Alt + Y同步&lt;br&gt;Ctrl + Shift + F12最大化编辑开关&lt;br&gt;Alt + Shift + F添加到最喜欢&lt;br&gt;Alt + Shift + </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/10/01/hello-world/"/>
    <id>http://example.com/2020/10/01/hello-world/</id>
    <published>2020-10-01T05:42:30.074Z</published>
    <updated>2020-10-01T05:42:30.074Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PicGo+GitHub图床</title>
    <link href="http://example.com/2019/12/01/github/PicGo+GitHub%E5%9B%BE%E5%BA%8A/"/>
    <id>http://example.com/2019/12/01/github/PicGo+GitHub%E5%9B%BE%E5%BA%8A/</id>
    <published>2019-12-01T05:43:10.000Z</published>
    <updated>2020-05-13T02:13:08.620Z</updated>
    
    <content type="html"><![CDATA[<p>一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种<strong>“轻量级标记语言”</strong>。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：<strong>Typora</strong>和<strong>马克飞象</strong>。</p><p>目前我是两款编辑器混合时候，当编写的Markdown文档需要和印象笔记对接的时候，则使用马克飞象；至于其他用途的文档就使用Typora。则两款编辑器都<strong>近乎完美但是却又不能达到完美</strong>。我写文档的时候经常需要截图，然后从剪贴板从直接黏贴放进文档，则两款编辑器虽然都能满足这种操作，但是其实现原理不过是<strong>将截图存放在本机电脑上</strong>，所以，一旦文档中有了截图，将Markdown文档的迁移到别的电脑上展示的成本就大大增加（图片也要一并复制过去）。</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-7f243dd5df471fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/693/format/webp" alt="img"></p><p>这是Typora对图片的解决方案</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-4871e650d1bbb1ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/283/format/webp" alt="img"></p><p>这是马克飞象中对图片的解决方案</p><p>这两款编辑器对图片处理的方法简直是丧尽天良，也是我在使用过程中唯一觉得不爽的一点。辛苦搜寻之下，终于让我找到了一种解决方案：<strong>PicGo+GitHub图床</strong></p><blockquote><p>注：实际上，Mac OS 上的Typora编辑器已经支持将本地图片或者截图先上传到服务器生成访问链接后，在存放到Markdown文档中，简单点说，Mac OS上的Typora是完美的（😭无奈我是Windows用户）</p></blockquote><h1 id="PicGo介绍"><a href="#PicGo介绍" class="headerlink" title="PicGo介绍"></a><a href="https://github.com/Molunerfinn/PicGo">PicGo介绍</a></h1><p>这是一款图片上传的工具，目前支持<code>微博图床</code>，<code>七牛图床</code>，<code>腾讯云</code>，<code>又拍云</code>，<code>GitHub</code>等图床，未来将支持更多图床。</p><p>所以解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪😊。</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-a818a6851f18d336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><p>Pic Go支持的图床</p><p>在众多的图床中，我选择的GitHub图床，其它类型的图床如果你们有兴趣的话可以试一下。</p><h1 id="创建自己的GitHub图床"><a href="#创建自己的GitHub图床" class="headerlink" title="创建自己的GitHub图床"></a>创建自己的GitHub图床</h1><h2 id="1-创建GitHub图床之前，需要注册-登陆GitHub账号"><a href="#1-创建GitHub图床之前，需要注册-登陆GitHub账号" class="headerlink" title="1. 创建GitHub图床之前，需要注册/登陆GitHub账号"></a>1. 创建GitHub图床之前，需要注册/登陆GitHub账号</h2><blockquote><p>申请GitHub账号很简单，我就不演示了</p></blockquote><h2 id="2-创建Repository"><a href="#2-创建Repository" class="headerlink" title="2. 创建Repository"></a>2. 创建Repository</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-25f1990a188f9103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>点击”New repository”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-596d8282a217da7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1097/format/webp" alt="img"></p><p>最后1234步骤执行</p><blockquote><ul><li>我已经建立过一个同名的repository的，所以第一步会显示红色</li><li>第三步，为repository初始化一个README.md文件可以根据需求选择，非必选</li></ul></blockquote><h2 id="3-生成一个Token用于操作GitHub-repository"><a href="#3-生成一个Token用于操作GitHub-repository" class="headerlink" title="3.生成一个Token用于操作GitHub repository"></a>3.生成一个Token用于操作GitHub repository</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-69a2b38f4634e509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>回到主页，点击”Settings”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-833a01142ad92e6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1060/format/webp" alt="img"></p><p>进入页面后，点击”Developer settings”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-3ba67ab9f5224bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>点击”Personal access tokens”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-8d67725f463f5fc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>创建新的Token</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-2cddeffa8fe35933.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1123/format/webp" alt="img"></p><p>填写描述，选择”repo”,然后点击”Generate token”按钮</p><blockquote><p>注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存</p></blockquote><h1 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h1><h2 id="1-下载运行PicGo"><a href="#1-下载运行PicGo" class="headerlink" title="1. 下载运行PicGo"></a>1. 下载运行PicGo</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-9fe439e9625c741f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1077/format/webp" alt="img"></p><p>下载zip包后，解压，运行可执行文件</p><h2 id="2-配置图床"><a href="#2-配置图床" class="headerlink" title="2. 配置图床"></a>2. 配置图床</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-33b10cfcc147cdc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><p>如图配置</p><blockquote><ul><li>设定仓库名的时候，是按照“账户名/仓库名的格式填写”</li><li>分支名统一填写“master”</li><li>将之前的Token黏贴在这里</li><li>存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹</li><li>自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上<code>https://raw.githubusercontent.com/用户名/RepositoryName/分支名，</code>，自定义域名需要按照这样去填写</li></ul></blockquote><h2 id="3-快捷键及相关配置"><a href="#3-快捷键及相关配置" class="headerlink" title="3.快捷键及相关配置"></a>3.快捷键及相关配置</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-8d2c2729e4f16fd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><p>可以按照这样配置</p><blockquote><p>注：可以将快捷键设置为<code>ctrl+shift+c</code></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>将上面的步骤都设置好之后，就可以让自己的Markdown文档飞起来了，每次截图之后，都可以按一下<code>ctrl+shift+c</code>，这样就会将剪切板上面的截图转化为在线网络图片链接，简直就是爽的不要不要的！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种&lt;strong&gt;“轻量级标记语言”&lt;/strong&gt;。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：&lt;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch</title>
    <link href="http://example.com/2019/11/16/Elasticsearch/es/"/>
    <id>http://example.com/2019/11/16/Elasticsearch/es/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:18:04.713Z</updated>
    
    <content type="html"><![CDATA[<p>博客:<a href="https://www.cnblogs.com/Neeo">https://www.cnblogs.com/Neeo</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客:&lt;a href=&quot;https://www.cnblogs.com/Neeo&quot;&gt;https://www.cnblogs.com/Neeo&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="http://example.com/2019/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/sf/"/>
    <id>http://example.com/2019/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/sf/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:17:08.957Z</updated>
    
    <content type="html"><![CDATA[<p>博客:<a href="https://www.cnblogs.com/bobo-zhang/category/1417180.html">https://www.cnblogs.com/bobo-zhang/category/1417180.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客:&lt;a href=&quot;https://www.cnblogs.com/bobo-zhang/category/1417180.html&quot;&gt;https://www.cnblogs.com/bobo-zhang/category/1417180.html&lt;/a&gt;&lt;/p&gt;
&lt;s</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>爬虫</title>
    <link href="http://example.com/2019/11/16/%E7%88%AC%E8%99%AB/pc/"/>
    <id>http://example.com/2019/11/16/%E7%88%AC%E8%99%AB/pc/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:17:33.571Z</updated>
    
    <content type="html"><![CDATA[<p>博客:<a href="https://www.cnblogs.com/bobo-zhang/">https://www.cnblogs.com/bobo-zhang/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客:&lt;a href=&quot;https://www.cnblogs.com/bobo-zhang/&quot;&gt;https://www.cnblogs.com/bobo-zhang/&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>自动化运维ansible</title>
    <link href="http://example.com/2019/11/16/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E9%A1%B9%E7%9B%AE/zdhyw/"/>
    <id>http://example.com/2019/11/16/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E9%A1%B9%E7%9B%AE/zdhyw/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:16:44.147Z</updated>
    
    <content type="html"><![CDATA[<p>博客:<a href="https://blog.51cto.com/wangfeng7399">https://blog.51cto.com/wangfeng7399</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客:&lt;a href=&quot;https://blog.51cto.com/wangfeng7399&quot;&gt;https://blog.51cto.com/wangfeng7399&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>DjangoRestFramework + VUE 项目</title>
    <link href="http://example.com/2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E7%8E%A9%E5%85%B7/znwj/"/>
    <id>http://example.com/2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E7%8E%A9%E5%85%B7/znwj/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:04:50.765Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/DragonFire/p/10356615.html">Celery - 一个懂得 异步任务 , 定时任务 , 周期任务 的芹菜</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9498396.html">DBUtils - Python数据库连接池</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260299.html">Flask最强攻略 - 跟DragonFire学Flask - 第八篇 实例化Flask的参数 及 对app的配置</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9255637.html">Flask最强攻略 - 跟DragonFire学Flask - 第二篇 Flask 中的 Render Redirect HttpResponse</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9264381.html">Flask最强攻略 - 跟DragonFire学Flask - 第九篇 Flask 中的蓝图(BluePrint)</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260228.html">Flask最强攻略 - 跟DragonFire学Flask - 第六篇 Flask 中内置的 Session</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260295.html">Flask最强攻略 - 跟DragonFire学Flask - 第七篇 Flask 中路由系统</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9259395.html">Flask最强攻略 - 跟DragonFire学Flask - 第三篇 Flask 中的 request 之 先知道有这么个东西</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10365963.html">Flask最强攻略 - 跟DragonFire学Flask - 第十六篇 Flask-Migrate</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9269303.html">Flask最强攻略 - 跟DragonFire学Flask - 第十篇 before_request after_request</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10363353.html">Flask最强攻略 - 跟DragonFire学Flask - 第十四篇 Flask-SQLAlchemy</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10365827.html">Flask最强攻略 - 跟DragonFire学Flask - 第十五篇 Flask-Script</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9259999.html">Flask最强攻略 - 跟DragonFire学Flask - 第四篇 Flask 中的模板语言 Jinja2 及 render_template 的深度用法</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260124.html">Flask最强攻略 - 跟DragonFire学Flask - 第五篇 做一个用户登录之后查看学员信息的小例子</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9254637.html">Flask最强攻略 - 跟DragonFire学Flask - 第一篇 你好,我叫Flask</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10166527.html">SQLAlchemy 增删改查 一对多 多对多</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9788927.html">websocket 工作原理</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/DragonFire/p/10356615.html&quot;&gt;Celery - 一个懂得 异步任务 , 定时任务 , 周期任务 的芹菜&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>DjangoRestFramework + VUE 项目</title>
    <link href="http://example.com/2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E5%9F%8E/lf/"/>
    <id>http://example.com/2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E5%9F%8E/lf/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T07:58:58.515Z</updated>
    
    <content type="html"><![CDATA[<p>VUE学习目录:<a href="https://www.cnblogs.com/clschao/articles/10706528.html">https://www.cnblogs.com/clschao/articles/10706528.html</a></p><p>DjangoRestFramework学习:</p><p><a href="https://www.cnblogs.com/clschao/articles/10709740.html">https://www.cnblogs.com/clschao/articles/10709740.html</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10711600.html">https://www.cnblogs.com/clschao/articles/10711600.html</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10732867.html">https://www.cnblogs.com/clschao/articles/10732867.html</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10746758.html">Django学习之django自带的contentType表:</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10757374.html">python时间类型转换</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10759183.html">redis简单操作</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10745966.html">跨域和CORS</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;VUE学习目录:&lt;a href=&quot;https://www.cnblogs.com/clschao/articles/10706528.html&quot;&gt;https://www.cnblogs.com/clschao/articles/10706528.html&lt;/a&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux之文档与目录结构</title>
    <link href="http://example.com/2019/11/15/Linux/Linux%E4%B9%8B%E6%96%87%E6%A1%A3%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2019/11/15/Linux/Linux%E4%B9%8B%E6%96%87%E6%A1%A3%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:37:45.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之文档与目录结构"><a href="#Linux之文档与目录结构" class="headerlink" title="Linux之文档与目录结构"></a><a href="https://www.cnblogs.com/pyyu/p/9213237.html">Linux之文档与目录结构</a></h1><h1 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h1><p>Linux目录结构的组织形式和Windows有很大的不同。首先Linux没有“盘(C盘、D盘、E盘)”的概念。已经建立文件系统的硬盘分区被挂载到某一个目录下，用户通过操作目录来实现磁盘读写。</p><p>Linux不像Windows那样的系统目录，Linux使用正斜杠”/“而不是反斜杠”"来标识目录。</p><p>Windows目录：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622134224409-1941390599.png" alt="img"></p><p>Linux目录：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622134328724-1952764525.png" alt="img"></p><p>Linux首先是建立一个根”/“文件系统，所有的目录也都是由根目录衍生出来。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719224707794-816913824.png" alt="img"></p><p>登录系统后，在当前命令窗口输入命令:</p><pre><code>ls /</code></pre><p>查看结果如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622134847306-163954950.png" alt="img"></p><p>在Linux底下，所有的文件与目录都是由根目录开始，是目录与文件的源头，然后一个个的分支下来，如同树枝状，因此称为这种目录配置为：目录树。</p><p>目录树的特点是什么呢？</p><ul><li>目录树的起始点是根目录(/,root);</li><li>每一个目录不止能使用本地的文件系统，也可以使用网络上的文件系统，可以利用NFS服务器挂载特定目录。</li><li>每一个文件在此目录树中的文件名，包含完整路径都是独一无二的。</li></ul><h2 id="目录树架构示意图"><a href="#目录树架构示意图" class="headerlink" title="目录树架构示意图"></a>目录树架构示意图</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180823103948862-1376998015.png" alt="img"></p><p>以下是对这些目录的解释：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180921150307683-759085586.png" alt="img"></p><ul><li><p><strong>/bin</strong>：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><strong>/dev ：</strong><br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><strong>/home</strong>：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li><li><p><strong>/lib</strong>：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>/media</strong>：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>/opt</strong>：<br> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>/proc</strong>：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></pre></li><li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>/sbin</strong>：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/selinux</strong>：<br> 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li><li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>/sys</strong>：<br> 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p><p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</p></li></ul><p>  该文件系统是内核设备树的一个直观反映。</p><p>  当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><ul><li><p><strong>/tmp</strong>：<br>这个目录是用来存放一些临时文件的。</p></li><li><p><strong>/usr</strong>：<br> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p></li><li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p></li><li><p><strong>/var</strong>：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li></ul><p>在linux系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p><p>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。</p><p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。</p><p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。</p><h1 id="为什么要学习linux命令"><a href="#为什么要学习linux命令" class="headerlink" title="为什么要学习linux命令"></a>为什么要学习linux命令</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322164008764-1025212772.png" alt="img"></p><p><strong>当年超哥在一家美资企业，一位台湾老程序员送我的一本书。。。</strong></p><p><strong>可能是看我骨骼惊奇吧！！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322164133605-1830349359.png" alt="img"></p><h1 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322164249397-825723345.png" alt="img"></p><p>我们知道切换目录的指令是cd，那么首先得知道如何切换目录，这个得用心记呀！</p><pre><code>.    当前目录..    上一层目录-    前一个工作目录~    当前【用户】所在的家目录</code></pre><p>需要注意的是，在所有目录底下都存在两个目录，分别是【.】和【..】，分别代表当前目录，上层目录！那么如何证明它的存在呢？</p><pre><code>命令： ls -la /查看命令解释：man ls  (Linux下的帮助指令)结论：ls - list directory contens (列出目录内容)ls -la /  以竖状格式化显示列出/目录所有内容</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716132338853-107586297.png" alt="img"></p><p>接下来看一下常用的目录处理指令：</p><pre><code>cd : (change directory,更改目录)pwd:(显示当前目录)mkdir:(建立一个新目录)rmdir:（删除一个空目录）</code></pre><h1 id="cd命令，变换目录"><a href="#cd命令，变换目录" class="headerlink" title="cd命令，变换目录"></a>cd命令，变换目录</h1><p>cd是change directory的缩写，这是用来变换工作目录的命令，注意命令和目录之间有一个空格。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716134328013-1031650900.png" alt="img"></p><h1 id="mkdir，建立新目录"><a href="#mkdir，建立新目录" class="headerlink" title="mkdir，建立新目录"></a>mkdir，建立新目录</h1><p>mkdir是make directory的缩写，用来建立新目录，在默认情况下，目录得一级一级的建立。</p><p>例如我要建立/home/oldboy/python目录，我就必须有/home，然后/home/oldboy，最后/home/oldboy/python，如果没有/home/oldboy，则不能建立python目录！</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716142641730-1625463100.png" alt="img"></p><p> 可见高效的创建目录用上-p参数，可以直接执行命令【mkdir -p /home/oldboy/python】，系统会自动添加上/home，/home/oldboy，/home/oldboy/python依次建立目录，是不是很方便，^ ^ </p><h1 id="rmdir，删除空目录"><a href="#rmdir，删除空目录" class="headerlink" title="rmdir，删除空目录"></a>rmdir，删除空目录</h1><p>当我想删除一个空目录时，就用rmdir吧，例如我想删除刚才建立的oldboy目录，以及/tmp/oldboy/python,那么可以使用【rmdir oldboy】，但是注意rmdir只能删除空目录。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180717231355821-689929245.png" alt="img"></p><pre><code>删除命令可以正确使用【rm -rf】</code></pre><h1 id="Linux的路径PATH"><a href="#Linux的路径PATH" class="headerlink" title="Linux的路径PATH"></a>Linux的路径PATH</h1><p>同学们应该都会配置windows下的环境变量（PATH），都知道系统会按照PATH的设定，去每个PATH定义的目录下搜索可执行文件。</p><p>那么如何查看Linux下的PATH环境变量呢？</p><pre><code>执行命令：echo $PATHecho命令是有打印的意思$符号后面跟上PATH,表示输出PATH的变量</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180717232700721-1562018264.png" alt="img"></p><p>PATH(一定是大写的)这个变量是由一堆目录组成，分隔符是”:”号，而不同于windows的”;”号。</p><h1 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h1><p>Linux中非常重要的概念–路径，路径用来定位如何找到某个文件。</p><p>这里超哥先讲个例子，到底什么是相对路径，绝对路径</p><p>比如一个老外，要来老男孩教育学习python，但是他找不到地点，因此向你问路，你可以告诉他：</p><p>　  　1.先坐飞机来中国北京，从北京机场坐地铁到沙河地铁站，然后走路800米到沙河汇德商厦，上四楼，找到超哥，结束寻路。</p><p>　　2. 超哥就在汇德商厦403办公室，武佩奇后面坐着呢！！！</p><p>Linux下特别注意文件名/路径的写法，可以将所谓的路径(path)定义为绝对路径(absolute)和相对路径(relative)。这两种文件名/路径的写法依据是这样的：</p><ul><li>绝对路径：由根目录(/)为开始写起的文件名或者目录名称，如/home/oldboy/test.py;</li><li>相对路径：相对于目前路径的文件名写法。例如./home/oldboy/exam.py或../../home/oldboy/exam.py，简单来说只要开头不是/，就是属于相对路径</li></ul><p>因此你必须了解，相对路径是：以你当前所在路径的相对路径来表示的。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622140257547-1356616310.png" alt="img"></p><p>例如你现在在/home 这个目录下，如要进入/var/log这个路径，如何写呢？</p><ol><li>cd /var/log (绝对路径)</li><li>cd ../var/log(相对路径)</li></ol><p>结果如图：</p><p>因为你在/home底下，因此你要回到上一层(../)之后，才能继续前往/var，特别注意：</p><ul><li>.   :代表当前的目录，也可以用./ 来表示</li><li>..  :代表上一层的目录，也可以用../来表示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622140612606-771359419.png" alt="img"></p><p>分割线—-</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622140823060-347310504.png" alt="img"></p><p>这个.与..目录概念非常重要，平时经常会看到cd ..或者python ../home/oldboy/exam.py 就是代表进入上一层与执行相对路径的python代码！</p><pre><code>1.linux是以 / 开始的树状目录结构,tree查看2.常用文件目录操作命令是ls,cd,mkdir,rmdir3.Linux的PATH查看是 echo $PATH，可以修改/etc/profile文件永久生效,以冒号分割4.绝对路径,相对路径的查看5.文件权限chmod chgrp chown</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322172711042-37362360.png" alt="img"></h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322172929688-1107644884.png" alt="img"></p><h1 id="Linux的文件系统"><a href="#Linux的文件系统" class="headerlink" title="Linux的文件系统"></a>Linux的文件系统</h1><p>用户在硬件存储设备中执行的文件建立，写入，读取，修改，转存与控制等操作都是依赖文件系统完成的。文件系统的作用是合理规划硬盘，保证用户正常使用。</p><p>Linux系统支持数十种文件系统，常见文件系统如下。</p><ul><li>Ext3    是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能 自动修复数据的不一致与错误。</li><li>Ext4     Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，它支持的存储容 量高达 1EB(1EB=1,073,741,824GB)，且能够有无限多的子目录。另外，Ext4 文件系统能够批量分配 block 块，从而极大地提高了读写效率。</li><li>XFS     是一种高性能的日志文件系统，而且是 RHEL 7 中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的 日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为 18EB， 这几乎满足了所有需求。</li></ul><pre><code>/etc/fstab是用来存放文件系统的静态信息的文件cat /etc/fstab #检查linux的文件系统</code></pre><p>练习</p><pre><code>1.在/home/目录创建文件夹oldboy,进入oldboy创建helloLinux.txt2.创建/tmp/chaogeLinux.txt，用绝对路径方式与相对路径两种方法3.在/tmp/目录下创建chaogeDir目录4.查看linuxPATH5.修改chaogeLinux.txt文件属主是chaoge,权限是可读可写</code></pre><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux之文档与目录结构&quot;&gt;&lt;a href=&quot;#Linux之文档与目录结构&quot; class=&quot;headerlink&quot; title=&quot;Linux之文档与目录结构&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/9213237</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程实战</title>
    <link href="http://example.com/2019/11/15/Linux/Shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%20/"/>
    <id>http://example.com/2019/11/15/Linux/Shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%20/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T06:18:30.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell编程实战"><a href="#Shell编程实战" class="headerlink" title="Shell编程实战"></a><a href="https://www.cnblogs.com/pyyu/p/9552661.html">Shell编程实战</a></h1><h1 id="为什么要学习Shell编程"><a href="#为什么要学习Shell编程" class="headerlink" title="为什么要学习Shell编程"></a>为什么要学习Shell编程</h1><p>Shell脚本语言是实现Linux/Unix系统管理及自动化运维所必须的重要工具，Linux系统的底层以及基础应用软件的核心大都涉及Shell脚本的内容。</p><p>一个合格的Linux系统管理员都必须熟练编写Shell脚本语言，从而提升运维人员的工作效率，减少不必要的重复性工作。</p><h2 id="学习Shell所需的基础知识"><a href="#学习Shell所需的基础知识" class="headerlink" title="学习Shell所需的基础知识"></a>学习Shell所需的基础知识</h2><p><strong>熟练使用VIm编辑器，熟悉SSH终端等配置</strong></p><p>在Linux下开发shell脚本用的最多的就是vim编辑器，熟练使用vim可以使得shell脚本开发事半功倍！</p><p><strong>有一定的Linux命令基础，熟练掌握80个命令以上</strong></p><p>shell和其他脚本语言不同，如python，Shell缺少可以直接使用的外部函数库，因此Linux系统的命令就可以当做Shell的函数库！</p><p><strong>熟悉常见Linux服务部署，优化，分析与排错</strong></p><p>学习Shell直接的目的是在工作中对系统以及服务进行自动化管理，因此如果不熟悉服务操作，使用shell也就没有意义了</p><h1 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180829102203128-345530932.png" alt="img"></p><p>Shell存在于操作系统的最外层，负责与用户直接对话，把用户的输入解释给操作系统，处理操作系统的输出结果，然后反馈给用户。</p><p>Shell是一个命令解释器，它的作用是解释并执行用户输入的命令和程序等，用户每输入一条命令，Shell解释器就执行一条，存在一种交互的方式。</p><p>从开机准备输入用户名和密码，到登录成功，所有的操作都是Shell解释并执行的。</p><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2><p>当命令或者程序语句不是在命令行中执行，而是通过一个程序文件来执行时，这个程序就称作Shell脚本。</p><p><strong>一个简单的Shell脚本</strong></p><p>清除/var/log下的messages日志文件</p><p>把所有命令放入一个文件，堆积起来后就是一个脚本文件！注意文件的可执行权限，与用户身份</p><pre><code>#清除脚本日志cd /var/logcat /dev/null &gt; messagesecho "Logs cleaned up . done"</code></pre><h2 id="Shell脚本语言的种类"><a href="#Shell脚本语言的种类" class="headerlink" title="Shell脚本语言的种类"></a>Shell脚本语言的种类</h2><pre><code>Shell脚本语言是弱类型语言（无须定义变量的类型即可使用）在Linux中有两大Shell，一是Bourne shell，二是C shell我们需要知道的就是标准的Bourne Again shell(bash)所取代查看CentOS 7系统的Shell</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180829104819001-1048787426.png" alt="img"></p><p>其他的脚本语言</p><pre><code>phpPerlPython</code></pre><p>语言选择</p><pre><code>Shell脚本语言优势在于处理系统底层的业务，基于linux命令处理也是最快的，常用语开发自动化安装，监控报警，软件启动等脚本。</code></pre><h2 id="第一个Shell脚本与hello-world"><a href="#第一个Shell脚本与hello-world" class="headerlink" title="第一个Shell脚本与hello world"></a>第一个Shell脚本与hello world</h2><p>脚本开头</p><pre><code>一个规范的脚本文件会在第一行指出由哪个程序来执行脚本的内容，必须位于第一行！！！如果你不加默认也会交给bash解释，良好的编程习惯，最好加上开头解释器语言标识#!/bin/bash#!/usr/bin/env python</code></pre><h2 id="执行Shell脚本的方式"><a href="#执行Shell脚本的方式" class="headerlink" title="执行Shell脚本的方式"></a>执行Shell脚本的方式</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>bash 脚本名sh    脚本名此方法是脚本没有可执行权限时，或者文件头没指定解释器时用的方法path/scriptName./scriptName 此方法需要脚本有可执行权限，chmod +x scriptNamesource scriptName. scriptName加载并执行脚本文件中的命令和语句</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python /tmp 11:10:08]#sh test.shchaoge nb[root@oldboy_python /tmp 11:10:18]#cat test.sh#!/bin/bashecho 'chaoge nb'[root@oldboy_python /tmp 11:10:21]#. test.shchaoge nb[root@oldboy_python /tmp 11:10:33]#source  test.shchaoge nb#添加可执行权限给test.shchmod +x test.sh./test.sh</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><pre><code>环境变量一般指的是export内置命令导出的变量，用于定义SHell的运行环境。Shell通过环境变量来确定命令提示符，也就是超哥前面说的PS1变量环境变量可以在命令行中设置和创建，但是用户退出命令行时变量值就会丢失，因此可以写入/etc/profile文件中，每次用户登录时，变量都会被初始化！环境变量名字均大写，用env查看</code></pre><p>设置登录的提示</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 11:21:51]#cat /etc/motd'welcome chaoge bakcome~~~~~~~~~'</code></pre><p>yudanL:~ yuchao$ ssh <a href="mailto:root@192.168.11.11">root@192.168.11.11</a><br>Last failed login: Wed Aug 29 11:20:20 CST 2018 from 111.231.199.24 on ssh:notty<br>There were 25 failed login attempts since the last successful login.<br>Last login: Wed Aug 29 10:45:51 2018 from 223.72.74.11<br>‘welcome chaoge bakcome<del>~</del>`’</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>定义变量</p><p>变量定义的注意点</p><ul><li>变量名和等号之间不能有空格</li><li>命名只能用英文字母，数字，下划线，首个字符不能用数字</li><li>不能用标点符号</li><li>不能用关键字</li></ul><pre><code>name='chaoge'echo $nameecho ${name} #帮助解释器识别变量的边界#变量重新赋值name='chaogenb'</code></pre><p>设置只读变量</p><pre><code>[root@oldboy_python ~ 11:29:31]#readonly name[root@oldboy_python ~ 11:30:27]#name='chaogenb3'-bash: name: 只读变量</code></pre><p>删除变量</p><pre><code>unset name</code></pre><p>变量类型</p><ul><li>局部变量 在脚本或命令中定义，仅在当前shell有效</li><li>环境变量 所有的程序，shell程序都能访问环境变量</li><li>shell变量 特殊变量 既有环境变量 又有局部变量</li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串可以用单引号，也可以双引号，也可以没引号</p><pre><code>[root@oldboy_python ~ 11:42:42]#addr='shahe'[root@oldboy_python ~ 11:44:55]#echo $addrshahe</code></pre><p>单引号的任何字符串都会原样输出，单引号字符串中的变量无效</p><p>单引号字符串不能出现单一的单引号，转义符也不可用，可用作字符串拼接</p><p>双引号</p><p>双引号里可以用变量</p><p>双引号可以有转义符</p><pre><code>[root@oldboy_python ~ 11:45:01]#addr='changpingshahe'[root@oldboy_python ~ 11:48:06]#name='yuchao'[root@oldboy_python ~ 11:49:00]#message="Hello,${name},Your addr is \"${addr}\" "[root@oldboy_python ~ 11:50:05]#echo $messageHello,yuchao,Your addr is "changpingshahe"</code></pre><p> 获取字符串长度</p><pre><code>[root@oldboy_python ~ 13:36:35]#str='abc'[root@oldboy_python ~ 13:36:49]#echo ${#str}3</code></pre><p>切片操作</p><p>左闭又开规则</p><pre><code>[root@oldboy_python ~ 13:39:45]#str='I am chaoge,hello world!'#取出0和10索引的字符[root@oldboy_python ~ 13:40:42]#echo ${str:0:11}I am chaoge</code></pre><p>查找字符索引</p><pre><code>[root@oldboy_python ~ 13:45:02]#str='I am chaoge,hello world!'[root@oldboy_python ~ 13:46:20]#echo `expr index "$str" e`11</code></pre><pre><code></code></pre><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shell编程实战&quot;&gt;&lt;a href=&quot;#Shell编程实战&quot; class=&quot;headerlink&quot; title=&quot;Shell编程实战&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/9552661.html&quot;&gt;Shell</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装之python开发</title>
    <link href="http://example.com/2019/11/15/Linux/Ubuntu%E5%AE%89%E8%A3%85%E4%B9%8Bpython%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2019/11/15/Linux/Ubuntu%E5%AE%89%E8%A3%85%E4%B9%8Bpython%E5%BC%80%E5%8F%91/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T06:12:48.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu安装之python开发"><a href="#Ubuntu安装之python开发" class="headerlink" title="Ubuntu安装之python开发"></a><a href="https://www.cnblogs.com/pyyu/p/9900100.html">Ubuntu安装之python开发</a></h1><p>什么？？公司要用Ubuntu(乌班图)？不会用？？怎么进行python开发？？？ </p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181102234826274-1090648545.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181103110824916-662123880.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181103110854741-1122135979.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181103110906518-1242690910.png" alt="img"></p><pre><code>乌班图操作系统下载地址：http://releases.ubuntu.com/18.04/ubuntu-18.04.1-desktop-amd64.iso</code></pre><p>  安装ubuntu</p><h2 id="第一步：准备好vmware虚拟机"><a href="#第一步：准备好vmware虚拟机" class="headerlink" title="第一步：准备好vmware虚拟机"></a>第一步：准备好vmware虚拟机</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113165258990-1315543038.png" alt="img">自行解决。。。</p><h2 id="第二步：安装ubuntu"><a href="#第二步：安装ubuntu" class="headerlink" title="第二步：安装ubuntu"></a>第二步：安装ubuntu</h2><p>[**详细安装过程**](<a href="https://www.cnblogs.com/pyyu/p/%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">https://www.cnblogs.com/pyyu/p/详细安装过程</a>  <a href="https://blog.csdn.net/u013142781/article/details/50529030">https://blog.csdn.net/u013142781/article/details/50529030</a>)</p><p>[**<a href="https://blog.csdn.net/u013142781/article/details/50529030**]">https://blog.csdn.net/u013142781/article/details/50529030**]</a>(<a href="https://www.cnblogs.com/pyyu/p/%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">https://www.cnblogs.com/pyyu/p/详细安装过程</a>  <a href="https://blog.csdn.net/u013142781/article/details/50529030">https://blog.csdn.net/u013142781/article/details/50529030</a>)</p><pre><code>1.设置好用户的账号密码2.可以自行通过sudo su - 切换root用户3.学习ubuntu相关命令</code></pre><p><strong>需要注意vmware和ubuntu的兼容性</strong> </p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181116090244808-1235344275.png" alt="img"></h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181116090251677-591155084.png" alt="img"></p><p> 然后安装</p><h2 id="第三步：安装pycharm"><a href="#第三步：安装pycharm" class="headerlink" title="第三步：安装pycharm"></a>第三步：安装pycharm</h2><pre><code>pycharm之linux版本下载地址：https://download.jetbrains.8686c.com/python/pycharm-community-2018.2.4.tar.gz</code></pre><p>下载好后查看</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113175052930-1118218842.png" alt="img"></p><p>解压缩pycharm</p><pre><code>yuchao@ubuntu:/tmp$ tar zxvf pycharm-professional-2018.2.4.tar.gz </code></pre><p>解压缩后进入文件夹</p><pre><code>cd /tmp/pycharm-2018.2.4/bin</code></pre><p>执行脚本，启动pycharm</p><pre><code> source pycharm.sh</code></pre><h2 id="第四步：配置桌面快捷启动pycharm"><a href="#第四步：配置桌面快捷启动pycharm" class="headerlink" title="第四步：配置桌面快捷启动pycharm"></a>第四步：配置桌面快捷启动pycharm</h2><ol><li>在桌面创建一个文本文件，名为Pycharm.desktop</li><li>在文件中添加内容</li></ol><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[Desktop Entry]Version=1.0Type=ApplicationName=PycharmIcon=/home/yuchao/Downloads/pycharm-professional-2018.2.4/pycharm-2018.2.4/bin/pycharm.pngExec=/home/yuchao/Downloads/pycharm-professional-2018.2.4/pycharm-2018.2.4/bin/pycharm.shMimeType=application/x-py;Name[en_US]=pycharm</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180101050-1773939019.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180146241-1107980216.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180156223-1099359137.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180218672-58584960.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu安装之python开发&quot;&gt;&lt;a href=&quot;#Ubuntu安装之python开发&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装之python开发&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/py</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>VMware与Centos系统安装</title>
    <link href="http://example.com/2019/11/15/Linux/VMware%E4%B8%8ECentos%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2019/11/15/Linux/VMware%E4%B8%8ECentos%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T06:11:22.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VMware与Centos系统安装"><a href="#VMware与Centos系统安装" class="headerlink" title="VMware与Centos系统安装"></a><a href="https://www.cnblogs.com/pyyu/articles/9313587.html">VMware与Centos系统安装</a></h1><h1 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h1><pre><code>1.Linux发行版的选择2.vmware创建一个虚拟机(centos)3.安装配置centos74.xshell配置连接虚拟机(centos)</code></pre><h1 id="选择性"><a href="#选择性" class="headerlink" title="选择性"></a>选择性</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>pc可以选择    -纯系统 Linux/windows    -双系统    Windows+Linux    -虚拟化技术    Windows+vmware workstation服务器    -物理机纯系统    -物理机+vmware（vmware esxi）    -物理机+docker安装    -简易安装    -自定义安装    -快照</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="下载centos系统ISO镜像"><a href="#下载centos系统ISO镜像" class="headerlink" title="下载centos系统ISO镜像"></a>下载centos系统ISO镜像</h1><p>要安装centos系统，就必须得有centos系统软件安装程序，可以通过浏览器访问centos官网<a href="http://www.centos.org,然后找到downloads/">http://www.centos.org，然后找到Downloads</a>  - &gt;  mirrors链接，点击后进入下载，但是由于这是国外的网址，下载速度肯定受限。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715143157429-375252113.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715143401449-1969739566.png" alt="img"></p><p>因此可以使用国内的镜像源</p><pre><code>https://opsx.alibaba.com/mirror#阿里云官方镜像站iso下载地址（此DVD映像包含可以使用该软件安装的所有软件包安装程序。这是大多数用户的推荐图像。）：https://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1804.iso</code></pre><p>为什么要选择64位操作系统？</p><pre><code>目前绝大多数生产环境，使用的都是64位操作Centos操作系统</code></pre><p>32位与64位系统的定位与区别？</p><pre><code>64位操作系统的设计定位是：满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域，这些领域共同特性就是需要大量的系统内存。32位操作系统是为普通用户设计的。</code></pre><p>区别二：</p><pre><code>64位操作系统只能安装在64位（cpu必须是64位的）电脑上（cpu必须是64位的），并且只针对64位的软件才能发挥其最佳的性能。32位操作系统既可以安装在32位（32位cpu）电脑上，也可以安装在64位电脑上。当然了32位操作系统是无法发挥出64位硬件性能的。</code></pre><p>区别三: 运算速度</p><pre><code>64位---&gt; 8车道大马路32位---&gt; 4车道马路</code></pre><p>区别四：支持的最大内存不同</p><pre><code>32位系统---&gt;4GB内存只能用3.5Gb64位系统 支持更大内存</code></pre><h1 id="安装VMware虚拟机"><a href="#安装VMware虚拟机" class="headerlink" title="安装VMware虚拟机"></a>安装VMware虚拟机</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>vmware是什么？有了这个软件，大家就不需要为了学习linux特意再去买一台电脑了，虚拟机能让用户在一台机器上模拟出多个操作系统的软件，一般的机器配置足够胜任虚拟机的任务。虚拟机不但可以虚拟出硬件资源，把实验环境与真机文件分离保证数据安全，更nb的是当你手残删掉系统核心配置时，还能有”快照“的功能，立即恢复到出错前的状态，省去装机的超长时间。。。。(Windows用户)VMware Workstation是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。下载激活地址：http://www.zdfans.com/html/5928.html(Mac用户) VMware fusion简单的说，虚拟机（virtual Machine）软件就是一套特殊的软件，同时可以用“多个操作系统”虚拟出硬件+操作系统==服务器+OS误区：学Linux不需要再物理机上安装，费时费力，采用虚拟机是最合适的方式</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715143727078-1973552951.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715144020795-347208669.png" alt="img"></p><p>Linux学习环境推荐电脑配置：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>笔记本电脑：1.内存8G2.磁盘500G SATA或者120G SSD3.i3,i5,i7处理器</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="为什么要通过VM虚拟机学习Linux？"><a href="#为什么要通过VM虚拟机学习Linux？" class="headerlink" title="为什么要通过VM虚拟机学习Linux？"></a>为什么要通过VM虚拟机学习Linux？</h1><p>什么？你又和我说搞双系统？老铁你的小霸王，打开windows需要5分钟。。双系统。。。。还是算了吧</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715145848386-170456558.png" alt="img"></p><ul><li><p>利用虚拟机搭建Linux学习环境简单方便、容易上手，最重要的是虚拟机模拟的Linux和真实服务器几乎无区别，以后工作了，也都是ssh连接到服务器，而不是坐在0度的机房操控服务器。因此虚拟机来模拟环境是最接近工作环境的</p></li><li><p>搭建Linux集群或者需要模拟多台服务器通信的时候，可以同时开启好几台虚拟机（前提本身机器硬件足够，虚拟机配置也选择较低的情况），虚拟机可以轻松满足多机器的需求。</p></li><li><p>自己租服务器？是个不错的选择，可以搭建Linux环境，并且用作个人开发学习使用。但是得花钱呀。。。。</p></li></ul><ul><li>很容易修改虚拟机（服务器）的配置，且不会影响自己的电脑，想删除虚拟机也不会影响电脑，因为虚拟机只是运行在电脑上的一个程序（一堆文件）</li></ul><h1 id="超哥手把手教你装虚拟机"><a href="#超哥手把手教你装虚拟机" class="headerlink" title="超哥手把手教你装虚拟机"></a>超哥手把手教你装虚拟机</h1><h2 id="1-准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）"><a href="#1-准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）" class="headerlink" title="1.准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）"></a>1.准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715150948154-930825626.png" alt="img"></p><h2 id="2-解压软件包，当前选择的是vm12"><a href="#2-解压软件包，当前选择的是vm12" class="headerlink" title="2.解压软件包，当前选择的是vm12"></a>2.解压软件包，当前选择的是vm12</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715151320079-929742541.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715151607034-1026981038.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715151741581-1899830534.png" alt="img"></p><p>全部“下一步”，安装即可，，这里无须说多</p><h2 id="3-安装好vmware虚拟机后，开始安装Linux"><a href="#3-安装好vmware虚拟机后，开始安装Linux" class="headerlink" title="3.安装好vmware虚拟机后，开始安装Linux"></a>3.安装好vmware虚拟机后，开始安装Linux</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152026777-201342832.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152153353-1601275196.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152350739-1942472916.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152728654-1117395886.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152928358-1607419151.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153142008-1600108425.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153233511-1274559113.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153329986-358960099.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153431500-1893205158.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153519327-1692747100.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153545015-961592455.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153625011-560747017.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153803366-947490800.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153924367-823293158.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715154205447-631511630.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715154433369-2106760403.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715154709752-2106936658.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715160600181-1513557331.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715161126939-657824379.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715161346434-790183842.png" alt="img"></p><h1 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h1><p>此时进入这个黑乎乎的界面，输入root账号与密码，成功进入linux系统</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715162003636-607799263.png" alt="img"></p><h1 id="确保你的Linux支持虚拟化"><a href="#确保你的Linux支持虚拟化" class="headerlink" title="确保你的Linux支持虚拟化"></a>确保你的Linux支持虚拟化</h1><p>　　安装 RHEL 7 或 CentOS 7 系统时，大家的电脑的 CPU 需要支持 VT(Virtualization Technology，虚拟化技术)。所谓 VT，指的是让单台计算机能够分割出多个独立资源区， 并让每个资源区按照需要模拟出系统的一项技术，其本质就是通过中间层实现计算机 资源的管理和再分配，让系统资源的利用率最大化。其实只要您的电脑不是五六年前 买的，价格不低于三千元，它的 CPU 就肯定会支持 VT 的。如果开启虚拟机后依然提 示“CPU 不支持 VT 技术”等报错信息，请重启电脑并进入到 BIOS 中把 VT 虚拟化功 能开启即可。</p><h1 id="你又忘了root密码？？？"><a href="#你又忘了root密码？？？" class="headerlink" title="你又忘了root密码？？？"></a>你又忘了root密码？？？</h1><p>　　针对好多好多同学经常忘记root密码。。。超哥这里给你整理怎么重置root密码！！</p><p>　　重启 Linux 系统主机并出现引导界面时，按下键盘上的 e 键进入内核编辑界面</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200454981-296642965.png" alt="img"></p><p>在 linux16 参数这行的最后面追加“rd.break”参数，然后按下 Ctrl + X 组合键来运行修 改过的内核程序</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200602854-2067722898.png" alt="img"></p><p>大约 30 秒过后，进入到系统的紧急求援模式，</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200630932-1408889196.png" alt="img"></p><p>依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux 系统了 </p><pre><code> mount -o remount,rw /sysroot    chroot /sysroot    passwd    touch /.autorelabelexit reboot</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200710908-118130154.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VMware与Centos系统安装&quot;&gt;&lt;a href=&quot;#VMware与Centos系统安装&quot; class=&quot;headerlink&quot; title=&quot;VMware与Centos系统安装&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/py</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>centos下redis安全相关</title>
    <link href="http://example.com/2019/11/15/Linux/centos%E4%B8%8Bredis%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2019/11/15/Linux/centos%E4%B8%8Bredis%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:43:43.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centos下redis安全相关"><a href="#centos下redis安全相关" class="headerlink" title="centos下redis安全相关"></a><a href="https://www.cnblogs.com/pyyu/p/9515937.html">centos下redis安全相关</a></h1><p>博文背景：</p><p>由于发现众多同学，在使用云服务器时，安装的redis3.0+版本都关闭了protected-mode，因而都遭遇了挖矿病毒的攻击，使得服务器99%的占用率！！</p><p>因此我们在使用redis时候，最好更改默认端口，并且使用redis密码登录。</p><p>（1）redis没有用户概念，redis只有密码<br>（2）redis默认在工作在保护模式下。不允许远程任何用户登录的（protected-mode）</p><p>redis.conf设置</p><pre><code>protected-mode yes   #打开保护模式port 6380  #更改默认启动端口requirepass xxxxxx   #设置redis启动密码，xxxx是自定义的密码</code></pre><p>启动redis服务端</p><pre><code>redis-server /opt/redis-4.0.10/redis.conf &amp;     #指定配置文件启动redis，且后台启动</code></pre><p>使用密码登录redis，使用6380端口</p><p>方法1，使用这个</p><pre><code>[root@oldboy_python ~ 09:48:41]#redis-cli -p 6380127.0.0.1:6380&gt; auth xxxxOK</code></pre><p>方法2，此方案不安全，容易暴露密码</p><pre><code>[root@oldboy_python ~ 09:49:46]#redis-cli -p 6380 -a xxxxWarning: Using a password with '-a' option on the command line interface may not be safe.127.0.0.1:6380&gt; pingPONG</code></pre><p>补充</p><p>检查redis是否设置了密码</p><p>127.0.0.1:6380&gt; CONFIG get requirepass</p><ol><li>“requirepass”</li><li>“xxxxxx”</li></ol><p>如果没有，也可以给redis设置密码（命令方式）</p><pre><code>CONFIG set requirepass "xxxxxx"</code></pre><p>因此你的redis就不容易被黑客入侵了。</p><p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1a36zff5cc86l">https://cloud.tencent.com/developer/support-plan?invite_code=1a36zff5cc86l</a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;centos下redis安全相关&quot;&gt;&lt;a href=&quot;#centos下redis安全相关&quot; class=&quot;headerlink&quot; title=&quot;centos下redis安全相关&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡</title>
    <link href="http://example.com/2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:37:32.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a><a href="https://www.cnblogs.com/pyyu/p/10004633.html">nginx负载均衡</a></h1><ul><li><a href="https://www.cnblogs.com/pyyu/p/10004583.html">集群概念</a></li><li><a href="https://www.cnblogs.com/pyyu/p/10004670.html">负载均衡</a></li><li><a href="https://www.cnblogs.com/pyyu/p/10004681.html">nginx负载均衡</a></li></ul><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nginx负载均衡&quot;&gt;&lt;a href=&quot;#nginx负载均衡&quot; class=&quot;headerlink&quot; title=&quot;nginx负载均衡&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/10004633.html&quot;&gt;ngin</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡实验</title>
    <link href="http://example.com/2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E9%AA%8C/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:37:26.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx负载均衡实验"><a href="#nginx负载均衡实验" class="headerlink" title="nginx负载均衡实验"></a><a href="https://www.cnblogs.com/pyyu/p/10004681.html">nginx负载均衡实验</a></h1><h1 id="Nginx负载均衡概述"><a href="#Nginx负载均衡概述" class="headerlink" title="Nginx负载均衡概述"></a>Nginx负载均衡概述</h1><pre><code>Web服务器，直接面向用户，往往要承载大量并发请求，单台服务器难以负荷，我使用多台WEB服务器组成集群，前端使用Nginx负载均衡，将请求分散的打到我们的后端服务器集群中，实现负载的分发。那么会大大提升系统的吞吐率、请求性能、高容灾</code></pre><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122233808543-706880577.png" alt="img"></p><p>Nginx要实现负载均衡需要用到proxy_pass代理模块配置</p><p>Nginx负载均衡与Nginx代理不同地方在于</p><p>Nginx代理仅代理一台服务器，而Nginx负载均衡则是将客户端请求代理转发至一组upstream虚拟服务池</p><p>Nginx可以配置代理多台服务器，当一台服务器宕机之后，仍能保持系统可用。</p><h1 id="upstream配置"><a href="#upstream配置" class="headerlink" title="upstream配置"></a>upstream配置</h1><p>在nginx.conf &gt; http 区域中</p><pre><code>upstream django {       server 10.0.0.10:8000;       server 10.0.0.11:9000;}</code></pre><p>在nginx.conf &gt; http 区域 &gt;  server区域  &gt; location配置中</p><p>添加proxy_pass</p><pre><code>location / {            root   html;            index  index.html index.htm;            proxy_pass http://django;}</code></pre><p>此时初步负载均衡已经完成，upstream默认按照轮训方式负载，每个请求按时间顺序逐一分配到后端节点。</p><h1 id="upstream分配策略"><a href="#upstream分配策略" class="headerlink" title="upstream分配策略"></a>upstream分配策略</h1><p>weight 权重</p><pre><code>upstream django {       server 10.0.0.10:8000 weight=5;       server 10.0.0.11:9000 weight=10;#这个节点访问比率是大于8000的}</code></pre><p>ip_hash</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器upstream django {　　　　ip_hash;       server 10.0.0.10:8000;       server 10.0.0.11:9000;}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>backup</strong></p><p><strong>在非backup机器繁忙或者宕机时，请求backup机器，因此机器默认压力最小</strong></p><pre><code>upstream django {       server 10.0.0.10:8000 weight=5;       server 10.0.0.11:9000;       server node.oldboy.com:8080 backup;}</code></pre><h1 id="负载均衡实验环境规划"><a href="#负载均衡实验环境规划" class="headerlink" title="负载均衡实验环境规划"></a>负载均衡实验环境规划</h1><pre><code>角色            ip                    主机名lb01        192.168.119.10        lb01    web01        192.168.119.11        web01web02        192.168.119.12        web02</code></pre><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><pre><code>iptables -Fsed  -i 's/enforcing/disabled/' /etc/selinux/configsystemctl stop firewalldsystemctl disable firewalld</code></pre><h2 id="一、web01服务器配置nginx，创建index-html"><a href="#一、web01服务器配置nginx，创建index-html" class="headerlink" title="一、web01服务器配置nginx，创建index.html"></a>一、web01服务器配置nginx，创建index.html</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>server {        listen       80;        server_name  192.168.119.11;        location / {        root /node;            index  index.html index.htm;        }}mkdir /nodeecho 'i am web01' &gt; /node/index.html#启动NGINX./sbgin/nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="二、web01服务器配置nginx-创建index-html"><a href="#二、web01服务器配置nginx-创建index-html" class="headerlink" title="二、web01服务器配置nginx,创建index.html"></a>二、web01服务器配置nginx,创建index.html</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>server {    listen       80;    server_name  192.168.119.12;    location / {        root /node;        index  index.html index.htm;}mkdir /nodeecho 'i am web02...' &gt; /node/index.html#启动nginx./sbing/nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="三、配置lb01服务器的nginx负载均衡"><a href="#三、配置lb01服务器的nginx负载均衡" class="headerlink" title="三、配置lb01服务器的nginx负载均衡"></a>三、配置lb01服务器的nginx负载均衡</h2><p>1.检查lb01的 nginx.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    upstream node {    　　server 192.168.119.11:80;    　　server 192.168.119.12:80;}    server {        listen       80;        server_name 192.168.119.10;        location / {        　　proxy_pass http://node;        　　include proxy_params;  #需要手动创建        }    }}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2.手动创建proxy_params文件，文件中存放代理的请求头相关参数</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@lb01 conf]# cat /opt/nginx/conf/proxy_paramsproxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_connect_timeout 30;proxy_send_timeout 60;proxy_read_timeout 60;proxy_buffering on;proxy_buffer_size 32k;proxy_buffers 4 128k;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>启动lb01负载均衡nginx服务./sbin/nginx</code></pre><h2 id="四、访问lb01节点nginx，反复刷新"><a href="#四、访问lb01节点nginx，反复刷新" class="headerlink" title="四、访问lb01节点nginx，反复刷新"></a>四、访问lb01节点nginx，反复刷新</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123114552274-506631111.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123114606575-1476598164.png" alt="img"></p><h1 id="五、nginx负载均衡调度算法"><a href="#五、nginx负载均衡调度算法" class="headerlink" title="五、nginx负载均衡调度算法"></a>五、nginx负载均衡调度算法</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>调度算法   　　 概述轮询    　　　　按时间顺序逐一分配到不同的后端服务器(默认)weight  　　   加权轮询,weight值越大,分配到的访问几率越高ip_hash   　　 每个请求按访问IP的hash结果分配,这样来自同一IP的固定访问一个后端服务器url_hash   　  按照访问URL的hash结果来分配请求,是每个URL定向到同一个后端服务器least_conn    最少链接数,那个机器链接数少就分发</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>1.轮询(不做配置，默认轮询)</p><p>2.weight权重(优先级)</p><p>3.ip_hash配置，根据客户端ip哈希分配，不能和weight一起用</p><h1 id="六、nginx动静分离负载均衡"><a href="#六、nginx动静分离负载均衡" class="headerlink" title="六、nginx动静分离负载均衡"></a>六、nginx动静分离负载均衡</h1><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123121107048-1594518031.png" alt="img"></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><pre><code>系统                 服务                软件                ip地址centos7(lb01)                负载均衡            nginx proxy        192.168.119.10centos7(web01)                静态资源            nginx静态资源        192.168.119.11centos7(web02)                动态资源            django            192.168.119.12</code></pre><h2 id="一、在web01机器上，配置静态资源，图片等"><a href="#一、在web01机器上，配置静态资源，图片等" class="headerlink" title="一、在web01机器上，配置静态资源，图片等"></a>一、在web01机器上，配置静态资源，图片等</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>cat nginx.confserver {        listen       80;        server_name  192.168.119.11;        #定义网页根目录         root /code;        #定义了静态资源        index index.html;#域名匹配，所有的png、jpg、gif请求资源，都去/root/code/images底下找         location ~* .*\.(png|jpg|gif)$ {                root /code/images;        }    #重启nginx./sbin/nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#创建目录mkdir -p /code/images#准备首页文件[root@web01  /code]$cat index.htmlstatic files...#准备静态文件，图片[root@web01  /code/images]$wget http://pythonav.cn/av/girlone.jpg^C[root@web01  /code/images]$lsgirlone.jpg</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="二、在web02配置动态请求，准备一个flask程序和静态资源转发"><a href="#二、在web02配置动态请求，准备一个flask程序和静态资源转发" class="headerlink" title="二、在web02配置动态请求，准备一个flask程序和静态资源转发"></a>二、在web02配置动态请求，准备一个flask程序和静态资源转发</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>cat  nginx.conf#静态资源地址upstream static {server 192.168.119.11:80;}#flask动态请求upstream flask {server 192.168.119.12:8080;}    server {        listen       80;        server_name  192.168.119.12;　　　　　　#当请求到达192.168.119.12:80/时，转发给flask的8080应用        location / {            proxy_pass http://flask;            include proxy_params;        }　　　　　　#当判断资源请求是 192.168.119.12/girl.jpg时候，转发请求给static地址池的服务器192.168.119.11/        location ~ .*\.(png|jpg|gif)$ {　　　　　　　　proxy_pass http://static;include proxy_params;}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>准备flask应用,flask.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>from flask import Flaskapp=Flask(__name__)@app.route('/')def hello():    return "i am flask....from nginx"if __name__=="__main__":    app.run(host='0.0.0.0',port=8080)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>后台运行flask程序</p><pre><code>python flask-web.py &amp;</code></pre><h2 id="三、在负载均衡服务器lb01上测试访问192-168-119-10"><a href="#三、在负载均衡服务器lb01上测试访问192-168-119-10" class="headerlink" title="三、在负载均衡服务器lb01上测试访问192.168.119.10"></a>三、在负载均衡服务器lb01上测试访问192.168.119.10</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123164434807-990604537.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123164441415-1872980063.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123164506188-1615595481.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nginx负载均衡实验&quot;&gt;&lt;a href=&quot;#nginx负载均衡实验&quot; class=&quot;headerlink&quot; title=&quot;nginx负载均衡实验&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/10004681.html</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
