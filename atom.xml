<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>多走几步</title>
  
  <subtitle>多走几步</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-01T05:42:30.074Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>wl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/10/01/hello-world/"/>
    <id>http://example.com/2020/10/01/hello-world/</id>
    <published>2020-10-01T05:42:30.074Z</published>
    <updated>2020-10-01T05:42:30.074Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PicGo+GitHub图床</title>
    <link href="http://example.com/2019/12/01/github/PicGo+GitHub%E5%9B%BE%E5%BA%8A/"/>
    <id>http://example.com/2019/12/01/github/PicGo+GitHub%E5%9B%BE%E5%BA%8A/</id>
    <published>2019-12-01T05:43:10.000Z</published>
    <updated>2020-05-13T02:13:08.620Z</updated>
    
    <content type="html"><![CDATA[<p>一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种<strong>“轻量级标记语言”</strong>。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：<strong>Typora</strong>和<strong>马克飞象</strong>。</p><p>目前我是两款编辑器混合时候，当编写的Markdown文档需要和印象笔记对接的时候，则使用马克飞象；至于其他用途的文档就使用Typora。则两款编辑器都<strong>近乎完美但是却又不能达到完美</strong>。我写文档的时候经常需要截图，然后从剪贴板从直接黏贴放进文档，则两款编辑器虽然都能满足这种操作，但是其实现原理不过是<strong>将截图存放在本机电脑上</strong>，所以，一旦文档中有了截图，将Markdown文档的迁移到别的电脑上展示的成本就大大增加（图片也要一并复制过去）。</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-7f243dd5df471fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/693/format/webp" alt="img"></p><p>这是Typora对图片的解决方案</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-4871e650d1bbb1ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/283/format/webp" alt="img"></p><p>这是马克飞象中对图片的解决方案</p><p>这两款编辑器对图片处理的方法简直是丧尽天良，也是我在使用过程中唯一觉得不爽的一点。辛苦搜寻之下，终于让我找到了一种解决方案：<strong>PicGo+GitHub图床</strong></p><blockquote><p>注：实际上，Mac OS 上的Typora编辑器已经支持将本地图片或者截图先上传到服务器生成访问链接后，在存放到Markdown文档中，简单点说，Mac OS上的Typora是完美的（😭无奈我是Windows用户）</p></blockquote><h1 id="PicGo介绍"><a href="#PicGo介绍" class="headerlink" title="PicGo介绍"></a><a href="https://github.com/Molunerfinn/PicGo">PicGo介绍</a></h1><p>这是一款图片上传的工具，目前支持<code>微博图床</code>，<code>七牛图床</code>，<code>腾讯云</code>，<code>又拍云</code>，<code>GitHub</code>等图床，未来将支持更多图床。</p><p>所以解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪😊。</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-a818a6851f18d336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><p>Pic Go支持的图床</p><p>在众多的图床中，我选择的GitHub图床，其它类型的图床如果你们有兴趣的话可以试一下。</p><h1 id="创建自己的GitHub图床"><a href="#创建自己的GitHub图床" class="headerlink" title="创建自己的GitHub图床"></a>创建自己的GitHub图床</h1><h2 id="1-创建GitHub图床之前，需要注册-登陆GitHub账号"><a href="#1-创建GitHub图床之前，需要注册-登陆GitHub账号" class="headerlink" title="1. 创建GitHub图床之前，需要注册/登陆GitHub账号"></a>1. 创建GitHub图床之前，需要注册/登陆GitHub账号</h2><blockquote><p>申请GitHub账号很简单，我就不演示了</p></blockquote><h2 id="2-创建Repository"><a href="#2-创建Repository" class="headerlink" title="2. 创建Repository"></a>2. 创建Repository</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-25f1990a188f9103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>点击”New repository”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-596d8282a217da7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1097/format/webp" alt="img"></p><p>最后1234步骤执行</p><blockquote><ul><li>我已经建立过一个同名的repository的，所以第一步会显示红色</li><li>第三步，为repository初始化一个README.md文件可以根据需求选择，非必选</li></ul></blockquote><h2 id="3-生成一个Token用于操作GitHub-repository"><a href="#3-生成一个Token用于操作GitHub-repository" class="headerlink" title="3.生成一个Token用于操作GitHub repository"></a>3.生成一个Token用于操作GitHub repository</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-69a2b38f4634e509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>回到主页，点击”Settings”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-833a01142ad92e6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1060/format/webp" alt="img"></p><p>进入页面后，点击”Developer settings”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-3ba67ab9f5224bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>点击”Personal access tokens”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-8d67725f463f5fc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>创建新的Token</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-2cddeffa8fe35933.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1123/format/webp" alt="img"></p><p>填写描述，选择”repo”,然后点击”Generate token”按钮</p><blockquote><p>注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存</p></blockquote><h1 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h1><h2 id="1-下载运行PicGo"><a href="#1-下载运行PicGo" class="headerlink" title="1. 下载运行PicGo"></a>1. 下载运行PicGo</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-9fe439e9625c741f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1077/format/webp" alt="img"></p><p>下载zip包后，解压，运行可执行文件</p><h2 id="2-配置图床"><a href="#2-配置图床" class="headerlink" title="2. 配置图床"></a>2. 配置图床</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-33b10cfcc147cdc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><p>如图配置</p><blockquote><ul><li>设定仓库名的时候，是按照“账户名/仓库名的格式填写”</li><li>分支名统一填写“master”</li><li>将之前的Token黏贴在这里</li><li>存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹</li><li>自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上<code>https://raw.githubusercontent.com/用户名/RepositoryName/分支名，</code>，自定义域名需要按照这样去填写</li></ul></blockquote><h2 id="3-快捷键及相关配置"><a href="#3-快捷键及相关配置" class="headerlink" title="3.快捷键及相关配置"></a>3.快捷键及相关配置</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-8d2c2729e4f16fd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><p>可以按照这样配置</p><blockquote><p>注：可以将快捷键设置为<code>ctrl+shift+c</code></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>将上面的步骤都设置好之后，就可以让自己的Markdown文档飞起来了，每次截图之后，都可以按一下<code>ctrl+shift+c</code>，这样就会将剪切板上面的截图转化为在线网络图片链接，简直就是爽的不要不要的！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种&lt;strong&gt;“轻量级标记语言”&lt;/strong&gt;。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：&lt;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="转载" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch</title>
    <link href="http://example.com/2019/11/16/Elasticsearch/es/"/>
    <id>http://example.com/2019/11/16/Elasticsearch/es/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:18:04.713Z</updated>
    
    <content type="html"><![CDATA[<p>博客:<a href="https://www.cnblogs.com/Neeo">https://www.cnblogs.com/Neeo</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客:&lt;a href=&quot;https://www.cnblogs.com/Neeo&quot;&gt;https://www.cnblogs.com/Neeo&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="http://example.com/2019/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/sf/"/>
    <id>http://example.com/2019/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/sf/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:17:08.957Z</updated>
    
    <content type="html"><![CDATA[<p>博客:<a href="https://www.cnblogs.com/bobo-zhang/category/1417180.html">https://www.cnblogs.com/bobo-zhang/category/1417180.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客:&lt;a href=&quot;https://www.cnblogs.com/bobo-zhang/category/1417180.html&quot;&gt;https://www.cnblogs.com/bobo-zhang/category/1417180.html&lt;/a&gt;&lt;/p&gt;
&lt;s</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>爬虫</title>
    <link href="http://example.com/2019/11/16/%E7%88%AC%E8%99%AB/pc/"/>
    <id>http://example.com/2019/11/16/%E7%88%AC%E8%99%AB/pc/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:17:33.571Z</updated>
    
    <content type="html"><![CDATA[<p>博客:<a href="https://www.cnblogs.com/bobo-zhang/">https://www.cnblogs.com/bobo-zhang/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客:&lt;a href=&quot;https://www.cnblogs.com/bobo-zhang/&quot;&gt;https://www.cnblogs.com/bobo-zhang/&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>自动化运维ansible</title>
    <link href="http://example.com/2019/11/16/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E9%A1%B9%E7%9B%AE/zdhyw/"/>
    <id>http://example.com/2019/11/16/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E9%A1%B9%E7%9B%AE/zdhyw/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:16:44.147Z</updated>
    
    <content type="html"><![CDATA[<p>博客:<a href="https://blog.51cto.com/wangfeng7399">https://blog.51cto.com/wangfeng7399</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客:&lt;a href=&quot;https://blog.51cto.com/wangfeng7399&quot;&gt;https://blog.51cto.com/wangfeng7399&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>DjangoRestFramework + VUE 项目</title>
    <link href="http://example.com/2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E7%8E%A9%E5%85%B7/znwj/"/>
    <id>http://example.com/2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E7%8E%A9%E5%85%B7/znwj/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T08:04:50.765Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/DragonFire/p/10356615.html">Celery - 一个懂得 异步任务 , 定时任务 , 周期任务 的芹菜</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9498396.html">DBUtils - Python数据库连接池</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260299.html">Flask最强攻略 - 跟DragonFire学Flask - 第八篇 实例化Flask的参数 及 对app的配置</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9255637.html">Flask最强攻略 - 跟DragonFire学Flask - 第二篇 Flask 中的 Render Redirect HttpResponse</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9264381.html">Flask最强攻略 - 跟DragonFire学Flask - 第九篇 Flask 中的蓝图(BluePrint)</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260228.html">Flask最强攻略 - 跟DragonFire学Flask - 第六篇 Flask 中内置的 Session</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260295.html">Flask最强攻略 - 跟DragonFire学Flask - 第七篇 Flask 中路由系统</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9259395.html">Flask最强攻略 - 跟DragonFire学Flask - 第三篇 Flask 中的 request 之 先知道有这么个东西</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10365963.html">Flask最强攻略 - 跟DragonFire学Flask - 第十六篇 Flask-Migrate</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9269303.html">Flask最强攻略 - 跟DragonFire学Flask - 第十篇 before_request after_request</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10363353.html">Flask最强攻略 - 跟DragonFire学Flask - 第十四篇 Flask-SQLAlchemy</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10365827.html">Flask最强攻略 - 跟DragonFire学Flask - 第十五篇 Flask-Script</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9259999.html">Flask最强攻略 - 跟DragonFire学Flask - 第四篇 Flask 中的模板语言 Jinja2 及 render_template 的深度用法</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260124.html">Flask最强攻略 - 跟DragonFire学Flask - 第五篇 做一个用户登录之后查看学员信息的小例子</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9254637.html">Flask最强攻略 - 跟DragonFire学Flask - 第一篇 你好,我叫Flask</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10166527.html">SQLAlchemy 增删改查 一对多 多对多</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9788927.html">websocket 工作原理</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/DragonFire/p/10356615.html&quot;&gt;Celery - 一个懂得 异步任务 , 定时任务 , 周期任务 的芹菜&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>DjangoRestFramework + VUE 项目</title>
    <link href="http://example.com/2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E5%9F%8E/lf/"/>
    <id>http://example.com/2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E5%9F%8E/lf/</id>
    <published>2019-11-16T11:24:01.000Z</published>
    <updated>2019-11-18T07:58:58.515Z</updated>
    
    <content type="html"><![CDATA[<p>VUE学习目录:<a href="https://www.cnblogs.com/clschao/articles/10706528.html">https://www.cnblogs.com/clschao/articles/10706528.html</a></p><p>DjangoRestFramework学习:</p><p><a href="https://www.cnblogs.com/clschao/articles/10709740.html">https://www.cnblogs.com/clschao/articles/10709740.html</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10711600.html">https://www.cnblogs.com/clschao/articles/10711600.html</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10732867.html">https://www.cnblogs.com/clschao/articles/10732867.html</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10746758.html">Django学习之django自带的contentType表:</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10757374.html">python时间类型转换</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10759183.html">redis简单操作</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10745966.html">跨域和CORS</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;VUE学习目录:&lt;a href=&quot;https://www.cnblogs.com/clschao/articles/10706528.html&quot;&gt;https://www.cnblogs.com/clschao/articles/10706528.html&lt;/a&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux之文档与目录结构</title>
    <link href="http://example.com/2019/11/15/Linux/Linux%E4%B9%8B%E6%96%87%E6%A1%A3%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2019/11/15/Linux/Linux%E4%B9%8B%E6%96%87%E6%A1%A3%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:37:45.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之文档与目录结构"><a href="#Linux之文档与目录结构" class="headerlink" title="Linux之文档与目录结构"></a><a href="https://www.cnblogs.com/pyyu/p/9213237.html">Linux之文档与目录结构</a></h1><h1 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h1><p>Linux目录结构的组织形式和Windows有很大的不同。首先Linux没有“盘(C盘、D盘、E盘)”的概念。已经建立文件系统的硬盘分区被挂载到某一个目录下，用户通过操作目录来实现磁盘读写。</p><p>Linux不像Windows那样的系统目录，Linux使用正斜杠”/“而不是反斜杠”"来标识目录。</p><p>Windows目录：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622134224409-1941390599.png" alt="img"></p><p>Linux目录：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622134328724-1952764525.png" alt="img"></p><p>Linux首先是建立一个根”/“文件系统，所有的目录也都是由根目录衍生出来。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719224707794-816913824.png" alt="img"></p><p>登录系统后，在当前命令窗口输入命令:</p><pre><code>ls /</code></pre><p>查看结果如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622134847306-163954950.png" alt="img"></p><p>在Linux底下，所有的文件与目录都是由根目录开始，是目录与文件的源头，然后一个个的分支下来，如同树枝状，因此称为这种目录配置为：目录树。</p><p>目录树的特点是什么呢？</p><ul><li>目录树的起始点是根目录(/,root);</li><li>每一个目录不止能使用本地的文件系统，也可以使用网络上的文件系统，可以利用NFS服务器挂载特定目录。</li><li>每一个文件在此目录树中的文件名，包含完整路径都是独一无二的。</li></ul><h2 id="目录树架构示意图"><a href="#目录树架构示意图" class="headerlink" title="目录树架构示意图"></a>目录树架构示意图</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180823103948862-1376998015.png" alt="img"></p><p>以下是对这些目录的解释：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180921150307683-759085586.png" alt="img"></p><ul><li><p><strong>/bin</strong>：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><strong>/dev ：</strong><br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><strong>/home</strong>：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li><li><p><strong>/lib</strong>：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>/media</strong>：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>/opt</strong>：<br> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>/proc</strong>：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></pre></li><li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>/sbin</strong>：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/selinux</strong>：<br> 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li><li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>/sys</strong>：<br> 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p><p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</p></li></ul><p>  该文件系统是内核设备树的一个直观反映。</p><p>  当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><ul><li><p><strong>/tmp</strong>：<br>这个目录是用来存放一些临时文件的。</p></li><li><p><strong>/usr</strong>：<br> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p></li><li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p></li><li><p><strong>/var</strong>：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li></ul><p>在linux系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p><p>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。</p><p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。</p><p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。</p><h1 id="为什么要学习linux命令"><a href="#为什么要学习linux命令" class="headerlink" title="为什么要学习linux命令"></a>为什么要学习linux命令</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322164008764-1025212772.png" alt="img"></p><p><strong>当年超哥在一家美资企业，一位台湾老程序员送我的一本书。。。</strong></p><p><strong>可能是看我骨骼惊奇吧！！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322164133605-1830349359.png" alt="img"></p><h1 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322164249397-825723345.png" alt="img"></p><p>我们知道切换目录的指令是cd，那么首先得知道如何切换目录，这个得用心记呀！</p><pre><code>.    当前目录..    上一层目录-    前一个工作目录~    当前【用户】所在的家目录</code></pre><p>需要注意的是，在所有目录底下都存在两个目录，分别是【.】和【..】，分别代表当前目录，上层目录！那么如何证明它的存在呢？</p><pre><code>命令： ls -la /查看命令解释：man ls  (Linux下的帮助指令)结论：ls - list directory contens (列出目录内容)ls -la /  以竖状格式化显示列出/目录所有内容</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716132338853-107586297.png" alt="img"></p><p>接下来看一下常用的目录处理指令：</p><pre><code>cd : (change directory,更改目录)pwd:(显示当前目录)mkdir:(建立一个新目录)rmdir:（删除一个空目录）</code></pre><h1 id="cd命令，变换目录"><a href="#cd命令，变换目录" class="headerlink" title="cd命令，变换目录"></a>cd命令，变换目录</h1><p>cd是change directory的缩写，这是用来变换工作目录的命令，注意命令和目录之间有一个空格。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716134328013-1031650900.png" alt="img"></p><h1 id="mkdir，建立新目录"><a href="#mkdir，建立新目录" class="headerlink" title="mkdir，建立新目录"></a>mkdir，建立新目录</h1><p>mkdir是make directory的缩写，用来建立新目录，在默认情况下，目录得一级一级的建立。</p><p>例如我要建立/home/oldboy/python目录，我就必须有/home，然后/home/oldboy，最后/home/oldboy/python，如果没有/home/oldboy，则不能建立python目录！</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716142641730-1625463100.png" alt="img"></p><p> 可见高效的创建目录用上-p参数，可以直接执行命令【mkdir -p /home/oldboy/python】，系统会自动添加上/home，/home/oldboy，/home/oldboy/python依次建立目录，是不是很方便，^ ^ </p><h1 id="rmdir，删除空目录"><a href="#rmdir，删除空目录" class="headerlink" title="rmdir，删除空目录"></a>rmdir，删除空目录</h1><p>当我想删除一个空目录时，就用rmdir吧，例如我想删除刚才建立的oldboy目录，以及/tmp/oldboy/python,那么可以使用【rmdir oldboy】，但是注意rmdir只能删除空目录。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180717231355821-689929245.png" alt="img"></p><pre><code>删除命令可以正确使用【rm -rf】</code></pre><h1 id="Linux的路径PATH"><a href="#Linux的路径PATH" class="headerlink" title="Linux的路径PATH"></a>Linux的路径PATH</h1><p>同学们应该都会配置windows下的环境变量（PATH），都知道系统会按照PATH的设定，去每个PATH定义的目录下搜索可执行文件。</p><p>那么如何查看Linux下的PATH环境变量呢？</p><pre><code>执行命令：echo $PATHecho命令是有打印的意思$符号后面跟上PATH,表示输出PATH的变量</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180717232700721-1562018264.png" alt="img"></p><p>PATH(一定是大写的)这个变量是由一堆目录组成，分隔符是”:”号，而不同于windows的”;”号。</p><h1 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h1><p>Linux中非常重要的概念–路径，路径用来定位如何找到某个文件。</p><p>这里超哥先讲个例子，到底什么是相对路径，绝对路径</p><p>比如一个老外，要来老男孩教育学习python，但是他找不到地点，因此向你问路，你可以告诉他：</p><p>　  　1.先坐飞机来中国北京，从北京机场坐地铁到沙河地铁站，然后走路800米到沙河汇德商厦，上四楼，找到超哥，结束寻路。</p><p>　　2. 超哥就在汇德商厦403办公室，武佩奇后面坐着呢！！！</p><p>Linux下特别注意文件名/路径的写法，可以将所谓的路径(path)定义为绝对路径(absolute)和相对路径(relative)。这两种文件名/路径的写法依据是这样的：</p><ul><li>绝对路径：由根目录(/)为开始写起的文件名或者目录名称，如/home/oldboy/test.py;</li><li>相对路径：相对于目前路径的文件名写法。例如./home/oldboy/exam.py或../../home/oldboy/exam.py，简单来说只要开头不是/，就是属于相对路径</li></ul><p>因此你必须了解，相对路径是：以你当前所在路径的相对路径来表示的。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622140257547-1356616310.png" alt="img"></p><p>例如你现在在/home 这个目录下，如要进入/var/log这个路径，如何写呢？</p><ol><li>cd /var/log (绝对路径)</li><li>cd ../var/log(相对路径)</li></ol><p>结果如图：</p><p>因为你在/home底下，因此你要回到上一层(../)之后，才能继续前往/var，特别注意：</p><ul><li>.   :代表当前的目录，也可以用./ 来表示</li><li>..  :代表上一层的目录，也可以用../来表示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622140612606-771359419.png" alt="img"></p><p>分割线—-</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622140823060-347310504.png" alt="img"></p><p>这个.与..目录概念非常重要，平时经常会看到cd ..或者python ../home/oldboy/exam.py 就是代表进入上一层与执行相对路径的python代码！</p><pre><code>1.linux是以 / 开始的树状目录结构,tree查看2.常用文件目录操作命令是ls,cd,mkdir,rmdir3.Linux的PATH查看是 echo $PATH，可以修改/etc/profile文件永久生效,以冒号分割4.绝对路径,相对路径的查看5.文件权限chmod chgrp chown</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322172711042-37362360.png" alt="img"></h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322172929688-1107644884.png" alt="img"></p><h1 id="Linux的文件系统"><a href="#Linux的文件系统" class="headerlink" title="Linux的文件系统"></a>Linux的文件系统</h1><p>用户在硬件存储设备中执行的文件建立，写入，读取，修改，转存与控制等操作都是依赖文件系统完成的。文件系统的作用是合理规划硬盘，保证用户正常使用。</p><p>Linux系统支持数十种文件系统，常见文件系统如下。</p><ul><li>Ext3    是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能 自动修复数据的不一致与错误。</li><li>Ext4     Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，它支持的存储容 量高达 1EB(1EB=1,073,741,824GB)，且能够有无限多的子目录。另外，Ext4 文件系统能够批量分配 block 块，从而极大地提高了读写效率。</li><li>XFS     是一种高性能的日志文件系统，而且是 RHEL 7 中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的 日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为 18EB， 这几乎满足了所有需求。</li></ul><pre><code>/etc/fstab是用来存放文件系统的静态信息的文件cat /etc/fstab #检查linux的文件系统</code></pre><p>练习</p><pre><code>1.在/home/目录创建文件夹oldboy,进入oldboy创建helloLinux.txt2.创建/tmp/chaogeLinux.txt，用绝对路径方式与相对路径两种方法3.在/tmp/目录下创建chaogeDir目录4.查看linuxPATH5.修改chaogeLinux.txt文件属主是chaoge,权限是可读可写</code></pre><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux之文档与目录结构&quot;&gt;&lt;a href=&quot;#Linux之文档与目录结构&quot; class=&quot;headerlink&quot; title=&quot;Linux之文档与目录结构&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/9213237</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程实战</title>
    <link href="http://example.com/2019/11/15/Linux/Shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%20/"/>
    <id>http://example.com/2019/11/15/Linux/Shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%20/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T06:18:30.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell编程实战"><a href="#Shell编程实战" class="headerlink" title="Shell编程实战"></a><a href="https://www.cnblogs.com/pyyu/p/9552661.html">Shell编程实战</a></h1><h1 id="为什么要学习Shell编程"><a href="#为什么要学习Shell编程" class="headerlink" title="为什么要学习Shell编程"></a>为什么要学习Shell编程</h1><p>Shell脚本语言是实现Linux/Unix系统管理及自动化运维所必须的重要工具，Linux系统的底层以及基础应用软件的核心大都涉及Shell脚本的内容。</p><p>一个合格的Linux系统管理员都必须熟练编写Shell脚本语言，从而提升运维人员的工作效率，减少不必要的重复性工作。</p><h2 id="学习Shell所需的基础知识"><a href="#学习Shell所需的基础知识" class="headerlink" title="学习Shell所需的基础知识"></a>学习Shell所需的基础知识</h2><p><strong>熟练使用VIm编辑器，熟悉SSH终端等配置</strong></p><p>在Linux下开发shell脚本用的最多的就是vim编辑器，熟练使用vim可以使得shell脚本开发事半功倍！</p><p><strong>有一定的Linux命令基础，熟练掌握80个命令以上</strong></p><p>shell和其他脚本语言不同，如python，Shell缺少可以直接使用的外部函数库，因此Linux系统的命令就可以当做Shell的函数库！</p><p><strong>熟悉常见Linux服务部署，优化，分析与排错</strong></p><p>学习Shell直接的目的是在工作中对系统以及服务进行自动化管理，因此如果不熟悉服务操作，使用shell也就没有意义了</p><h1 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180829102203128-345530932.png" alt="img"></p><p>Shell存在于操作系统的最外层，负责与用户直接对话，把用户的输入解释给操作系统，处理操作系统的输出结果，然后反馈给用户。</p><p>Shell是一个命令解释器，它的作用是解释并执行用户输入的命令和程序等，用户每输入一条命令，Shell解释器就执行一条，存在一种交互的方式。</p><p>从开机准备输入用户名和密码，到登录成功，所有的操作都是Shell解释并执行的。</p><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2><p>当命令或者程序语句不是在命令行中执行，而是通过一个程序文件来执行时，这个程序就称作Shell脚本。</p><p><strong>一个简单的Shell脚本</strong></p><p>清除/var/log下的messages日志文件</p><p>把所有命令放入一个文件，堆积起来后就是一个脚本文件！注意文件的可执行权限，与用户身份</p><pre><code>#清除脚本日志cd /var/logcat /dev/null &gt; messagesecho "Logs cleaned up . done"</code></pre><h2 id="Shell脚本语言的种类"><a href="#Shell脚本语言的种类" class="headerlink" title="Shell脚本语言的种类"></a>Shell脚本语言的种类</h2><pre><code>Shell脚本语言是弱类型语言（无须定义变量的类型即可使用）在Linux中有两大Shell，一是Bourne shell，二是C shell我们需要知道的就是标准的Bourne Again shell(bash)所取代查看CentOS 7系统的Shell</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180829104819001-1048787426.png" alt="img"></p><p>其他的脚本语言</p><pre><code>phpPerlPython</code></pre><p>语言选择</p><pre><code>Shell脚本语言优势在于处理系统底层的业务，基于linux命令处理也是最快的，常用语开发自动化安装，监控报警，软件启动等脚本。</code></pre><h2 id="第一个Shell脚本与hello-world"><a href="#第一个Shell脚本与hello-world" class="headerlink" title="第一个Shell脚本与hello world"></a>第一个Shell脚本与hello world</h2><p>脚本开头</p><pre><code>一个规范的脚本文件会在第一行指出由哪个程序来执行脚本的内容，必须位于第一行！！！如果你不加默认也会交给bash解释，良好的编程习惯，最好加上开头解释器语言标识#!/bin/bash#!/usr/bin/env python</code></pre><h2 id="执行Shell脚本的方式"><a href="#执行Shell脚本的方式" class="headerlink" title="执行Shell脚本的方式"></a>执行Shell脚本的方式</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>bash 脚本名sh    脚本名此方法是脚本没有可执行权限时，或者文件头没指定解释器时用的方法path/scriptName./scriptName 此方法需要脚本有可执行权限，chmod +x scriptNamesource scriptName. scriptName加载并执行脚本文件中的命令和语句</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python /tmp 11:10:08]#sh test.shchaoge nb[root@oldboy_python /tmp 11:10:18]#cat test.sh#!/bin/bashecho 'chaoge nb'[root@oldboy_python /tmp 11:10:21]#. test.shchaoge nb[root@oldboy_python /tmp 11:10:33]#source  test.shchaoge nb#添加可执行权限给test.shchmod +x test.sh./test.sh</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><pre><code>环境变量一般指的是export内置命令导出的变量，用于定义SHell的运行环境。Shell通过环境变量来确定命令提示符，也就是超哥前面说的PS1变量环境变量可以在命令行中设置和创建，但是用户退出命令行时变量值就会丢失，因此可以写入/etc/profile文件中，每次用户登录时，变量都会被初始化！环境变量名字均大写，用env查看</code></pre><p>设置登录的提示</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 11:21:51]#cat /etc/motd'welcome chaoge bakcome~~~~~~~~~'</code></pre><p>yudanL:~ yuchao$ ssh <a href="mailto:root@192.168.11.11">root@192.168.11.11</a><br>Last failed login: Wed Aug 29 11:20:20 CST 2018 from 111.231.199.24 on ssh:notty<br>There were 25 failed login attempts since the last successful login.<br>Last login: Wed Aug 29 10:45:51 2018 from 223.72.74.11<br>‘welcome chaoge bakcome<del>~</del>`’</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>定义变量</p><p>变量定义的注意点</p><ul><li>变量名和等号之间不能有空格</li><li>命名只能用英文字母，数字，下划线，首个字符不能用数字</li><li>不能用标点符号</li><li>不能用关键字</li></ul><pre><code>name='chaoge'echo $nameecho ${name} #帮助解释器识别变量的边界#变量重新赋值name='chaogenb'</code></pre><p>设置只读变量</p><pre><code>[root@oldboy_python ~ 11:29:31]#readonly name[root@oldboy_python ~ 11:30:27]#name='chaogenb3'-bash: name: 只读变量</code></pre><p>删除变量</p><pre><code>unset name</code></pre><p>变量类型</p><ul><li>局部变量 在脚本或命令中定义，仅在当前shell有效</li><li>环境变量 所有的程序，shell程序都能访问环境变量</li><li>shell变量 特殊变量 既有环境变量 又有局部变量</li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串可以用单引号，也可以双引号，也可以没引号</p><pre><code>[root@oldboy_python ~ 11:42:42]#addr='shahe'[root@oldboy_python ~ 11:44:55]#echo $addrshahe</code></pre><p>单引号的任何字符串都会原样输出，单引号字符串中的变量无效</p><p>单引号字符串不能出现单一的单引号，转义符也不可用，可用作字符串拼接</p><p>双引号</p><p>双引号里可以用变量</p><p>双引号可以有转义符</p><pre><code>[root@oldboy_python ~ 11:45:01]#addr='changpingshahe'[root@oldboy_python ~ 11:48:06]#name='yuchao'[root@oldboy_python ~ 11:49:00]#message="Hello,${name},Your addr is \"${addr}\" "[root@oldboy_python ~ 11:50:05]#echo $messageHello,yuchao,Your addr is "changpingshahe"</code></pre><p> 获取字符串长度</p><pre><code>[root@oldboy_python ~ 13:36:35]#str='abc'[root@oldboy_python ~ 13:36:49]#echo ${#str}3</code></pre><p>切片操作</p><p>左闭又开规则</p><pre><code>[root@oldboy_python ~ 13:39:45]#str='I am chaoge,hello world!'#取出0和10索引的字符[root@oldboy_python ~ 13:40:42]#echo ${str:0:11}I am chaoge</code></pre><p>查找字符索引</p><pre><code>[root@oldboy_python ~ 13:45:02]#str='I am chaoge,hello world!'[root@oldboy_python ~ 13:46:20]#echo `expr index "$str" e`11</code></pre><pre><code></code></pre><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shell编程实战&quot;&gt;&lt;a href=&quot;#Shell编程实战&quot; class=&quot;headerlink&quot; title=&quot;Shell编程实战&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/9552661.html&quot;&gt;Shell</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装之python开发</title>
    <link href="http://example.com/2019/11/15/Linux/Ubuntu%E5%AE%89%E8%A3%85%E4%B9%8Bpython%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2019/11/15/Linux/Ubuntu%E5%AE%89%E8%A3%85%E4%B9%8Bpython%E5%BC%80%E5%8F%91/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T06:12:48.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu安装之python开发"><a href="#Ubuntu安装之python开发" class="headerlink" title="Ubuntu安装之python开发"></a><a href="https://www.cnblogs.com/pyyu/p/9900100.html">Ubuntu安装之python开发</a></h1><p>什么？？公司要用Ubuntu(乌班图)？不会用？？怎么进行python开发？？？ </p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181102234826274-1090648545.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181103110824916-662123880.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181103110854741-1122135979.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181103110906518-1242690910.png" alt="img"></p><pre><code>乌班图操作系统下载地址：http://releases.ubuntu.com/18.04/ubuntu-18.04.1-desktop-amd64.iso</code></pre><p>  安装ubuntu</p><h2 id="第一步：准备好vmware虚拟机"><a href="#第一步：准备好vmware虚拟机" class="headerlink" title="第一步：准备好vmware虚拟机"></a>第一步：准备好vmware虚拟机</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113165258990-1315543038.png" alt="img">自行解决。。。</p><h2 id="第二步：安装ubuntu"><a href="#第二步：安装ubuntu" class="headerlink" title="第二步：安装ubuntu"></a>第二步：安装ubuntu</h2><p>[**详细安装过程**](<a href="https://www.cnblogs.com/pyyu/p/%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">https://www.cnblogs.com/pyyu/p/详细安装过程</a>  <a href="https://blog.csdn.net/u013142781/article/details/50529030">https://blog.csdn.net/u013142781/article/details/50529030</a>)</p><p>[**<a href="https://blog.csdn.net/u013142781/article/details/50529030**]">https://blog.csdn.net/u013142781/article/details/50529030**]</a>(<a href="https://www.cnblogs.com/pyyu/p/%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">https://www.cnblogs.com/pyyu/p/详细安装过程</a>  <a href="https://blog.csdn.net/u013142781/article/details/50529030">https://blog.csdn.net/u013142781/article/details/50529030</a>)</p><pre><code>1.设置好用户的账号密码2.可以自行通过sudo su - 切换root用户3.学习ubuntu相关命令</code></pre><p><strong>需要注意vmware和ubuntu的兼容性</strong> </p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181116090244808-1235344275.png" alt="img"></h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181116090251677-591155084.png" alt="img"></p><p> 然后安装</p><h2 id="第三步：安装pycharm"><a href="#第三步：安装pycharm" class="headerlink" title="第三步：安装pycharm"></a>第三步：安装pycharm</h2><pre><code>pycharm之linux版本下载地址：https://download.jetbrains.8686c.com/python/pycharm-community-2018.2.4.tar.gz</code></pre><p>下载好后查看</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113175052930-1118218842.png" alt="img"></p><p>解压缩pycharm</p><pre><code>yuchao@ubuntu:/tmp$ tar zxvf pycharm-professional-2018.2.4.tar.gz </code></pre><p>解压缩后进入文件夹</p><pre><code>cd /tmp/pycharm-2018.2.4/bin</code></pre><p>执行脚本，启动pycharm</p><pre><code> source pycharm.sh</code></pre><h2 id="第四步：配置桌面快捷启动pycharm"><a href="#第四步：配置桌面快捷启动pycharm" class="headerlink" title="第四步：配置桌面快捷启动pycharm"></a>第四步：配置桌面快捷启动pycharm</h2><ol><li>在桌面创建一个文本文件，名为Pycharm.desktop</li><li>在文件中添加内容</li></ol><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[Desktop Entry]Version=1.0Type=ApplicationName=PycharmIcon=/home/yuchao/Downloads/pycharm-professional-2018.2.4/pycharm-2018.2.4/bin/pycharm.pngExec=/home/yuchao/Downloads/pycharm-professional-2018.2.4/pycharm-2018.2.4/bin/pycharm.shMimeType=application/x-py;Name[en_US]=pycharm</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180101050-1773939019.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180146241-1107980216.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180156223-1099359137.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180218672-58584960.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu安装之python开发&quot;&gt;&lt;a href=&quot;#Ubuntu安装之python开发&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装之python开发&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/py</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>VMware与Centos系统安装</title>
    <link href="http://example.com/2019/11/15/Linux/VMware%E4%B8%8ECentos%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2019/11/15/Linux/VMware%E4%B8%8ECentos%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T06:11:22.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VMware与Centos系统安装"><a href="#VMware与Centos系统安装" class="headerlink" title="VMware与Centos系统安装"></a><a href="https://www.cnblogs.com/pyyu/articles/9313587.html">VMware与Centos系统安装</a></h1><h1 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h1><pre><code>1.Linux发行版的选择2.vmware创建一个虚拟机(centos)3.安装配置centos74.xshell配置连接虚拟机(centos)</code></pre><h1 id="选择性"><a href="#选择性" class="headerlink" title="选择性"></a>选择性</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>pc可以选择    -纯系统 Linux/windows    -双系统    Windows+Linux    -虚拟化技术    Windows+vmware workstation服务器    -物理机纯系统    -物理机+vmware（vmware esxi）    -物理机+docker安装    -简易安装    -自定义安装    -快照</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="下载centos系统ISO镜像"><a href="#下载centos系统ISO镜像" class="headerlink" title="下载centos系统ISO镜像"></a>下载centos系统ISO镜像</h1><p>要安装centos系统，就必须得有centos系统软件安装程序，可以通过浏览器访问centos官网<a href="http://www.centos.org,然后找到downloads/">http://www.centos.org，然后找到Downloads</a>  - &gt;  mirrors链接，点击后进入下载，但是由于这是国外的网址，下载速度肯定受限。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715143157429-375252113.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715143401449-1969739566.png" alt="img"></p><p>因此可以使用国内的镜像源</p><pre><code>https://opsx.alibaba.com/mirror#阿里云官方镜像站iso下载地址（此DVD映像包含可以使用该软件安装的所有软件包安装程序。这是大多数用户的推荐图像。）：https://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1804.iso</code></pre><p>为什么要选择64位操作系统？</p><pre><code>目前绝大多数生产环境，使用的都是64位操作Centos操作系统</code></pre><p>32位与64位系统的定位与区别？</p><pre><code>64位操作系统的设计定位是：满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域，这些领域共同特性就是需要大量的系统内存。32位操作系统是为普通用户设计的。</code></pre><p>区别二：</p><pre><code>64位操作系统只能安装在64位（cpu必须是64位的）电脑上（cpu必须是64位的），并且只针对64位的软件才能发挥其最佳的性能。32位操作系统既可以安装在32位（32位cpu）电脑上，也可以安装在64位电脑上。当然了32位操作系统是无法发挥出64位硬件性能的。</code></pre><p>区别三: 运算速度</p><pre><code>64位---&gt; 8车道大马路32位---&gt; 4车道马路</code></pre><p>区别四：支持的最大内存不同</p><pre><code>32位系统---&gt;4GB内存只能用3.5Gb64位系统 支持更大内存</code></pre><h1 id="安装VMware虚拟机"><a href="#安装VMware虚拟机" class="headerlink" title="安装VMware虚拟机"></a>安装VMware虚拟机</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>vmware是什么？有了这个软件，大家就不需要为了学习linux特意再去买一台电脑了，虚拟机能让用户在一台机器上模拟出多个操作系统的软件，一般的机器配置足够胜任虚拟机的任务。虚拟机不但可以虚拟出硬件资源，把实验环境与真机文件分离保证数据安全，更nb的是当你手残删掉系统核心配置时，还能有”快照“的功能，立即恢复到出错前的状态，省去装机的超长时间。。。。(Windows用户)VMware Workstation是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。下载激活地址：http://www.zdfans.com/html/5928.html(Mac用户) VMware fusion简单的说，虚拟机（virtual Machine）软件就是一套特殊的软件，同时可以用“多个操作系统”虚拟出硬件+操作系统==服务器+OS误区：学Linux不需要再物理机上安装，费时费力，采用虚拟机是最合适的方式</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715143727078-1973552951.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715144020795-347208669.png" alt="img"></p><p>Linux学习环境推荐电脑配置：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>笔记本电脑：1.内存8G2.磁盘500G SATA或者120G SSD3.i3,i5,i7处理器</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="为什么要通过VM虚拟机学习Linux？"><a href="#为什么要通过VM虚拟机学习Linux？" class="headerlink" title="为什么要通过VM虚拟机学习Linux？"></a>为什么要通过VM虚拟机学习Linux？</h1><p>什么？你又和我说搞双系统？老铁你的小霸王，打开windows需要5分钟。。双系统。。。。还是算了吧</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715145848386-170456558.png" alt="img"></p><ul><li><p>利用虚拟机搭建Linux学习环境简单方便、容易上手，最重要的是虚拟机模拟的Linux和真实服务器几乎无区别，以后工作了，也都是ssh连接到服务器，而不是坐在0度的机房操控服务器。因此虚拟机来模拟环境是最接近工作环境的</p></li><li><p>搭建Linux集群或者需要模拟多台服务器通信的时候，可以同时开启好几台虚拟机（前提本身机器硬件足够，虚拟机配置也选择较低的情况），虚拟机可以轻松满足多机器的需求。</p></li><li><p>自己租服务器？是个不错的选择，可以搭建Linux环境，并且用作个人开发学习使用。但是得花钱呀。。。。</p></li></ul><ul><li>很容易修改虚拟机（服务器）的配置，且不会影响自己的电脑，想删除虚拟机也不会影响电脑，因为虚拟机只是运行在电脑上的一个程序（一堆文件）</li></ul><h1 id="超哥手把手教你装虚拟机"><a href="#超哥手把手教你装虚拟机" class="headerlink" title="超哥手把手教你装虚拟机"></a>超哥手把手教你装虚拟机</h1><h2 id="1-准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）"><a href="#1-准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）" class="headerlink" title="1.准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）"></a>1.准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715150948154-930825626.png" alt="img"></p><h2 id="2-解压软件包，当前选择的是vm12"><a href="#2-解压软件包，当前选择的是vm12" class="headerlink" title="2.解压软件包，当前选择的是vm12"></a>2.解压软件包，当前选择的是vm12</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715151320079-929742541.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715151607034-1026981038.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715151741581-1899830534.png" alt="img"></p><p>全部“下一步”，安装即可，，这里无须说多</p><h2 id="3-安装好vmware虚拟机后，开始安装Linux"><a href="#3-安装好vmware虚拟机后，开始安装Linux" class="headerlink" title="3.安装好vmware虚拟机后，开始安装Linux"></a>3.安装好vmware虚拟机后，开始安装Linux</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152026777-201342832.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152153353-1601275196.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152350739-1942472916.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152728654-1117395886.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152928358-1607419151.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153142008-1600108425.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153233511-1274559113.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153329986-358960099.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153431500-1893205158.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153519327-1692747100.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153545015-961592455.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153625011-560747017.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153803366-947490800.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153924367-823293158.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715154205447-631511630.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715154433369-2106760403.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715154709752-2106936658.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715160600181-1513557331.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715161126939-657824379.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715161346434-790183842.png" alt="img"></p><h1 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h1><p>此时进入这个黑乎乎的界面，输入root账号与密码，成功进入linux系统</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715162003636-607799263.png" alt="img"></p><h1 id="确保你的Linux支持虚拟化"><a href="#确保你的Linux支持虚拟化" class="headerlink" title="确保你的Linux支持虚拟化"></a>确保你的Linux支持虚拟化</h1><p>　　安装 RHEL 7 或 CentOS 7 系统时，大家的电脑的 CPU 需要支持 VT(Virtualization Technology，虚拟化技术)。所谓 VT，指的是让单台计算机能够分割出多个独立资源区， 并让每个资源区按照需要模拟出系统的一项技术，其本质就是通过中间层实现计算机 资源的管理和再分配，让系统资源的利用率最大化。其实只要您的电脑不是五六年前 买的，价格不低于三千元，它的 CPU 就肯定会支持 VT 的。如果开启虚拟机后依然提 示“CPU 不支持 VT 技术”等报错信息，请重启电脑并进入到 BIOS 中把 VT 虚拟化功 能开启即可。</p><h1 id="你又忘了root密码？？？"><a href="#你又忘了root密码？？？" class="headerlink" title="你又忘了root密码？？？"></a>你又忘了root密码？？？</h1><p>　　针对好多好多同学经常忘记root密码。。。超哥这里给你整理怎么重置root密码！！</p><p>　　重启 Linux 系统主机并出现引导界面时，按下键盘上的 e 键进入内核编辑界面</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200454981-296642965.png" alt="img"></p><p>在 linux16 参数这行的最后面追加“rd.break”参数，然后按下 Ctrl + X 组合键来运行修 改过的内核程序</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200602854-2067722898.png" alt="img"></p><p>大约 30 秒过后，进入到系统的紧急求援模式，</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200630932-1408889196.png" alt="img"></p><p>依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux 系统了 </p><pre><code> mount -o remount,rw /sysroot    chroot /sysroot    passwd    touch /.autorelabelexit reboot</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200710908-118130154.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VMware与Centos系统安装&quot;&gt;&lt;a href=&quot;#VMware与Centos系统安装&quot; class=&quot;headerlink&quot; title=&quot;VMware与Centos系统安装&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/py</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>centos下redis安全相关</title>
    <link href="http://example.com/2019/11/15/Linux/centos%E4%B8%8Bredis%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2019/11/15/Linux/centos%E4%B8%8Bredis%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:43:43.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centos下redis安全相关"><a href="#centos下redis安全相关" class="headerlink" title="centos下redis安全相关"></a><a href="https://www.cnblogs.com/pyyu/p/9515937.html">centos下redis安全相关</a></h1><p>博文背景：</p><p>由于发现众多同学，在使用云服务器时，安装的redis3.0+版本都关闭了protected-mode，因而都遭遇了挖矿病毒的攻击，使得服务器99%的占用率！！</p><p>因此我们在使用redis时候，最好更改默认端口，并且使用redis密码登录。</p><p>（1）redis没有用户概念，redis只有密码<br>（2）redis默认在工作在保护模式下。不允许远程任何用户登录的（protected-mode）</p><p>redis.conf设置</p><pre><code>protected-mode yes   #打开保护模式port 6380  #更改默认启动端口requirepass xxxxxx   #设置redis启动密码，xxxx是自定义的密码</code></pre><p>启动redis服务端</p><pre><code>redis-server /opt/redis-4.0.10/redis.conf &amp;     #指定配置文件启动redis，且后台启动</code></pre><p>使用密码登录redis，使用6380端口</p><p>方法1，使用这个</p><pre><code>[root@oldboy_python ~ 09:48:41]#redis-cli -p 6380127.0.0.1:6380&gt; auth xxxxOK</code></pre><p>方法2，此方案不安全，容易暴露密码</p><pre><code>[root@oldboy_python ~ 09:49:46]#redis-cli -p 6380 -a xxxxWarning: Using a password with '-a' option on the command line interface may not be safe.127.0.0.1:6380&gt; pingPONG</code></pre><p>补充</p><p>检查redis是否设置了密码</p><p>127.0.0.1:6380&gt; CONFIG get requirepass</p><ol><li>“requirepass”</li><li>“xxxxxx”</li></ol><p>如果没有，也可以给redis设置密码（命令方式）</p><pre><code>CONFIG set requirepass "xxxxxx"</code></pre><p>因此你的redis就不容易被黑客入侵了。</p><p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1a36zff5cc86l">https://cloud.tencent.com/developer/support-plan?invite_code=1a36zff5cc86l</a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;centos下redis安全相关&quot;&gt;&lt;a href=&quot;#centos下redis安全相关&quot; class=&quot;headerlink&quot; title=&quot;centos下redis安全相关&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡</title>
    <link href="http://example.com/2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:37:32.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a><a href="https://www.cnblogs.com/pyyu/p/10004633.html">nginx负载均衡</a></h1><ul><li><a href="https://www.cnblogs.com/pyyu/p/10004583.html">集群概念</a></li><li><a href="https://www.cnblogs.com/pyyu/p/10004670.html">负载均衡</a></li><li><a href="https://www.cnblogs.com/pyyu/p/10004681.html">nginx负载均衡</a></li></ul><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nginx负载均衡&quot;&gt;&lt;a href=&quot;#nginx负载均衡&quot; class=&quot;headerlink&quot; title=&quot;nginx负载均衡&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/10004633.html&quot;&gt;ngin</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡实验</title>
    <link href="http://example.com/2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E9%AA%8C/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:37:26.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx负载均衡实验"><a href="#nginx负载均衡实验" class="headerlink" title="nginx负载均衡实验"></a><a href="https://www.cnblogs.com/pyyu/p/10004681.html">nginx负载均衡实验</a></h1><h1 id="Nginx负载均衡概述"><a href="#Nginx负载均衡概述" class="headerlink" title="Nginx负载均衡概述"></a>Nginx负载均衡概述</h1><pre><code>Web服务器，直接面向用户，往往要承载大量并发请求，单台服务器难以负荷，我使用多台WEB服务器组成集群，前端使用Nginx负载均衡，将请求分散的打到我们的后端服务器集群中，实现负载的分发。那么会大大提升系统的吞吐率、请求性能、高容灾</code></pre><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122233808543-706880577.png" alt="img"></p><p>Nginx要实现负载均衡需要用到proxy_pass代理模块配置</p><p>Nginx负载均衡与Nginx代理不同地方在于</p><p>Nginx代理仅代理一台服务器，而Nginx负载均衡则是将客户端请求代理转发至一组upstream虚拟服务池</p><p>Nginx可以配置代理多台服务器，当一台服务器宕机之后，仍能保持系统可用。</p><h1 id="upstream配置"><a href="#upstream配置" class="headerlink" title="upstream配置"></a>upstream配置</h1><p>在nginx.conf &gt; http 区域中</p><pre><code>upstream django {       server 10.0.0.10:8000;       server 10.0.0.11:9000;}</code></pre><p>在nginx.conf &gt; http 区域 &gt;  server区域  &gt; location配置中</p><p>添加proxy_pass</p><pre><code>location / {            root   html;            index  index.html index.htm;            proxy_pass http://django;}</code></pre><p>此时初步负载均衡已经完成，upstream默认按照轮训方式负载，每个请求按时间顺序逐一分配到后端节点。</p><h1 id="upstream分配策略"><a href="#upstream分配策略" class="headerlink" title="upstream分配策略"></a>upstream分配策略</h1><p>weight 权重</p><pre><code>upstream django {       server 10.0.0.10:8000 weight=5;       server 10.0.0.11:9000 weight=10;#这个节点访问比率是大于8000的}</code></pre><p>ip_hash</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器upstream django {　　　　ip_hash;       server 10.0.0.10:8000;       server 10.0.0.11:9000;}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>backup</strong></p><p><strong>在非backup机器繁忙或者宕机时，请求backup机器，因此机器默认压力最小</strong></p><pre><code>upstream django {       server 10.0.0.10:8000 weight=5;       server 10.0.0.11:9000;       server node.oldboy.com:8080 backup;}</code></pre><h1 id="负载均衡实验环境规划"><a href="#负载均衡实验环境规划" class="headerlink" title="负载均衡实验环境规划"></a>负载均衡实验环境规划</h1><pre><code>角色            ip                    主机名lb01        192.168.119.10        lb01    web01        192.168.119.11        web01web02        192.168.119.12        web02</code></pre><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><pre><code>iptables -Fsed  -i 's/enforcing/disabled/' /etc/selinux/configsystemctl stop firewalldsystemctl disable firewalld</code></pre><h2 id="一、web01服务器配置nginx，创建index-html"><a href="#一、web01服务器配置nginx，创建index-html" class="headerlink" title="一、web01服务器配置nginx，创建index.html"></a>一、web01服务器配置nginx，创建index.html</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>server {        listen       80;        server_name  192.168.119.11;        location / {        root /node;            index  index.html index.htm;        }}mkdir /nodeecho 'i am web01' &gt; /node/index.html#启动NGINX./sbgin/nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="二、web01服务器配置nginx-创建index-html"><a href="#二、web01服务器配置nginx-创建index-html" class="headerlink" title="二、web01服务器配置nginx,创建index.html"></a>二、web01服务器配置nginx,创建index.html</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>server {    listen       80;    server_name  192.168.119.12;    location / {        root /node;        index  index.html index.htm;}mkdir /nodeecho 'i am web02...' &gt; /node/index.html#启动nginx./sbing/nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="三、配置lb01服务器的nginx负载均衡"><a href="#三、配置lb01服务器的nginx负载均衡" class="headerlink" title="三、配置lb01服务器的nginx负载均衡"></a>三、配置lb01服务器的nginx负载均衡</h2><p>1.检查lb01的 nginx.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    upstream node {    　　server 192.168.119.11:80;    　　server 192.168.119.12:80;}    server {        listen       80;        server_name 192.168.119.10;        location / {        　　proxy_pass http://node;        　　include proxy_params;  #需要手动创建        }    }}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2.手动创建proxy_params文件，文件中存放代理的请求头相关参数</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@lb01 conf]# cat /opt/nginx/conf/proxy_paramsproxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_connect_timeout 30;proxy_send_timeout 60;proxy_read_timeout 60;proxy_buffering on;proxy_buffer_size 32k;proxy_buffers 4 128k;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>启动lb01负载均衡nginx服务./sbin/nginx</code></pre><h2 id="四、访问lb01节点nginx，反复刷新"><a href="#四、访问lb01节点nginx，反复刷新" class="headerlink" title="四、访问lb01节点nginx，反复刷新"></a>四、访问lb01节点nginx，反复刷新</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123114552274-506631111.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123114606575-1476598164.png" alt="img"></p><h1 id="五、nginx负载均衡调度算法"><a href="#五、nginx负载均衡调度算法" class="headerlink" title="五、nginx负载均衡调度算法"></a>五、nginx负载均衡调度算法</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>调度算法   　　 概述轮询    　　　　按时间顺序逐一分配到不同的后端服务器(默认)weight  　　   加权轮询,weight值越大,分配到的访问几率越高ip_hash   　　 每个请求按访问IP的hash结果分配,这样来自同一IP的固定访问一个后端服务器url_hash   　  按照访问URL的hash结果来分配请求,是每个URL定向到同一个后端服务器least_conn    最少链接数,那个机器链接数少就分发</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>1.轮询(不做配置，默认轮询)</p><p>2.weight权重(优先级)</p><p>3.ip_hash配置，根据客户端ip哈希分配，不能和weight一起用</p><h1 id="六、nginx动静分离负载均衡"><a href="#六、nginx动静分离负载均衡" class="headerlink" title="六、nginx动静分离负载均衡"></a>六、nginx动静分离负载均衡</h1><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123121107048-1594518031.png" alt="img"></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><pre><code>系统                 服务                软件                ip地址centos7(lb01)                负载均衡            nginx proxy        192.168.119.10centos7(web01)                静态资源            nginx静态资源        192.168.119.11centos7(web02)                动态资源            django            192.168.119.12</code></pre><h2 id="一、在web01机器上，配置静态资源，图片等"><a href="#一、在web01机器上，配置静态资源，图片等" class="headerlink" title="一、在web01机器上，配置静态资源，图片等"></a>一、在web01机器上，配置静态资源，图片等</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>cat nginx.confserver {        listen       80;        server_name  192.168.119.11;        #定义网页根目录         root /code;        #定义了静态资源        index index.html;#域名匹配，所有的png、jpg、gif请求资源，都去/root/code/images底下找         location ~* .*\.(png|jpg|gif)$ {                root /code/images;        }    #重启nginx./sbin/nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#创建目录mkdir -p /code/images#准备首页文件[root@web01  /code]$cat index.htmlstatic files...#准备静态文件，图片[root@web01  /code/images]$wget http://pythonav.cn/av/girlone.jpg^C[root@web01  /code/images]$lsgirlone.jpg</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="二、在web02配置动态请求，准备一个flask程序和静态资源转发"><a href="#二、在web02配置动态请求，准备一个flask程序和静态资源转发" class="headerlink" title="二、在web02配置动态请求，准备一个flask程序和静态资源转发"></a>二、在web02配置动态请求，准备一个flask程序和静态资源转发</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>cat  nginx.conf#静态资源地址upstream static {server 192.168.119.11:80;}#flask动态请求upstream flask {server 192.168.119.12:8080;}    server {        listen       80;        server_name  192.168.119.12;　　　　　　#当请求到达192.168.119.12:80/时，转发给flask的8080应用        location / {            proxy_pass http://flask;            include proxy_params;        }　　　　　　#当判断资源请求是 192.168.119.12/girl.jpg时候，转发请求给static地址池的服务器192.168.119.11/        location ~ .*\.(png|jpg|gif)$ {　　　　　　　　proxy_pass http://static;include proxy_params;}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>准备flask应用,flask.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>from flask import Flaskapp=Flask(__name__)@app.route('/')def hello():    return "i am flask....from nginx"if __name__=="__main__":    app.run(host='0.0.0.0',port=8080)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>后台运行flask程序</p><pre><code>python flask-web.py &amp;</code></pre><h2 id="三、在负载均衡服务器lb01上测试访问192-168-119-10"><a href="#三、在负载均衡服务器lb01上测试访问192-168-119-10" class="headerlink" title="三、在负载均衡服务器lb01上测试访问192.168.119.10"></a>三、在负载均衡服务器lb01上测试访问192.168.119.10</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123164434807-990604537.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123164441415-1872980063.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123164506188-1615595481.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nginx负载均衡实验&quot;&gt;&lt;a href=&quot;#nginx负载均衡实验&quot; class=&quot;headerlink&quot; title=&quot;nginx负载均衡实验&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/10004681.html</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>python开发之virtualenv与virtualenvwrapper讲解</title>
    <link href="http://example.com/2019/11/15/Linux/python%E5%BC%80%E5%8F%91%E4%B9%8Bvirtualenv%E4%B8%8Evirtualenvwrapper%E8%AE%B2%E8%A7%A3/"/>
    <id>http://example.com/2019/11/15/Linux/python%E5%BC%80%E5%8F%91%E4%B9%8Bvirtualenv%E4%B8%8Evirtualenvwrapper%E8%AE%B2%E8%A7%A3/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:37:14.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python开发之virtualenv与virtualenvwrapper讲解"><a href="#python开发之virtualenv与virtualenvwrapper讲解" class="headerlink" title="python开发之virtualenv与virtualenvwrapper讲解"></a><a href="https://www.cnblogs.com/pyyu/p/9015317.html">python开发之virtualenv与virtualenvwrapper讲解</a></h1><p><strong>在使用 Python 开发的过程中，工程一多，难免会碰到不同的工程依赖不同版本的库的问题；</strong></p><p><strong>亦或者是在开发过程中不想让物理环境里充斥各种各样的库，引发未来的依赖灾难。</strong></p><p><strong>此时，我们需要对于不同的工程使用不同的虚拟环境来保持开发环境以及宿主环境的清洁。</strong></p><p><strong>这里，就要隆重介绍 virtualenv，一个可以帮助我们管理不同 Python 环境的绝好工具。</strong></p><p><strong>virtualenv 可以在系统中建立多个不同并且相互不干扰的虚拟环境。</strong></p><h1 id="一、Linux下安装、配置virtualenv"><a href="#一、Linux下安装、配置virtualenv" class="headerlink" title="一、Linux下安装、配置virtualenv"></a>一、Linux下安装、配置virtualenv</h1><pre><code>#指定清华源下载pip的包pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple virtualenv#升级pip工具pip3 install --upgrade pip</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.安装virtualenvpip3 install virtualenv 2.创建目录mkdir Myprojectcd Myproject3.创建独立运行环境-命名virtualenv --no-site-packages --python=python3  venv#得到独立第三方包的环境，并且指定解释器是python34.进入虚拟环境source venv/bin/activate#此时进入虚拟环境(venv)Myproject5.安装第三方包(venv)Myproject: pip3 install django==1.9.8#此时pip的包都会安装到venv环境下，venv是针对Myproject创建的6.退出venv环境deactivate命令7.virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="二、确保开发环境的一致性"><a href="#二、确保开发环境的一致性" class="headerlink" title="二、确保开发环境的一致性"></a>二、确保开发环境的一致性</h2><pre><code>1.假设我们在本地开发环境，准备好了项目+依赖包环境2.现在需要将项目上传至服务器，上线发布3.那么就要保证服务器的python环境一致性</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>解决方案：1.通过命令保证环境的一致性，导出当前python环境的包pip3 freeze &gt; requirements.txt   这将会创建一个 requirements.txt 文件，其中包含了当前环境中所有包及 各自的版本的简单列表。可以使用 “pip list”在不产生requirements文件的情况下， 查看已安装包的列表。2.上传至服务器后，在服务器下创建virtualenv，在venv中导入项目所需的模块依赖pip3 install -r requirements.txt</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="三、虚拟环境之virtualenvwrapper"><a href="#三、虚拟环境之virtualenvwrapper" class="headerlink" title="三、虚拟环境之virtualenvwrapper"></a>三、虚拟环境之virtualenvwrapper</h1><p><strong>virtualenv 的一个最大的缺点就是：</strong></p><p><strong>每次开启虚拟环境之前要去虚拟环境所在目录下的 bin 目录下 source 一下 activate，这就需要我们记住每个虚拟环境所在的目录。</strong></p><p><strong>并且还有可能你忘记了虚拟环境放在哪。。。</strong></p><ul><li>一种可行的解决方案是，将所有的虚拟环境目录全都集中起来，例如/opt/all_venv/，并且针对不同的目录做不同的事。</li><li>使用virtualenvwrapper管理你的虚拟环境（virtualenv），其实他就是统一管理虚拟环境的目录，并且省去了source的步骤。</li></ul><h2 id="步骤1：安装virtualenvwrapper"><a href="#步骤1：安装virtualenvwrapper" class="headerlink" title="步骤1：安装virtualenvwrapper"></a>步骤1：安装virtualenvwrapper</h2><pre><code>pip3 install virtualenvwrapper</code></pre><h2 id="步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper"><a href="#步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper" class="headerlink" title="步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper"></a>步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>把下面两行代码添加到 ~/.bashrc文件中打开文件vim ~/.bashrc写入以下两行代码export WORKON_HOME=~/Envs   #设置virtualenv的统一管理目录export VIRTUALENVWRAPPER_VIRTUALENV_ARGS='--no-site-packages'   #添加virtualenvwrapper的参数，生成干净隔绝的环境export VIRTUALENVWRAPPER_PYTHON=/opt/python347/bin/python3     #指定python解释器source /opt/python34/bin/virtualenvwrapper.sh #执行virtualenvwrapper安装脚本读取文件，使得生效，此时已经可以使用virtalenvwrappersource ~/.bashrc</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="步骤3：基本使用virtualenvwrapper"><a href="#步骤3：基本使用virtualenvwrapper" class="headerlink" title="步骤3：基本使用virtualenvwrapper"></a>步骤3：基本使用virtualenvwrapper</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>创建一个虚拟环境：$ mkvirtualenv my_django115这会在 ~/Envs 中创建 my_django115 文件夹。在虚拟环境上工作：激活虚拟环境my_django115$ workon my_django115再创建一个新的虚拟环境$ mkvirtualenv my_django2virtualenvwrapper 提供环境名字的tab补全功能。当有很多环境， 并且很难记住它们的名字时，这就显得很有用。workon还可以任意停止你当前的环境，可以在多个虚拟环境中来回切换workon django1.15workon django2.0也可以手动停止虚拟环境deactivate删除虚拟环境，需要先退出虚拟环境rmvirtualenv my_django115</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="步骤四：常用其他命令"><a href="#步骤四：常用其他命令" class="headerlink" title="步骤四：常用其他命令"></a>步骤四：常用其他命令</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>lsvirtualenv列举所有的环境。cdvirtualenv导航到当前激活的虚拟环境的目录中，比如说这样您就能够浏览它的 site-packages 。cdsitepackages和上面的类似，但是是直接进入到 site-packages 目录中。lssitepackages显示 site-packages 目录中的内容。完整官网介绍：https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180726113018954-757644711.png" alt="img"></p><h2 id="二、Mac下创建pycharm"><a href="#二、Mac下创建pycharm" class="headerlink" title="二、Mac下创建pycharm"></a>二、Mac下创建pycharm</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509165253912-1953506088.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180514111707923-1338423208.png" alt="img"></p><h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509165438463-1744082688.png" alt="img"></p><h2 id="第三步：此时这里的Django环境是虚拟环境的版本"><a href="#第三步：此时这里的Django环境是虚拟环境的版本" class="headerlink" title="第三步：此时这里的Django环境是虚拟环境的版本"></a>第三步：此时这里的Django环境是虚拟环境的版本</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509165546752-145926924.png" alt="img"></p><h2 id="第四步：检查venv下的django版本"><a href="#第四步：检查venv下的django版本" class="headerlink" title="第四步：检查venv下的django版本"></a>第四步：检查venv下的django版本</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509165801924-773808653.png" alt="img"></p><h2 id="第五步：添加已创建的虚拟环境venv的python解释器，至pycharm，用于创建1-98指定版本的django"><a href="#第五步：添加已创建的虚拟环境venv的python解释器，至pycharm，用于创建1-98指定版本的django" class="headerlink" title="第五步：添加已创建的虚拟环境venv的python解释器，至pycharm，用于创建1.98指定版本的django"></a>第五步：添加已创建的虚拟环境venv的python解释器，至pycharm，用于创建1.98指定版本的django</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509171128359-1783396835.png" alt="img"></p><h2 id="第六步：成功启动1-98版本的django"><a href="#第六步：成功启动1-98版本的django" class="headerlink" title="第六步：成功启动1.98版本的django"></a>第六步：成功启动1.98版本的django</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509171411218-1986171670.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python开发之virtualenv与virtualenvwrapper讲解&quot;&gt;&lt;a href=&quot;#python开发之virtualenv与virtualenvwrapper讲解&quot; class=&quot;headerlink&quot; title=&quot;python开发之virtu</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>redis-cluster配置</title>
    <link href="http://example.com/2019/11/15/Linux/redis-cluster%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2019/11/15/Linux/redis-cluster%E9%85%8D%E7%BD%AE/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:37:07.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis-cluster配置"><a href="#redis-cluster配置" class="headerlink" title="redis-cluster配置"></a><a href="https://www.cnblogs.com/pyyu/p/9844093.html">redis-cluster配置</a></h1><h1 id="为什么要用redis-cluster"><a href="#为什么要用redis-cluster" class="headerlink" title="为什么要用redis-cluster"></a>为什么要用redis-cluster</h1><h2 id="1-并发问题"><a href="#1-并发问题" class="headerlink" title="1.并发问题"></a>1.并发问题</h2><pre><code>redis官方生成可以达到 10万/每秒,每秒执行10万条命令假如业务需要每秒100万的命令执行呢？</code></pre><h2 id="2-数据量太大"><a href="#2-数据量太大" class="headerlink" title="2.数据量太大"></a>2.数据量太大</h2><p>一台服务器内存正常是16~256G，假如你的业务需要500G内存，</p><p>新浪微博作为世界上最大的redis存储，就超过1TB的数据，去哪买这么大的内存条？各大公司有自己的解决方案，推出各自的集群功能，核心思想都是将数据分片（sharding）存储在多个redis实例中，每一片就是一个redis实例。</p><pre><code>各大企业集群方案：twemproxy由Twitter开源Codis由豌豆荚开发，基于GO和C开发redis-cluster官方3.0版本后的集群方案</code></pre><p>解决方案如下</p><ol><li>配置一个超级牛逼的计算机，超大内存，超强cpu，但是问题是。。。。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024160915096-209591231.png" alt="img"></p><p>2.正确的应该是考虑分布式，加机器，把数据分到不同的位置，分摊集中式的压力，<strong>一堆机器做一件事</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024161047230-851823170.png" alt="img"></p><h1 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h1><p>redis3.0集群采用P2P模式，完全去中心化，将redis所有的key分成了16384个槽位，每个redis实例负责一部分slot，集群中的所有信息通过节点数据交换而更新。</p><pre><code>redis实例集群主要思想是将redis数据的key进行散列，通过hash函数特定的key会映射到指定的redis节点上</code></pre><h1 id="数据分布原理图"><a href="#数据分布原理图" class="headerlink" title="数据分布原理图"></a>数据分布原理图</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181125134928388-1528161304.png" alt="img"></p><h3 id="数据分布理论"><a href="#数据分布理论" class="headerlink" title="数据分布理论"></a>数据分布理论</h3><p>分布式数据库首要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整个数据的一个子集。</p><p>常见的分区规则有哈希分区和顺序分区。<code>Redis Cluster</code>采用哈希分区规则，因此接下来会讨论哈希分区规则。</p><ul><li>节点取余分区</li><li>一致性哈希分区</li><li><strong>虚拟槽分区(redis-cluster采用的方式)</strong></li></ul><h2 id="顺序分区"><a href="#顺序分区" class="headerlink" title="顺序分区"></a>顺序分区</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024161255329-1946317777.png" alt="img"></p><h2 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h2><p>节点取余</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024161354680-200751267.png" alt="img"></p><p>例如按照节点取余的方式，分三个节点</p><p>1~100的数据对3取余，可以分为三类</p><ul><li>余数为0</li><li>余数为1</li><li>余数为2</li></ul><p>那么同样的分4个节点就是hash(key)%4</p><p>节点取余的优点是简单，客户端分片直接是哈希+取余</p><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>客户端进行分片，哈希+顺时针取余</p><h2 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h2><p><code>Redis Cluster</code>采用虚拟槽分区</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有的数据映射到一个固定范围内的整数集合，整数定义为槽（slot）。</p><p><strong>Redis Cluster槽的范围是0 ～ 16383。</strong></p><p><strong>槽是集群内数据管理和迁移的基本单位。</strong>采用大范围的槽的主要目的是为了方便数据的拆分和集群的扩展，</p><p><strong>每个节点负责一定数量的槽。</strong></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181125140406355-792376591.png" alt="img"></p><h1 id="搭建redis-cluster"><a href="#搭建redis-cluster" class="headerlink" title="搭建redis cluster"></a>搭建redis cluster</h1><p>搭建集群分为几部</p><ul><li>准备节点（几匹马儿）</li><li>节点通信（几匹马儿分配主从）</li><li>分配槽位给节点（slot分配给马儿）</li></ul><p>redis-cluster集群架构</p><pre><code>多个服务端，负责读写，彼此通信，redis指定了16384个槽。多匹马儿，负责运输数据，马儿分配16384个槽位，管理数据。ruby的脚本自动就把分配槽位这事做了</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024170727913-1418417703.png" alt="img"></p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p>官方提供通过ruby语言的脚本一键安装</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h2><p>通过配置，开启redis-cluster</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>port 7000daemonize yesdir "/opt/redis/data"logfile "7000.log"dbfilename "dump-7000.rdb"cluster-enabled yes   #开启集群模式cluster-config-file nodes-7000.conf　　#集群内部的配置文件cluster-require-full-coverage no　　#redis cluster需要16384个slot都正常的时候才能对外提供服务，换句话说，只要任何一个slot异常那么整个cluster不对外提供服务。 因此生产环境一般为no</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>redis支持多实例的功能，我们在单机演示集群搭建，需要6个实例，三个是主节点，三个是从节点，数量为6个节点才能保证高可用的集群。</p><p><strong>每个节点仅仅是端口运行的不同！</strong></p><pre><code>[root@yugo /opt/redis/config 17:12:30]#lsredis-7000.conf  redis-7002.conf  redis-7004.confredis-7001.conf  redis-7003.conf  redis-7005.conf#确保每个配置文件中的端口修改！！</code></pre><h2 id="2-运行redis实例"><a href="#2-运行redis实例" class="headerlink" title="2.运行redis实例"></a>2.运行redis实例</h2><p>创建6个节点的redis实例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code> 1855  2018-10-24 15:46:01 redis-server redis-7000.conf 1856  2018-10-24 15:46:13 redis-server redis-7001.conf 1857  2018-10-24 15:46:16 redis-server redis-7002.conf 1858  2018-10-24 15:46:18 redis-server redis-7003.conf 1859  2018-10-24 15:46:20 redis-server redis-7004.conf 1860  2018-10-24 15:46:23 redis-server redis-7005.conf</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>检查日志文件</p><pre><code>cat 7000.log</code></pre><p>检查redis服务的端口、进程</p><pre><code>netstat -tunlp|grep redisps -ef|grep redis</code></pre><p><strong>此时集群还不可用</strong>，可以通过登录redis查看</p><pre><code>redis-cli -p 7000set hello world(error)CLUSTERDOWN The cluster is down</code></pre><h2 id="3-创建开启redis-cluster"><a href="#3-创建开启redis-cluster" class="headerlink" title="3.创建开启redis-cluster"></a>3.创建开启redis-cluster</h2><h2 id="准备ruby环境"><a href="#准备ruby环境" class="headerlink" title="准备ruby环境"></a>准备ruby环境</h2><ol><li>下载、编译、安装Ruby</li><li>安装rubygem redis</li><li>安装redis-trib.rb命令</li></ol><p>第一步，安装ruby(这些命令可以放入一个sh脚本文件里)</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#下载rubywget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz#安装rubytar -xvf ruby-2.3.1.tar.gz./configure --prefix=/opt/ruby/make &amp;&amp; make install#准备一个ruby命令#准备一个gem软件包管理命令#拷贝ruby命令到path下/usr/local/rubycp /opt/ruby/bin/ruby /usr/local/cp bin/gem /usr/local/bin</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>安装ruby gem 包管理工具</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>wget http://rubygems.org/downloads/redis-3.3.0.gemgem install -l redis-3.3.0.gem#查看gem有哪些包gem list -- check redis gem</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>安装redis-trib.rb命令</p><pre><code>[root@yugo /opt/redis/src 18:38:13]#cp /opt/redis/src/redis-trib.rb /usr/local/bin/</code></pre><h2 id="一键开启redis-cluster集群"><a href="#一键开启redis-cluster集群" class="headerlink" title="一键开启redis-cluster集群"></a>一键开启redis-cluster集群</h2><pre><code>#每个主节点，有一个从节点，代表--replicas 1redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005#集群自动分配主从关系  7000、7001、7002为 7003、7004、7005 主动关系</code></pre><h1 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>redis-cli -p 7000 cluster info  redis-cli -p 7000 cluster nodes  #等同于查看nodes-7000.conf文件节点信息集群主节点状态redis-cli -p 7000 cluster nodes | grep master集群从节点状态redis-cli -p 7000 cluster nodes | grep slave</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>安装完毕后，检查集群状态</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@yugo /opt/redis/src 18:42:14]#redis-cli -p 7000 cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:10468cluster_stats_messages_pong_sent:10558cluster_stats_messages_sent:21026cluster_stats_messages_ping_received:10553cluster_stats_messages_pong_received:10468cluster_stats_messages_meet_received:5cluster_stats_messages_received:21026</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>测试写入集群数据，登录集群必须使用redis-cli -c -p 7000必须加上-c参数</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:7000&gt; set name chao     -&gt; Redirected to slot [5798] located at 127.0.0.1:7001       OK127.0.0.1:7001&gt; exit[root@yugo /opt/redis/src 18:46:07]#redis-cli -c -p 7000127.0.0.1:7000&gt; pingPONG127.0.0.1:7000&gt; keys *(empty list or set)127.0.0.1:7000&gt; get name-&gt; Redirected to slot [5798] located at 127.0.0.1:7001"chao"</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>集群ok</p><p>工作原理：</p><p>redis客户端任意访问一个redis实例，如果数据不在该实例中，通过重定向引导客户端访问所需要的redis实例</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis-cluster配置&quot;&gt;&lt;a href=&quot;#redis-cluster配置&quot; class=&quot;headerlink&quot; title=&quot;redis-cluster配置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/9</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>python操作redis集群</title>
    <link href="http://example.com/2019/11/15/Linux/python%E6%93%8D%E4%BD%9Credis%E9%9B%86%E7%BE%A4%20/"/>
    <id>http://example.com/2019/11/15/Linux/python%E6%93%8D%E4%BD%9Credis%E9%9B%86%E7%BE%A4%20/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T07:37:20.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python操作redis集群"><a href="#python操作redis集群" class="headerlink" title="python操作redis集群"></a><a href="https://www.cnblogs.com/pyyu/p/10015776.html">python操作redis集群</a></h1><p>strictRedis对象方法用于连接redis</p><p>指定主机地址，port与服务器连接，默认db是0，redis默认数据库有16个，在配置文件中指定database 16</p><p>上代码</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1、对redis的单实例进行连接操作根据不同的实例方法，与redis的命令对应python3&gt;&gt;&gt;import redis&gt;&gt;&gt;r = redis.StrictRedis(host='localhost', port=6379, db=0,password='root')&gt;&gt;&gt;r.set('lufei', 'guojialei')True&gt;&gt;&gt;r.get('lufei')'bar'增删改查</code></pre><p>&gt;&gt;&gt; conn=redis.StrictRedis()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; conn.set(“name1”,”alex1”)<br>True<br>&gt;&gt;&gt; conn.set(“name2”,”wupeiqi”)<br>True<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; conn.set(“name1”,”alex666”)<br>True<br>&gt;&gt;&gt; conn.delete(“name2”,”name1”)<br>2</p><p>&gt;&gt;&gt; conn.keys()<br>[b’name3’, b’name2’, b’name1’]</p><pre><code>--------------------2、sentinel集群连接并操作[root@db01 ~]# redis-server /data/6380/redis.conf[root@db01 ~]# redis-server /data/6381/redis.conf[root@db01 ~]# redis-server /data/6382/redis.conf [root@db01 ~]# redis-sentinel /data/26380/sentinel.conf &amp;--------------------------------## 导入redis sentinel包&gt;&gt;&gt; from redis.sentinel import Sentinel  ##指定sentinel的地址和端口号&gt;&gt;&gt; sentinel = Sentinel([('localhost', 26380)], socket_timeout=0.1)  ##测试，获取以下主库和从库的信息&gt;&gt;&gt; sentinel.discover_master('mymaster')  &gt;&gt;&gt; sentinel.discover_slaves('mymaster')  ##配置读写分离#写节点&gt;&gt;&gt; master = sentinel.master_for('mymaster', socket_timeout=0.1)  #读节点&gt;&gt;&gt; slave = sentinel.slave_for('mymaster', socket_timeout=0.1)  ###读写分离测试   key     &gt;&gt;&gt; master.set('oldboy', '123')  &gt;&gt;&gt; slave.get('oldboy')  '123'----------------------redis cluster的连接并操作（python2.7.2以上版本才支持redis cluster，我们选择的是3.5）https://github.com/Grokzen/redis-py-cluster3、python连接rediscluster集群测试使用python3&gt;&gt;&gt; from rediscluster import StrictRedisCluster  &gt;&gt;&gt; startup_nodes = [{"host": "127.0.0.1", "port": "7000"}]  ### Note: decode_responses must be set to True when used with python3  &gt;&gt;&gt; rc = StrictRedisCluster(startup_nodes=startup_nodes, decode_responses=True)  &gt;&gt;&gt; rc.set("foo", "bar")  True  &gt;&gt;&gt;   'bar'----------------------</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="redis存储session"><a href="#redis存储session" class="headerlink" title="redis存储session"></a>redis存储session</h2><p>django-redis-sessions 官方文档：<a href="https://pypi.org/project/django-redis-sessions/">https://pypi.org/project/django-redis-sessions/</a></p><p>dango-redis 官方文档：<a href="http://niwinz.github.io/django-redis/latest/#_configure_as_cache_backend">http://niwinz.github.io/django-redis/latest/#_configure_as_cache_backend</a></p><p>安装模块</p><pre><code>安装模块 pip3 install django-redis-sessions或者pip3 install django-redis</code></pre><p>本文这里用的是django 2.0语法，创建django项目</p><pre><code>django-admin startproject mydjango</code></pre><p>修改settings.py文件</p><p>写入</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>CACHES = {    "default": {        "BACKEND": "django_redis.cache.RedisCache",        "LOCATION": "redis://127.0.0.1:6379/0",        "OPTIONS": {            "CLIENT_CLASS": "django_redis.client.DefaultClient",            "PASSWORD": "",#             "PARSER_CLASS": "redis.connection.HiredisParser",#             "SOCKET_TIMEOUT": 10,#             "CONNECTION_POOL_CLASS_KWARGS": {#                 "max_connections": 2,#             }        }    }}#SESSION_COOKIE_AGE = 30 * 60 #设置session过期时间为30分钟SESSION_ENGINE = 'django.contrib.sessions.backends.cache'</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>创建app01</p><pre><code>django-admin startapp app01</code></pre><p>编写session视图函数 app01.views</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>from django.shortcuts import render,HttpResponsedef set_session(request):    request.session['username']='chaoge'    request.session['age']=18    return HttpResponse("设置sesson成功")def get_session(request):    username=request.session['username']    age = request.session['age']    return HttpResponse(username+":"+str(age))</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>添加url路由</p><p>vim mydjango/urls.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>from django.contrib import adminfrom django.urls import pathfrom app01 import viewsurlpatterns = [    path('set_session/',views.set_session),    path('get_session/',views.get_session),    path('admin/', admin.site.urls),]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>确保启动redis服务端，默认方式启动</p><pre><code>redis-server &amp;redis-cli 连接无误发送ping命令得到pong即可</code></pre><p>启动django</p><pre><code>python3 manage.py runserver 0.0.0.0:8000</code></pre><p>访问视图，设置一条session信息，存入redis数据库</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190323161551235-1043972135.png" alt="img"></p><p>访问视图，获取session信息</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190323161710547-1955920838.png" alt="img"></p><p>检查redis数据库，是否存在一条key</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; keys *1) ":1:django.contrib.sessions.cachep220moqvxclz2hyjqmbybqs3v8ck2i39"获取这个key的值</code></pre><p>127.0.0.1:6379&gt; get :1:django.contrib.sessions.cachep220moqvxclz2hyjqmbybqs3v8ck2i39<br>“\x80\x04\x95!\x00\x00\x00\x00\x00\x00\x00}\x94(\x8c\busername\x94\x8c\x06chaoge\x94\x8c\x03age\x94K\x12u.”</p><pre><code></code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python操作redis集群&quot;&gt;&lt;a href=&quot;#python操作redis集群&quot; class=&quot;headerlink&quot; title=&quot;python操作redis集群&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pyyu/p/1</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>redis-sentinel主从复制高可用</title>
    <link href="http://example.com/2019/11/15/Linux/redis-sentinel%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://example.com/2019/11/15/Linux/redis-sentinel%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AB%98%E5%8F%AF%E7%94%A8/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T06:31:52.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis-sentinel主从复制高可用"><a href="#redis-sentinel主从复制高可用" class="headerlink" title="redis-sentinel主从复制高可用"></a><a href="https://www.cnblogs.com/pyyu/p/9718679.html">redis-sentinel主从复制高可用</a></h1><h1 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis-Sentinel"></a>Redis-Sentinel</h1><pre><code>Redis-Sentinel是redis官方推荐的高可用性解决方案，当用redis作master-slave的高可用时，如果master本身宕机，redis本身或者客户端都没有实现主从切换的功能。而redis-sentinel就是一个独立运行的进程，用于监控多个master-slave集群，自动发现master宕机，进行自动切换slave &gt; master。</code></pre><p>sentinel主要功能如下：</p><ul><li>不时的监控redis是否良好运行，如果节点不可达就会对节点进行下线标识</li><li>如果被标识的是主节点，sentinel就会和其他的sentinel节点“协商”，如果其他节点也人为主节点不可达，就会选举一个sentinel节点来完成自动故障转义</li><li>在master-slave进行切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换</li></ul><h1 id="Sentinel的工作方式："><a href="#Sentinel的工作方式：" class="headerlink" title="Sentinel的工作方式："></a>Sentinel的工作方式：</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">sentinel公作方式</p><h1 id="redis主从复制背景问题"><a href="#redis主从复制背景问题" class="headerlink" title="redis主从复制背景问题"></a>redis主从复制背景问题</h1><p><code>Redis</code>主从复制可将主节点数据同步给从节点，从节点此时有两个作用：</p><ul><li>一旦主节点宕机，从节点作为主节点的备份可以随时顶上来。</li><li>扩展主节点的读能力，分担主节点读压力。</li></ul><p>但是问题是：</p><ul><li>一旦主节点宕机，从节点上位，那么需要人为修改所有应用方的主节点地址（改为新的master地址），还需要命令所有从节点复制新的主节点</li></ul><p>那么这个问题，redis-sentinel就可以解决了</p><h1 id="主从复制架构"><a href="#主从复制架构" class="headerlink" title="主从复制架构"></a>主从复制架构</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928114913282-867816204.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928115021716-2071889796.png" alt="img"></p><h1 id="Redis-Sentinel架构"><a href="#Redis-Sentinel架构" class="headerlink" title="Redis Sentinel架构"></a>Redis Sentinel架构</h1><p>redis的一个进程，但是不存储数据，只是监控redis</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181124181822218-1125753774.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928115711245-1503702880.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928145626051-1360651849.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928145734973-1288883859.png" alt="img"></p><h1 id="redis命令整理"><a href="#redis命令整理" class="headerlink" title="redis命令整理"></a>redis命令整理</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>官网地址：http://redisdoc.com/redis-cli info #查看redis数据库信息redis-cli info replication #查看redis的复制授权信息redis-cli info sentinel   #查看redis的哨兵信息</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><p><strong>本实验是在测试环境下，考虑到学生机器较弱，因此只准备一台linux服务器用作环境！！</strong></p><p>服务器环境，一台即可完成操作</p><pre><code>master 192.168.119.10</code></pre><p>所有配置文件如下</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181107174748993-868053884.png" alt="img"></p><h3 id="主节点master的redis-6379-conf"><a href="#主节点master的redis-6379-conf" class="headerlink" title="主节点master的redis-6379.conf"></a>主节点master的redis-6379.conf</h3><pre><code>port 6379daemonize yeslogfile "6379.log"dbfilename "dump-6379.rdb"dir "/var/redis/data/"</code></pre><h3 id="从节点slave的redis-6380-conf"><a href="#从节点slave的redis-6380-conf" class="headerlink" title="从节点slave的redis-6380.conf"></a>从节点slave的redis-6380.conf</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>port 6380daemonize yeslogfile "6380.log"dbfilename "dump-6380.rdb"dir "/var/redis/data/" slaveof 127.0.0.1 6379      // 从属主节点</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="从节点slave的redis-6381-conf"><a href="#从节点slave的redis-6381-conf" class="headerlink" title="从节点slave的redis-6381.conf"></a>从节点slave的redis-6381.conf</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>port 6381daemonize yeslogfile "6380.log"dbfilename "dump-6380.rdb"dir "/var/redis/data/" slaveof 127.0.0.1 6379      // 从属主节点</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="启动redis主节点"><a href="#启动redis主节点" class="headerlink" title="启动redis主节点"></a>启动redis主节点</h3><pre><code>redis-server /etc/redis-6379.conf</code></pre><h3 id="测试redis主节点是否通信"><a href="#测试redis主节点是否通信" class="headerlink" title="测试redis主节点是否通信"></a>测试redis主节点是否通信</h3><pre><code>redis-cli  ping</code></pre><h2 id="启动两slave节点"><a href="#启动两slave节点" class="headerlink" title="启动两slave节点"></a>启动两slave节点</h2><p>还记得上面超哥的截图吗？总体redis配置文件如下，6379为master，6380和6381为slave</p><pre><code>-rw-r--r-- 1 root root 145 Nov  7 17:44 /etc/redis-6379.conf      #这个为主，port是6379-rw-r--r-- 1 root root  93 Nov  7 17:42 /etc/redis-6380.conf　　　 # 这个是从，port6380，并且得加上新的参数slaveof-rw-r--r-- 1 root root 115 Nov  7 17:42 /etc/redis-6381.conf      # 这个是从，port6381，并且得加上新的参数slaveof</code></pre><p>redis-6380.conf  slave配置文件详解，6381端口的配置文件，仅仅和6380端口不一样</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>port 6380daemonize yeslogfile "6379.log"dbfilename "dump-6379.rdb"dir "/var/redis/data"# Generated by CONFIG REWRITEslaveof 127.0.0.1 6379</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">redis.conf详解–补充–</p><h3 id="启动slave从节点的redis服务"><a href="#启动slave从节点的redis服务" class="headerlink" title="启动slave从节点的redis服务"></a>启动slave从节点的redis服务</h3><pre><code>[root@master 192.168.119.10 ~]$redis-server /etc/redis-6380.conf[root@master 192.168.119.10 ~]$redis-server /etc/redis-6381.conf</code></pre><h3 id="验证从节点的redis服务"><a href="#验证从节点的redis服务" class="headerlink" title="验证从节点的redis服务"></a>验证从节点的redis服务</h3><pre><code>[root@master  ~]$redis-cli   -p 6380 pingPONG[root@master  ~]$redis-cli   -p 6381 pingPONG</code></pre><h2 id="确定主从关系"><a href="#确定主从关系" class="headerlink" title="确定主从关系"></a>确定主从关系</h2><p>在主节点上查看主从通信关系</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@master ~]# redis-cli  -p 6379 info replication# Replicationrole:masterconnected_slaves:2slave0:ip=192.168.119.10,port=6380,state=online,offset=407,lag=0slave1:ip=192.168.119.10,port=6381,state=online,offset=407,lag=0master_repl_offset:407repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:406</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>在从节点上查看主从关系（6380、6379）</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@slave 192.168.119.11 ~]$redis-cli  -p 6380 info replication# Replicationrole:slavemaster_host:192.168.119.10master_port:6379master_link_status:upmaster_last_io_seconds_ago:3master_sync_in_progress:0slave_repl_offset:505slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>此时可以在master上写入数据，在slave上查看数据，此时主从复制配置完成</strong></p><h1 id="开始配置Redis-Sentinel"><a href="#开始配置Redis-Sentinel" class="headerlink" title="开始配置Redis Sentinel"></a>开始配置Redis Sentinel</h1><p>超哥实验的环境是单独一台linux，192.168.119.10</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@master tmp]# ll /etc/redis-*-rw-r--r-- 1 root root 145 Nov  7 17:44 /etc/redis-6379.conf-rw-r--r-- 1 root root  93 Nov  7 17:42 /etc/redis-6380.conf-rw-r--r-- 1 root root 115 Nov  7 17:42 /etc/redis-6381.conf-rw-r--r-- 1 root root 556 Nov  7 17:42 /etc/redis-sentinel-26379.conf-rw-r--r-- 1 root root 556 Nov  7 17:42 /etc/redis-sentinel-26380.conf-rw-r--r-- 1 root root 556 Nov  7 17:42 /etc/redis-sentinel-26381.conf</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>redis-sentinel-26379.conf配置文件写入如下信息</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>// Sentinel节点的端口port 26379  dir /var/redis/data/logfile "26379.log"// 当前Sentinel节点监控 192.168.119.10:6379 这个主节点// 2代表判断主节点失败至少需要2个Sentinel节点节点同意// mymaster是主节点的别名sentinel monitor mymaster 192.168.119.10 6379 2//每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过30000毫秒30s且没有回复，则判定不可达sentinel down-after-milliseconds mymaster 30000//当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1sentinel parallel-syncs mymaster 1//故障转移超时时间为180000毫秒sentinel failover-timeout mymaster 180000</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>redis-sentinel-26380.conf和redis-sentinel-26381.conf的配置仅仅差异是port(端口)的不同。然后启动三个sentinel哨兵redis-sentinel /etc/redis-sentinel-26379.confredis-sentinel /etc/redis-sentinel-26380.confredis-sentinel /etc/redis-sentinel-26381.conf</code></pre><p>监控拓扑图</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181116091956977-1189113564.png" alt="img"></p><p>此时查看哨兵是否成功通信</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@master ~]# redis-cli -p 26379  info sentinel# Sentinelsentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name=mymaster,status=ok,address=192.168.119.10:6379,slaves=2,sentinels=3#看到最后一条信息正确即成功了哨兵，哨兵主节点名字叫做mymaster，状态ok，监控地址是192.168.119.10:6379，有两个从节点，3个哨兵</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="redis高可用故障实验"><a href="#redis高可用故障实验" class="headerlink" title="redis高可用故障实验"></a>redis高可用故障实验</h1><p>大致思路</p><ul><li><p>杀掉主节点的redis进程6379端口，观察从节点是否会进行新的master选举，进行切换</p></li><li><p>重新恢复旧的“master”节点，查看此时的redis身份</p><p>首先查看三个redis的进程状态</p></li></ul><pre><code>ps -ef|grep redis</code></pre><p>检查三个节点的复制身份状态</p><p>第一个</p><pre><code>[root@master tmp]# redis-cli -p 6381 info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6380</code></pre><p>第二个</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@master tmp]# redis-cli -p 6380 info replication# Replicationrole:masterconnected_slaves:2slave0:ip=127.0.0.1,port=6381,state=online,offset=54386,lag=0slave1:ip=127.0.0.1,port=6379,state=online,offset=54253,lag=0</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>第三个</p><pre><code>[root@master tmp]# redis-cli -p 6379 info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6380</code></pre><p><strong>此时，干掉master！！！然后等待其他两个节点是否能自动被哨兵sentienl，切换为master节点</strong></p><pre><code>ps -ef|grep 6380   #干掉master进程</code></pre><p>此时查看两个slave的状态</p><p><strong>精髓就是查看一个参数</strong></p><pre><code>master_link_down_since_seconds:13</code></pre><p><strong>稍等片刻之后，发现slave节点成为master节点！！</strong></p><pre><code>[root@master tmp]# redis-cli -p 6379 info replication# Replicationrole:masterconnected_slaves:1slave0:ip=127.0.0.1,port=6381,state=online,offset=41814,lag=1</code></pre><p><strong>大功告成！！开心！！！</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis-sentinel主从复制高可用&quot;&gt;&lt;a href=&quot;#redis-sentinel主从复制高可用&quot; class=&quot;headerlink&quot; title=&quot;redis-sentinel主从复制高可用&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cn</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>redis不重启，切换RDB备份到AOF备份</title>
    <link href="http://example.com/2019/11/15/Linux/redis%E4%B8%8D%E9%87%8D%E5%90%AF%EF%BC%8C%E5%88%87%E6%8D%A2RDB%E5%A4%87%E4%BB%BD%E5%88%B0AOF%E5%A4%87%E4%BB%BD/"/>
    <id>http://example.com/2019/11/15/Linux/redis%E4%B8%8D%E9%87%8D%E5%90%AF%EF%BC%8C%E5%88%87%E6%8D%A2RDB%E5%A4%87%E4%BB%BD%E5%88%B0AOF%E5%A4%87%E4%BB%BD/</id>
    <published>2019-11-15T11:24:01.000Z</published>
    <updated>2019-11-18T06:31:29.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis不重启，切换RDB备份到AOF备份"><a href="#redis不重启，切换RDB备份到AOF备份" class="headerlink" title="redis不重启，切换RDB备份到AOF备份"></a><a href="https://www.cnblogs.com/pyyu/p/10061526.html">redis不重启，切换RDB备份到AOF备份</a></h1><h1 id="确保redis版本在2-2以上"><a href="#确保redis版本在2-2以上" class="headerlink" title="确保redis版本在2.2以上"></a>确保redis版本在2.2以上</h1><pre><code>[root@pyyuc /data 22:23:30]#redis-server -vRedis server v=4.0.10 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=64cb6afcf41664c</code></pre><p>本文在redis4.0中，通过config set命令，达到不重启redis服务，从RDB持久化切换为AOF</p><h1 id="实验环境准备"><a href="#实验环境准备" class="headerlink" title="实验环境准备"></a>实验环境准备</h1><p>redis.conf服务端配置文件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>daemonize yesport 6379logfile /data/6379/redis.logdir /data/6379dbfilename  dbmp.rdbsave 900 1                    #rdb机制 每900秒 有1个修改记录save 300 10                    #每300秒        10个修改记录save 60  10000                #每60秒内        10000修改记录</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>启动redis服务端</p><pre><code>redis-server redis.conf</code></pre><p>登录redis-cli插入数据，手动持久化</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; set name chaogeOK127.0.0.1:6379&gt; set age 18OK127.0.0.1:6379&gt; set addr shaheOK127.0.0.1:6379&gt; saveOK</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>检查RDB文件</p><pre><code>[root@pyyuc /data 22:34:16]#ls 6379/dbmp.rdb  redis.log</code></pre><h1 id="备份这个rdb文件，保证数据安全"><a href="#备份这个rdb文件，保证数据安全" class="headerlink" title="备份这个rdb文件，保证数据安全"></a>备份这个rdb文件，保证数据安全</h1><pre><code>[root@pyyuc /data/6379 22:35:38]#cp dbmp.rdb /opt/</code></pre><h1 id="执行命令，开启AOF持久化"><a href="#执行命令，开启AOF持久化" class="headerlink" title="执行命令，开启AOF持久化"></a>执行命令，开启AOF持久化</h1><pre><code>127.0.0.1:6379&gt; CONFIG set appendonly yes   #开启AOF功能OK127.0.0.1:6379&gt; CONFIG SET save ""  #关闭RDB功能OK</code></pre><h1 id="确保数据库的key数量正确"><a href="#确保数据库的key数量正确" class="headerlink" title="确保数据库的key数量正确"></a>确保数据库的key数量正确</h1><pre><code>127.0.0.1:6379&gt; keys *1) "addr"2) "age"3) "name"</code></pre><h1 id="确保插入新的key，AOF文件会记录"><a href="#确保插入新的key，AOF文件会记录" class="headerlink" title="确保插入新的key，AOF文件会记录"></a>确保插入新的key，AOF文件会记录</h1><pre><code>127.0.0.1:6379&gt; set title golangOK</code></pre><p><strong>此时RDB已经正确切换AOF，注意还得修改redis.conf添加AOF设置，不然重启后，通过config set的配置将丢失</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis不重启，切换RDB备份到AOF备份&quot;&gt;&lt;a href=&quot;#redis不重启，切换RDB备份到AOF备份&quot; class=&quot;headerlink&quot; title=&quot;redis不重启，切换RDB备份到AOF备份&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www</summary>
      
    
    
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="技术" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
