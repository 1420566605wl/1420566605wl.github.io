<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="操作系统, 多走几步">
    <meta name="description" content="多走几步">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>操作系统 | 多走几步</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="多走几步" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">多走几步</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">多走几步</div>
        <div class="logo-desc">
            
            多走几步
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/%E5%AD%A6%E4%B9%A0/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">操作系统</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%AD%A6%E4%B9%A0/">
                                <span class="chip bg-color">学习</span>
                            </a>
                        
                            <a href="/tags/%E6%8A%80%E6%9C%AF/">
                                <span class="chip bg-color">技术</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-11-15
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    18.2k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><strong>阅读目录</strong></p>
<ul>
<li>一 为什么要有操作系统</li>
<li>二 什么是操作系统</li>
<li>三 操作系统与普通软件的区别</li>
<li>四 操作系统发展史</li>
<li>五 操作系统原理</li>
</ul>
<h2 id="一-为什么要有操作系统（两本书：现代操作系统、操作系统原理，学好python以后再去研究吧-）"><a href="#一-为什么要有操作系统（两本书：现代操作系统、操作系统原理，学好python以后再去研究吧-）" class="headerlink" title="一 为什么要有操作系统（两本书：现代操作系统、操作系统原理，学好python以后再去研究吧~~）"></a>一 为什么要有操作系统（两本书：现代操作系统、操作系统原理，学好python以后再去研究吧~~）</h2><p>　　现代的计算机系统主要是由一个或者多个处理器，主存，硬盘，键盘，鼠标，显示器，打印机，网络接口及其他输入输出设备组成。</p>
<p>　　一般而言，现代计算机系统是一个复杂的系统。</p>
<p>　　其一：如果每位应用程序员都必须掌握该系统所有的细节，那就不可能再编写代码了（严重影响了程序员的开发效率：全部掌握这些细节可能需要一万年….）</p>
<p>　　其二：并且管理这些部件并加以优化使用，是一件极富挑战性的工作，于是，计算安装了一层软件（系统软件），称为操作系统。它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。</p>
<p><strong>总结：</strong></p>
<p>　　<strong>程序员无法把所有的硬件操作细节都了解到，管理这些硬件并且加以优化使用是非常繁琐的工作，这个繁琐的工作就是操作系统来干的，有了他，程序员就从这些繁琐的工作中解脱了出来，只需要考虑自己的应用软件的编写就可以了，应用软件直接使用操作系统提供的功能来间接使用硬件。</strong></p>
<h2 id="二-什么是操作系统"><a href="#二-什么是操作系统" class="headerlink" title="二 什么是操作系统"></a>二 什么是操作系统</h2><p>　　<strong>精简的说的话，操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序。操作系统所处的位置如图1</strong></p>
<pre><code>#操作系统位于计算机硬件与应用软件之间，本质也是一个软件。操作系统由操作系统的内核（运行于内核态，管理硬件资源）以及系统调用（运行于用户态，为应用程序员写的应用程序提供系统调用接口）两部分组成，所以，单纯的说操作系统是运行于内核态的，是不准确的。</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/1036857-20170118112402265-1697763795.png" alt="img"></p>
<p>​                                                                      图1</p>
<p>　　<strong>细说的话，操作系统应该分成两部分功能：</strong></p>
<pre><code>#一：隐藏了丑陋的硬件调用接口（键盘、鼠标、音箱等等怎么实现的，就不需要你管了），为应用程序员提供调用硬件资源的更好，更简单，更清晰的模型（系统调用接口）。应用程序员有了这些接口后，就不用再考虑操作硬件的细节，专心开发自己的应用程序即可。
例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制（比如控制磁盘转动，移动磁头读写数据等细节），

#二：将应用程序对硬件资源的竞态请求变得有序化
例如：很多应用软件其实是共享一套计算机硬件，比方说有可能有三个应用程序同时需要申请打印机来输出内容，那么a程序竞争到了打印机资源就打印，然后可能是b竞争到打印机资源，也可能是c，这就导致了无序，打印机可能打印一段a的内容然后又去打印c...,操作系统的一个功能就是将这种无序变得有序。</code></pre>
<pre><code>#作用一：为应用程序提供如何使用硬件资源的抽象
例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制

注意：
    操作系统提供给应用程序的该抽象是简单，清晰，优雅的。为何要提供该抽象呢？
    硬件厂商需要为操作系统提供自己硬件的驱动程序（设备驱动，这也是为何我们要使用声卡，就必须安装声卡驱动。。。），厂商为了节省成本或者兼容旧的硬件，它们的驱动程序是复杂且丑陋的
    操作系统就是为了隐藏这些丑陋的信息，从而为用户提供更好的接口
    这样用户使用的shell，Gnome，KDE看到的是不同的界面，但其实都使用了同一套由linux系统提供的抽象接口


#作用二：管理硬件资源
    现代的操作系统运行同时运行多道程序，操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他I/O接口设备的分配。
例如：
    同一台计算机上同时运行三个程序，它们三个想在同一时刻在同一台计算机上输出结果，那么开始的几行可能是程序1的输出，接着几行是程序2的输出，然后又是程序3的输出，最终将是一团糟（程序之间是一种互相竞争资源的过程）
    操作系统将打印机的结果送到磁盘的缓冲区，在一个程序完全结束后，才将暂存在磁盘上的文件送到打印机输出，同时其他的程序可以继续产生更多的输出结果（这些程序的输出没有真正的送到打印机），这样，操作系统就将由竞争产生的无序变得有序化。</code></pre>
<p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/1036857-20170825154958011-1047256710.png" alt="img"></p>
<p>​                                                     图 2</p>
<h2 id="三-操作系统与普通软件的区别"><a href="#三-操作系统与普通软件的区别" class="headerlink" title="三 操作系统与普通软件的区别"></a>三 操作系统与普通软件的区别</h2><p>　　1.主要区别是：你不想用暴风影音了你可以选择用迅雷播放器或者干脆自己写一个，但是你无法写一个属于操作系统一部分的程序（时钟中断处理程序），操作系统由硬件保护，不能被用户修改。</p>
<p>　　2.操作系统与用户程序的差异并不在于二者所处的地位。特别地，操作系统是一个大型、复杂、长寿的软件，</p>
<ul>
<li>大型：linux或windows的源代码有五百万行数量级。按照每页50行共1000行的书来算，五百万行要有100卷，要用一整个书架子来摆置，这还仅仅是内核部分。用户程序，如GUI，库以及基本应用软件（如windows Explorer等），很容易就能达到这个数量的10倍或者20倍之多。</li>
<li>长寿：操作系统很难编写，如此大的代码量，一旦完成，操作系统所有者便不会轻易扔掉，再写一个。而是在原有的基础上进行改进。（基本上可以把windows95/98/Me看出一个操作系统，而windows NT/2000/XP/Vista则是两位一个操作系统，对于用户来说它们十分相似。还有UNIX以及它的变体和克隆版本也演化了多年，如System V版，Solaris以及FreeBSD等都是Unix的原始版，不过尽管linux非常依照UNIX模式而仿制，并且与UNIX高度兼容，但是linux具有全新的代码基础）</li>
</ul>
<h2 id="四-操作系统发展史"><a href="#四-操作系统发展史" class="headerlink" title="四 操作系统发展史"></a>四 操作系统发展史</h2><h3 id="第一代（1940-1955）-手工操作—-穿孔卡片"><a href="#第一代（1940-1955）-手工操作—-穿孔卡片" class="headerlink" title="第一代（1940~1955）  手工操作—-穿孔卡片"></a><strong>第一代（1940~1955）  手工操作—-穿孔卡片</strong></h3><p>　　第一代之前人类是想用机械取代人力，第一代计算机的产生是计算机由机械时代进入电子时代的标志，从Babbage失败之后一直到第二次世界大战，数字计算机的建造几乎没有什么进展，第二次世界大战刺激了有关计算机研究的爆炸性进展。</p>
<p>　　lowa州立大学的john Atanasoff教授和他的学生Clifford Berry建造了据认为是第一台可工作的数字计算机。该机器使用300个真空管。大约在同时，Konrad Zuse在柏林用继电器构建了Z3计算机，英格兰布莱切利园的一个小组在1944年构建了Colossus，Howard Aiken在哈佛大学建造了Mark 1，宾夕法尼亚大学的William Mauchley和他的学生J.Presper Eckert建造了ENIAC。这些机器有的是二进制的，有的使用真空管，有的是可编程的，但都非常原始，设置需要花费数秒钟时间才能完成最简单的运算。</p>
<p>　　在这个时期，同一个小组里的工程师们，设计、建造、编程、操作及维护同一台机器，所有的程序设计是用纯粹的机器语言编写的，甚至更糟糕，需要通过成千上万根电缆接到插件板上连成电路来控制机器的基本功能。没有程序设计语言（汇编也没有），操作系统则是从来都没听说过。使用机器的过程更加原始</p>
<p>​      <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110182111238-747473806.png" alt="img">   <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110182812441-1603066554.png" alt="img"></p>
<p>　　穿孔卡带的过程：程序员将对应于程序和数据的已穿孔的纸带（或卡片）装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行；计算完毕，打印机输出计算结果；用户取走结果并卸下纸带（或卡片）后，才让下一个用户上机。</p>
<p>　　手工操作特点：</p>
<p>　　　　（1）用户独占全机。不会出现因资源已被其他用户占用而等待的现象，但资源的利用率低。</p>
<p>　　　　（2）CPU 等待手工操作。CPU的利用不充分。</p>
<p>　　　　（3）没有操作系统的概念。</p>
<p>　　　　（4）所有的程序设计都是直接操控硬件。</p>
<h3 id="第二代（1955-1965）-磁带存储—批处理系统"><a href="#第二代（1955-1965）-磁带存储—批处理系统" class="headerlink" title="第二代（1955~1965）  磁带存储—批处理系统"></a><strong>第二代（1955~1965）  磁带存储—批处理系统</strong></h3><p>　　 20世纪50年代后期，出现<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%BA%E6%9C%BA%E7%9F%9B%E7%9B%BE">人机矛盾</a>：手工操作的慢速度和计算机的高速度之间形成了尖锐矛盾，手工操作方式已严重损害了系统资源的利用率（使资源利用率降为百分之几，甚至更低），不能容忍。唯一的解决办法：只有摆脱人的手工操作，实现作业的自动过渡。这样就出现了成<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86">批处理</a>。</p>
<p>　　批处理系统：加载在计算机上的一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">系统软件</a>，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（这作业包括程序、数据和命令）。</p>
<p><strong>特点：</strong></p>
<p>　　　　设计人员、生产人员、操作人员、程序人员和维护人员直接有了明确的分工，计算机被锁在专用空调房间中，由专业操作人员运行，这便是‘大型机’。</p>
<p>　　　　有了操作系统的概念</p>
<p>　　　　有了程序设计语言：FORTRAN语言或汇编语言</p>
<h3 id="1-联机批处理系统"><a href="#1-联机批处理系统" class="headerlink" title="　  1.联机批处理系统"></a>　  1.联机批处理系统</h3><p>　　　　首先出现的是联机批处理系统，即作业的输入/输出由CPU来处理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110182929754-795493284.png" alt="img"></p>
<p>　　　　主机与输入机之间增加一个存储设备——磁带，在运行于主机上的监督程序的自动控制下，计算机可自动完成：成批(把一堆人的输入攒起来，一起出入，一大波人的输出攒起来，一起输出)地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行并把计算结果向输出机输出。完成了上一批作业后，监督程序又从输入机上输入另一批作业，保存在磁带上，并按上述步骤重复处理。</p>
<p>监督程序不停地处理各个作业，从而实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间，有效克服了人机矛盾，提高了计算机的利用率。</p>
<p>但是，在作业输入和结果输出时，主机的高速CPU仍处于空闲状态，等待慢速的输入/输出设备完成工作： 主机处于“忙等”状态。（忙等状态就是说CPU等着输出完成之后再去从输入机上读指令来执行，造成了CPU的浪费）</p>
<h3 id="2-脱机批处理系统"><a href="#2-脱机批处理系统" class="headerlink" title="　　2.脱机批处理系统"></a>　　2.脱机批处理系统</h3><p>　　　　为克服与缓解：高速主机与慢速外设（输入输出设备）的矛盾，提高CPU的利用率，又引入了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%84%B1%E6%9C%BA%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">脱机批处理系统</a>，即输入/输出（input\output，简称I\O操作）脱离主机控制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110183045738-226986599.png" alt="img"></p>
<p>​     　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110183131738-1701797644.png" alt="img"></p>
<p>　　　　　　卫星机：一台不与主机直接相连而专门用于与输入/输出设备打交道的。</p>
<p>　　　　　　其功能是：</p>
<p>　　　　　　　　（1）从输入机上读取用户作业并放到输入磁带上。</p>
<p>　　　　　　　　（2）从输出磁带上读取执行结果并传给输出机。</p>
<p>　　　　　    这样，主机不是直接与慢速的输入/输出设备打交道，而是与速度相对较快的磁带机发生关系，有效缓解了主机与设备的矛盾。主机与卫星机可并行工作，二者分工明确，可以充分发挥主机的高速计算能力。</p>
<p>​      　　　　  脱机批处理系统:20世纪60年代应用十分广泛，它极大缓解了人机矛盾及主机与外设的矛盾。</p>
<p>　　　　　    不足：但目前为止，所有的程序都还是串行执行的，也就是一个程序结束才执行下一个程序，每次主机内存中仅存放一道作业，每当主机中这个运行期间的作业或者说程序发出输入/输出（I/O）请求后，CPU要去高速磁带里读数据，计算结果要往高速磁带里面写数据，那么高速的CPU便处于等待低速的I/O完成状态，CPU并没有完全的运算起来，也可以理解为我要等着你输入或者等着你输出，致使CPU空闲。注意：之前系统的缺点说的是等待用户将程序全部输入进去，等待程序运行结束后输出最终结果的操作。现在说的是程序运行期间发生的输入\输出操作，也就是去高速磁带里面去读取程序数据，然后将输出数据写到高速磁带中，也是耗时的，cpu这段时间内的利用率也是很低的。</p>
<p>　　　　　　 为改善CPU的利用率，又引入了<strong>多道程序系统</strong>。</p>
<p>我们总结一下上面的几个操作系统，1、为了解决大家都要排队去运行自己的程序，出现了批处理系统，2、为了解决输出设备和输入设备的人工操作以及高速cpu和输入输出设备之间速度的差异问题，出现了高速磁带和脱机批处理系统，3、因为cpu的运算速度比高速磁带的读取和输出的速度要高很多，那么当程序运当中去和高速磁带打交道，并且解决程序串行，也就是一个程序完了之后，才能执行下一个的情况，出现了下面的多道系统。</p>
<h3 id="第三代（1955-1965）-多道程序系统（多道是重点-）"><a href="#第三代（1955-1965）-多道程序系统（多道是重点-）" class="headerlink" title="第三代（1955~1965）  多道程序系统（多道是重点\*\）**"></a><strong>第三代（1955~1965）  多道程序系统（多道是重点\</strong>*<em>\</em>）**</h3><p>　　多道技术产生的技术背景：cpu在执行一个任务的过程中，若需要操作硬盘，则发送操作硬盘的指令，指令一旦发出，硬盘上的机械手臂滑动读取数据到内存中，这一段时间，cpu需要等待，时间可能很短，但对于cpu来说已经很长很长，长到可以让cpu做很多其他的任务，如果我们让cpu在这段时间内切换到去做其他的任务，这样cpu不就充分利用了吗。</p>
<p>　　1.多道程序设计技术</p>
<p>　　　　所谓多道程序设计技术，就是指允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110183621582-153745188.png" alt="img"></p>
<p>　　　　在A程序计算时，I/O空闲， A程序I/O操作时，CPU空闲（B程序也是同样）；必须A工作完成后，B才能进入内存中开始工作，两者是串行的，全部完成共需时间=T1+T2。</p>
<p>​      　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110183714426-287499114.png" alt="img"></p>
<p>　　　　将A、B两道程序同时存放在内存中，它们在系统的控制下，可相互穿插、交替地在CPU上运行：当A程序因请求I/O操作而放弃CPU时，B程序就可占用CPU运行，这样 CPU不再空闲，而正进行A I/O操作的I/O设备也不空闲，显然，CPU和I/O设备都处于“忙”状态，大大提高了资源的利用率，从而也提高了系统的效率，A、B全部完成所需时间&lt;&lt;T1+T2。</p>
<p>　　　　多道程序设计技术不仅使CPU得到充分利用，同时改善I/O设备和内存的利用率，从而提高了整个系统的资源利用率和系统吞吐量（单位时间内处理作业（程序）的个数），最终提高了整个系统的效率。</p>
<p>　　　　单处理机系统中多道程序运行时的特点：</p>
<p>　　　　　　（1）多道：计算机内存中同时存放几道相互独立的程序；</p>
<p>　　　　　　（2）宏观上并行：同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；</p>
<p>　　　　　　（3）微观上串行：实际上，各道程序轮流地用CPU，并交替运行。</p>
<p>　　　　<strong>多道程序系统的出现，标志着操作系统渐趋成熟的阶段，先后出现了作业调度管理、处理机管理、存储器管理、外部设备管理、文件系统管理等功能。</strong></p>
<p>　　　　<strong>由于多个程序同时在计算机中运行，开始有了空间隔离的概念，只有内存空间的隔离，才能让数据更加安全、稳定。</strong></p>
<p>　　　　<strong>出了空间隔离之外，多道技术还第一次体现了时空复用的特点，遇到IO操作就切换程序，使得cpu的利用率提高了，计算机的工作效率也随之提高。</strong></p>
<p>　　　　<strong>空间上的复用</strong>：将内存分为几部分，每个部分放入一个程序，这样，同一时间内存中就有了多道程序。</p>
<p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/1036857-20170313010137401-1096621807.png" alt="img"></p>
<p>　　　　<strong>时间上的复用</strong>：当一个程序在等待I/O时，另一个程序可以使用cpu，如果内存中可以同时存放足够多的作业，则cpu的利用率可以接近100%</p>
<p>　　　　</p>
<p>　　2.多道批处理系统　　　　　</p>
<p>　　　　20世纪60年代中期，在前述的批处理系统中，引入多道程序设计技术后形成多道批处理系统（简称：批处理系统）。</p>
<p>　　　　它有两个特点：</p>
<p>　　　　　　（1）多道：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。</p>
<p>　　　　　　（2）成批：在系统运行过程中，不允许用户与其作业发生交互作用，即：作业一旦进入系统，用户就不能直接干预其作业的运行。</p>
<p>　　　　批处理系统的追求目标：提高系统资源利用率和系统吞吐量，以及作业流程的自动化。</p>
<p>　　　　批处理系统的一个重要缺点：不提供人机交互能力，给用户使用计算机带来不便。</p>
<p>　　　　虽然用户独占全机资源，并且直接控制程序的运行，可以随时了解程序运行情况。但这种工作方式因独占全机造成资源效率极低。</p>
<p>　　　　一种新的追求目标：既能保证计算机效率，又能方便用户使用计算机。 20世纪60年代中期，计算机技术和软件技术的发展使这种追求成为可能。</p>
<p> 　　　　但是 有两个缺点，举例：</p>
<p>　　　　　　<strong>1、时间复用上的缺点：</strong>程序员A的程序运行10分钟就能够运行结束，程序员B的程序需要运行24小时，如何程序员B的程序先运行，并且程序员B的程序没有任何I\O操作，那么程序员A需要等待24小时之后才能执行，那么这就不太合理了。</p>
<p>　　　　　　<strong>2、空间复用上的缺点：</strong>首先丧失的是安全性，比如你的qq程序可以访问操作系统的内存，这意味着你的qq可以拿到操作系统的所有权限。其次丧失的是稳定性，某个程序崩溃时有可能把别的程序的内存也给回收了，比方说把操作系统的内存给回收了，则操作系统崩溃。</p>
<p>　　　　为了解决<strong>空间</strong>复用上的问题：程序之间的内存必须分割，由操作系统控制。如果内存彼此不分割，则一个程序可以访问另外一个程序的内存。<br>　　　　为了解决<strong>时间</strong>出现了分时系统</p>
<p>　　　　</p>
<p>　　3.分时系统</p>
<p>　　　　由于CPU速度不断提高和采用分时技术，一台计算机可同时连接多个用户终端，而每个用户可在自己的终端上联机使用计算机，好象自己独占机器一样。</p>
<p>​      　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110184819504-1786017242.png" alt="img"></p>
<p>　　　　分时技术：把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。</p>
<p>　　　　若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的印象是，好象他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。</p>
<p>具有上述特征的计算机系统称为分时系统，它允许多个用户同时联机使用计算机。</p>
<p>　　　　特点：</p>
<p>　　　　（1）多路性。若干个用户同时使用一台计算机。微观上看是各用户轮流使用计算机；宏观上看是各用户并行工作。</p>
<p>　　　　（2）交互性。用户可根据系统对请求的响应结果，进一步向系统提出新的请求。这种能使用户与系统进行人机对话的工作方式，明显地有别于批处理系统，因而，分时系统又被称为交互式系统。</p>
<p>　　　　（3）独立性。用户之间可以相互独立操作，互不干扰。系统保证各用户程序运行的完整性，不会发生相互混淆或破坏现象。</p>
<p>　　　　（4）及时性。系统可对用户的输入及时作出响应。分时系统性能的主要指标之一是响应时间，它是指：从终端发出命令到系统予以应答所需的时间。</p>
<p>　　　　<strong>分时系统的主要目标</strong>：对用户响应的及时性，即不至于用户等待每一个命令的处理时间过长。</p>
<p>分时系统可以同时接纳数十个甚至上百个用户，由于内存空间有限，往往采用对换（又称交换）方式的存储方法。即将未“轮到”的作业放入磁盘，一旦“轮到”，再将其调入内存；而时间片用完后，又将作业存回磁盘（俗称“滚进”、“滚出“法），使同一存储区域轮流为多个用户服务。</p>
<p>多用户分时系统是当今计算机操作系统中最普遍使用的一类操作系统。</p>
<p>​      　　<strong>注意：分时系统的分时间片工作，在没有遇到IO操作的时候就用完了自己的时间片被切走了，这样的切换工作其实并没有提高cpu的效率，反而使得计算机的效率降低了。为什么下降了呢？因为CPU需要切换，并且记录每次切换程序执行到了哪里，以便下次再切换回来的时候能够继续之前的程序，虽然我们牺牲了一点效率，但是却实现了多个程序共同执行的效果，这样你就可以在计算机上一边听音乐一边聊qq了。</strong></p>
<p>　　　　</p>
<p>　　4.实时系统</p>
<p>　　　　虽然多道批处理系统和分时系统能获得较令人满意的资源利用率和系统响应时间，但却不能满足实时控制与实时信息处理两个应用领域的需求。于是就产生了实时系统，即系统能够及时响应随机发生的外部事件，并在严格的时间范围内完成对该事件的处理。</p>
<p>　　　　实时系统在一个特定的应用中常作为一种控制设备来使用。</p>
<p>　　　　　　实时系统可分成两类：</p>
<p>　　　　　　（1）实时控制系统。当用于飞机飞行、导弹发射等的自动控制时，要求计算机能尽快处理测量系统测得的数据，及时地对飞机或导弹进行控制，或将有关信息通过显示终端提供给决策人员。当用于轧钢、石化等工业生产过程控制时，也要求计算机能及时处理由各类传感器送来的数据，然后控制相应的执行机构。</p>
<p>　　　　　　（2）实时信息处理系统。当用于预定飞机票、查询有关航班、航线、票价等事宜时，或当用于银行系统、情报检索系统时，都要求计算机能对终端设备发来的服务请求及时予以正确的回答。此类对响应及时性的要求稍弱于第一类。</p>
<p>　　　　<strong>实时操作系统的主要特点</strong>：</p>
<p>　　　　　　（1）及时响应。每一个信息接收、分析处理和发送的过程必须在严格的时间限制内完成。</p>
<p>　　　　　　（2）高可靠性。需采取冗余措施，双机系统前后台工作，也包括必要的保密措施等。</p>
<pre><code>分时——现在流行的PC，服务器都是采用这种运行模式，即把CPU的运行分成若干时间片分别处理不同的运算请求 linux系统
实时——一般用于单片机上、PLC等，比如电梯的上下控制中，对于按键等动作要求进行实时处理 </code></pre>
<p> 　　5.通用操作系统</p>
<p>　　　　操作系统的三种基本类型：多道批处理系统、分时系统、实时系统。</p>
<p>　　　　<strong>通用操作系统：具有多种类型操作特征的操作系统。可以同时兼有多道批处理、分时、实时处理的功能，或其中两种以上的功能。</strong></p>
<p>　　　　例如：实时处理+批处理=实时批处理系统。首先保证优先处理实时任务，插空进行批处理作业。常把实时任务称为前台作业，批作业称为后台作业。</p>
<p>　　　　再如：分时处理+批处理=分时批处理系统。即：时间要求不强的作业放入“后台”（批处理）处理，需频繁交互的作业在“前台”（分时）处理，处理机优先运行“前台”作业。</p>
<p>　　　　从上世纪60年代中期，国际上开始研制一些大型的通用操作系统。这些系统试图达到功能齐全、可适应各种应用范围和操作方式变化多端的环境的目标。但是，这些系统过于复杂和庞大，不仅付出了巨大的代价，且在解决其可靠性、可维护性和可理解性方面都遇到很大的困难。</p>
<p>　　　　相比之下，UNIX操作系统却是一个例外。这是一个通用的多用户分时交互型的操作系统。它首先建立的是一个精干的核心，而其功能却足以与许多大型的操作系统相媲美，在核心层以外，可以支持庞大的软件系统。它很快得到应用和推广，并不断完善，对现代操作系统有着重大的影响。</p>
<p>　　　　至此，操作系统的基本概念、功能、基本结构和组成都已形成并渐趋完善。</p>
<p><strong>第三代（1980~至今）  现代计算机</strong></p>
<p> 　　进入20世纪80年代，大规模集成电路工艺技术的飞跃发展，微处理机的出现和发展，掀起了计算机大发展大普及的浪潮。一方面迎来了个人计算机的时代，同时又向计算机网络、分布式处理、巨型计算机和智能化方向发展。于是，操作系统有了进一步的发展，如：个人计算机操作系统、网络操作系统、分布式操作系统等。</p>
<p>　　1.个人计算机操作系统</p>
<p>　　　　个人计算机上的操作系统是联机交互的单用户操作系统，它提供的联机交互功能与通用分时系统提供的功能很相似。</p>
<p>　　　　由于是个人专用，因此一些功能会简单得多。然而，由于个人计算机的应用普及，对于提供更方便友好的用户接口和丰富功能的文件系统的要求会愈来愈迫切。</p>
<p>　　2.网络操作系统</p>
<p>　　　　计算机网络：通过通信设施，将地理上分散的、具有自治功能的多个计算机系统互连起来，实现信息交换、资源共享、互操作和协作处理的系统。</p>
<p>　　　　网络操作系统：在原来各自计算机操作系统上，按照网络体系结构的各个协议标准增加网络管理模块，其中包括：通信、资源共享、系统安全和各种网络应用服务。</p>
<p> 　　　   就是添加了一些网络方面的功能。</p>
<p>　　3.分布式操作系统</p>
<p>　　　　表面上看，分布式系统与计算机网络系统没有多大区别。分布式操作系统也是通过通信网络，将地理上分散的具有自治功能的数据处理系统或计算机系统互连起来，实现信息交换和资源共享，协作完成任务。——硬件连接相同。</p>
<p>　　　　分布式：将一个大的任务拆分成几个小的任务，分配给不同的任务处理机制，具体怎么分配是由系统中的算法决定的，大家同时来运行自己的任务，然后各自将人物的返回结果再返回给你这个大的任务。</p>
<p>　　　　但有如下一些明显的区别：</p>
<p>　　　　　　（1）分布式系统要求一个统一的操作系统，实现系统操作的统一性。</p>
<p>　　　　　　（2）分布式操作系统管理分布式系统中的所有资源，它负责全系统的资源分配和调度、任务划分、信息传输和控制协调工作，并为用户提供一个统一的界面。</p>
<p>　　　　　　（3）用户通过这一界面，实现所需要的操作和使用系统资源，至于操作定在哪一台计算机上执行，或使用哪台计算机的资源，则是操作系统完成的，用户不必知道，此谓：系统的透明性。</p>
<p>　　　　　　（4）分布式系统更强调分布式计算和处理，因此对于多机合作和系统重构、坚强性和容错能力有更高的要求，希望系统有：更短的响应时间、高吞吐量和高可靠性。</p>
<p>　　　　分布式系统已经很普遍了，一般个人用不到，企业在处理比较大的任务的时候才会使用。</p>
<h2 id="本篇部分博客摘自：https-blog-csdn-net-yanglingwell-article-details-53745758"><a href="#本篇部分博客摘自：https-blog-csdn-net-yanglingwell-article-details-53745758" class="headerlink" title="本篇部分博客摘自：https://blog.csdn.net/yanglingwell/article/details/53745758"></a>本篇部分博客摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yanglingwell/article/details/53745758">https://blog.csdn.net/yanglingwell/article/details/53745758</a></h2><h2 id="五、操作系统原理"><a href="#五、操作系统原理" class="headerlink" title="五、操作系统原理"></a>五、操作系统原理</h2><h3 id="1-操作系统的资源管理技术"><a href="#1-操作系统的资源管理技术" class="headerlink" title="1. 操作系统的资源管理技术"></a>1. 操作系统的资源管理技术</h3><p>　　资源管理解决物理资源数量不足和合理分配资源这两个问题。<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219183259469.png" alt="PM2VM"><br>　　操作系统虚拟机为用户提供了一种简单、清晰、易用、高效的计算机模型。虚拟机的每种资源都是物力资源通过复用、虚拟和抽象而得到的产物。<br>　　虚拟机提供进程运行的逻辑计算环境。从概念上来说，一个进程运行在一台虚拟机上，可以认为一个进程就是一台虚拟机，一台虚拟机就是一个进程。</p>
<ul>
<li><p>复用：<em>空分复用共享</em>和<em>时分复用共享</em>。<br>a. 空分复用共享(space-multiplexed sharing): 将资源从“空间”上分割成更小的单位供不同进程使用。在计算机系统中，内存和外存(磁盘)等是空分复用共享的。<br>b. 时分复用共享(time-multiplexed sharing): 将资源从“时间”上分割成更小的单位供不同进程使用。在计算机系统中，处理器和磁盘机等是时分复用共享的。</p>
</li>
<li><p>虚拟：对资源进行转化、模拟或整合，把一个物理资源转变成多个逻辑上的对应物，也可以把多个物理资源变成单个逻辑上的对应物，即创建无须共享独占资源的假象，或创建易用且多于实际物理资源的虚拟资源假象，以达到多用户共享一套计算机物理资源的目的。虚拟技术可用于外部设备(外部设备同时联机操作(SPOOLing)),存储资源(虚拟内存)和文件系统(虚拟文件系统(Virtual File System, VFS))中。</p>
<blockquote>
<p>复用和虚拟相比较，复用所分割的是实际存在的物理资源，而虚拟则实现假想的同类资源。虚拟技术解决某类物理资源不足的问题，提供易用的虚拟资源和更好的运行环境。</p>
</blockquote>
</li>
<li><p>抽象：通过创建软件来屏蔽硬件资源的物理特性和实现细节，简化对硬件资源的操作、控制和使用。</p>
<blockquote>
<p>复用和虚拟的主要目标是解决物理资源数量不足的问题，抽象则用于处理系统复杂性，重点解决资源易用性。</p>
</blockquote>
</li>
</ul>
<h3 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="2. 系统调用"></a>2. 系统调用</h3><ul>
<li><p>系统调用： 为给应用程序的运行提供良好环境，内核提供了一系列具有预定功能的服务例程，通过一组称为系统调用（System Call）的接口呈现给用户，系统调用把应用程序的请求传送至内核，调用相应的服务例程完成所需处理，将处理结果返回给应用程序。<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219165735777.png" alt="OS_System_Call"></p>
<blockquote>
<p>注：系统调用的编号称为功能号</p>
</blockquote>
</li>
<li><p>系统调用的执行过程： 当CPU执行程序中编写的由访管指令(supervisor, 也称自陷指令(trap)或中断指令(interrupt), 指引起处理器中断的机器指令)实现的系统调用时会产生异常信号，通过陷阱机制(也称异常处理机制，当异常或中断发生时，处理器捕捉到一个执行线程，并且将控制权转移到操作系统中某一个固定地址的机制)，处理器的状态由用户态(user mode, 又称目态或普通态)转变为核心态(kerbel mode, 又称管态或内核态)，进入操作系统并执行相应服务例程，以获得操作系统服务。当系统调用执行完毕时，处理器再次切换状态，控制返回至发出系统调用的程序。</p>
</li>
<li><p>系统调用是应用程序获得操作系统服务的唯一途径。</p>
</li>
</ul>
<blockquote>
<p>系统调用的作用：<br>\1. 内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性。<br>\2. 系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且编程效率大大提高。</p>
<p>系统调用与函数调用的区别：<br>\1. 调用形式和实现方式不同。功能号 VS 地址； 用户态转换到内核态 VS 用户态。<br>\2. 被调用代码的位置不同。 动态调用 + 操作系统 VS 静态调用 + 用户级程序。<br>\3. 提供方式不同。 操作系统 VS 编程语言。</p>
</blockquote>
<h3 id="3-操作系统内核"><a href="#3-操作系统内核" class="headerlink" title="3. 操作系统内核"></a>3. 操作系统内核</h3><ul>
<li>内核： 是一组程序模块，作为可信软件来提供支持进程并发执行的基本功能和基本操作，通常驻留在内核空间，运行于内核态，具有直接访问硬件设备和所有内存空间的权限，是仅有的能够执行特权指令的程序。</li>
<li>内核的功能：<br>a. 中断处理。中断处理是内核中最基本的功能，也是操作系统赖以活动的基础。<br>b. 时钟管理。时钟管理是内核的基本功能。<br>c. 短程调度。短程调度的职责是分配处理器，按照一定的策略管理处理器的转让，以及完成保护和恢复现场工作。<br>d. 原语管理。 原语是内核中实现特定功能的不可中断过程。</li>
</ul>
<blockquote>
<p>内核是操作系统对裸机的第一次改造，内核和裸机组成了第一层虚拟机，进程在虚拟机上运行。</p>
</blockquote>
<hr>
<h3 id="4-处理器状态：-内核态和用户态"><a href="#4-处理器状态：-内核态和用户态" class="headerlink" title="4. 处理器状态： 内核态和用户态"></a>4. 处理器状态： 内核态和用户态</h3><ul>
<li>仅在内核态下才能使用的指令称为特权指令，执行这些指令不仅影响运行程序自身，而且还会干扰其他程序及操作系统。 非特权指令在内核态和和用户态下都能工作。</li>
</ul>
<blockquote>
<p>现代计算机为处理器建立硬件标志位，称处理器状态位，通常是程序状态字(Program Status Word, PSW)中的一位，来将处理器的状态设置为内核态或用户态。</p>
</blockquote>
<ul>
<li>用户态向内核态转换的情况：<br>a. 程序请求操作系统服务， 执行系统调用。<br>b. 在程序运行时产生中断事件(如I/O操作完成)，运行程序被中断，转向中断处理程序处理。<br>c. 在程序运行时产生异常事件(如在目态下执行特权指令)，运行程序被打断，转向异常处理程序工作。</li>
</ul>
<blockquote>
<p>以上三种情况都是通过中断机制发生，可以说中断和异常是用户态到内核态转换的仅有途径。</p>
</blockquote>
<ul>
<li>用户栈和核心栈<br>a. 用户栈是用户进程空间中的一块区域。用于保存应用程序的子程序(函数)间相互调用的参数，返回值，返回点和子程序的局部变量。<br>b. 核心栈是内存中操作系统空间的一块区域。用于保存中断现场和保存操作系统程序(函数)间相互调用的参数，返回值，返回点和程序的局部变量。</li>
</ul>
<h3 id="5-中断（Interupt）"><a href="#5-中断（Interupt）" class="headerlink" title="5. 中断（Interupt）"></a>5. 中断（Interupt）</h3><ul>
<li>中断：程序执行过程中遇到急需处理的事件时，暂时终止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再返回断点或调度其他程序的执行过程。</li>
<li>中断的分类：<br>a. 外中断(又称中断或异步中断)： 来自处理器之外的中断信号，如，时钟中断、键盘中断等。外中断可分为可屏蔽中断和非可屏蔽中断。<br>b. 内中断(又称异常或同步中断)，来自处理器内部的中断信号，如，访管中断，硬件故障中断，程序性中断等。内中断不能被屏蔽。</li>
<li>中断和异常的响应： 发现中断源 → 保护现场 → 转向中断/异常事件处理程序执行 → 恢复现场</li>
</ul>
<h3 id="6-进程"><a href="#6-进程" class="headerlink" title="6. 进程"></a>6. 进程</h3><ul>
<li><p>进程：具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。<br>a. 从原理角度看，进程是支持程序执行的一种系统机制，它对处理器上运行程序的活动进行抽象。<br>b. 从实现角度看，进程是一种数据结构，用来准确地刻画运行程序的状态和系统动态变化状况。</p>
</li>
<li><p>进程状态的七态模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219181305933.png" alt="OS_SEVEN"></p>
<p>a. 新建态(new): 进程被创建，尚未进入就绪队列。<br>b. 就绪态(ready): 进程具备运行条件，等待系统分配处理器。<br>c. 挂起就绪态(ready suspend)：进程具备运行条件，但目前在外存中。<br>d. 运行态(running): 进程占有处理器正在运行。<br>e. 终止态(exit): 进程达到正常结束点或被其他原因所终止，下一步将被撤销。<br>f. 等待态(wait): 又称阻塞态或休眠态。进程正在等待某个事件完成，目前不具备运行条件。<br>g. 挂起等待态(blocked suspend): 进程正在等待某个事件完成，并且在外存中。</p>
</li>
<li><p>程序和数据刻画进程的静态特征，称为进程控制块的一种数据结构刻画进程的动态特征。进程映像(process image)包括进程控制块、进程程序块、进程核心块、进程数据块等要素。</p>
</li>
<li><p>进程控制块(Process Control Block, PCB)：进程存在的唯一标识，操作系统掌握进程的唯一资料结构和管理进程的主要依据。包括标识信息、现场信息和控制信息等信息。</p>
</li>
<li><p>进程队列(process queue)：处于同一状态的所有进程的PCB链接在一起的数据结构。 有两种队列组织方式：链接方式和索引方式。</p>
</li>
<li><p>进程切换必定在内核态而非用户态发生。</p>
</li>
<li><p>进程可以分为两部分，资源集合和线程集合。进程要支撑线程运行，为线程提供虚拟地址空间和各种资源。进程封装管理信息，线程封装执行信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219181350933.png" alt="OS_MultiThread"></p>
</li>
</ul>
<h3 id="7-处理器调度"><a href="#7-处理器调度" class="headerlink" title="7. 处理器调度"></a>7. 处理器调度</h3><ul>
<li><p>处理器调度层次：<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219181558617.png" alt="OS_Scheduling"><br>a. 高级调度： 又称作业调度、长程调度。从输入系统的一批作业(job, 用户提交给操作系统计算的一个独立任务)中按照预定的调度策略挑选若干作业进入内存，为其分配所需资源并创建对应作业的用户进程。<br>b. 中级调度： 又称平衡调度，中程调度。根据内存资源情况决定内存所能容纳的进程数目，并完成外存和内存中进程对换工作。<br>c. 低级调度：又称进程调度/线程调度，短程调度。根据某种原则决定就绪队列中那个进程/线程先获得处理器，并将处理器出让给它使用。</p>
</li>
<li><p>低级调度算法：<br>a. 先来先服务(First Come First Server, FCFS)算法。<br>b. 最短作业优先(Shortest Job First, SJF)算法。<br>c. 最短剩余时间优先(Shortest Remaining Time First, SRTF)算法： 假设当前某进程/线程正在运行，如果<em>有新进程/线程移入就绪队列</em>，若它所需的CPU运行时间比当前运行的进程/线程所需的剩余CPU时间还短，抢占式最短作业优先算法强行剥夺当前执行者的控制权，调度新进程/线程执行。<br>d. 最高响应比优先(Highest Response Ratio First, HRRF)算法:非剥夺式算法。其中，响应比 = (作业已等待时间 + 作业处理时间) / 作业处理时间。<br>e. 优先级调度算法：优先级高的选择进程/线程优先选择。<br>f. 轮转调度(Round-Robin, RR)算法： 也称时间片调度。就绪队列的进程轮流运行一个时间片。<br>g. 多级反馈队列(Multi-Level Feedback Queue, MLFQ)算法。</p>
<blockquote>
<p>衡量调度算法的性能指标：<br>a. 资源利用率: CPU利用率 = CPU有效工作时间/(CPU有效工作时间 + CPU空闲等待时间)<br>b. 吞吐率： 单位时间内CPU处理作业的个数。<br>c. 公平性： 确保每个进程都能获得合理的CPU份额和其他资源份额，不会出现饥饿现象。<br>d. 响应时间： 从交互式进程提交一个请求(命令)直到获得响应之间的时间间隔。<br>e. 周转时间： 批处理用户从向系统提交作业开始到作业完成为止的时间间隔。<br>平均周转时间：T = (∑ni=1ti∑i=1nti ) / n ， 其中 titi 表示作业i的周转时间。<br>平均带权作业周转时间： T = (∑ni=1wi∑i=1nwi) / n, 其中 wi=ti/tkwi=ti/tk ， titi 表示作业i的周转时间。 tktk 表示作业i的运行时间。</p>
</blockquote>
</li>
</ul>
<h3 id="8-进程的交互"><a href="#8-进程的交互" class="headerlink" title="8. 进程的交互"></a>8. 进程的交互</h3><ul>
<li><p>进程互斥(Mutual Exclusion): 若干进程因相互抢夺<em>独占型资源</em>而产生的竞争制约关系。</p>
</li>
<li><p>进程同步(Synchronization): 为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的先后次序而等待、传递信息或消息所产生的协作制约关系。</p>
<blockquote>
<p>资源竞争会引发两个控制问题：<br>a. 死锁： 一组进程因争夺资源陷入永远等待的状态。<br>b. 饥饿： 一个可运行进程由于由于其他进程总是优先于它，而被调度程序无限期地拖延而不能被执行。</p>
</blockquote>
</li>
</ul>
<h3 id="9-临界区管理"><a href="#9-临界区管理" class="headerlink" title="9. 临界区管理"></a>9. 临界区管理</h3><ul>
<li><p>并发进程中与共享变量有关的程序段称为临界区(Critical Section)。共享变量所代表的资源称为临界资源(Critical Resource)，即一次仅能供一个进程使用的资源。</p>
</li>
<li><p>临界区调度原则：<br>a. 择一而入。 一次之多只有一个进程进入临界区内执行。<br>b. 忙则要等。 如果已有进程在临界区中， 试图进入此临界区的其他进程应等待。<br>c. 有限等待。 进入临界区内的进程应在有限时间内退出。</p>
</li>
<li><p>临界区管理的软件算法：Peterson算法。<br>为每个进程设置标志，当标志值为 <code>true</code> 时表示该进程要求进入临界区，另外再设置一个指示器 <code>turn</code> 以指示可以由哪个进程进入临界区，当 <code>turn = i</code> 时则可由 <code>Pi</code> 进入临界区。</p>
<pre><code> 1 /* Peterson 算法 */
 2 
 3 bool inside[2];
 4 inside[0] = false;
 5 inside[1] = false;
 6 enum { 0, 1 } turn;
 7 
 8 /* 进程0 */
 9 process P0(){
10     inside[0] = true;               //请求...
11     turn = 1;
12     while(inside[1] &amp;&amp; turn == 1) ; //等待...
13 
14     /*临界区 */
15 
16     inside[0] = false;              //归还...
17 }
18 
19 /* 进程1 */
20 process P1(){
21     inside[1] = true;               //请求...
22     turn = 0;
23     while(inside[0] &amp;&amp; turn == 0) ; //等待...
24 
25     /*临界区 */
26 
27     inside[1] = false;              //归还...
28 }</code></pre>
</li>
<li><p>Peterson算法满足临界区管理的三个原则。</p>
</li>
<li><p>临界区管理的硬件设施:<br>a. 关中断。 在进程进入临界区时关中断，进程退出临界区时开中断。<br>b. 测试并设置指令。 利用机器指令TS(Test and Set)实现临界区的上锁和开锁原语操作。<br>c. 对换指令。 利用对换指令实现临界区的上锁和开锁原语操作。</p>
</li>
</ul>
<h3 id="10-信号量-samaphore-和PV操作"><a href="#10-信号量-samaphore-和PV操作" class="headerlink" title="10. 信号量(samaphore)和PV操作"></a>10. 信号量(samaphore)和PV操作</h3><blockquote>
<p>PV操作都是原语操作， 不可中断。</p>
</blockquote>
<ul>
<li><p>信号量和PV操作</p>
<pre><code> 1 // 信号量
 2 typedef struct semaphore {
 3     int value;                 // 信号量值
 4     struct pcb* list;          // 指向“等待该信号量的进程队列”的指针
 5 };  
 6 
 7 // P操作
 8 void P(semaphore s){
 9     s.value--;                 // 信号量值减一
10 
11     // 如果信号量值小于0， 执行P操作的进程调用sleep(s.list)阻塞自己，
12     // 被置成“等待信号量s”状态，并移入s信号量队列，转向进程调度程序。
13     if(s.value &lt; 0) sleep(s.list);
14 }
15 
16 // V操作
17 void V(semaphore s){
18     s.value++;                 // 信号量值加一
19 
20     // 如果信号量小于等于0， 则调用wakeup(s.list)释放一个等待信号量s的进程，
21     // 并转换成就绪态， 进程则继续执行。
22     if(s.value &lt;= 0) wakeup(s.list);
23 }</code></pre>
</li>
<li><p>a. 若信号量值 <code>s.value</code> 为正值， 此值等于在封锁进程之前对信号量 <code>s</code> 可施行P操作的次数，即，s所代表的实际可用的资源数。<br>b. 若信号量值 <code>s.value</code> 为负值， 其绝对值等于登记在 <code>s</code> 信号量队列中的等待进程的数目。<br>c. 通常P操作意味着请求一个资源，V操作意味着释放一个资源。在一定条件下，P操作也可表示挂起进程的操作，V操作代表唤醒被挂起进程的操作。</p>
</li>
<li><p>信号量实现互斥</p>
<pre><code> 1 semaphore mutex;
 2 mutex = 1；
 3 
 4 //进程Pi， i = 1， 2 ...， n
 5 process Pi(){
 6     P(mutex);
 7 
 8     /* 临界区 */
 9 
10     V(mutex);
11 }</code></pre>
</li>
</ul>
<h3 id="11-管程"><a href="#11-管程" class="headerlink" title="11. 管程"></a>11. 管程</h3><ul>
<li><p>管程(monitor)：代表共享资源的数据结构及并发进程在其上执行的一组构成就构成管程，管程被请求和释放资源的进程锁调用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182812462.png" alt="OS_manitor"></p>
<p>a. 条件变量。 管程内的一种数据结构。只有在管程中才能被访问，进程可以在条件变量上等待或被唤醒。只能通过 <code>wait()</code> 和 <code>signal()</code> 原语操作来控制。<br>b. <code>wait()</code> 原语。 挂起调用进程并释放管程，直至另一个进程在条件变量上执行 <code>signal()</code>。<br>c. <code>signal()</code> 原语。如果有其他的进程因对条件变量执行 <code>wait()</code> 而被挂起，便释放之。 如果没有进程在等待，那么相当于空操作，信号不被保存。</p>
</li>
</ul>
<h3 id="12-死锁"><a href="#12-死锁" class="headerlink" title="12. 死锁"></a>12. 死锁</h3><ul>
<li><p>死锁的主要解决方法： 死锁防止、死锁避免、死锁检测和恢复。</p>
</li>
<li><p>死锁产生的必要条件：<br>a. 互斥条件。 临界资源是独占资源，进程应互斥且排他地使用这些资源。<br>b. 占有和等待条件。 进程在请求资源得不到满足而等待时，不释放已占有的资源。<br>c. 不剥夺条件。已获资源只能由进程资源释放，不允许被其他程序剥夺。<br>d. 循环等待条件。 存在循环等待链，其中每个进程都在等待下一个进程所持有的资源。</p>
<blockquote>
<p>死锁的防止就是去破坏死锁产生的必要条件。 如，使资源可同时使用(破坏互斥条件)、静态分配资源(破坏占有和等待条件)、剥夺调度(破坏不剥夺条件)、层次分配策略(循环等待条件)等。</p>
</blockquote>
</li>
<li><p>死锁避免： <a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=8bOYnVjs5ya2QcVYp7L2OaIAWkGD1GhtTEQyXhJgbIjtSmLgagTfLCM8Wc1jhlvOJpCwOu7Ddx7ZVclFCdRJ40sjRnMde41J7a5IAWmVMeqzN0WdESisqZI_oblqfC5O34ntmWjsxt8lDV6FoUhDGa">银行家算法</a> (额…自己百度去吧。 = =!)</p>
</li>
<li><p>死锁检测和恢复： 进程-资源分配图(额…还是去百度吧。)<br>a. 如果进程-资源分配图中无环路，此时系统没有死锁。<br>b. 如果进程-资源分配图中有环路，且每个资源类中只有一个资源，则系统发生死锁。<br>c. 如果进程-资源分配图中有环路，且所涉及的资源类有多个资源，则不一定会发生死锁。</p>
</li>
</ul>
<h3 id="13-可变分区存储管理"><a href="#13-可变分区存储管理" class="headerlink" title="13. 可变分区存储管理"></a>13. 可变分区存储管理</h3><ul>
<li>可变分区存储分配算法：<br>a. 最先适应分配算法。从未分配区的<em>开始位置</em>开始扫描，在找到的第一个能满足长度要求的空闲区上分配存储空间。<br>b. 下次适应分配算法。从未分配区<em>上次扫描结束处</em>开始顺序查找，在找到的第一个能满足长度要求的空闲区上分配存储空间。<br>c. 最优适应分配算法。扫描整个未分配区，选择能满足用户进程要求的<em>最小分区</em>分配存储空间。<br>d. 最坏适应分配算法。扫描整个未分配区，选择能满足用户进程要求的<em>最大分区</em>分配存储空间。<br>e. 快速适应分配算法。为经常用到的长度的空闲区设立单独的空闲区链表。</li>
</ul>
<h3 id="14-分页存储管理"><a href="#14-分页存储管理" class="headerlink" title="14. 分页存储管理"></a>14. 分页存储管理</h3><ul>
<li><p>基本概念：<br>a. 页面。 <em>进程逻辑地址空间</em>分成<em>大小相等</em>的区，每个区称为页面或页。(注： 页面的本质是逻辑地址空间)<br>b. 页框(kuàng, 0.0)。 又称页帧。<em>内存物理地址空间</em>分成<em>大小相等</em>的区，其大小和页面大小相等，每个区就是一个页框。(注： 页框的本质是物理地址空间)<br>c. 逻辑地址。分页存储器的逻辑地址由页号和页内偏移两部分组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219181753651.png" alt="OS_PageOffset"></p>
<p>d. 内存页框表。页框表的表项给出物理块使用情况：0为空闲，1为占用。<br>e. 页表。页表是操作系统为进程建立的，是程序页面和内存页框的对照表，页表的每一栏指明程序中的某一页面和分得的页框之间的关系。</p>
</li>
<li><p>分页存储管理的地址转换</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182005327.png" alt="OS_PageTable"></p>
</li>
<li><p>翻译快表：也称转换后援缓冲(Translation Look_aside Buffer, TLB)。用来存放进程最近访问的部分页表项。(注： 翻译快表之于页表类似于Cache之于存储器)</p>
</li>
<li><p>二级页表：把整个页表分割成许多小页表，每个称为页表页，每个页表页含有若干个页表表项。页表页允许分散对应不连续的页框。为了找到页表页，应建立地址索引，称为页目录表，其表项指出页表页起始地址。</p>
</li>
<li><p>二级页表实现逻辑地址到物理地址转换的过程： 由硬件“页目录表基址寄存器”指出当前运行进程的页目录表的内存起始地址，加上“页目录位移”作为索引，可找到页表页在内存的起始地址，再以“页目录位移”作为索引，找到页表页在内存的起始位置，再以“页表页位移”作为索引，找到页表页的表项，此表项中包含一个页面对应的页框号，由页框号和页内偏移便可生成物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182359453.png" alt="OS_TwoLvPageTable"></p>
<blockquote>
<p>注： 类比于书的目录，找某一段内容的时候，先在目录上找到对应的章节，再在对应的章节下面找具体的知识点。比如，我要在《操作系统原理》中查“多级页表”。首先我知道它是在存储管理一章的，于是就找到了“第四章 存储管理”（类似于找到了页目录表）。 然后在第四章下面找“多级页表”（类似于在页目录表下面找具体的页表页）。最后找到“多级页表”对应的页码（类似于在页表页中找到其对应的页框）。最后查阅对应的章节页码（类似于读取对应页框的数据）。</p>
</blockquote>
</li>
</ul>
<h3 id="15-分段存储管理"><a href="#15-分段存储管理" class="headerlink" title="15. 分段存储管理"></a>15. 分段存储管理</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182458829.png" alt="OS_Segment"></p>
<blockquote>
<p>分段和分页的比较：<br>a. 分段是信息的<em>逻辑单位</em>，由源程序的逻辑结构及含义所决定，是用户可见的，段长由用户根据需要来确定，段起始地址可以从任何内存地址开始。引入的目的是<em>满足用户模块化程序设计的需要</em>。<br>b. 分页是信息的<em>物理单位</em>，与源程序的逻辑无关，是用户不可见的，页长由系统(硬件)决定，页面只能从页大小的整数倍地址开始。引入目的是<em>实现离散分配并提高内存利用率</em>。</p>
</blockquote>
<h3 id="16-虚拟存储管理"><a href="#16-虚拟存储管理" class="headerlink" title="16. 虚拟存储管理"></a>16. 虚拟存储管理</h3><ul>
<li><p>虚拟存储管理的基本思路：</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182713867.png" alt="OS_VirtualMemory"></p>
<p>把磁盘空间当做内存的一部分，进程的程序和数据部分放在内存中，部分放在磁盘上。程序运行时，它执行的指令或访问的数据在哪里由存储管理负责判断，并针对情况采取响应的措施。</p>
</li>
<li><p>请求分页虚存管理： 将进程信息副本存放在外存中，当它被调度投入运行时，程序和数据没有全部装进内存，仅装入当前使用页面，进程执行过程中访问到不在内存的页面时，产生缺页异常，再由系统自动调入。</p>
</li>
<li><p>全局页面替换策略(页面替换算法的作用范围是整个系统，不考虑进程的属主)：<br>a. 最佳页面替换算法(Optimal Replacement， OPT)。 淘汰不再访问的页或者距现在最长时间后才访问的页。<br>b. 先进先出页面替换算法(First in First Out Replacement， FIFO)。淘汰在内存中驻留时间最长的页。<br>c. 最近最少使用页面替换算法(Least Recently Used Replacement, LRU)。 淘汰最近一段时间内最久未被使用的页面。<br>d. 第二次机会页面替换算法(Second Chance Replacement， SCR)。 首先检查FIFO页面队列中的队首，这是最早进入内存的页面，如果其“引用位”为0，那么它最早进入且未被引用，此页被淘汰。如果其“引用位”为1，说明虽然它最早进内存，但最近仍在使用，于是将“引用位”清零，并把这个页面移到队尾，把它看做新调入的页面，再给它一次机会。<br>e. 时钟页面替换算法(Clock Policy Replacement， Clock)。与SCR算法思路一致。只是用循环队列来构造页面队列，队列指针指向可能被淘汰的页面。如果队列指针指向的页的“引用位”为1，则将其置为0，同时队列指针指向下一个页。</p>
</li>
<li><p>局部页面替换算法(页面替换算法的作用局限于进程自身，要为进程维护称为工作集的一组页面)：<br>a. 局部最佳页面替换算法(Local Minimum Replacement, MIN)。 在t时刻时，若页面P在未来(t, t+delta)时间段内未被引用，则它被淘汰。<br>b. 工作集置换算法。 在t时刻时，若页面P在未来(t-delta, t)时间段内未被引用，则它被淘汰。<br>c. 模拟工作集替换算法。<br>d. 缺页频率替换算法。</p>
</li>
</ul>
<h3 id="17-请求段页式虚拟内存管理"><a href="#17-请求段页式虚拟内存管理" class="headerlink" title="17. 请求段页式虚拟内存管理"></a>17. 请求段页式虚拟内存管理</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182601897.png" alt="OS_SegmentPage"></p>
<ul>
<li>虚地址以程序的逻辑结构划分为段。</li>
<li>实地址划分为位置固定、大小相等的页框(块)。</li>
<li>逻辑地址分为三个部分：段号s、段内页号p、页内位移d。对于用户而言，段式虚拟地址应该由段号s和段内位移d’组成，操作系统内部自动把d’解释成段内页号p和页内位移号d。</li>
</ul>
<h3 id="18-I-O硬件原理：I-O控制方式"><a href="#18-I-O硬件原理：I-O控制方式" class="headerlink" title="18. I/O硬件原理：I/O控制方式"></a>18. I/O硬件原理：I/O控制方式</h3><ul>
<li>轮询方式： 又称程序直接控制方式。使用查询指令测试设备控制器的忙闲状态位，确定内存和设备是否能能交换数据。（注：所谓轮询，就好比，老湿依次问每一个童鞋：“有问题没？”， 如果没问题，就继续问下一个童鞋。如果这个童鞋有问题，这个老湿就停下了解决这个问题。然后又继续询问下一个童鞋。）</li>
<li>中断方式： 要求CPU和设备控制器及设备之间存在中断请求线，设备控制器的状态寄存器有相应的中断允许位。<br>a. 进程发出启动I/O指令。<br>b. 设备控制器检查状态寄存器的内容，执行相应的I/O操作，一旦传输完成，设备控制器通过中断请求线发出I/O中断信号。<br>c. CPU收到并响应I/O中断后，转向设备的I/O中断处理程序执行。<br>d. 中断处理程序执行数据读取操作，将I/O缓冲寄存器的内容写入内存。操作结束后退出中断程序恢复之前的状态。<br>e. 执行中断前之前运行的进程。<br>（注： 类似于老湿在上面讲课，有童鞋问问题时，老湿就记录下自己讲到的位置，然后取回答童鞋的问题，回答完之后，又回到刚刚讲课的地方继续讲课）</li>
<li>DMA(Direct Memory Access, 直接存储器存取)方式： 内存和设备之间有一条数据通路成块的传输数据，无须CPU干9预，实际数据传输操作由DMA直接完成。</li>
<li>通道方式： CPU在执行主程序时遇到I/O请求，启动在指定通道上选址的设备，一旦启动成功，通道开始控制设备进行操作，这时CPU就可以执行其他任务并与通道并行工作，直到I/O操作完成；当通道发出I/O操作结束中断时，处理器才响应并停止当前工作，转而处理I/O操作结束时间。</li>
</ul>
<h3 id="19-I-O软件原理"><a href="#19-I-O软件原理" class="headerlink" title="19. I/O软件原理"></a>19. I/O软件原理</h3><ul>
<li>I/O中断处理程序： 通常是设备驱动程序的组成部分之一。检查设备状态寄存器内容，判断产生中断原因，根据I/O操作的完成情况进行相应处理。若数据传输有错，应向上层软件报告设备出错信息，实施重新执行；若正常结束，应唤醒等待传输的进程，使其转换为就绪态；若有等待传输的I/O命令，应通知相关软件启动下一个I/O请求。</li>
<li>I/O设备驱动程序：设备驱动程序是设备专有的。把用户提交的逻辑I/O请求转化为物理I/O的启动和执行。同时监督设备是否正确执行，管理数据缓冲区，进行必要的纠错处理。</li>
<li>独立于设备的I/O软件</li>
<li>用户空间的I/O软件</li>
</ul>
<h3 id="20-缓冲技术"><a href="#20-缓冲技术" class="headerlink" title="20. 缓冲技术"></a>20. 缓冲技术</h3><ul>
<li><p>缓冲技术的基本思想： 当进程执行写操作输出数据时，先向系统申请一个输出缓冲区，然后将数据送至缓冲区，若是顺序写请求，则不断地把数据填入缓冲区，直至装满为止，此后进程可以继续计算，同时，系统将缓冲区的内容写在设备上。当进程执行读操作输入数据时，先向系统申请一个输入缓冲区，系统将设备上的一条物理记录读至缓冲区，根据要求把当前所需要的逻辑记录从缓冲区中选出并传送给进程。</p>
</li>
<li><p>单缓冲： 是最简单的缓冲技术，每当有I/O请求时，操作系统就在内存的系统区中开设一个缓冲区。不允许多个进程同时对一个缓冲器操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204616794.png" alt="OS_SingleBuffer"></p>
</li>
<li><p>双缓冲： CPU可把输出到设备的数据放入其中一个缓冲器(区)、让设备慢慢处理；然后，它又可以从另一个为终端设置的缓冲器(区)中读取所需要的输入数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204731068.png" alt="OS_TwoBuffer"></p>
</li>
<li><p>多缓冲： 是把多个缓冲区连接起来组成两部分，一部分专门用于输入，另一部分专门用于输出的缓冲结构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204816679.png" alt="OS_MultiBuffer"></p>
</li>
</ul>
<h3 id="21-驱动调度技术"><a href="#21-驱动调度技术" class="headerlink" title="21. 驱动调度技术"></a>21. 驱动调度技术</h3><ul>
<li>磁盘的物理结构：<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161224212641212.png" alt="OS_DISK"><br>磁盘包括多个盘面，每个盘面有一个读写磁头，所有的磁头都固定在唯一的移动臂上同时移动。一个盘面上的读写磁头的轨迹称为磁道，读写磁头下的所有磁道形成柱面，一个磁道又可以划分为多个扇区。在磁盘上定位某个物理记录需要知道其柱面号、磁头号以及扇区号。定位物理记录时，磁头到达指定扇区的时间称为查找时间， 选择磁头号并旋转至指定扇区的时间称为搜索延迟。</li>
<li>磁道(柱面)的搜索定位算法：<br>a. 先来先服务算法(First Come First Server algorithm, FCFS)。<br>b. 最短查找时间优先算法： 总是执行查找时间最短的请求。<br>c. 扫描算法： 移动臂来回的扫过所有柱面，扫描处遇到I/O请求便进行处理。<br>d. 分步扫描算法： 将I/O请求分为长度为N的子队列，按FIFO算法依次处理每个队列，而每个子队列采用扫描算法，处理完一个后再服务下一个队列。<br>e. 电梯调度算法： 又称LOOK算法。<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204846592.jpg" alt="OS_Elevator"><br>磁头号由外向内递增。<br>f. 循环扫描算法： 移动臂总是从0号柱面至最大号柱面顺序扫描，然后直接返回0号柱面重复进行，归途中不提供服务(而扫描算法归途是要提供服务的)。</li>
</ul>
<h3 id="22-设备独立性"><a href="#22-设备独立性" class="headerlink" title="22. 设备独立性"></a>22. 设备独立性</h3><ul>
<li>设备独立性： 用户通常不指定物理设备，而是指定逻辑设备，使得用户作业和物理设备分离开来，再通过其他途径建立逻辑设备和物理设备之间的映射，设备的这种特性称为设备独立性。</li>
</ul>
<h3 id="23-虚拟设备"><a href="#23-虚拟设备" class="headerlink" title="23. 虚拟设备"></a>23. 虚拟设备</h3><ul>
<li><p>外部设备同时联机操作(Simultaneous Peripheral Operations On Line, SPPPLing)：<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204916946.png" alt="OS_SPOOLing"></p>
<p>a. 预输入程序。 控制信息从输入设备至输入井，填写预输入表以便在作业执行过程中要求输入信息时可以随时找到其存放位置。<br>b. 井管理程序。 作业执行过程中要求启动某台设备进程I/O操作时，作业控制程序截获这个要求并调用井管理程序控制从相应输入井读取信息，或将信息送至输出井。<br>c. 缓输出程序。 当处理器空闲时，操作系统调用缓输出程序执行缓输出，它查看缓输出表是否有输出打印的文件，文件打印前还可能组织作业或文件标题，也可能对从输出井中读出的信息进行格式加工。</p>
</li>
</ul>
<h3 id="24-文件逻辑结构"><a href="#24-文件逻辑结构" class="headerlink" title="24. 文件逻辑结构"></a>24. 文件逻辑结构</h3><ul>
<li>文件的逻辑结构的两种形式：<br>a. 流式文件。 一种无结构的文件，文件内的数据不再组成记录，只是一串顺序的信息集合，称为字节流文件。<br>b. 记录式文件。 一种有结构的文件，包含若干逻辑记录，逻辑记录是文件中按信息在逻辑上独立含义所划分的信息单位。</li>
</ul>
<h3 id="25-文件物理结构"><a href="#25-文件物理结构" class="headerlink" title="25. 文件物理结构"></a>25. 文件物理结构</h3><ul>
<li>文件物理结构： 文件的物理结构和组织是指逻辑文件在物理存储空间中的存放方法和组织关系。</li>
<li>常见组织方式：顺序文件、连接文件、直接文件和索引文件。</li>
</ul>
<h2 id="二、Q-amp-A"><a href="#二、Q-amp-A" class="headerlink" title="二、Q&amp;A"></a>二、Q&amp;A</h2><h3 id="1-什么是操作系统？操作系统在计算机系统中的主要作用是什么？"><a href="#1-什么是操作系统？操作系统在计算机系统中的主要作用是什么？" class="headerlink" title="1. 什么是操作系统？操作系统在计算机系统中的主要作用是什么？"></a>1. 什么是操作系统？操作系统在计算机系统中的主要作用是什么？</h3><ul>
<li>定义： 操作系统尚无严格的定义。 一般可把操作系统定义为： 管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便有效地使用计算机提供良好的运行环境的一种软件系统。</li>
<li>作用：<br>a. 服务用户。 操作系统作为用户接口和公共服务程序。<br>b. 进程交互。 操作系统作为进程执行的控制者和协调者。<br>c. 系统实现。 操作系统作为扩展机或虚拟机。<br>d. 资源管理。 操作系统作为资源的管理者和控制者。</li>
</ul>
<h3 id="2-什么是多道程序设计？多道程序设计有什么特点？"><a href="#2-什么是多道程序设计？多道程序设计有什么特点？" class="headerlink" title="2. 什么是多道程序设计？多道程序设计有什么特点？"></a>2. 什么是多道程序设计？多道程序设计有什么特点？</h3><ul>
<li>多道程序设计(multiprogramming)： 允许多个作业(程序)同时进入计算机系统的内存并启动交替计算的方法。</li>
<li>多道程序设计的特点： 从宏观上看是并行的，从微观上看是串行的。</li>
</ul>
<h3 id="3-计算机操作系统为什么引入进程？"><a href="#3-计算机操作系统为什么引入进程？" class="headerlink" title="3. 计算机操作系统为什么引入进程？"></a>3. 计算机操作系统为什么引入进程？</h3><ul>
<li>刻画程序的并发性。</li>
<li>解决资源的共享性。</li>
</ul>
<h3 id="4-在分时系统中，什么是响应时间？它与哪些因素有关？"><a href="#4-在分时系统中，什么是响应时间？它与哪些因素有关？" class="headerlink" title="4. 在分时系统中，什么是响应时间？它与哪些因素有关？"></a>4. 在分时系统中，什么是响应时间？它与哪些因素有关？</h3><ul>
<li>从交互式进程提交一个请求(命令)直到获得响应之间的时间间隔称为响应时间。</li>
<li>影响分时操作系统的响应时间的因素很多，如，CPU的处理速度、联机终端的数目、所用时间片的大小、系统调度开销和对换信息量的多少等。</li>
</ul>
<h3 id="5-解释并发性与并行性"><a href="#5-解释并发性与并行性" class="headerlink" title="5. 解释并发性与并行性"></a>5. 解释并发性与并行性</h3><ul>
<li>计算机操作系统中把并行性和并发性明显区分开，主要是从微观的角度来说的，具体是指进程的并行性（多处理机的情况下，多个进程同时运行）和并发性（单处理机的情况下，多个进程在同一时间间隔运行的）。</li>
<li>并行性是指硬件的并行性，两个或多个事件在同一时刻发生。</li>
<li>并发性是指进程的并发性，两个或多个事件在同一时间段内发生。</li>
</ul>
<h3 id="6-试述存储管理的基本功能。"><a href="#6-试述存储管理的基本功能。" class="headerlink" title="6. 试述存储管理的基本功能。"></a>6. 试述存储管理的基本功能。</h3><ul>
<li>存储分配。</li>
<li>地址映射。</li>
<li>存储保护。</li>
<li>存储共享。</li>
<li>存储扩充。</li>
</ul>
<h3 id="7-何谓地址转换-重定向-？哪些方法可以实现地址转换？"><a href="#7-何谓地址转换-重定向-？哪些方法可以实现地址转换？" class="headerlink" title="7. 何谓地址转换(重定向)？哪些方法可以实现地址转换？"></a>7. 何谓地址转换(重定向)？哪些方法可以实现地址转换？</h3><ul>
<li><p>地址重定位： 又称地址转换，地址映射。 可执行程序逻辑地址转换(绑定)为物理地址的过程。</p>
</li>
<li><p>实现方法：<br>a. 静态地址重定位。 由装载程序实现装载代码模块的加载和地址转换，把它装入分配给进程的内存指定区域，其中的所有逻辑地址修改成内存物理地址。<br>b. 动态地址重定位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182644798.png" alt="OS_Dynamic"></p>
<p>由装载程序实现装载代码模块的加载和地址转换，把它装入分配给进程的内存指定区域，但对链接程序处理过的应用程序的逻辑地址则不做任何修改，程序内存起始地址被置于硬件专用寄存器 —— 重定位寄存器。程序执行过程中，每当CPU引用内存地址(访问程序和数据)时，由硬件截取此逻辑地址，并在它被发送到内存之前加上重定位寄存器的值，以便实现地址转换。<br>c. 运行时链接地址重定位</p>
<blockquote>
<p>程序链接的三种方式：<br>a. 静态链接。在程序装载到内存和运行前，就已将它的所有目标模块及所需要的库函数进行链接和装配成一个完整的可执行程序且此后不可拆分。<br>b. 动态链接。在程序装入内存前<em>并未</em>事先进行程序各目标模块的链接，而是在程序装载时一边装载一边链接，生成一个可执行文件。<br>c. 运行时链接。 将某些目标模块或库函数的链接 推迟到执行时才进行。</p>
</blockquote>
</li>
</ul>
<h3 id="8-什么是文件的共享？介绍文件共享的分类和实现思想。"><a href="#8-什么是文件的共享？介绍文件共享的分类和实现思想。" class="headerlink" title="8. 什么是文件的共享？介绍文件共享的分类和实现思想。"></a>8. 什么是文件的共享？介绍文件共享的分类和实现思想。</h3><ul>
<li><ul>
<li>文件共享： 不同进程共同使用同一个文件。</li>
<li>文件共享的分类：<br>a. 静态共享。 两个或多个进程通过文件链接(一个文件同时属于多个目录，但实际上仅有一处物理存储)达到共享同一个文件的目的，无论进程是否运行，其文件的链接关系都是存在的，因此称为静态共享。<br>b. 动态共享。 系统不同的应用程序或同一用户的不同进程并发地访问同一文件，这种共享关系只有当进程存在时才可能出现，一旦进程消亡，其共享关系也就随之消失。<br>c. 符号链接共享。</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%AD%A6%E4%B9%A0/">
                                    <span class="chip bg-color">学习</span>
                                </a>
                            
                                <a href="/tags/%E6%8A%80%E6%9C%AF/">
                                    <span class="chip bg-color">技术</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="路由器与交换机的工作原理">
                        
                        <span class="card-title">路由器与交换机的工作原理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-11-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Wlcc___
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">学习</span>
                    </a>
                    
                    <a href="/tags/%E6%8A%80%E6%9C%AF/">
                        <span class="chip bg-color">技术</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/11/15/%E5%9F%BA%E7%A1%80/25.%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="二十五.模块和包">
                        
                        <span class="card-title">二十五.模块和包</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-11-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Wlcc___
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">学习</span>
                    </a>
                    
                    <a href="/tags/%E6%8A%80%E6%9C%AF/">
                        <span class="chip bg-color">技术</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            wl
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/1420566605wl" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1420566605@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>




    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1420566605" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1420566605" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
