<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="消息队列rabbitmq, 多走几步">
    <meta name="description" content="多走几步">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>消息队列rabbitmq | 多走几步</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="多走几步" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">多走几步</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">多走几步</div>
        <div class="logo-desc">
            
            多走几步
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/%E5%AD%A6%E4%B9%A0/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">消息队列rabbitmq</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%AD%A6%E4%B9%A0/">
                                <span class="chip bg-color">学习</span>
                            </a>
                        
                            <a href="/tags/%E6%8A%80%E6%9C%AF/">
                                <span class="chip bg-color">技术</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-11-15
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8.1k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="消息队列rabbitmq"><a href="#消息队列rabbitmq" class="headerlink" title="消息队列rabbitmq"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pyyu/p/10318053.html">消息队列rabbitmq</a></h1><h1 id="为什么用消息队列"><a href="#为什么用消息队列" class="headerlink" title="为什么用消息队列"></a>为什么用消息队列</h1><p>举例</p>
<pre><code>比如在一个企业里，技术老大接到boss的任务，技术老大把这个任务拆分成多个小任务，完成所有的小任务就算搞定整个任务了。
那么在执行这些小任务的时候，可能有一个环节很费时间，并且优先级很低，推迟完成也不影响整个任务运转，那么技术老大就会将这个很费时间，且不重要的任务，丢给他的小弟去解决，自己继续完成其他任务。</code></pre>
<p>转化为计算机思想</p>
<pre><code>那个技术老大就是一个 程序系统，那个小弟就是消息队列。
当程序系统发现某些任务耗费时间且优先级较低，迟点完成也不影响整个任务，就把这个任务丢给消息队列。</code></pre>
<p>场景</p>
<pre><code>在程序系统中，例如外卖系统，订单系统，库存系统，优先级较高
发红包，发邮件，发短信，app消息推送等任务优先级很低，很适合交给消息队列去处理，以便于程序系统更快的处理其他请求。</code></pre>
<p>消息队列工作流程</p>
<pre><code>消息队列一般有三个角色：
队列服务端
队列生产者
队列消费者
消息队列工作流程就如同一个流水线，有产品加工，一个输送带，一个打包产品
输送带就是 不停运转的消息队列服务端
加工产品的就是 队列生产者
在传输带结尾打包产品的 就是队列消费者</code></pre>
<p>队列产品</p>
<pre><code>RabbitMQ
Erlang编写的消息队列产品，企业级消息队列软件，支持消息负载均衡，数据持久化等。

ZeroMQ 
saltstack软件使用此消息，速度最快。

Redis
key-value的系统，也支持队列数据结构，轻量级消息队列

Kafka
由Scala编写，目标是为处理实时数据提供一个统一、高通量、低等待的平台</code></pre>
<p>一个app系统消息队列工作流程</p>
<pre><code>消费者，一个后台进程，不断的去检测消息队列中是否有消息，有消息就取走，开启新线程去处理业务，如果没有一会再来</code></pre>
<h2 id="消息队列作用"><a href="#消息队列作用" class="headerlink" title="消息队列作用"></a>消息队列作用</h2><p>1）程序解耦</p>
<p>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p>
<p>2）冗余：</p>
<p>消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。</p>
<p>许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p>
<p>3）峰值处理能力：</p>
<p>(大白话，就是本来公司业务只需要5台机器，但是临时的秒杀活动，5台机器肯定受不了这个压力，我们又不可能将整体服务器架构提升到10台，那在秒杀活动后，机器不就浪费了吗？因此引入消息队列)</p>
<p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。</p>
<p>如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。</p>
<p>使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
<p>4）可恢复性：</p>
<p>系统的一部分组件失效时，不会影响到整个系统。</p>
<p>消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
<p>5）顺序保证：</p>
<p>在大多使用场景下，数据处理的顺序都很重要。</p>
<p>大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka保证一个Partition内的消息的有序性）</p>
<p>6）缓冲：</p>
<p>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p>
<p>7）异步通信：</p>
<p>很多时候，用户不想也不需要立即处理消息。比如发红包，发短信等流程。</p>
<p>消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="rabbitMQ"><a href="#rabbitMQ" class="headerlink" title="rabbitMQ"></a>rabbitMQ</h1><h1 id="1-你了解的消息队列"><a href="#1-你了解的消息队列" class="headerlink" title="1. 你了解的消息队列"></a>1. 你了解的消息队列</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>生活里的消息队列，如同邮局的邮箱，
如果没邮箱的话，
邮件必须找到邮件那个人，递给他，才玩完成，那这个任务会处理的很麻烦，很慢，效率很低

但是如果有了邮箱，
邮件直接丢给邮箱，用户只需要去邮箱里面去找，有没有邮件，有就拿走，没有就下次再来，这样可以极大的提升邮件收发效率！</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code>rabbitmq是一个消息代理，它接收和转发消息，可以理解为是生活的邮局。你可以将邮件放在邮箱里，你可以确定有邮递员会发送邮件给收件人。概括：rabbitmq是接收，存储，转发数据的。官方教程：http://www.rabbitmq.com/tutorials/tutorial-one-python.html</code></pre>
<p>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</p>
<p>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p>
<h1 id="2-公司在什么情况下会用消息队列"><a href="#2-公司在什么情况下会用消息队列" class="headerlink" title="2. 公司在什么情况下会用消息队列?"></a>2. 公司在什么情况下会用消息队列?</h1><h3 id="1-电商订单"><a href="#1-电商订单" class="headerlink" title="1.电商订单"></a>1.电商订单</h3><p>想必同学们都点过外卖，点击下单后的业务逻辑可能包括：检查库存、生成单据、发红包、短信通知等，如果这些业务同步执行，完成下单率会非常低，如发红包，短信通知等不必要的流程，异步执行即可。</p>
<p>此时使用MQ，可以在核心流程（扣减库存、生成订单记录）等完成后发送消息到MQ，快速结束本次流程。消费者拉取MQ消息时，发现红包、短信等消息时，再进行处理。</p>
<p>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093411988-542157523.png" alt="img"></p>
<p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p3.png?lastModify=1548379963" alt="img"></p>
<p>这种做法有一个缺点:</p>
<ul>
<li>当库存系统出现故障时,订单就会失败。(这样马云将少赚好多好多钱钱。。。。)</li>
<li>订单系统和库存系统高耦合.</li>
</ul>
<pre><code>引入消息队列</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093422429-531587085.png" alt="img"></p>
<p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p4.png?lastModify=1548379963" alt="img"></p>
<ul>
<li>订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</li>
<li>库存系统:订阅下单的消息,获取下单消息,进行库操作。 就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失(马云这下高兴了，钞票快快的来呀~~).</li>
</ul>
<h3 id="2-秒杀活动"><a href="#2-秒杀活动" class="headerlink" title="2.秒杀活动"></a>2.秒杀活动</h3><p>流量削峰一般在秒杀活动中应用广泛 场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。 作用: 1.可以控制活动人数，超过此一定阀值的订单直接丢弃(怪不得我一次秒杀都没抢到过。。。。。wtf？？？)</p>
<p>2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单)</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093446896-525958645.png" alt="img"></p>
<p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p5.png?lastModify=1548379963" alt="img"></p>
<p>3.用户的请求，服务器接收到之后，写入消息队列，超过定义的阈值就直接丢弃请求，或者跳转错误页面。</p>
<p>4.业务系统取出队列中的消息，再做后续处理。</p>
<h1 id="3-rabbitMQ安装"><a href="#3-rabbitMQ安装" class="headerlink" title="3. rabbitMQ安装"></a>3. rabbitMQ安装</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>rabbitmq-server服务端

1.下载centos源
wget -O /etc/yum.repos.d/CentOS-Base.repo   http://mirrors.cloud.tencent.com/repo/centos7_base.repo
2.下载epel源
wget -O /etc/yum.repos.d/epel.repo http://mirrors.cloud.tencent.com/repo/epel-7.repo
3.清空yum缓存并且生成新的yum缓存
yum clean all
yum makecache
4.安装erlang
   $ yum -y install erlang
5.安装RabbitMQ
   $ yum -y install rabbitmq-server
6.启动(无用户名密码):
    systemctl start/stop/restart/status rabbitmq-server

设置rabbitmq账号密码，以及角色权限设置

# 设置新用户yugo 密码123
sudo rabbitmqctl add_user yugo 123

# 设置用户为administrator角色
sudo rabbitmqctl set_user_tags yugo administrator

# 设置权限，允许对所有的队列都有权限对何种资源具有配置、写、读的权限通过正则表达式来匹配，具体命令如下：set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;
sudo rabbitmqctl set_permissions -p "/" yugo ".*" ".*" ".*"

#重启服务生效设置
service rabbitmq-server start/stop/restart
rabbitmq相关命令

// 新建用户
rabbitmqctl add_user {用户名} {密码}

// 设置权限
rabbitmqctl set_user_tags {用户名} {权限}

// 查看用户列表
rabbitmqctl list_users

// 为用户授权
添加 Virtual Hosts ：    
rabbitmqctl add_vhost &lt;vhost&gt;    

// 删除用户
rabbitmqctl delete_user Username

// 修改用户的密码
rabbitmqctl change_password Username Newpassword

// 删除 Virtual Hosts ：    
rabbitmqctl delete_vhost &lt;vhost&gt;    

// 添加 Users ：    
rabbitmqctl add_user &lt;username&gt; &lt;password&gt;    
rabbitmqctl set_user_tags &lt;username&gt; &lt;tag&gt; ...    
rabbitmqctl set_permissions [-p &lt;vhost&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;    

// 删除 Users ：    
delete_user &lt;username&gt;   

// 使用户user1具有vhost1这个virtual host中所有资源的配置、写、读权限以便管理其中的资源
rabbitmqctl  set_permissions -p vhost1 user1 '.*' '.*' '.*' 

// 查看权限
rabbitmqctl list_user_permissions user1

rabbitmqctl list_permissions -p vhost1

// 清除权限
rabbitmqctl clear_permissions [-p VHostPath] User

//清空队列步骤
rabbitmqctl reset 
需要提前关闭应用rabbitmqctl stop_app ，
然后再清空队列，启动应用
rabbitmqctl start_app
此时查看队列rabbitmqctl list_queues

查看所有的exchange：                              rabbitmqctl list_exchanges
查看所有的queue：                                 rabbitmqctl list_queues
查看所有的用户：                                   rabbitmqctl list_users
查看所有的绑定（exchange和queue的绑定信息）：         rabbitmqctl list_bindings
查看消息确认信息：
rabbitmqctl list_queues name messages_ready messages_unacknowledged
查看RabbitMQ状态，包括版本号等信息：rabbitmqctl status#开启web界面rabbitmqrabbitmq-plugins enable rabbitmq_management#访问web界面http://server-name:15672/</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h1 id="RabbitMQ组件解释"><a href="#RabbitMQ组件解释" class="headerlink" title="RabbitMQ组件解释"></a>RabbitMQ组件解释</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>AMQP

AMQP协议是一个高级抽象层消息通信协议，RabbitMQ是AMQP协议的实现。它主要包括以下组件：</code></pre>
<p>1.Server(broker): 接受客户端连接，实现AMQP消息队列和路由功能的进程。</p>
<pre><code></code></pre>
<p>2.Virtual Host:其实是一个虚拟概念，类似于权限控制组，一个Virtual Host里面可以有若干个Exchange和Queue，但是权限控制的最小粒度是Virtual Host</p>
<pre><code></code></pre>
<p>3.Exchange:接受生产者发送的消息，并根据Binding规则将消息路由给服务器中的队列。ExchangeType决定了Exchange路由消息的行为，例如，在RabbitMQ中，ExchangeType有direct、Fanout和Topic三种，不同类型的Exchange路由的行为是不一样的。</p>
<pre><code></code></pre>
<p>4.Message Queue：消息队列，用于存储还未被消费者消费的消息。</p>
<pre><code></code></pre>
<p>5.Message: 由Header和Body组成，Header是由生产者添加的各种属性的集合，包括Message是否被持久化、由哪个Message Queue接受、优先级是多少等。而Body是真正需要传输的APP数据。</p>
<pre><code></code></pre>
<p>6.Binding:Binding联系了Exchange与Message Queue。Exchange在与多个Message Queue发生Binding后会生成一张路由表，路由表中存储着Message Queue所需消息的限制条件即Binding Key。当Exchange收到Message时会解析其Header得到Routing Key，Exchange根据Routing Key与Exchange Type将Message路由到Message Queue。Binding Key由Consumer在Binding Exchange与Message Queue时指定，而Routing Key由Producer发送Message时指定，两者的匹配方式由Exchange Type决定。 </p>
<pre><code></code></pre>
<p>7.Connection:连接，对于RabbitMQ而言，其实就是一个位于客户端和Broker之间的TCP连接。</p>
<pre><code></code></pre>
<p>8.Channel:信道，仅仅创建了客户端到Broker之间的连接后，客户端还是不能发送消息的。需要为每一个Connection创建Channel，AMQP协议规定只有通过Channel才能执行AMQP的命令。一个Connection可以包含多个Channel。之所以需要Channel，是因为TCP连接的建立和释放都是十分昂贵的，如果一个客户端每一个线程都需要与Broker交互，如果每一个线程都建立一个TCP连接，暂且不考虑TCP连接是否浪费，就算操作系统也无法承受每秒建立如此多的TCP连接。RabbitMQ建议客户端线程之间不要共用Channel，至少要保证共用Channel的线程发送消息必须是串行的，但是建议尽量共用Connection。</p>
<pre><code></code></pre>
<p>9.Command:AMQP的命令，客户端通过Command完成与AMQP服务器的交互来实现自身的逻辑。例如在RabbitMQ中，客户端可以通过publish命令发送消息，txSelect开启一个事务，txCommit提交一个事务。</p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h1 id="python客户端"><a href="#python客户端" class="headerlink" title="python客户端"></a>python客户端</h1><pre><code>// rabbitmq官方推荐的python客户端pika模块
pip3 install pika</code></pre>
<h2 id="应用场景1：单发送单接收"><a href="#应用场景1：单发送单接收" class="headerlink" title="应用场景1：单发送单接收"></a>应用场景1：单发送单接收</h2><h2 id="生产-消费者模型"><a href="#生产-消费者模型" class="headerlink" title="生产-消费者模型"></a>生产-消费者模型</h2><pre><code>P   是生产者C   是消费者中间hello是消息队列可以有多个P、多个CP发送消息给hello队列，C消费者从队列中获取消息，默认轮询方式</code></pre>
<p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190318104310784-1782839265.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093518791-776768428.png" alt="img"></p>
<p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p1.png?lastModify=1548379963" alt="img"></p>
<p><strong>生产者send.py</strong></p>
<pre><code>我们的第一个程序send.py将向队列发送一条消息。我们需要做的第一件事是建立与RabbitMQ服务器的连接。</code></pre>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>#!/usr/bin/env python
import pika
# 创建凭证，使用rabbitmq用户密码登录
# 去邮局取邮件，必须得验证身份
credentials = pika.PlainCredentials("s14","123")
# 新建连接，这里localhost可以更换为服务器ip
# 找到这个邮局，等于连接上服务器
connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))
# 创建频道
# 建造一个大邮箱，隶属于这家邮局的邮箱，就是个连接
channel = connection.channel()
# 声明一个队列，用于接收消息，队列名字叫“水许传”
channel.queue_declare(queue='水许传')
# 注意在rabbitmq中，消息想要发送给队列，必须经过交换(exchange)，初学可以使用空字符串交换(exchange='')，它允许我们精确的指定发送给哪个队列(routing_key=''),参数body值发送的数据
channel.basic_publish(exchange='',
                      routing_key='水许传',
                      body='武松又去打老虎啦2')
print("已经发送了消息")
# 程序退出前，确保刷新网络缓冲以及消息发送给rabbitmq，需要关闭本次连接
connection.close()</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code></code></pre>
<p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p2.png?lastModify=1548379963" alt="img"></p>
<p><strong>可以同时存在多个接受者，等待接收队列的消息，默认是轮训方式分配消息</strong></p>
<p><strong>接受者receive.py，可以运行多次，运行多个消费者</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>import pika
# 建立与rabbitmq的连接
credentials = pika.PlainCredentials("s14","123")
connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))
channel = connection.channel()
channel.queue_declare(queue="水许传")

def callbak(ch,method,properties,body):
    print("消费者接收到了任务：%r"%body.decode("utf8"))
# 有消息来临，立即执行callbak，没有消息则夯住，等待消息
# 老百姓开始去邮箱取邮件啦，队列名字是水许传
channel.basic_consume(callbak,queue="水许传",no_ack=True)
# 开始消费，接收消息
channel.start_consuming()</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>练习：</p>
<p>分别启动生产者、两个消费者，往队列发送数据，查看消费者的结果</p>
<h1 id="应用场景2：单发送多接收"><a href="#应用场景2：单发送多接收" class="headerlink" title="应用场景2：单发送多接收"></a>应用场景2：单发送多接收</h1><p>使用场景：一个发送端，多个接收端，如分布式的任务派发。为了保证消息发送的可靠性，不丢失消息，使消息持久化了。同时为了防止接收端在处理消息时down掉，只有在消息处理完成后才发送ack消息。</p>
<h1 id="rabbitmq消息确认之ack"><a href="#rabbitmq消息确认之ack" class="headerlink" title="rabbitmq消息确认之ack"></a>rabbitmq消息确认之ack</h1><p>官网资料：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/tutorials/tutorial-two-python.html">http://www.rabbitmq.com/tutorials/tutorial-two-python.html</a></p>
<pre><code>默认情况下，生产者发送数据给队列，消费者取出消息后，数据将被清除。
特殊情况，如果消费者处理过程中，出现错误，数据处理没有完成，那么这段数据将从队列丢失</code></pre>
<h2 id="no-ack机制"><a href="#no-ack机制" class="headerlink" title="no-ack机制"></a>no-ack机制</h2><p><code>不确认机制</code>也就是说每次消费者接收到数据后，不管是否处理完毕，rabbitmq-server都会把这个消息标记完成，从队列中删除</p>
<h2 id="ACK机制"><a href="#ACK机制" class="headerlink" title="ACK机制"></a>ACK机制</h2><p>ACK机制用于保证消费者如果拿了队列的消息，<code>客户端</code>处理时出错了，那么队列中仍然还存在这个消息，提供下一位消费者继续取</p>
<p>流程</p>
<pre><code>1.生产者无须变动，发送消息
2.消费者如果no_ack=True啊，数据消费后如果出错就会丢失
反之no_ack=False，数据消费如果出错，数据也不会丢失

3.ack机制在消费者代码中演示</code></pre>
<p>生产者.py <code>只负责发送数据即可，无须变动</code></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>#!/usr/bin/env python
import pika
# 创建凭证，使用rabbitmq用户密码登录
# 去邮局取邮件，必须得验证身份
credentials = pika.PlainCredentials("s14","123")
# 新建连接，这里localhost可以更换为服务器ip
# 找到这个邮局，等于连接上服务器
connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))
# 创建频道
# 建造一个大邮箱，隶属于这家邮局的邮箱，就是个连接
channel = connection.channel()
# 新建一个hello队列，用于接收消息
# 这个邮箱可以收发各个班级的邮件，通过
channel.queue_declare(queue='金品没')
# 注意在rabbitmq中，消息想要发送给队列，必须经过交换(exchange)，初学可以使用空字符串交换(exchange='')，它允许我们精确的指定发送给哪个队列(routing_key=''),参数body值发送的数据
channel.basic_publish(exchange='',
                      routing_key='金品没',
                      body='潘金莲又出去。。。')
print("已经发送了消息")
# 程序退出前，确保刷新网络缓冲以及消息发送给rabbitmq，需要关闭本次连接
connection.close()</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>消费者.py<code>给与ack回复</code></p>
<p>拿到消息必须给rabbitmq服务端回复ack信息，否则消息不会被删除，防止客户端出错，数据丢失</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>import pika

credentials = pika.PlainCredentials("s14","123")
connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))
channel = connection.channel()

# 声明一个队列(创建一个队列)
channel.queue_declare(queue='金品没')

def callback(ch, method, properties, body):
    print("消费者接受到了任务: %r" % body.decode("utf-8"))
    # int('asdfasdf')
    # 我告诉rabbitmq服务端，我已经取走了消息
    # 回复方式在这
    ch.basic_ack(delivery_tag=method.delivery_tag)
# 关闭no_ack，代表给与服务端ack回复，确认给与回复
channel.basic_consume(callback,queue='金品没',no_ack=False)

channel.start_consuming()</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>演示1.执行生产者，向队列写入数据，产生一个新队列queue
2.重启服务端，队列丢失3.开启生产者数据持久化后，重启rabbitmq，队列不丢失4.依旧可以读取数据</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>消息的可靠性是RabbitMQ的一大特色，那么RabbitMQ是如何保证消息可靠性的呢——消息持久化。 为了保证RabbitMQ在退出或者crash等异常情况下数据没有丢失，需要将queue，exchange和Message都持久化。</p>
<p>生产者.py</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>import pika
# 无密码
# connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61'))
# 有密码
credentials = pika.PlainCredentials("s14","123")
connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))
channel = connection.channel()
# 声明一个队列(创建一个队列)
# 默认此队列不支持持久化，如果服务挂掉，数据丢失
# durable=True 开启持久化，必须新开启一个队列，原本的队列已经不支持持久化了
'''
实现rabbitmq持久化条件
 delivery_mode=2
使用durable=True声明queue是持久化

'''
channel.queue_declare(queue='LOL',durable=True)
channel.basic_publish(exchange='',
                      routing_key='LOL', # 消息队列名称
                      body='德玛西亚万岁',
                      # 支持数据持久化
                      properties=pika.BasicProperties(
                          delivery_mode=2,#代表消息是持久的  2
                      )
                      )
connection.close()</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code></code></pre>
<p>消费者.py</p>
<pre><code></code></pre>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>import pika
credentials = pika.PlainCredentials("s14","123")
connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))
channel = connection.channel()
# 确保队列持久化
channel.queue_declare(queue='LOL',durable=True)

'''
必须确保给与服务端消息回复，代表我已经消费了数据，否则数据一直持久化，不会消失
'''
def callback(ch, method, properties, body):
    print("消费者接受到了任务: %r" % body.decode("utf-8"))
    # 模拟代码报错
    # int('asdfasdf')    # 此处报错，没有给予回复，保证客户端挂掉，数据不丢失

    # 告诉服务端，我已经取走了数据，否则数据一直存在
    ch.basic_ack(delivery_tag=method.delivery_tag)
# 关闭no_ack，代表给与回复确认
channel.basic_consume(callback,queue='LOL',no_ack=False)
channel.start_consuming()</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h1 id="Exchange模型"><a href="#Exchange模型" class="headerlink" title="Exchange模型"></a>Exchange模型</h1><p>rabbitmq发送消息首先是发给exchange，然后再通过exchange发送消息给队列（queue）</p>
<p>exchange有四种模式</p>
<p><strong>fanout</strong></p>
<p>exchange将消息发送给和该exchange连接的所有queue；也就是所谓的广播模式；此模式下忽略routing_key；</p>
<p><strong>direct</strong></p>
<p>路由模式，通过routing_key将消息发送给对应的queue; 如下面这句即可设置exchange为direct模式，只有routing_key为“black”时才将其发送到队列queue_name；<code>channel.queue_bind(exchange=exchange_name,queue=queue_name,routing_key='black')</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093542406-227376628.png" alt="img"></p>
<p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p8.png?lastModify=1548379963" alt="img"></p>
<p>在上图中，Q1和Q2可以绑定同一个key，如绑定routing_key=‘KeySame’，那么收到routing_key为KeySame的消息时将会同时发送给Q1和Q2，退化为广播模式；</p>
<p><strong>top</strong></p>
<p>topic模式类似于direct模式，只是其中的routing_key变成了一个有“.”分隔的字符串，“.”将字符串分割成几个单词，每个单词代表一个条件；</p>
<p><strong>headers</strong></p>
<p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。</p>
<p>官方教程：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/tutorials/tutorial-three-python.html">http://www.rabbitmq.com/tutorials/tutorial-three-python.html</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093553696-841323657.png" alt="img"></p>
<p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p61.png?lastModify=1548379963" alt="img"></p>
<p>发布订阅和简单的消息队列区别在于，发布订阅会将消息发送给所有的订阅者，而消息队列中的数据被消费一次便消失。所以，RabbitMQ实现发布和订阅时，会为每一个订阅者创建一个队列，而发布者发布消息时，会将消息放置在所有相关队列中。</p>
<pre><code># fanout所有的队列放一份/给某些队列发# 传送消息的模式# 与exchange有关的模式都发exchange_type = fanout
消费者_订阅.py</code></pre>
<p>可以运行多次，运行多个消费者，等待消息</p>
<pre><code>import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# exchange='m1',exchange(秘书)的名称# exchange_type='fanout' , 秘书工作方式将消息发送给所有的队列channel.exchange_declare(exchange='m1',exchange_type='fanout')# 随机生成一个队列result = channel.queue_declare(exclusive=True)queue_name = result.method.queue# 让exchange和queque进行绑定.channel.queue_bind(exchange='m1',queue=queue_name)def callback(ch, method, properties, body):    print("消费者接受到了任务: %r" % body)channel.basic_consume(callback,queue=queue_name,no_ack=True)channel.start_consuming()
生产者_发布者.py
# -*- coding: utf-8 -*-# __author__ = "yugo"import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# 指定exchangechannel.exchange_declare(exchange='m1',exchange_type='fanout')channel.basic_publish(exchange='m1',                      routing_key='',# 这里不再指定队列，由exchange分配,如果是fanout模式，每一个队列放一份                      body='haohaio')connection.close()</code></pre>
<p>实例</p>
<pre><code>1.可以运行多个消费者，相当于有多个滴滴司机，等待着Exchange同一个电台发消息
2.运行发布者，发送消息给Exchange，查看是否给所有的队列(滴滴司机)发送了消息</code></pre>
<h1 id="关键字发布Exchange"><a href="#关键字发布Exchange" class="headerlink" title="关键字发布Exchange"></a>关键字发布Exchange</h1><p>之前事例，发送消息时明确指定某个队列并向其中发送消息，RabbitMQ还支持根据关键字发送，即：队列绑定关键字，发送者将数据根据关键字发送到消息exchange，exchange根据 关键字 判定应该将数据发送至指定队列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093607392-697752958.png" alt="img"></p>
<p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p7.png?lastModify=1548379963" alt="img"></p>
<p><strong>消费者1.py</strong></p>
<p>路由关键字是sb,alex</p>
<pre><code># -*- coding: utf-8 -*-# __author__ = "maple"import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# exchange='m1',exchange(秘书)的名称# exchange_type='fanout' , 秘书工作方式将消息发送给所有的队列channel.exchange_declare(exchange='m2',exchange_type='direct')# 随机生成一个队列,队列退出时，删除这个队列result = channel.queue_declare(exclusive=True)queue_name = result.method.queue# 让exchange和queque进行绑定，只要channel.queue_bind(exchange='m2',queue=queue_name,routing_key='alex')channel.queue_bind(exchange='m2',queue=queue_name,routing_key='sb')def callback(ch, method, properties, body):    print("消费者接受到了任务: %r" % body)channel.basic_consume(callback,queue=queue_name,no_ack=True)channel.start_consuming()</code></pre>
<p>消费者2.py</p>
<p>路由关键字sb</p>
<pre><code># -*- coding: utf-8 -*-# __author__ = "maple"import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# exchange='m1',exchange(秘书)的名称# exchange_type='fanout' , 秘书工作方式将消息发送给所有的队列channel.exchange_declare(exchange='m2',exchange_type='direct')# 随机生成一个队列result = channel.queue_declare(exclusive=True)queue_name = result.method.queue# 让exchange和queque进行绑定.channel.queue_bind(exchange='m2',queue=queue_name,routing_key='sb')def callback(ch, method, properties, body):    print("消费者接受到了任务: %r" % body)channel.basic_consume(callback,queue=queue_name,no_ack=True)channel.start_consuming()</code></pre>
<p>生产者.py</p>
<p>发送消息给匹配的路由，sb或者alex</p>
<pre><code># -*- coding: utf-8 -*-# __author__ = "yugo"import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# 路由模式的交换机会发送给绑定的key和routing_key匹配的队列channel.exchange_declare(exchange='m2',exchange_type='direct')# 发送消息，给有关sb的路由关键字channel.basic_publish(exchange='m2',                      routing_key='sb',                      body='aaaalexlaolelaodi')connection.close()</code></pre>
<h1 id="RPC之远程过程调用"><a href="#RPC之远程过程调用" class="headerlink" title="RPC之远程过程调用"></a>RPC之远程过程调用</h1><p><strong>将一个函数运行在远程计算机上并且等待获取那里的结果，这个称作远程过程调用（Remote Procedure Call）或者 RPC。</strong></p>
<p>RPC<strong>是一个计算机通信协议。</strong></p>
<p><strong>比喻</strong></p>
<pre><code>将计算机服务运行理解为厨师做饭，厨师想做一个小葱拌豆腐，厨师需要洗小葱、切豆腐、调汁、凉拌。他一个人完成所有的事，如同古老的集中式应用，一台计算机做所有的事。制作小葱拌豆腐{    厨师&gt;洗小葱&gt;切豆腐&gt;凉拌}</code></pre>
<p><code>rpc</code>应用场景</p>
<pre><code>而如今，饭店做大了，有钱了，专职分工来干活，不再是厨师单打独斗，备菜师傅准备小葱、豆腐，切菜师傅切小葱、豆腐，厨师只负责调味，完成食品。制作小葱拌豆腐{    备菜师&gt;洗菜    切菜师&gt;切菜    厨师&gt;调味}</code></pre>
<p>此时一件事好多人在做，厨师就得和其他人沟通，通知备菜、洗菜师傅的这个动作就是远程过程调用（RPC）。</p>
<p>这个过程在计算机系统中，一个电商的下单过程，涉及物流、支付、库存、红包等多个系统，多个系统又在多个服务器上，由不同的技术团队负责，整个下单过程，需要所有团队进行远程调用。</p>
<pre><code>下单{    库存&gt;减少库存    支付&gt;扣款    红包&gt;减免红包    物流&gt;生成订单}</code></pre>
<h3 id="到底什么是rpc"><a href="#到底什么是rpc" class="headerlink" title="到底什么是rpc"></a>到底什么是rpc</h3><pre><code>rpc指的是在计算机A上的进程，调用另外一台计算机B的进程，A上的进程被挂起，B上的被调用进程开始执行后，产生返回值给A，A继续执行。调用方可以通过参数将信息传递给被调用方，而后通过返回结果得到信息，这个过程对于开发人员来说是透明的。如同厨师一样，服务员把菜单给后厨，厨师告诉洗菜人，备菜人，开始工作，完成工作后，整个过程对于服务员是透明的，他完全不用管后厨是怎么把菜做好的。</code></pre>
<p>由于服务在不同的机器上，远程调用必经网络通信，调用服务必须写一坨网络通信代码，很容易出错且很复杂，因此就出现了RPC框架。</p>
<pre><code>阿里巴巴的 Dubbo     java新浪的     Motan    java谷歌的     gRPC     多语言Apache      thrift  多语言
rpc封装了数据的序列化，反序列化，以及传输协议</code></pre>
<h2 id="python实现RPC"><a href="#python实现RPC" class="headerlink" title="python实现RPC"></a>python实现RPC</h2><p>利用RabbitMQ构建一个RPC系统，包含了客户端和RPC服务器，依旧使用pika模块</p>
<h3 id="Callback-queue-回调队列"><a href="#Callback-queue-回调队列" class="headerlink" title="Callback queue 回调队列"></a>Callback queue 回调队列</h3><p>一个客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址<code>reply_to</code>。</p>
<h3 id="Correlation-id-关联标识"><a href="#Correlation-id-关联标识" class="headerlink" title="Correlation id 关联标识"></a>Correlation id 关联标识</h3><p>一个客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有<code>correlation_id</code>属性，这样客户端在回调队列中根据<code>correlation_id</code>字段的值就可以分辨此响应属于哪个请求。</p>
<pre><code>客户端发送请求：某个应用将请求信息交给客户端，然后客户端发送RPC请求，在发送RPC请求到RPC请求队列时，客户端至少发送带有reply_to以及correlation_id两个属性的信息服务器端工作流： 等待接受客户端发来RPC请求，当请求出现的时候，服务器从RPC请求队列中取出请求，然后处理后，将响应发送到reply_to指定的回调队列中客户端接受处理结果： 客户端等待回调队列中出现响应，当响应出现时，它会根据响应中correlation_id字段的值，将其返回给对应的应用过程
1.启动rpc客户端，等待接收数据到来，来了之后就进行处理，再将结果丢进队列
2.启动rpc服务端，发起请求</code></pre>
<pre><code>
rpc_server.py</code></pre>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>
import pikaimport uuidclass FibonacciRpcClient(object):    def __init__(self):        # 客户端启动时，创建回调队列，会开启会话用于发送RPC请求以及接受响应        # 建立连接，指定服务器的ip地址        self.connection = pika.BlockingConnection(pika.ConnectionParameters(            host='192.168.119.10'))        # 建立一个会话，每个channel代表一个会话任务        self.channel = self.connection.channel()        # 声明回调队列，再次声明的原因是，服务器和客户端可能先后开启，该声明是幂等的，多次声明，但只生效一次        #exclusive=True 参数是指只对首次声明它的连接可见        #exclusive=True 会在连接断开的时候，自动删除        result = self.channel.queue_declare(exclusive=True)        # 将次队列指定为当前客户端的回调队列        self.callback_queue = result.method.queue        # 客户端订阅回调队列，当回调队列中有响应时，调用`on_response`方法对响应进行处理;        self.channel.basic_consume(self.on_response, no_ack=True,                                   queue=self.callback_queue)    # 对回调队列中的响应进行处理的函数    def on_response(self, ch, method, props, body):        if self.corr_id == props.correlation_id:            self.response = body    # 发出RPC请求    # 例如这里服务端就是一个切菜师傅，菜切好了，需要传递给洗菜师傅，这个过程是发送rpc请求    def call(self, n):        # 初始化 response        self.response = None        # 生成correlation_id 关联标识，通过python的uuid库，生成全局唯一标识ID，保证时间空间唯一性        self.corr_id = str(uuid.uuid4())        # 发送RPC请求内容到RPC请求队列`s14rpc`，同时发送的还有`reply_to`和`correlation_id`        self.channel.basic_publish(exchange='',                                   routing_key='s14rpc',                                   properties=pika.BasicProperties(                                       reply_to=self.callback_queue,                                       correlation_id=self.corr_id,                                   ),                                   body=str(n))        while self.response is None:            self.connection.process_data_events()        return int(self.response)# 建立客户端fibonacci_rpc = FibonacciRpcClient()# 发送RPC请求，丢进rpc队列，等待客户端处理完毕，给与响应print("发送了请求sum(99)")response = fibonacci_rpc.call(99)print("得到远程结果响应%r" % response)
</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code></code></pre>
<p>rpc_client.py</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<pre><code>
import pika# 建立连接，服务器地址为localhost，可指定ip地址connection = pika.BlockingConnection(pika.ConnectionParameters(    host='192.168.119.10'))# 建立会话channel = connection.channel()# 声明RPC请求队列channel.queue_declare(queue='s14rpc')# 模拟一个进程，例如切菜师傅，等着洗菜师傅传递数据def sum(n):    n+=100    return n# 对RPC请求队列中的请求进行处理def on_request(ch, method, props, body):    print(body,type(body))    n = int(body)    print(" 正在处理sum(%s)" % n)    # 调用数据处理方法    response = sum(n)    # 将处理结果(响应)发送到回调队列    ch.basic_publish(exchange='',                     # reply_to代表回复目标                     routing_key=props.reply_to,                     # correlation_id（关联标识）：用来将RPC的响应和请求关联起来。                     properties=pika.BasicProperties(correlation_id= \                                                         props.correlation_id),                     body=str(response))    ch.basic_ack(delivery_tag=method.delivery_tag)# 负载均衡，同一时刻发送给该服务器的请求不超过一个channel.basic_qos(prefetch_count=1)channel.basic_consume(on_request, queue='s14rpc')print("等待接收rpc请求")#开始消费channel.start_consuming()
</code></pre>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%AD%A6%E4%B9%A0/">
                                    <span class="chip bg-color">学习</span>
                                </a>
                            
                                <a href="/tags/%E6%8A%80%E6%9C%AF/">
                                    <span class="chip bg-color">技术</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/11/15/Linux/redis%E5%AD%A6%E4%B9%A0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="redis学习">
                        
                        <span class="card-title">redis学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-11-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Wlcc___
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">学习</span>
                    </a>
                    
                    <a href="/tags/%E6%8A%80%E6%9C%AF/">
                        <span class="chip bg-color">技术</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/11/15/Linux/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="Linux系统基础优化及常用命令">
                        
                        <span class="card-title">Linux系统基础优化及常用命令</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-11-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Wlcc___
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">学习</span>
                    </a>
                    
                    <a href="/tags/%E6%8A%80%E6%9C%AF/">
                        <span class="chip bg-color">技术</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            wl
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/1420566605wl" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1420566605@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>




    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1420566605" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1420566605" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>

</html>
