<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>技术栈-wl</title>
      <link href="2020/10/11/%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%8A%80%E6%9C%AF%E6%A0%88-wl/"/>
      <url>2020/10/11/%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%8A%80%E6%9C%AF%E6%A0%88-wl/</url>
      
        <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><p><a href="">Data structure</a></p></li><li><p><a href="">Python</a></p></li><li><p><a href="">Golang</a></p></li><li><p><a href="">Web</a></p></li><li><p><a href="">Testing</a></p></li><li><p><a href="">Linux</a></p></li><li><p><a href="">Docker</a></p></li><li><p><a href="">Jenkins</a></p></li><li><p><a href="">elk</a></p></li><li><p><a href="">MySQL</a></p></li><li><p><a href="">redis</a></p></li><li><p><a href="">More</a></p></li><li><p><a href="https://1420566605wl.github.io/">返回首页</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/02/%E7%88%AC%E8%99%AB/Python%20-%20requests%20-%20%E5%90%AC%E9%9B%A8%E5%8D%B1%E6%A5%BC%20-%20%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E7%BD%91%E4%B8%8A%E5%AE%B6%E5%9B%AD/"/>
      <url>2020/10/02/%E7%88%AC%E8%99%AB/Python%20-%20requests%20-%20%E5%90%AC%E9%9B%A8%E5%8D%B1%E6%A5%BC%20-%20%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E7%BD%91%E4%B8%8A%E5%AE%B6%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[    <a name="top"></a>    <div id="top_nav" class="navbar navbar-custom">        <nav id="nav_main" class="navbar-main">            <ul id="nav_left" class="navbar-list navbar-left">                <li class="navbar-branding">                    <a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo"></a>                </li>                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>            </ul>            <ul id="nav_right" class="navbar-list navbar-right">                <li>                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3">                        <button type="submit" id="zzk_search_button">                            <img src="/images/aggsite/search.svg" alt="搜索">                        </button>                    </form>                </li>                <li id="navbar_login_status" class="navbar-list">                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客">                    </a>                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=oS4PkibyMjZ9rGD5XAcLt99uW_s76Javy2up4dbnZNY" alt="短消息">                        <span id="msg_count" style="display: none"></span>                    </a>                    <div id="user_info" class="navbar-user-info dropdown">                        <a class="dropdown-button" href="https://home.cnblogs.com/">                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像">                        </a>                        <div class="dropdown-menu">                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>                            <a href="https://home.cnblogs.com/">我的园子</a>                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>                            <a href="javascript:void(0)" onclick="logout();">退出登录</a>                        </div>                    </div>                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signin/?returnUrl=https://www.cnblogs.com/">登录</a>                </li>            </ul>        </nav>    </div>        <!--done--><div id="home"><div id="header"><div id="blogTitle">        <a id="lnkBlogLogo" href="https://www.cnblogs.com/Neeo/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页"></a><!--done--><h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/Neeo/">仰望星空,脚踏实地</a></h1><h2></h2></div><!--end: blogTitle 博客的标题和副标题 --><div id="navigator"><ul id="navList"><li></li><li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/Neeo/">首页</a></li><li></li><li></li><li><!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li><li><a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">管理</a></li></ul><div class="blogStats"><span id="stats_post_count">随笔 - 1&nbsp; </span><span id="stats_article_count">文章 - 444&nbsp; </span><span id="stats-comment_count">评论 - 33</span></div><!--end: blogStats --></div><!--end: navigator 博客导航栏 --></div><!--end: header 头部 --><div id="main"><div id="mainContent"><div class="forFlow"><div id="post_detail">    <!--done-->    <div id="topics">        <div class="post">            <h1 class="postTitle">                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Neeo/articles/11511087.html">    <span>Python - requests</span>    </a>            </h1>            <div class="clear"></div>            <div class="postBody">                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">    <p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#about">About</a></li><li><a href="#requestsrequest">requests.request()</a><ul><li><a href="#请求接受的参数">请求接受的参数</a></li><li><a href="#响应对象支持的属性">响应对象支持的属性</a></li></ul></li><li><a href="#requestsget">requests.get()</a><ul><li><a href="#params参数">params参数</a></li><li><a href="#headers">headers</a></li><li><a href="#cookies">cookies</a></li><li><a href="#文件下载">文件下载</a></li></ul></li><li><a href="#requestspost">requests.post()</a><ul><li><a href="#data参数">data参数</a></li><li><a href="#文件上传">文件上传</a></li><li><a href="#json参数">json参数</a></li></ul></li><li><a href="#requestshead">requests.head()</a></li><li><a href="#requestsput">requests.put()</a></li><li><a href="#requestspatch">requests.patch()</a></li><li><a href="#requestsdelete">requests.delete()</a></li><li><a href="#requestssession">requests.Session()</a></li><li><a href="#证书验证">证书验证</a></li><li><a href="#代理设置">代理设置</a></li><li><a href="#超时">超时</a></li><li><a href="#认证设置">认证设置</a></li><li><a href="#异常处理">异常处理</a></li></ul></div><p></p><ul><li><a href="https://www.cnblogs.com/Neeo/p/10864123.html#python">返回Python目录</a></li><li><a href="https://www.cnblogs.com/Neeo/p/10864123.html#testing">返回测试目录</a></li><li><a href="https://www.cnblogs.com/Neeo">返回随笔首页</a></li></ul><h1 id="about">About</h1><blockquote><p>环境：win10 + Python3.6</p></blockquote><p>requests库是Python语言编写，基于urllib，采用Apache2 Licensed开源协议的HTTP库。<br><img src="https://img2018.cnblogs.com/blog/1168165/202001/1168165-20200116160640019-3882704.png" alt="" loading="lazy"><br>它相对于urllib更加方便，大大节约了代码量，完全满足了HTTP测试相关需求。</p><blockquote><p>关于urllib：<a href="https://www.cnblogs.com/Neeo/articles/11520952.html">https://www.cnblogs.com/Neeo/articles/11520952.html</a></p></blockquote><p><strong>安装</strong></p><pre><code>pip install requestspip install -i https://pypi.doubanio.com/simple/ requests</code></pre><p>使用之前需引入。</p><p><strong>测试安装是否成功</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import requests   # 回车不报错就算安装成功response = requests.get("https://www.baidu.com")print(response.status_code)  # 200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有网的情况下，返回了200表示安装成功。</p><p><strong>requests库的主要方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>requests.request()</td><td>构造一个请求，支持以下各种方法</td></tr><tr><td>requests.get()</td><td>获取html的主要方法</td></tr><tr><td>requests.head()</td><td>获取html头部信息的主要方法</td></tr><tr><td>requests.post()</td><td>向html网页提交post请求的方法</td></tr><tr><td>requests.put()</td><td>向html网页提交put请求的方法</td></tr><tr><td>requests.patch()</td><td>向html提交局部修改的请求</td></tr><tr><td>requests.delete()</td><td>向html提交删除请求</td></tr><tr><td>requests.Session()</td><td>session相关</td></tr></tbody></table><p>我们一起来看看都是怎么玩儿的。</p><h1 id="requestsrequest">requests.request()</h1><p>这一节非常的重要！！！能用到的参数、基本都在这节展开。</p><h2 id="请求接受的参数">请求接受的参数</h2><p>requests.request(method, url, **kwargs)类能够构造一个请求，支持不同的请求方式。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.request(method='get', url='https://www.baidu.com')print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>request类中来看看几个参数：</p><ul><li>method：请求方式。</li><li>url：请求URL。</li><li>**kwargs：<ul><li>params：字典或者字节序列，作为参数增加到url中，使用这个参数可以把一些键值对以<code>k1=v1&amp;k2=v2</code>的模式增加到url中，get请求中用的较多。</li><li>data：字典、字节序列或者文件对象，重点作为向服务器提供或提交资源，作为请求的请求体，与params不同放在url上不同。它也可以接受一个字符串对象。</li><li>json：json格式的数据，可以向服务器提交json类型的数据。</li><li>headers：字典，定义请求的请求头，比如可以headers字典定义user agent。</li><li>cookies：字典或者CookieJar。</li><li>auth：元组，用来支持HTTP认证功能。</li><li>files：字典，用来向服务器传输文件。</li><li>timeout：指定超时时间。</li><li>proxies：字典，设置代理服务器。</li><li>allow_redirects：开关，是否允许对URL进行重定向，默认为True。</li><li>stream：开关，是否对获取内容进行立即下载，默认为False，也就是立即下载。这里需要说明的，stream一般应用于流式请求，比如说下载大文件，不可能一次请求就把整个文件都下载了，不现实，这种情况下，就要设置<code>stream=True</code>，requests无法将连接释放回连接池，除非下载完了所有数据，或者调用了response.close。</li><li>verify：开关，用于SSL证书认证，默认为True。</li><li>cert：用于设置保存本地SSL证书路径。</li></ul></li></ul><blockquote><p>流式请求，指的不是请求是流，而是请求返回的数据流，返回一点取一点，而普通的请求是返回完毕你再取内容。</p></blockquote><h2 id="响应对象支持的属性">响应对象支持的属性</h2><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.request(method='get', url='http://www.httpbin.org/get')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当一个请求被发送后，会有一个response响应。requests同样为这个response赋予了相关方法：</p><ul><li>response：响应对象。</li><li>response.status_code：请求返回状态码。</li><li>response.text：字符串形式的响应内容。</li><li>response.json()：返回响应的是json类型的数据，如果响应的类型不是json，则抛出<code>ValueError </code>。</li><li>response.content：二进制的响应内容。</li><li>response.iter_content(chunk_size)：生成器，在<code>stream=True</code>的情况下，当遍历生成器时，以块的形式返回，也就是一块一块的遍历要下载的内容。避免了遇到大文件一次性的将内容读取到内存中的弊端，如果<code>stream=False</code>，全部数据作为一个块返回。chunk_size参数指定块大小。</li><li>response.iter_lines()：生成器，当<code>stream=True</code>时，迭代响应数据，每次一行，也就是一行一行的遍历要下载的内容。同样避免了大文件一次性写入到内存中的问题。当然，该方法不安全。至于为啥不安全，咱也不知道，咱也不敢问，主要是<a href="https://2.python-requests.org//zh_CN/latest/api.html">官网</a>上没说！经查，如果多次调用该方法，iter_lines不保证重新进入时的安全性，因此可能会导致部分收到的数据丢失。</li><li>response.cookies：响应中的cookie信息。</li><li>response.cookies.get_dict()：以字典的形式返回cookies信息。</li><li>response.cookies.items()：以列表的形式返回cookies信息。</li><li>response.headers：响应头字典。取其中的指定key，<code>response.headers.get('Content-Type',  '哎呀，没取到！')</code></li><li>response.reqeust：请求类型。</li><li>response.url：请求的URL。</li><li>response.reason：响应HTTP状态的文本原因。</li><li>response.encoding：响应结果的编码方式。</li><li>response.encoding = “gbk”：修该响应编码方式，比如说响应结果的编码是utf-8，通过这么<code>response.encoding = “gbk”</code>指定为gbk。</li><li>response.apparent_encoding：根据响应字节流中去chardet库中匹配，返回编码方式，并不保证100%准确。</li><li>response.history：以列表的形式返回请求记录。列表内的请求以最老到最新排序。</li></ul><blockquote><p>see also：<a href="https://www.cnblogs.com/Neeo/articles/10835898.html#http%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81">HTTP协议状态码</a> | <a href="https://www.cnblogs.com/Neeo/articles/11528011.html">chardet</a></p></blockquote><h1 id="requestsget">requests.get()</h1><p><code>requests.get(url, params=None, **kwargs)</code>发送<code>GET</code>请求。相关参数：</p><ul><li>url，请求的URL。</li><li>params参数： 可选url中的额外参数，字典或者字节流格式。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><h2 id="params参数">params参数</h2><p>get请求难免会带一些额外的参数<code>K1=V1&amp;K2=V2</code>。</p><p>我们可以手动的拼接：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.get(url='http://www.httpbin.org/get?k1=v1&amp;k2=v2')print(response.url)  # http://www.httpbin.org/get?k1=v1&amp;k2=v2print(response.json().get('args'))  # {'k1': 'v1', 'k2': 'v2'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然没问题，但是稍显麻烦。</p><p>现在，我们可以使用params参数来解决这个问题。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsparams = {"user": "张开", "pwd": "666"}response = requests.get(url='http://www.httpbin.org/get', params=params)print(response.url)  # http://www.httpbin.org/get?user=%E5%BC%A0%E5%BC%80&amp;pwd=666print(response.json().get('args'))  # {'pwd': '666', 'user': '张开'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="headers">headers</h2><p>再来看，<code>GET</code>请求中如何携带headers。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsheaders = {"user-agent": UserAgent().random}response = requests.get(url='http://www.httpbin.org/get', headers=headers)print(response.json()['headers']['User-Agent'])  # Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-TW) AppleWebKit/533.19.4 (KHTML, like Gecko) Version/5.0.2 Safari/533.18.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于 fake_useragent：<a href="https://www.cnblogs.com/Neeo/articles/11525001.html">https://www.cnblogs.com/Neeo/articles/11525001.html</a></p></blockquote><h2 id="cookies">cookies</h2><p>来看，requests模块如何携带cookis参数。</p><pre class="line-numbers language-language-python"><code class="language-language-python"># 1. 登录,获取cookies值data = {    "userName": "=admin",    "password": "1234"}response = requests.post(url="http://www.neeo.cc:6002/pinter/bank/api/login", data=data)print(response.json())print(response.cookies)print(response.cookies.get_dict())# 2. 在需要cookies验证的时候，携带上刚才获取到的cookies值response = requests.get(url='http://www.neeo.cc:6002/pinter/bank/api/query?userName=admin', cookies=response.cookies.get_dict())print(response.status_code)print(response.json())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件下载">文件下载</h2><p>如果你访问的是一个小文件，或者图片之类的，我们可以直接写入到本地就完了，也就是不用管<code>stream</code>，让它默认为False即可。</p><p>来个美女图片提提神！</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsimport webbrowserurl = 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1568638318957&amp;di=1d7f37e7caece1c39af05b624f42f0a7&amp;imgtype=0&amp;src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201501%2F17%2F20150117224236_vYFmL.jpeg'response = requests.get(url=url)f = open('a.jpeg', 'wb')f.write(response.content)f.close()webbrowser.open('a.jpeg')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>过瘾不？</p><p>那要是下载大文件，可就不能这么干了：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsimport webbrowserurl = 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1568638318957&amp;di=1d7f37e7caece1c39af05b624f42f0a7&amp;imgtype=0&amp;src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201501%2F17%2F20150117224236_vYFmL.jpeg'response = requests.get(url=url, stream=True)with open('a.jpeg', 'wb') as f:    for chunk in response.iter_content(chunk_size=256):        f.write(chunk)webbrowser.open('a.jpeg')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>response.iter_content(chunk_size=256)</code>一块一块下载，并且可以指定chunk_size大小。</p><p>当然，也可以使用<code>response.iter_lines</code>一行一行遍历下载，但是官网说不安全，所以，忘掉它吧。</p><h1 id="requestspost">requests.post()</h1><p><code>requests.post(url, data=None, json=None, **kwargs)</code>发送<code>POST</code>请求，相关参数：</p><ul><li>url：请求的URL。</li><li>data：可选参数，请求中携带表单编码的字典、bytes或者文件对象。</li><li>json：请求中携带json类型的数据。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><p>在post请求中，data与json既可以是str类型，也可以是dict类型。</p><p>区别：</p><p>1、不管json是str还是dict，如果不指定headers中的content-type，默认为application/json</p><p>2、data为dict时，如果不指定content-type，默认为application/x-www-form-urlencoded，相当于普通form表单提交的形式</p><p>3、data为str时，如果不指定content-type，默认为application/json</p><p>4、用data参数提交数据时，request.body的内容则为<code>a=1&amp;b=2</code>的这种形式，用json参数提交数据时，request.body的内容则为<code>'{"a": 1, "b": 2}'</code>的这种形式</p><p>实际应用时候，需要根据后端服务处理的方式来确定</p><h2 id="data参数">data参数</h2><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://www.httpbin.org/post'# data为字典data_dict = {"k1": "v1"}response = requests.post(url=url, data=data_dict)print(response.json())# data为字符串data_str = "abc"response = requests.post(url=url, data=data_str)print(response.json(), type(response.json()['data']))# data为文件对象file = open('a.jpg', 'rb')response = requests.post(url=url, data=file)print(response.json())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的基于data参数上传文件，不如使用专门的<code>files</code>参数来的合适。</p><h2 id="文件上传">文件上传</h2><p>基于<code>POST</code>请求的文件上传，使用<code>files</code>参数。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsfile = {"file": open('a.jpg', 'rb')}response = requests.post('http://www.httpbin.org/post', files=file)print(response.json())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="json参数">json参数</h2><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://www.httpbin.org/post'response = requests.post(url=url, json={"user": "zhangkai"})print(response.json())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="requestshead">requests.head()</h1><p><code>requests.head(url, **kwargs)</code>发送<code>HEAD</code>请求，相关参数：</p><ul><li>url：请求URL。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://httpbin.org/get'response = requests.head(url=url)print(response.headers)'''{    'Access-Control-Allow-Credentials': 'true',     'Access-Control-Allow-Origin': '*',     'Content-Encoding': 'gzip',     'Content-Type': 'application/json',     'Date': 'Mon, 16 Sep 2019 10:58:07 GMT',     'Referrer-Policy': 'no-referrer-when-downgrade',     'Server': 'nginx',     'X-Content-Type-Options': 'nosniff',     'X-Frame-Options': 'DENY',     'X-XSS-Protection': '1; mode=block',     'Connection': 'keep-alive'}'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>requests.head(url, **kwargs)</code>的优点就是以较少的流量获得响应头信息，也可以用在分页中。</p><h1 id="requestsput">requests.put()</h1><p><code>requests.put(url, data=None, **kwargs)</code>发送<code>PUT</code>请求，相关参数：</p><ul><li>url：请求URL。</li><li>data：可选参数，请求中携带表单编码的字典、bytes或者文件对象。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://www.httpbin.org/put'data_dict = {"k1": "v1"}response = requests.put(url=url, data=data_dict)print(response.json())'''{    'args': {},     'data': '',     'files': {},     'form': {'k1': 'v1'},     'headers': {        'Accept': '*/*',         'Accept-Encoding': 'gzip, deflate',         'Content-Length': '5',         'Content-Type': 'application/x-www-form-urlencoded',         'Host': 'www.httpbin.org',         'User-Agent': 'python-requests/2.19.1'    },     'json': None,     'origin': '1.202.184.14, 1.202.184.14',     'url': 'https://www.httpbin.org/put'}'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="requestspatch">requests.patch()</h1><p><code>requests.patch(url, data=None, **kwargs)</code>发送<code>PATCH</code>请求，相关参数：</p><ul><li>url：请求URL。</li><li>data：可选参数，请求中携带表单编码的字典、bytes或者文件对象。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsurl = 'http://www.httpbin.org/patch'data_dict = {"k1": "v1"}response = requests.patch(url=url, data=data_dict)print(response.json())'''{       'args': {},     'data': '',     'files': {},     'form': {'k1': 'v1'},     'headers': {        'Accept': '*/*',         'Accept-Encoding': 'gzip, deflate',         'Content-Length': '5',         'Content-Type': 'application/x-www-form-urlencoded',         'Host': 'www.httpbin.org',         'User-Agent': 'python-requests/2.19.1'    },     'json': None,     'origin': '1.202.184.14, 1.202.184.14',     'url': 'https://www.httpbin.org/patch'}'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在requests中，<code>PATCH</code>请求和<code>PUT</code>类似。而区别：</p><ul><li><code>PATCH</code>是对<code>PUT</code>方法的补充，用来对已知资源进行局部更新。</li><li><code>PATCH</code>相比<code>PUT</code>更加节省带宽。</li></ul><h1 id="requestsdelete">requests.delete()</h1><p><code>requests.head(url, **kwargs)</code>发送<code>DELETE</code>请求，相关参数：</p><ul><li>url：请求URL。</li><li>**kwargs：参见requests.request中的kwargs。</li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">import requeststest_url = 'https://api.github.com'def get_url(url):    return '/'.join([test_url,url])email = '24xxxxx48@qq.com'def delete_email():    r = requests.delete(get_url('user/emails'),json = email ,auth=('username','password'))    print(r.status_code)    print(r.text)    print(r.request.headers)delete_email()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将email，用户名，密码，换成自己的GitHub的。</p><h1 id="requestssession">requests.Session()</h1><p><code>requests.Session()</code>可以用来帮我们保持会话。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestssession = requests.Session()session.get('http://www.httpbin.org/cookies/set/username/root')response = session.get('http://www.httpbin.org/cookies')print(response.json())  # {'cookies': {'username': 'root'}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="证书验证">证书验证</h1><p>在之前，这个知识点还能拿12306网站举例的时候.....</p><p>如果你请求的<code>https</code>协议的网址，那么人家网站首先会检测你的证书是否是合法的，如果不合法，会抛出<code>SSLError</code>。怎么处理呢。</p><p>证书验证这里，有两种方式处理。第一种就是使用<code>verify</code>，是否进行证书校验，默认是True。我们选择不校验。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.get(url='https://www.12306.cn', verify=False)print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但有的时候，会有一个<code>Warnning</code>警告，建议你加证书验证。</p><p>我们可以选择忽略这个警告：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsfrom requests.packages import urllib3urllib3.disable_warnings()response = requests.get(url='https://www.12306.cn', verify=False)print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以选择提供一个CA证书：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.get(url='https://www.12306.cn', cert=('/path/server.crt', 'path/key'))print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，我们没有什么CA证书，这就看个热闹吧。</p><h1 id="代理设置">代理设置</h1><p>代理：就是你访问一个网站，其实并不是你直接访问的，而是你发请求给A机器，A机器取请求B机器。B返回给A，A再返回给你。代理就是中间人的意思。为什么需要代理？因为：反爬虫网站一般使用IP来识别一个机器。老是一个IP在不停访问网站，该网站就会把这个IP拉入黑名单，不允许访问。这时，就需要很多IP再扰乱反爬虫工具的思维，避免封IP。</p><p><strong>普通代理</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsproxies = {    "http": "http://10.10.1.10:3128",    "https": "https://10.10.1.10:1080",}response = requests.get(url='https://www.12306.cn', proxies=proxies)print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代理需要用户名和密码</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsproxies = {    "http": "http://user:password@10.10.1.10:3128",}response = requests.get(url='https://www.12306.cn', proxies=proxies)print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持sock代理</strong></p><p>想要支持sock代理，那么首先要下载：</p><pre><code>pip install requests[socks]</code></pre><p>完事在用：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsproxies = {    'http': 'socks5://user:pass@host:port',    'https': 'socks5://user:pass@host:port'}respone=requests.get('https://www.12306.cn',proxies=proxies)print(respone.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="超时">超时</h1><p>超时，在规定的时间无响应。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsrespone=requests.get('https://www.12306.cn', timeout=0.0001)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="认证设置">认证设置</h1><p>有些网站，会弹出一个提示框，要求你输入用户名和密码。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsfrom requests.auth import HTTPBasicAuthresponse = requests.get(url='https://www.12306.cn', auth=HTTPBasicAuth(username='user', password='123'))print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>HTTPBasicAuth</code>的简写形式：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsresponse = requests.get(url='https://www.12306.cn', auth=('user', '123'))print(response.status_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="异常处理">异常处理</h1><p>异常处理相关异常类主要在<code>requests.exceptions</code>下，可以根据需求去翻看源码。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import requestsfrom requests.exceptions import ReadTimeout, ConnectionError, RequestExceptiontry:    # RequestException    # response = requests.get(url='https://www.12306.com')    # ReadTimeout    # response = requests.get(url='https://www.12306.cn', timeout=0.01)    # ConnectionError ,断网演示...    response = requests.get(url='https://xueqiu.com/stock/f10/finmainindex.json')    # print(response.status_code)except ReadTimeout as e:    print('ReadTimeout:', e)except ConnectionError as e:    print('ConnectionError:', e)except RequestException as e:    print('RequestException:', e)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr color="purple">欢迎斧正，that's allsee also：[Requests: 让 HTTP 服务人类](http://2.python-requests.org/zh_CN/latest/index.html#requests-http) | <https: www.cnblogs.com="" linhaifeng="" articles="" 7785043.html=""> | <https: 2.python-requests.org="" en="" master=""> | [urllib](<https: www.cnblogs.com="" neeo="" articles="" 11520952.html="">) | [requests模块 - egon](https://www.cnblogs.com/linhaifeng/articles/7785043.html) | [python3 requests详解](<https: blog.csdn.net="" pittpakk="" article="" details="" 81218566="">) | [Python爬虫系列（三）：requests高级耍法](<https: www.jianshu.com="" p="" 9ccebab67cc1="">) | [requests库入门08-delete请求](https://www.cnblogs.com/myal/p/9337384.html) | [请求接口时params和data的区别](https://blog.csdn.net/weixin_34130269/article/details/93193952) | [python request.post请求data参数与json参数的区别](https://blog.csdn.net/u011498011/article/details/96300354)</https:></https:></https:></https:></https:></div><div id="MySignature"></div><div class="clear"></div><div id="blog_post_info_block">    <div id="blog_post_info"></div>    <div class="clear"></div>    <div id="post_next_prev"></div></div>            </div>            <div class="postDesc">posted @ <span id="post-date">2019-09-16 22:37</span>&nbsp;<a href="https://www.cnblogs.com/Neeo/">听雨危楼</a>&nbsp;阅读(<span id="post_view_count">1538</span>)&nbsp;评论(<span id="post_comment_count">1</span>)&nbsp;<a href="https://i.cnblogs.com/EditArticles.aspx?postid=11511087" rel="nofollow">编辑</a>&nbsp;<a href="javascript:void(0)" onclick="AddToWz(11511087);return false;">收藏</a></div>        </div>            </div><!--end: topics 文章、评论容器--></div><script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script><script>markdown_highlight();</script><script>    var allowComments = true, cb_blogId = 356352, cb_blogApp = 'Neeo', cb_blogUserGuid = 'd9c29d9f-8210-4711-e20c-08d49c350eca';    var cb_entryId = 11511087, cb_entryCreatedDate = '2019-09-16 22:37', cb_postType = 2;    loadViewCount(cb_entryId);</script><a name="!comments"></a><div id="blog-comments-placeholder"></div><script>    var commentManager = new blogCommentManager();    commentManager.renderComments(0);</script><div id="comment_form" class="commentform">    <a name="commentform"></a>    <div id="divCommentShow"></div>    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>    <div id="comment_form_container"></div>    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>    <div id="ad_t2"></div>    <div id="opt_under_post"></div>    <div id="cnblogs_c1" class="c_ad_block">        <div id="div-gpt-ad-1592365906576-0" style="width: 300px; height: 250px;"></div>    </div>    <div id="under_post_news"></div>    <div id="cnblogs_c2" class="c_ad_block">        <div id="div-gpt-ad-1592366332455-0" style="width: 468px; height: 60px;"></div>    </div>    <div id="under_post_kb"></div>    <div id="HistoryToday" class="c_ad_block"></div>    <script type="text/javascript">        fixPostBody();        deliverBigBanner();setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverT2();        deliverC1C2();        loadNewsAndKb();        loadBlogSignature();LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);        loadOptUnderPost();        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);    </script></div></div><!--end: forFlow --></div><!--end: mainContent 主体内容容器--><div id="sideBar"><div id="sideBarMain"><div id="sidebar_news" class="newsItem">            <script>loadBlogNews();</script></div><div id="sidebar_ad"></div><div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script><div id="leftcontentcontainer"><div id="blog-sidecolumn"></div>                    <script>loadBlogSideColumn();</script></div></div><!--end: sideBarMain --></div><!--end: sideBar 侧边栏容器 --><div class="clear"></div></div><!--end: main --><div class="clear"></div><div id="footer"><!--done-->Copyright © 2020 听雨危楼<br><span id="poweredby">Powered by .NET Core on Kubernetes</span></div><!--end: footer --></div><!--end: home 自定义的最大容器 -->        <script>    var _hmt = _hmt || [];    (function() {      var hm = document.createElement("script");      hm.src = "https://hm.baidu.com/hm.js?39b794a97f47c65b6b2e4e1741dcba38";      var s = document.getElementsByTagName("script")[0];      s.parentNode.insertBefore(hm, s);    })();    </script><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/02/%E7%88%AC%E8%99%AB/Python%20-%20urllib%20-%20%E5%90%AC%E9%9B%A8%E5%8D%B1%E6%A5%BC%20-%20%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E7%BD%91%E4%B8%8A%E5%AE%B6%E5%9B%AD/"/>
      <url>2020/10/02/%E7%88%AC%E8%99%AB/Python%20-%20urllib%20-%20%E5%90%AC%E9%9B%A8%E5%8D%B1%E6%A5%BC%20-%20%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E7%BD%91%E4%B8%8A%E5%AE%B6%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[    <a name="top"></a>    <div id="top_nav" class="navbar navbar-custom">        <nav id="nav_main" class="navbar-main">            <ul id="nav_left" class="navbar-list navbar-left">                <li class="navbar-branding">                    <a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo"></a>                </li>                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>            </ul>            <ul id="nav_right" class="navbar-list navbar-right">                <li>                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3">                        <button type="submit" id="zzk_search_button">                            <img src="/images/aggsite/search.svg" alt="搜索">                        </button>                    </form>                </li>                <li id="navbar_login_status" class="navbar-list">                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客">                    </a>                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=oS4PkibyMjZ9rGD5XAcLt99uW_s76Javy2up4dbnZNY" alt="短消息">                        <span id="msg_count" style="display: none"></span>                    </a>                    <div id="user_info" class="navbar-user-info dropdown">                        <a class="dropdown-button" href="https://home.cnblogs.com/">                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像">                        </a>                        <div class="dropdown-menu">                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>                            <a href="https://home.cnblogs.com/">我的园子</a>                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>                            <a href="javascript:void(0)" onclick="logout();">退出登录</a>                        </div>                    </div>                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signin/?returnUrl=https://www.cnblogs.com/">登录</a>                </li>            </ul>        </nav>    </div>        <!--done--><div id="home"><div id="header"><div id="blogTitle">        <a id="lnkBlogLogo" href="https://www.cnblogs.com/Neeo/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页"></a><!--done--><h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/Neeo/">仰望星空,脚踏实地</a></h1><h2></h2></div><!--end: blogTitle 博客的标题和副标题 --><div id="navigator"><ul id="navList"><li></li><li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/Neeo/">首页</a></li><li></li><li></li><li><!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li><li><a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">管理</a></li></ul><div class="blogStats"><span id="stats_post_count">随笔 - 1&nbsp; </span><span id="stats_article_count">文章 - 444&nbsp; </span><span id="stats-comment_count">评论 - 33</span></div><!--end: blogStats --></div><!--end: navigator 博客导航栏 --></div><!--end: header 头部 --><div id="main"><div id="mainContent"><div class="forFlow"><div id="post_detail">    <!--done-->    <div id="topics">        <div class="post">            <h1 class="postTitle">                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Neeo/articles/11520952.html">    <span>Python - urllib</span>    </a>            </h1>            <div class="clear"></div>            <div class="postBody">                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">    <p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#about">About</a></li><li><a href="#urllib、urllib2、urllib3傻傻分不清楚">urllib、urllib2、urllib3傻傻分不清楚</a></li><li><a href="#urllibrequest">urllib.request</a><ul><li><a href="#请求">请求</a></li><li><a href="#响应">响应</a></li><li><a href="#request对象">request对象</a></li><li><a href="#cookie">Cookie</a></li><li><a href="#代理">代理</a></li><li><a href="#下载">下载</a></li></ul></li><li><a href="#urlliberror">urllib.error</a></li><li><a href="#urllibparse">urllib.parse</a></li><li><a href="#urllibrobotparser">urllib.robotparser</a><ul><li><a href="#robots协议">Robots协议</a></li><li><a href="#robotfileparser">RobotFileParser</a></li></ul></li></ul></div><p></p><ul><li><a href="https://www.cnblogs.com/Neeo/p/10864123.html#python">返回上一页</a></li></ul><h1 id="about">About</h1><p>urllib是Python内置的HTTP请求库。urllib 模块提供的上层接口，使访问 www 和 ftp 上的数据就像访问本地文件一样，并且它也是requests的底层库。</p><p>其中包括4个主要模块：</p><ul><li>urllib.request：请求模块。</li><li>urllib.error：异常处理模块。</li><li>urllib.parse：URL解析模块。</li><li>urllib.robotparser：robots.txt解析模块。</li></ul><p>这里以Python3.6为例。</p><h1 id="urllib、urllib2、urllib3傻傻分不清楚">urllib、urllib2、urllib3傻傻分不清楚</h1><p>在Python2.x中，分为urllib和urllib2，简单来说，urllib2是urllib的增强版，但urllib中的函数又比urllib2多一些，对于简单的下载之类的，urllib绰绰有余，如果涉及到实现HTTP身份验证或者cookie或者扩展编写自定义协议，urllib2更好一些。</p><ul><li><p>urllib支持设置编码的函数urllib.urlencode，在模拟登陆的时候经常需要传递经过post编码之后的参数，如果不想使用第三方库完成模拟登录，就必须使用到标准库中的urllib。urllib提供一些比较原始基础的方法而urllib2并没有，比如urllib中的urlencode方法用来GET查询字符串的产生。</p></li><li><p>urllib2比较有优势的地方在于urllib2.openurl中可以接受一个Request类的实例来设置Request参数，来修改/设置Header头从而达到控制HTTP Request的header部分的目的，也可以修改用户代理,设置cookie等，但urllib仅可以接受URL。这就意味着，如果你访问一个网站想更改User Agent(可以伪装你的浏览器)，你就需要使用urllib2。</p></li><li><p>urllib2模块没有加入urllib.urlretrieve函数以及urllib.quote等一系列quote和unquote功能，这个时候就需要urllib的辅助。</p></li></ul><p>因此，在Python2.x中，这两个库可以搭配使用。<br>而urllib3则是增加了连接池等功能，两者互相都有补充的部分。<br>那么Python3.x中呢，urllib和urllib2都合并到了urllib中了，所以，啥也别想了，Python3.x即将一统江湖，所以，我们还是踏实儿的学习Python3.x下的urllib吧。</p><p>再来看看Python2.x和Python3.x的区别。<br>在Python2.x中，<code>urlopen</code>方法在urllib下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib2response = urllib2.urlopen()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在Python3.x中，<code>urlopen</code>方法就移动到了<code>urllib.request</code>下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="urllibrequest">urllib.request</h1><h2 id="请求">请求</h2><p>先来看urllib怎么发送请求。</p><p><strong>发送get请求</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllibresponse = urllib.request.urlopen('http://www.baidu.com')# 获取bytes类型的数据# print(response.read())# 想要获取到字符串类型的数据，需要使用 decode 转码为字符串print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>发送post请求</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.parsedata = bytes(urllib.parse.urlencode({'world': 'hello'}), encoding='utf-8')response = urllib.request.urlopen(url='http://httpbin.org/post', data=data)print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，需要了解一个<code>http://httpbin.org</code>这个网站，HTTPBin是以Python+Flask写的一款工具，它包含了各类的HTTP场景，且每个接口一定都有返回。</p><p>data参数需要字节类型的数据，所以，我们首先用bytes转码，然后将我们的字典使用<code>urllib.parse.urlencode</code>并指定编码方式完成编码。</p><p>另外，data参数用来控制请求方式，如果请求中有data则是post请求，否则为get请求。</p><p><strong>timeout</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import socketimport urllib.requestimport urllib.errortry:    # 没有超时，正常返回json格式的内容    # response = urllib.request.urlopen(url='http://www.httpbin.org/get', timeout=2)    # 超时会抛出异常，由异常语句捕获    response = urllib.request.urlopen(url='http://www.httpbin.org/get', timeout=0.1)    print(response.read().decode('utf-8'))except urllib.error.URLError as e:    # print(e)  # <urlopen error="" timed="" out="">    if isinstance(e.reason, socket.timeout):        print(e.reason)  # timed out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></urlopen></code></pre><p><code>e.reason</code>为错误原因。<code>timeout</code>单位是秒。</p><h2 id="响应">响应</h2><p>现在来研究urlopen返回对象提供的方法：</p><ul><li>read()，readline()，readlines()，fileno(), close()：这些方法与文件对象一样。</li><li>info()：返回一个httplibHTTPMessage对象，表示远程服务器返回的头信息。</li><li>getcode()：返回HTTP状态码。</li><li>geturl()：返回请求的url。</li></ul><p><strong>响应类型</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen(url='http://www.httpbin.org/get')print(response)  # <http.client.httpresponse object="" at="" 0x07b65270="">print(type(response))  # <class 'http.client.httpresponse'=""><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></class></http.client.httpresponse></code></pre><p><strong>状态码</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen(url='http://www.httpbin.org/get')print(response.status)  # 200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>响应头</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen(url='http://www.httpbin.org/get')print(response.headers)  print(response.getheaders())  # 列表类型的响应头print(response.getheader('Server', None))  # 获取特定的响应头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>响应体</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestresponse = urllib.request.urlopen(url='http://www.httpbin.org')# print(response.read())print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之前说过，urllib获取到的内容是字节形式，我们通过read读出来之后需要使用decode解码。</p><h2 id="request对象">request对象</h2><p>上面我们发送一些简单的请求没问题，但是复杂的请求（比如带headers）就力有不逮了。这个时候，我们需要学习一个<code>Request</code>来定制复杂的请求参数了。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestrequest = urllib.request.Request(url='http://www.httpbin.org')response = urllib.request.urlopen(request)print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们使用<code>urllib.request.Request</code>来构建一个request对象，然后传给<code>urlopen</code>即可。</p><p>再来看一个复杂点的带headers。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.parse# 指定urlurl='http://www.httpbin.org/post'# 自定义headersheaders = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36"}# 自定义data参数并编码为bytes类型data_dict = {"username": "zhangkai"}data = bytes(urllib.parse.urlencode(data_dict), encoding='utf-8')# 使用urllib.request.Request构造request对象request = urllib.request.Request(url=url, data=data, headers=headers, method='POST')# 将request对象交给urlopen发请求去吧response = urllib.request.urlopen(request)print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看一个<code>add_headers</code>方法。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.parseurl='http://www.httpbin.org/post'# 这里跟上面的示例区别就是不在单独指定headers字典# headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36"}data_dict = {"username": "zhangkai"}data = bytes(urllib.parse.urlencode(data_dict), encoding='utf-8')request = urllib.request.Request(url=url, data=data, method='POST')# 而是使用构造好的request对象下面的add_header方法添加header，换汤不换药....request.add_header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36")response = urllib.request.urlopen(request)print(response.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>add_header</code>方法作为添加headers的补充方式，如果有多个header键值对，可以使用for循环一一添加进去.....</p><p>会了构造request对象，我们基本能应付大部分的网站了。</p><p>再来看看更复杂的一些用法，以应对更多的复杂环境，比如携带cookie什么的。</p><h2 id="cookie">Cookie</h2><p><strong>获取cookie</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport http.cookiejar# 声明 cookiejar 对象cookie = http.cookiejar.CookieJar()# 使用handler处理cookie对象handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)# 当opener.open发送请求response = opener.open('http://www.baidu.com')# 当response有了结果之后，会自动将cookie信息保存到上面声明的cookie对象中去print(cookie)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code> http.cookiejar</code>提供一个永久性的cookie对象。并且<code>cookiejar</code>有3个子类：</p><ul><li>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。</li><li>FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。</li><li>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。</li><li>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。</li></ul><p>大多数情况下，我们只用<code>CookieJar()</code>，如果需要和本地文件交互，就用 <code>MozillaCookjar()</code> 或 <code>LWPCookieJar()</code></p><p>补充：libwww-perl集合是一组Perl模块，它为万维网提供简单而一致的应用程序编程接口。该库的主要重点是提供允许您编写WWW客户端的类和函数。</p><p><strong>将cookie写入文件</strong></p><p>我们知道cookie是保持登录会话信息的凭证，那么在获取到cookie后写入本地，在cookie失效前，后续访问再读取本地文件，并在请求中携带，以达到继续保持登录信息的状态。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport http.cookiejar'''写入cookie对象到本地'''url = 'http://www.baidu.com'file_name = 'cookie.txt'# 这里将cookie信息处理成火狐浏览器cookie格式cookie = http.cookiejar.MozillaCookieJar(file_name)# LWPCookieJar格式cookie# cookie = http.cookiejar.LWPCookieJar(file_name)# 使用handler处理cookie对象handler = urllib.request.HTTPCookieProcessor(cookie1)opener = urllib.request.build_opener(handler)response1 = opener.open(url)# 将cookie信息保存到本地文件cookie1.save(ignore_discard=True, ignore_expires=True)'''读取本地cookie信息'''# 以什么格式保存，就以什么格式读出来，这里都用MozillaCookieJarcookie2 = http.cookiejar.MozillaCookieJar()# 使用load方法从本地读取cookie信息cookie2.load(file_name, ignore_discard=True, ignore_expires=True)# 放到handle中handler = urllib.request.HTTPCookieProcessor(cookie2)opener = urllib.request.build_opener(handler)response2 = opener.open(url)print(response2.read().decode('utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>save</code>和<code>load</code>中，有两个参数需要说明：</p><ul><li>ignore_discard：保存cookie，即使设置为丢弃的cookie也保存。</li><li>ignore_expires：如果cookie已过期也要保存到文件，并且如果文件存在则覆盖。后续可以使用<code>load</code>或者<code>revert</code>方法恢复保存的文件。</li></ul><h2 id="代理">代理</h2><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.request# 调用ProxyHandler 代理ip的形式是字典# 付费代理# money_proxy = {"协议":"username:pwd@ip:port"}proxy_handler = urllib.request.ProxyHandler({'sock5': 'localhost:1080'})# 使用build_opener构建opener对象opener = urllib.request.build_opener(proxy_handler)# 调用opener的open方法向指定url发请求response = opener.open('http://www.httpbin.org/get')print(response.read().decode('utf-8'))'''{  "args": {},   "headers": {    "Accept-Encoding": "identity",     "Host": "www.httpbin.org",     "User-Agent": "Python-urllib/3.6"  },   "origin": "124.64.16.181, 124.64.16.181",   "url": "https://www.httpbin.org/get"}'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>{'sock5': 'localhost:1080'}</code>中<code>sock5</code>是协议，<code>localhost:1080</code>是走本地的1080端口。</p><p>其实<code>urlopen</code>在内部也是调用了<code>opener.open</code>方法发送请求。</p><p>另外，返回结果<code>origin</code>是访问IP，而这个IP正好是我们使用的代理IP。</p><h2 id="下载">下载</h2><p>我们可以使用urllib下载图片，文件等到本地。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requesturl = 'http://n.sinaimg.cn/news/1_img/upload/cf3881ab/69/w1000h669/20190912/bed4-iepyyhh6925213.jpg' filename = 'a.jpg'# 使用urlretrieve进行下载操作urllib.request.urlretrieve(url=url, filename=filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，我们还可以使用<code>urllib.urlcleanup()</code>来清除<code>urllib.urlretrieve</code>所产生的缓存。</p><h1 id="urlliberror">urllib.error</h1><p>urllib中的异常处理有3个：</p><ul><li><code>urllib.error.URLError</code>：捕获关于url的错误，只有一个返回方法reason，错误原因。</li><li><code>urllib.error.HTTPError</code>：捕获关于http的错误，有3个返回方法。code，http中定义的http状态码；reason，错误原因；headers，响应头。</li><li><code>urllib.error.ContentTooShortError</code>：当<code>urlretrieve</code>检测到下载数据量小于预期时，会引发此异常。</li></ul><p><strong>urllib.error.URLError</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.errortry:    # 这里将 cnblogs 写成 cnblogsww    # response = urllib.request.urlopen(url='https://www.cnblogsww.com/Neeo/p/1083589221.html')    print(response.read().decode('utf-8'))except urllib.error.ContentTooShortError as e:    print('ContentTooShortError: ', e.reason)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>urllib.error.HTTPError</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.errortry:    headers = {        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36"}    # 不存在的 103048922222.html    response = urllib.request.urlopen(url='https://www.cnblogs.com/Neeo/p/103048922222.html')    print(response.read())except urllib.error.HTTPError as e:    print('HTTPError: ', e.reason, e.headers, e.code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>urllib.error.ContentTooShortError</strong></p><p>这个错误比较重要，因为我们在下载文件时，很可能会因为各种原因导致下载没有完成就失败了。这个时候，我们就可以使用<code>ContentTooShortError</code>来捕捉错误从新下载。如果重新下载还是下载失败，可以考虑使用递归，下载失败就重新下，直到下载成功。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.requestimport urllib.errortry:    url = 'http://n.sinaimg.cn/news/1_img/upload/cf3881ab/69/w1000h669/20190912/bed4-iepyyhh6925213.jpg'    filename = 'a.jpg'    urllib.request.urlretrieve(url=url, filename=filename)except urllib.error.ContentTooShortError as e:    print('ContentTooShortError: ', e.reason)    # 如果下载失败，就重新下载    urllib.request.urlretrieve(url=url, filename=filename)        def get_file(url, filename):""" 使用递归进行重新下载，直到下载成功为止 """    try:        urllib.request.urlretrieve(url=url, filename=filename)        print('download done ......')    except urllib.error.ContentTooShortError:        get_file(url, filename)url = "http://n.sinaimg.cn/news/1_img/upload/cf3881ab/69/w1000h669/20190912/bed4-iepyyhh6925213.jpg"filename = 'a.jpg'get_file(url, filename)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="urllibparse">urllib.parse</h1><p><code>urllib.parse</code>定义了URL的标准接口，实现对于URL的各种操作，包括解析、合并、编码、解码，使用之前需导入。</p><p><strong>urllib.parse.urlparse</strong></p><p><code>urllib.parse.urlparse</code>以元组的形式返回URL解析后的6个组件。对应的URL结构一般是这样的：</p><pre><code>scheme://netloc/path;parameters?query#fragment</code></pre><p>每个元组项都是一个字符串，也可能是空的。</p><p>返回的元组中：</p><ul><li>scheme：协议。</li><li>netloc：域名。</li><li>path：路径。</li><li>params：参数。</li><li>query：查询条件，一般用于个get请求的URL。</li><li>fragment：锚点。</li></ul><p>基本使用：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseurllib.parse.urlparse(url, scheme='', allow_fragments=True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>url：待解析的url</li><li>scheme：协议，如果URL中没有协议，则使用该参数设置协议，如果有协议，该参数不生效</li><li>allow_fragments:是否忽略锚点，默认为True，表示表示不忽略，False表示忽略</li></ul><p>示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseresult = urllib.parse.urlparse('https://www.cnblogs.com/Neeo/p/10864123.html?k1=v1#python')print(result)'''ParseResult(scheme='https', netloc='www.cnblogs.com', path='/Neeo/p/10864123.html', params='', query='k1=v1', fragment='python')'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>urllib.parse.urlunparse</strong></p><p>与<code>urlparse</code>相反，<code>urllib.parse.urlunparse</code>用来构造URL。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseurl_components = ['https', 'www.cnblogs.com', '/Neeo/p/10864123.html', '', '', 'python']result = urllib.parse.urlunparse(url_components)print(result)  # https://www.cnblogs.com/Neeo/p/10864123.html#python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>url_components</code>中，顺序必须遵循：</p><pre><code>scheme, netloc, url, params, query, fragment</code></pre><p>也就是6个选项都要有值，如果没有也要填充空字符串占位。</p><p><strong>urllib.parse.urljoin</strong></p><p><code>urllib.parse.urljoin</code>用来拼接URL。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parse# 将两个url拼接成一个完整的url，base_url + sub_urlprint(urllib.parse.urljoin('https://www.cnbogs.com', '/Neeo/p/10864123.html'))# 如果每个参数中都有相应的参数的话，比如都有协议，那么将以后面的为准print(urllib.parse.urljoin('https://www.cnbogs.com', 'http://www.baidu.com/Neeo/p/10864123.html'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，<code>urljoin</code>方法只能接受两个url参数：</p><pre><code>urljoin(base, url, allow_fragments=True)</code></pre><p>别意淫它能跟<code>os.path.join</code>一样可劲儿的往后拼！</p><p><strong>urllib.parse.urlencode</strong></p><p><code>urllib.parse.urlencode</code>将字典类型的参数序列化为url编码后的字符串，常用来构造get/post请求的参数<code>k1=v1&amp;k2=v2</code>。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseparams = {"k1": "v1", "k2": "v2"}encode_params = urllib.parse.urlencode(params)print('https://www.baidu.com?' + encode_params)  # https://www.baidu.com?k1=v1&amp;k2=v2# 这里用urljoin不好使, 它在处理base url时会将 ? 干掉print(urllib.parse.urljoin('https://www.baidu.com', encode_params))  # https://www.baidu.com/k1=v1&amp;k2=v2# 或者你继续使用拼接....好蛋疼print(urllib.parse.urljoin('https://www.baidu.com', '?' + encode_params))  # https://www.baidu.com?k1=v1&amp;k2=v2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>urllib.parse.quote系列</strong></p><p>按照标准，URL只允许一部分ASCII字符（数字字母和部分符号）,其他的字符如汉字是不符合URL标准的。所以在使用URL的时候，要进行URL编码。</p><p>urllib提供了<code>urllib.parse.quote</code>和<code>urllib.parse.quote_plus</code>进行URL编码。</p><p>而<code>urllib.parse.quote_plus</code>比<code>urllib.parse.quote</code>更近一步，会对<code>/</code>符号进行编码。</p><p>而<code>urllib.parse.unquote</code>和<code>urllib.parse.unquote_plus</code>则是将编码后的URL进行还原。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.parseurl = 'https://www.baidu.com/s?&amp;wd=张开'result = urllib.parse.quote(url)print(result)  # https%3A//www.baidu.com/s%3F%26wd%3D%E5%BC%A0%E5%BC%80result_plus = urllib.parse.quote_plus(url)print(result_plus)  # https%3A%2F%2Fwww.baidu.com%2Fs%3F%26wd%3D%E5%BC%A0%E5%BC%80un_result = urllib.parse.unquote(result)print(un_result)  # https://www.baidu.com/s?&amp;wd=张开un_result_plus = urllib.parse.unquote_plus(result_plus)print(un_result_plus)  # https://www.baidu.com/s?&amp;wd=张开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="urllibrobotparser">urllib.robotparser</h1><p>我们可以利用<code>urllib.robotparser</code>对爬取网站的Robots协议进行分析。</p><p>那问题来了，什么是Robots协议？</p><h2 id="robots协议">Robots协议</h2><p>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。robots.txt文件是一个文本文件，放在站点的根目录下。</p><p>当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p><p><strong>禁止所有爬虫访问任何内容</strong></p><pre><code>User-Agent:  *Disallow:  /</code></pre><p><strong>允许所有爬虫访问任何内容</strong></p><pre><code>User-Agent:  *Disallow: </code></pre><p><strong>允许某些爬虫访问某些目录</strong></p><pre><code>User-agent:  BaiduspiderAllow:  /articleAllow:  /oshtmlDisallow:  /product/Disallow:  /User-Agent:  GooglebotAllow:  /articleAllow:  /oshtmlAllow:  /productAllow:  /spuAllow:  /dianpuAllow:  /overseaAllow:  /listDisallow:  /User-Agent:  *Disallow:  /</code></pre><p><strong>关于爬虫名称</strong></p><table><thead><tr><th>爬虫名称</th><th>所属公司</th><th>网址</th></tr></thead><tbody><tr><td>Baiduspider</td><td>百度</td><td><a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td>Googlebot</td><td>谷歌</td><td><a href="http://www.google.com/">www.google.com</a></td></tr><tr><td>Bingbot</td><td>微软必应</td><td>cn.bing.com</td></tr><tr><td>360Spider</td><td>360搜索</td><td><a href="http://www.so.com/">www.so.com</a></td></tr><tr><td>Yisouspider</td><td>神马搜索</td><td><a href="http://m.sm.cn/">http://m.sm.cn/</a></td></tr><tr><td>Sogouspider</td><td>搜狗搜索</td><td><a href="https://www.sogou.com/">https://www.sogou.com/</a></td></tr><tr><td>Yahoo! Slurp</td><td>雅虎</td><td><a href="https://www.yahoo.com/">https://www.yahoo.com/</a></td></tr></tbody></table><h2 id="robotfileparser">RobotFileParser</h2><p>robotpaser模块提供RobotFileParser类来解析robots.txt文件，判断是否允许爬取网站的某一目录。</p><p>在实例化类时传入robots.txt。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.robotparserresponse = urllib.robotparser.RobotFileParser(url='https://www.zhihu.com/robots.txt')response.read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者通过实例化对象调用<code>set_url</code>方法传入robots.txt。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.robotparserresponse = urllib.robotparser.RobotFileParser()response.set_url('https://www.zhihu.com/robots.txt')response.read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>whatever，都需要使用<code>response.read()</code>读出来，不然后面解析不到。</p><p>常用方法：</p><ul><li>set_url(url)：用来设置 robots.txt 文件链接，如果在初次实例化 RobotFileParser 类的时候传入了 url 参数，那么就不需要再次调用此方法设置了。</li><li>read()：读取 robots.txt 文件并将读取结果交给 parse() 解析器进行解析。</li><li>parse(lines)：用来解析 robots.txt 文件内容，分析传入的某些行的协议内容。</li><li>can_fetch(useragent, url)：需要两个参数，User-Agent、所要抓取的 URL 链接，返回此搜索引擎是否允许抓取此 URL，返回结果为 True、False。</li><li>mtime()：返回上次抓取分析 robots.txt 文件的时间，这对于需要对 robots.txt 进行定期检查更新的长时间运行的网络爬虫非常有用 。</li><li>modified()：同样的对于长时间分析和抓取的搜索爬虫很有帮助，将当前时间设置为上次抓取和分析 robots.txt 的时间。</li><li>crawl_delay(useragent)：返回抓取延迟时间的值，从相应的 User-Agent 的 robots.txt 返回 Crawl-delay 参数的值。 如果没有这样的参数，或者它不适用于指定的 User-Agent，或者此参数的 robots.txt 条目语法无效，则返回 None。</li><li>request_rate(useragent)：从robots.txt返回Request-rate参数的内容，作为命名元组RequestRate（requests，seconds）。 如果没有这样的参数，或者它不适用于指定的useragent，或者此参数的robots.txt条目语法无效，则返回None。（Python3.6新增方法）</li></ul><p>示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.robotparserresponse = urllib.robotparser.RobotFileParser(url='https://www.zhihu.com/robots.txt')# 要有读操作response.read()# 判断某一个网址是否能爬取print(response.can_fetch('Googlebot', 'https://www.zhihu.com/question/268464407/answer/804631692'))  # Trueprint(response.can_fetch('*', 'https://www.zhihu.com/question/268464407/answer/804631692'))  # False# 返回上一次抓取分析 robots.txt 的时间print(response.mtime())  # 1568542822.1876643# 将当前时间设置为上次抓取和分析 robots.txt 的时间response.modified()# 返回 robots.txt 文件对请求频率的限制print(response.request_rate('MSNBot').requests)  # 1print(response.request_rate('*'))  # None# 返回 robots.txt 文件对抓取延迟限制print(response.crawl_delay('*'))  # Noneprint(response.crawl_delay('MSNBot'))  # 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用parser方法读取和分析robots.txt。</p><pre class="line-numbers language-language-python"><code class="language-language-python">import urllib.robotparserimport urllib.request# 实例化 RobotFileParser 对象response = urllib.robotparser.RobotFileParser()# 使用parser读取 robots.txt 文件result = urllib.request.urlopen('https://www.zhihu.com/robots.txt').read().decode('utf-8').split('\n')response.parse(result)# 判断url是否可爬取print(response.can_fetch('Googlebot', 'https://www.zhihu.com/question/268464407/answer/804631692'))  # Trueprint(response.can_fetch('*', 'https://www.zhihu.com/question/268464407/answer/804631692'))  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr color="purple">欢迎斧正，that's allsee also：[http://www.httpbin.org/](<http: www.httpbin.org="">) | [使用HTTPBin测试HTTP库](<https: www.jianshu.com="" p="" 00db00cd287d="">) | [urllib  — URL handling modules](https://docs.python.org/3/library/urllib.html#module-urllib) | [http://www.66ip.cn/](http://www.66ip.cn/) | [HTTP模块](https://docs.python.org/3/library/http.html#module-http) | [使用ip付费的代理是遇到http.client.RemoteDisconnected: Remote end closed connection without response 解决方法](https://blog.csdn.net/lovlu18/article/details/79921885) | [http.cookiejar库之CookieJar](https://blog.csdn.net/levon2018/article/details/80558108) |[libwww-perl](https://github.com/libwww-perl/libwww-perl) | [爬虫保存cookies时重要的两个参数（ignore_discard和ignore_expires）的作用](https://blog.csdn.net/qq_33472765/article/details/80738923) | [http.cookiejar- HTTP客户端的Cookie处理](https://docs.python.org/3/library/http.cookiejar.html#module-http.cookiejar) | [[python]解决urllib.urlretrieve()下载不完全的问题](https://blog.csdn.net/Innovation_Z/article/details/51106601) | [urllib.parse模块使用](<https: www.jianshu.com="" p="" e7d87e1ed38c="">) | [4. Urllib -- urllib.robotparser](<https: www.jianshu.com="" p="" 21fc41453784="">) | [urllib.robotparser- robots.txt的解析器](<https: docs.python.org="" dev="" library="" urllib.robotparser.html#module-urllib.robotparser="">) | [urllib模块中的方法](<https: www.cnblogs.com="" sysu-blackbear="" p="" 3629420.html="">) | [python中quote函数是什么意思，怎么用](<https: zhidao.baidu.com="" question="" 1047750056353229099.html="">)</https:></https:></https:></https:></https:></https:></http:></div><div id="MySignature"></div><div class="clear"></div><div id="blog_post_info_block">    <div id="blog_post_info"></div>    <div class="clear"></div>    <div id="post_next_prev"></div></div>            </div>            <div class="postDesc">posted @ <span id="post-date">2019-09-15 01:14</span>&nbsp;<a href="https://www.cnblogs.com/Neeo/">听雨危楼</a>&nbsp;阅读(<span id="post_view_count">490</span>)&nbsp;评论(<span id="post_comment_count">0</span>)&nbsp;<a href="https://i.cnblogs.com/EditArticles.aspx?postid=11520952" rel="nofollow">编辑</a>&nbsp;<a href="javascript:void(0)" onclick="AddToWz(11520952);return false;">收藏</a></div>        </div>            </div><!--end: topics 文章、评论容器--></div><script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script><script>markdown_highlight();</script><script>    var allowComments = true, cb_blogId = 356352, cb_blogApp = 'Neeo', cb_blogUserGuid = 'd9c29d9f-8210-4711-e20c-08d49c350eca';    var cb_entryId = 11520952, cb_entryCreatedDate = '2019-09-15 01:14', cb_postType = 2;    loadViewCount(cb_entryId);</script><a name="!comments"></a><div id="blog-comments-placeholder"></div><script>    var commentManager = new blogCommentManager();    commentManager.renderComments(0);</script><div id="comment_form" class="commentform">    <a name="commentform"></a>    <div id="divCommentShow"></div>    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>    <div id="comment_form_container"></div>    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>    <div id="ad_t2"></div>    <div id="opt_under_post"></div>    <div id="cnblogs_c1" class="c_ad_block">        <div id="div-gpt-ad-1592365906576-0" style="width: 300px; height: 250px;"></div>    </div>    <div id="under_post_news"></div>    <div id="cnblogs_c2" class="c_ad_block">        <div id="div-gpt-ad-1592366332455-0" style="width: 468px; height: 60px;"></div>    </div>    <div id="under_post_kb"></div>    <div id="HistoryToday" class="c_ad_block"></div>    <script type="text/javascript">        fixPostBody();        deliverBigBanner();setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverT2();        deliverC1C2();        loadNewsAndKb();        loadBlogSignature();LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);        loadOptUnderPost();        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);    </script></div></div><!--end: forFlow --></div><!--end: mainContent 主体内容容器--><div id="sideBar"><div id="sideBarMain"><div id="sidebar_news" class="newsItem">            <script>loadBlogNews();</script></div><div id="sidebar_ad"></div><div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script><div id="leftcontentcontainer"><div id="blog-sidecolumn"></div>                    <script>loadBlogSideColumn();</script></div></div><!--end: sideBarMain --></div><!--end: sideBar 侧边栏容器 --><div class="clear"></div></div><!--end: main --><div class="clear"></div><div id="footer"><!--done-->Copyright © 2020 听雨危楼<br><span id="poweredby">Powered by .NET Core on Kubernetes</span></div><!--end: footer --></div><!--end: home 自定义的最大容器 -->    <script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/02/pep8/"/>
      <url>2020/10/02/pep8/</url>
      
        <content type="html"><![CDATA[<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p><a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a>规范建议四个空格为语句的缩进块.</p><p>如果要是想让代码往右侧缩进4个，就<code>Tab</code>一次就行了；要是让代码往左侧缩进4个空格，就<code>Shift + Tab</code>就完了.</p><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>Python不建议使用分号！除此之外，也不要用分号连接两条命令</p><h2 id="不要中文符号"><a href="#不要中文符号" class="headerlink" title="不要中文符号"></a>不要中文符号</h2><p>使用<strong>英文状态下</strong>的符号</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>当行注释#xxx</p><p>多行注释 “””  xxx  “””</p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>单引号双引号都一样</p><pre><code>str = "xx'xxxx'"  </code></pre><h2 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h2><p>不超过80字符</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/02/pycharm/pycharm%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/10/02/pycharm/pycharm%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>常用类</strong><br>Alt + #[0-9]打开相应的工具窗口<br>Ctrl + Alt + Y同步<br>Ctrl + Shift + F12最大化编辑开关<br>Alt + Shift + F添加到最喜欢<br>Alt + Shift + I根据配置检查当前文件<br>Ctrl + BackQuote(’)快速切换当前计划<br>Ctrl + Alt + S　打开设置页<br>Ctrl + Shift + A查找编辑器里所有的动作<br>Ctrl + Tab在窗口间进行切换<br>Ctrl + Space 基本的代码完成（类、方法、属性）<br>Ctrl + Alt + Space 类名完成<br>Ctrl + Shift + Enter 语句完成<br>Ctrl + P 参数信息（在方法中调用参数）<br>Ctrl + Q 快速查看文档<br>Shift + F1 外部文档<br>Ctrl + 鼠标 简介<br>Ctrl + F1 显示错误描述或警告信息<br>Alt + Insert 自动生成代码<br>Ctrl + O 重新方法<br>Ctrl + Alt + T 选中<br>Ctrl + / 行注释<br>Ctrl + Shift + / 块注释<br>Ctrl + W 选中增加的代码块<br>Ctrl + Shift + W 回到之前状态<br>Ctrl + Shift + ]/[ 选定代码块结束、开始<br>Alt + Enter 快速修正<br>Ctrl + Alt + L 代码格式化<br>Ctrl + Alt + O 优化导入<br>Ctrl + Alt + I 自动缩进<br>Tab / Shift + Tab 缩进、不缩进当前行<br>Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板<br>Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板<br>Ctrl+V/Shift+Insert 从剪贴板粘贴<br>Ctrl + Shift + V 从最近的缓冲区粘贴<br>Ctrl + D 复制选定的区域或行<br>Ctrl + Y 删除选定的行<br>Ctrl + Shift + J 添加智能线<br>Ctrl + Enter 智能线切割<br>Shift + Enter 另起一行<br>Ctrl + Shift + U 在选定的区域或代码块间切换<br>Ctrl + Delete 删除到字符结束<br>Ctrl + Backspace 删除到字符开始<br>Ctrl + Numpad+/- 展开折叠代码块<br>Ctrl + Numpad+ 全部展开<br>Ctrl + Numpad- 全部折叠<br>Ctrl + F4 关闭运行的选项卡</p><p><strong>运行类</strong><br>Alt + Shift + F10 运行模式配置<br>Alt + Shift + F9 调试模式配置<br>Shift + F10 运行<br>Shift + F9 调试<br>Ctrl + Shift + F10 运行编辑器配置<br>Ctrl + Alt + R 运行manage.py任务</p><p><strong>调试类</strong><br>F8 跳过<br>F7 进入<br>Shift + F8 退出<br>Alt + F9 运行游标<br>Alt + F8 验证表达式<br>Ctrl + Alt + F8 快速验证表达式<br>F9 恢复程序<br>Ctrl + F8 断点开关<br>Ctrl + Shift + F8 查看断点</p><p><strong>导航类</strong><br>Ctrl + N 跳转到类<br>Ctrl + Shift + N 跳转到符号<br>Alt + Right/Left 跳转到下一个、前一个编辑的选项卡<br>F12 回到先前的工具窗口<br>Esc 从工具窗口回到编辑窗口<br>Shift + Esc 隐藏运行的、最近运行的窗口<br>Ctrl + Shift + F4 关闭主动运行的选项卡<br>Ctrl + G 查看当前行号、字符号<br>Ctrl + E 当前文件弹出<br>Ctrl+Alt+Left/Right 后退、前进<br>Ctrl+Shift+Backspace 导航到最近编辑区域<br>Alt + F1 查找当前文件或标识<br>Ctrl+B / Ctrl+Click 跳转到声明<br>Ctrl + Alt + B 跳转到实现<br>Ctrl + Shift + I查看快速定义<br>Ctrl + Shift + B跳转到类型声明<br>Ctrl + U跳转到父方法、父类<br>Alt + Up/Down跳转到上一个、下一个方法<br>Ctrl + ]/[跳转到代码块结束、开始<br>Ctrl + F12弹出文件结构<br>Ctrl + H类型层次结构<br>Ctrl + Shift + H方法层次结构<br>Ctrl + Alt + H调用层次结构<br>F2 / Shift + F2下一条、前一条高亮的错误<br>F4 / Ctrl + Enter编辑资源、查看资源<br>Alt + Home显示导航条F11书签开关<br>Ctrl + Shift + F11书签助记开关<br>Ctrl + #[0-9]跳转到标识的书签<br>Shift + F11显示书签</p><p><strong>查找/替换类</strong><br>F3 下一个<br>Shift + F3 前一个<br>Ctrl + R 替换<br>Ctrl + Shift + F 全局查找<br>Ctrl + Shift + R 全局替换</p><p><strong>搜索类</strong></p><p>Alt + F7/Ctrl + F7文件中查询用法<br>Ctrl + Shift + F7文件中用法高亮显示<br>Ctrl + Alt + F7显示用法</p><p><strong>重构类</strong></p><p>F5复制F6剪切<br>Alt + Delete安全删除<br>Shift + F6重命名<br>Ctrl + F6更改签名<br>Ctrl + Alt + N内联<br>Ctrl + Alt + M提取方法<br>Ctrl + Alt + V提取属性<br>Ctrl + Alt + F提取字段<br>Ctrl + Alt + C提取常量<br>Ctrl + Alt + P提取参数</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/01/hello-world/"/>
      <url>2020/10/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+GitHub图床</title>
      <link href="2019/12/01/github/PicGo+GitHub%E5%9B%BE%E5%BA%8A/"/>
      <url>2019/12/01/github/PicGo+GitHub%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种<strong>“轻量级标记语言”</strong>。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：<strong>Typora</strong>和<strong>马克飞象</strong>。</p><p>目前我是两款编辑器混合时候，当编写的Markdown文档需要和印象笔记对接的时候，则使用马克飞象；至于其他用途的文档就使用Typora。则两款编辑器都<strong>近乎完美但是却又不能达到完美</strong>。我写文档的时候经常需要截图，然后从剪贴板从直接黏贴放进文档，则两款编辑器虽然都能满足这种操作，但是其实现原理不过是<strong>将截图存放在本机电脑上</strong>，所以，一旦文档中有了截图，将Markdown文档的迁移到别的电脑上展示的成本就大大增加（图片也要一并复制过去）。</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-7f243dd5df471fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/693/format/webp" alt="img"></p><p>这是Typora对图片的解决方案</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-4871e650d1bbb1ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/283/format/webp" alt="img"></p><p>这是马克飞象中对图片的解决方案</p><p>这两款编辑器对图片处理的方法简直是丧尽天良，也是我在使用过程中唯一觉得不爽的一点。辛苦搜寻之下，终于让我找到了一种解决方案：<strong>PicGo+GitHub图床</strong></p><blockquote><p>注：实际上，Mac OS 上的Typora编辑器已经支持将本地图片或者截图先上传到服务器生成访问链接后，在存放到Markdown文档中，简单点说，Mac OS上的Typora是完美的（😭无奈我是Windows用户）</p></blockquote><h1 id="PicGo介绍"><a href="#PicGo介绍" class="headerlink" title="PicGo介绍"></a><a href="https://github.com/Molunerfinn/PicGo">PicGo介绍</a></h1><p>这是一款图片上传的工具，目前支持<code>微博图床</code>，<code>七牛图床</code>，<code>腾讯云</code>，<code>又拍云</code>，<code>GitHub</code>等图床，未来将支持更多图床。</p><p>所以解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪😊。</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-a818a6851f18d336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><p>Pic Go支持的图床</p><p>在众多的图床中，我选择的GitHub图床，其它类型的图床如果你们有兴趣的话可以试一下。</p><h1 id="创建自己的GitHub图床"><a href="#创建自己的GitHub图床" class="headerlink" title="创建自己的GitHub图床"></a>创建自己的GitHub图床</h1><h2 id="1-创建GitHub图床之前，需要注册-登陆GitHub账号"><a href="#1-创建GitHub图床之前，需要注册-登陆GitHub账号" class="headerlink" title="1. 创建GitHub图床之前，需要注册/登陆GitHub账号"></a>1. 创建GitHub图床之前，需要注册/登陆GitHub账号</h2><blockquote><p>申请GitHub账号很简单，我就不演示了</p></blockquote><h2 id="2-创建Repository"><a href="#2-创建Repository" class="headerlink" title="2. 创建Repository"></a>2. 创建Repository</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-25f1990a188f9103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>点击”New repository”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-596d8282a217da7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1097/format/webp" alt="img"></p><p>最后1234步骤执行</p><blockquote><ul><li>我已经建立过一个同名的repository的，所以第一步会显示红色</li><li>第三步，为repository初始化一个README.md文件可以根据需求选择，非必选</li></ul></blockquote><h2 id="3-生成一个Token用于操作GitHub-repository"><a href="#3-生成一个Token用于操作GitHub-repository" class="headerlink" title="3.生成一个Token用于操作GitHub repository"></a>3.生成一个Token用于操作GitHub repository</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-69a2b38f4634e509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>回到主页，点击”Settings”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-833a01142ad92e6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1060/format/webp" alt="img"></p><p>进入页面后，点击”Developer settings”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-3ba67ab9f5224bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>点击”Personal access tokens”按钮</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-8d67725f463f5fc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>创建新的Token</p><p><img src="https://upload-images.jianshu.io/upload_images/3146329-2cddeffa8fe35933.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1123/format/webp" alt="img"></p><p>填写描述，选择”repo”,然后点击”Generate token”按钮</p><blockquote><p>注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存</p></blockquote><h1 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h1><h2 id="1-下载运行PicGo"><a href="#1-下载运行PicGo" class="headerlink" title="1. 下载运行PicGo"></a>1. 下载运行PicGo</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-9fe439e9625c741f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1077/format/webp" alt="img"></p><p>下载zip包后，解压，运行可执行文件</p><h2 id="2-配置图床"><a href="#2-配置图床" class="headerlink" title="2. 配置图床"></a>2. 配置图床</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-33b10cfcc147cdc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><p>如图配置</p><blockquote><ul><li>设定仓库名的时候，是按照“账户名/仓库名的格式填写”</li><li>分支名统一填写“master”</li><li>将之前的Token黏贴在这里</li><li>存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹</li><li>自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上<code>https://raw.githubusercontent.com/用户名/RepositoryName/分支名，</code>，自定义域名需要按照这样去填写</li></ul></blockquote><h2 id="3-快捷键及相关配置"><a href="#3-快捷键及相关配置" class="headerlink" title="3.快捷键及相关配置"></a>3.快捷键及相关配置</h2><p><img src="https://upload-images.jianshu.io/upload_images/3146329-8d2c2729e4f16fd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><p>可以按照这样配置</p><blockquote><p>注：可以将快捷键设置为<code>ctrl+shift+c</code></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>将上面的步骤都设置好之后，就可以让自己的Markdown文档飞起来了，每次截图之后，都可以按一下<code>ctrl+shift+c</code>，这样就会将剪切板上面的截图转化为在线网络图片链接，简直就是爽的不要不要的！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="2019/11/16/Elasticsearch/es/"/>
      <url>2019/11/16/Elasticsearch/es/</url>
      
        <content type="html"><![CDATA[<p>博客:<a href="https://www.cnblogs.com/Neeo">https://www.cnblogs.com/Neeo</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法</title>
      <link href="2019/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/sf/"/>
      <url>2019/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/sf/</url>
      
        <content type="html"><![CDATA[<p>博客:<a href="https://www.cnblogs.com/bobo-zhang/category/1417180.html">https://www.cnblogs.com/bobo-zhang/category/1417180.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫</title>
      <link href="2019/11/16/%E7%88%AC%E8%99%AB/pc/"/>
      <url>2019/11/16/%E7%88%AC%E8%99%AB/pc/</url>
      
        <content type="html"><![CDATA[<p>博客:<a href="https://www.cnblogs.com/bobo-zhang/">https://www.cnblogs.com/bobo-zhang/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化运维ansible</title>
      <link href="2019/11/16/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E9%A1%B9%E7%9B%AE/zdhyw/"/>
      <url>2019/11/16/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E9%A1%B9%E7%9B%AE/zdhyw/</url>
      
        <content type="html"><![CDATA[<p>博客:<a href="https://blog.51cto.com/wangfeng7399">https://blog.51cto.com/wangfeng7399</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DjangoRestFramework + VUE 项目</title>
      <link href="2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E7%8E%A9%E5%85%B7/znwj/"/>
      <url>2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E7%8E%A9%E5%85%B7/znwj/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/DragonFire/p/10356615.html">Celery - 一个懂得 异步任务 , 定时任务 , 周期任务 的芹菜</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9498396.html">DBUtils - Python数据库连接池</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260299.html">Flask最强攻略 - 跟DragonFire学Flask - 第八篇 实例化Flask的参数 及 对app的配置</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9255637.html">Flask最强攻略 - 跟DragonFire学Flask - 第二篇 Flask 中的 Render Redirect HttpResponse</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9264381.html">Flask最强攻略 - 跟DragonFire学Flask - 第九篇 Flask 中的蓝图(BluePrint)</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260228.html">Flask最强攻略 - 跟DragonFire学Flask - 第六篇 Flask 中内置的 Session</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260295.html">Flask最强攻略 - 跟DragonFire学Flask - 第七篇 Flask 中路由系统</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9259395.html">Flask最强攻略 - 跟DragonFire学Flask - 第三篇 Flask 中的 request 之 先知道有这么个东西</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10365963.html">Flask最强攻略 - 跟DragonFire学Flask - 第十六篇 Flask-Migrate</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9269303.html">Flask最强攻略 - 跟DragonFire学Flask - 第十篇 before_request after_request</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10363353.html">Flask最强攻略 - 跟DragonFire学Flask - 第十四篇 Flask-SQLAlchemy</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10365827.html">Flask最强攻略 - 跟DragonFire学Flask - 第十五篇 Flask-Script</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9259999.html">Flask最强攻略 - 跟DragonFire学Flask - 第四篇 Flask 中的模板语言 Jinja2 及 render_template 的深度用法</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9260124.html">Flask最强攻略 - 跟DragonFire学Flask - 第五篇 做一个用户登录之后查看学员信息的小例子</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9254637.html">Flask最强攻略 - 跟DragonFire学Flask - 第一篇 你好,我叫Flask</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/10166527.html">SQLAlchemy 增删改查 一对多 多对多</a></p><p><a href="https://www.cnblogs.com/DragonFire/p/9788927.html">websocket 工作原理</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DjangoRestFramework + VUE 项目</title>
      <link href="2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E5%9F%8E/lf/"/>
      <url>2019/11/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E5%9F%8E/lf/</url>
      
        <content type="html"><![CDATA[<p>VUE学习目录:<a href="https://www.cnblogs.com/clschao/articles/10706528.html">https://www.cnblogs.com/clschao/articles/10706528.html</a></p><p>DjangoRestFramework学习:</p><p><a href="https://www.cnblogs.com/clschao/articles/10709740.html">https://www.cnblogs.com/clschao/articles/10709740.html</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10711600.html">https://www.cnblogs.com/clschao/articles/10711600.html</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10732867.html">https://www.cnblogs.com/clschao/articles/10732867.html</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10746758.html">Django学习之django自带的contentType表:</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10757374.html">python时间类型转换</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10759183.html">redis简单操作</a></p><p><a href="https://www.cnblogs.com/clschao/articles/10745966.html">跨域和CORS</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之文档与目录结构</title>
      <link href="2019/11/15/Linux/Linux%E4%B9%8B%E6%96%87%E6%A1%A3%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>2019/11/15/Linux/Linux%E4%B9%8B%E6%96%87%E6%A1%A3%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux之文档与目录结构"><a href="#Linux之文档与目录结构" class="headerlink" title="Linux之文档与目录结构"></a><a href="https://www.cnblogs.com/pyyu/p/9213237.html">Linux之文档与目录结构</a></h1><h1 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h1><p>Linux目录结构的组织形式和Windows有很大的不同。首先Linux没有“盘(C盘、D盘、E盘)”的概念。已经建立文件系统的硬盘分区被挂载到某一个目录下，用户通过操作目录来实现磁盘读写。</p><p>Linux不像Windows那样的系统目录，Linux使用正斜杠”/“而不是反斜杠”"来标识目录。</p><p>Windows目录：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622134224409-1941390599.png" alt="img"></p><p>Linux目录：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622134328724-1952764525.png" alt="img"></p><p>Linux首先是建立一个根”/“文件系统，所有的目录也都是由根目录衍生出来。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719224707794-816913824.png" alt="img"></p><p>登录系统后，在当前命令窗口输入命令:</p><pre><code>ls /</code></pre><p>查看结果如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622134847306-163954950.png" alt="img"></p><p>在Linux底下，所有的文件与目录都是由根目录开始，是目录与文件的源头，然后一个个的分支下来，如同树枝状，因此称为这种目录配置为：目录树。</p><p>目录树的特点是什么呢？</p><ul><li>目录树的起始点是根目录(/,root);</li><li>每一个目录不止能使用本地的文件系统，也可以使用网络上的文件系统，可以利用NFS服务器挂载特定目录。</li><li>每一个文件在此目录树中的文件名，包含完整路径都是独一无二的。</li></ul><h2 id="目录树架构示意图"><a href="#目录树架构示意图" class="headerlink" title="目录树架构示意图"></a>目录树架构示意图</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180823103948862-1376998015.png" alt="img"></p><p>以下是对这些目录的解释：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180921150307683-759085586.png" alt="img"></p><ul><li><p><strong>/bin</strong>：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><strong>/dev ：</strong><br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><strong>/home</strong>：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li><li><p><strong>/lib</strong>：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>/media</strong>：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>/opt</strong>：<br> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>/proc</strong>：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></pre></li><li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>/sbin</strong>：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/selinux</strong>：<br> 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li><li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>/sys</strong>：<br> 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p><p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</p></li></ul><p>  该文件系统是内核设备树的一个直观反映。</p><p>  当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><ul><li><p><strong>/tmp</strong>：<br>这个目录是用来存放一些临时文件的。</p></li><li><p><strong>/usr</strong>：<br> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p></li><li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p></li><li><p><strong>/var</strong>：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li></ul><p>在linux系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p><p>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。</p><p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。</p><p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。</p><h1 id="为什么要学习linux命令"><a href="#为什么要学习linux命令" class="headerlink" title="为什么要学习linux命令"></a>为什么要学习linux命令</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322164008764-1025212772.png" alt="img"></p><p><strong>当年超哥在一家美资企业，一位台湾老程序员送我的一本书。。。</strong></p><p><strong>可能是看我骨骼惊奇吧！！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322164133605-1830349359.png" alt="img"></p><h1 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322164249397-825723345.png" alt="img"></p><p>我们知道切换目录的指令是cd，那么首先得知道如何切换目录，这个得用心记呀！</p><pre><code>.    当前目录..    上一层目录-    前一个工作目录~    当前【用户】所在的家目录</code></pre><p>需要注意的是，在所有目录底下都存在两个目录，分别是【.】和【..】，分别代表当前目录，上层目录！那么如何证明它的存在呢？</p><pre><code>命令： ls -la /查看命令解释：man ls  (Linux下的帮助指令)结论：ls - list directory contens (列出目录内容)ls -la /  以竖状格式化显示列出/目录所有内容</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716132338853-107586297.png" alt="img"></p><p>接下来看一下常用的目录处理指令：</p><pre><code>cd : (change directory,更改目录)pwd:(显示当前目录)mkdir:(建立一个新目录)rmdir:（删除一个空目录）</code></pre><h1 id="cd命令，变换目录"><a href="#cd命令，变换目录" class="headerlink" title="cd命令，变换目录"></a>cd命令，变换目录</h1><p>cd是change directory的缩写，这是用来变换工作目录的命令，注意命令和目录之间有一个空格。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716134328013-1031650900.png" alt="img"></p><h1 id="mkdir，建立新目录"><a href="#mkdir，建立新目录" class="headerlink" title="mkdir，建立新目录"></a>mkdir，建立新目录</h1><p>mkdir是make directory的缩写，用来建立新目录，在默认情况下，目录得一级一级的建立。</p><p>例如我要建立/home/oldboy/python目录，我就必须有/home，然后/home/oldboy，最后/home/oldboy/python，如果没有/home/oldboy，则不能建立python目录！</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716142641730-1625463100.png" alt="img"></p><p> 可见高效的创建目录用上-p参数，可以直接执行命令【mkdir -p /home/oldboy/python】，系统会自动添加上/home，/home/oldboy，/home/oldboy/python依次建立目录，是不是很方便，^ ^ </p><h1 id="rmdir，删除空目录"><a href="#rmdir，删除空目录" class="headerlink" title="rmdir，删除空目录"></a>rmdir，删除空目录</h1><p>当我想删除一个空目录时，就用rmdir吧，例如我想删除刚才建立的oldboy目录，以及/tmp/oldboy/python,那么可以使用【rmdir oldboy】，但是注意rmdir只能删除空目录。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180717231355821-689929245.png" alt="img"></p><pre><code>删除命令可以正确使用【rm -rf】</code></pre><h1 id="Linux的路径PATH"><a href="#Linux的路径PATH" class="headerlink" title="Linux的路径PATH"></a>Linux的路径PATH</h1><p>同学们应该都会配置windows下的环境变量（PATH），都知道系统会按照PATH的设定，去每个PATH定义的目录下搜索可执行文件。</p><p>那么如何查看Linux下的PATH环境变量呢？</p><pre><code>执行命令：echo $PATHecho命令是有打印的意思$符号后面跟上PATH,表示输出PATH的变量</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180717232700721-1562018264.png" alt="img"></p><p>PATH(一定是大写的)这个变量是由一堆目录组成，分隔符是”:”号，而不同于windows的”;”号。</p><h1 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h1><p>Linux中非常重要的概念–路径，路径用来定位如何找到某个文件。</p><p>这里超哥先讲个例子，到底什么是相对路径，绝对路径</p><p>比如一个老外，要来老男孩教育学习python，但是他找不到地点，因此向你问路，你可以告诉他：</p><p>　  　1.先坐飞机来中国北京，从北京机场坐地铁到沙河地铁站，然后走路800米到沙河汇德商厦，上四楼，找到超哥，结束寻路。</p><p>　　2. 超哥就在汇德商厦403办公室，武佩奇后面坐着呢！！！</p><p>Linux下特别注意文件名/路径的写法，可以将所谓的路径(path)定义为绝对路径(absolute)和相对路径(relative)。这两种文件名/路径的写法依据是这样的：</p><ul><li>绝对路径：由根目录(/)为开始写起的文件名或者目录名称，如/home/oldboy/test.py;</li><li>相对路径：相对于目前路径的文件名写法。例如./home/oldboy/exam.py或../../home/oldboy/exam.py，简单来说只要开头不是/，就是属于相对路径</li></ul><p>因此你必须了解，相对路径是：以你当前所在路径的相对路径来表示的。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622140257547-1356616310.png" alt="img"></p><p>例如你现在在/home 这个目录下，如要进入/var/log这个路径，如何写呢？</p><ol><li>cd /var/log (绝对路径)</li><li>cd ../var/log(相对路径)</li></ol><p>结果如图：</p><p>因为你在/home底下，因此你要回到上一层(../)之后，才能继续前往/var，特别注意：</p><ul><li>.   :代表当前的目录，也可以用./ 来表示</li><li>..  :代表上一层的目录，也可以用../来表示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622140612606-771359419.png" alt="img"></p><p>分割线—-</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180622140823060-347310504.png" alt="img"></p><p>这个.与..目录概念非常重要，平时经常会看到cd ..或者python ../home/oldboy/exam.py 就是代表进入上一层与执行相对路径的python代码！</p><pre><code>1.linux是以 / 开始的树状目录结构,tree查看2.常用文件目录操作命令是ls,cd,mkdir,rmdir3.Linux的PATH查看是 echo $PATH，可以修改/etc/profile文件永久生效,以冒号分割4.绝对路径,相对路径的查看5.文件权限chmod chgrp chown</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322172711042-37362360.png" alt="img"></h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322172929688-1107644884.png" alt="img"></p><h1 id="Linux的文件系统"><a href="#Linux的文件系统" class="headerlink" title="Linux的文件系统"></a>Linux的文件系统</h1><p>用户在硬件存储设备中执行的文件建立，写入，读取，修改，转存与控制等操作都是依赖文件系统完成的。文件系统的作用是合理规划硬盘，保证用户正常使用。</p><p>Linux系统支持数十种文件系统，常见文件系统如下。</p><ul><li>Ext3    是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能 自动修复数据的不一致与错误。</li><li>Ext4     Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，它支持的存储容 量高达 1EB(1EB=1,073,741,824GB)，且能够有无限多的子目录。另外，Ext4 文件系统能够批量分配 block 块，从而极大地提高了读写效率。</li><li>XFS     是一种高性能的日志文件系统，而且是 RHEL 7 中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的 日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为 18EB， 这几乎满足了所有需求。</li></ul><pre><code>/etc/fstab是用来存放文件系统的静态信息的文件cat /etc/fstab #检查linux的文件系统</code></pre><p>练习</p><pre><code>1.在/home/目录创建文件夹oldboy,进入oldboy创建helloLinux.txt2.创建/tmp/chaogeLinux.txt，用绝对路径方式与相对路径两种方法3.在/tmp/目录下创建chaogeDir目录4.查看linuxPATH5.修改chaogeLinux.txt文件属主是chaoge,权限是可读可写</code></pre><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程实战</title>
      <link href="2019/11/15/Linux/Shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%20/"/>
      <url>2019/11/15/Linux/Shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%20/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell编程实战"><a href="#Shell编程实战" class="headerlink" title="Shell编程实战"></a><a href="https://www.cnblogs.com/pyyu/p/9552661.html">Shell编程实战</a></h1><h1 id="为什么要学习Shell编程"><a href="#为什么要学习Shell编程" class="headerlink" title="为什么要学习Shell编程"></a>为什么要学习Shell编程</h1><p>Shell脚本语言是实现Linux/Unix系统管理及自动化运维所必须的重要工具，Linux系统的底层以及基础应用软件的核心大都涉及Shell脚本的内容。</p><p>一个合格的Linux系统管理员都必须熟练编写Shell脚本语言，从而提升运维人员的工作效率，减少不必要的重复性工作。</p><h2 id="学习Shell所需的基础知识"><a href="#学习Shell所需的基础知识" class="headerlink" title="学习Shell所需的基础知识"></a>学习Shell所需的基础知识</h2><p><strong>熟练使用VIm编辑器，熟悉SSH终端等配置</strong></p><p>在Linux下开发shell脚本用的最多的就是vim编辑器，熟练使用vim可以使得shell脚本开发事半功倍！</p><p><strong>有一定的Linux命令基础，熟练掌握80个命令以上</strong></p><p>shell和其他脚本语言不同，如python，Shell缺少可以直接使用的外部函数库，因此Linux系统的命令就可以当做Shell的函数库！</p><p><strong>熟悉常见Linux服务部署，优化，分析与排错</strong></p><p>学习Shell直接的目的是在工作中对系统以及服务进行自动化管理，因此如果不熟悉服务操作，使用shell也就没有意义了</p><h1 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180829102203128-345530932.png" alt="img"></p><p>Shell存在于操作系统的最外层，负责与用户直接对话，把用户的输入解释给操作系统，处理操作系统的输出结果，然后反馈给用户。</p><p>Shell是一个命令解释器，它的作用是解释并执行用户输入的命令和程序等，用户每输入一条命令，Shell解释器就执行一条，存在一种交互的方式。</p><p>从开机准备输入用户名和密码，到登录成功，所有的操作都是Shell解释并执行的。</p><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2><p>当命令或者程序语句不是在命令行中执行，而是通过一个程序文件来执行时，这个程序就称作Shell脚本。</p><p><strong>一个简单的Shell脚本</strong></p><p>清除/var/log下的messages日志文件</p><p>把所有命令放入一个文件，堆积起来后就是一个脚本文件！注意文件的可执行权限，与用户身份</p><pre><code>#清除脚本日志cd /var/logcat /dev/null &gt; messagesecho "Logs cleaned up . done"</code></pre><h2 id="Shell脚本语言的种类"><a href="#Shell脚本语言的种类" class="headerlink" title="Shell脚本语言的种类"></a>Shell脚本语言的种类</h2><pre><code>Shell脚本语言是弱类型语言（无须定义变量的类型即可使用）在Linux中有两大Shell，一是Bourne shell，二是C shell我们需要知道的就是标准的Bourne Again shell(bash)所取代查看CentOS 7系统的Shell</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180829104819001-1048787426.png" alt="img"></p><p>其他的脚本语言</p><pre><code>phpPerlPython</code></pre><p>语言选择</p><pre><code>Shell脚本语言优势在于处理系统底层的业务，基于linux命令处理也是最快的，常用语开发自动化安装，监控报警，软件启动等脚本。</code></pre><h2 id="第一个Shell脚本与hello-world"><a href="#第一个Shell脚本与hello-world" class="headerlink" title="第一个Shell脚本与hello world"></a>第一个Shell脚本与hello world</h2><p>脚本开头</p><pre><code>一个规范的脚本文件会在第一行指出由哪个程序来执行脚本的内容，必须位于第一行！！！如果你不加默认也会交给bash解释，良好的编程习惯，最好加上开头解释器语言标识#!/bin/bash#!/usr/bin/env python</code></pre><h2 id="执行Shell脚本的方式"><a href="#执行Shell脚本的方式" class="headerlink" title="执行Shell脚本的方式"></a>执行Shell脚本的方式</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>bash 脚本名sh    脚本名此方法是脚本没有可执行权限时，或者文件头没指定解释器时用的方法path/scriptName./scriptName 此方法需要脚本有可执行权限，chmod +x scriptNamesource scriptName. scriptName加载并执行脚本文件中的命令和语句</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python /tmp 11:10:08]#sh test.shchaoge nb[root@oldboy_python /tmp 11:10:18]#cat test.sh#!/bin/bashecho 'chaoge nb'[root@oldboy_python /tmp 11:10:21]#. test.shchaoge nb[root@oldboy_python /tmp 11:10:33]#source  test.shchaoge nb#添加可执行权限给test.shchmod +x test.sh./test.sh</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><pre><code>环境变量一般指的是export内置命令导出的变量，用于定义SHell的运行环境。Shell通过环境变量来确定命令提示符，也就是超哥前面说的PS1变量环境变量可以在命令行中设置和创建，但是用户退出命令行时变量值就会丢失，因此可以写入/etc/profile文件中，每次用户登录时，变量都会被初始化！环境变量名字均大写，用env查看</code></pre><p>设置登录的提示</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 11:21:51]#cat /etc/motd'welcome chaoge bakcome~~~~~~~~~'</code></pre><p>yudanL:~ yuchao$ ssh <a href="mailto:root@192.168.11.11">root@192.168.11.11</a><br>Last failed login: Wed Aug 29 11:20:20 CST 2018 from 111.231.199.24 on ssh:notty<br>There were 25 failed login attempts since the last successful login.<br>Last login: Wed Aug 29 10:45:51 2018 from 223.72.74.11<br>‘welcome chaoge bakcome<del>~</del>`’</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>定义变量</p><p>变量定义的注意点</p><ul><li>变量名和等号之间不能有空格</li><li>命名只能用英文字母，数字，下划线，首个字符不能用数字</li><li>不能用标点符号</li><li>不能用关键字</li></ul><pre><code>name='chaoge'echo $nameecho ${name} #帮助解释器识别变量的边界#变量重新赋值name='chaogenb'</code></pre><p>设置只读变量</p><pre><code>[root@oldboy_python ~ 11:29:31]#readonly name[root@oldboy_python ~ 11:30:27]#name='chaogenb3'-bash: name: 只读变量</code></pre><p>删除变量</p><pre><code>unset name</code></pre><p>变量类型</p><ul><li>局部变量 在脚本或命令中定义，仅在当前shell有效</li><li>环境变量 所有的程序，shell程序都能访问环境变量</li><li>shell变量 特殊变量 既有环境变量 又有局部变量</li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串可以用单引号，也可以双引号，也可以没引号</p><pre><code>[root@oldboy_python ~ 11:42:42]#addr='shahe'[root@oldboy_python ~ 11:44:55]#echo $addrshahe</code></pre><p>单引号的任何字符串都会原样输出，单引号字符串中的变量无效</p><p>单引号字符串不能出现单一的单引号，转义符也不可用，可用作字符串拼接</p><p>双引号</p><p>双引号里可以用变量</p><p>双引号可以有转义符</p><pre><code>[root@oldboy_python ~ 11:45:01]#addr='changpingshahe'[root@oldboy_python ~ 11:48:06]#name='yuchao'[root@oldboy_python ~ 11:49:00]#message="Hello,${name},Your addr is \"${addr}\" "[root@oldboy_python ~ 11:50:05]#echo $messageHello,yuchao,Your addr is "changpingshahe"</code></pre><p> 获取字符串长度</p><pre><code>[root@oldboy_python ~ 13:36:35]#str='abc'[root@oldboy_python ~ 13:36:49]#echo ${#str}3</code></pre><p>切片操作</p><p>左闭又开规则</p><pre><code>[root@oldboy_python ~ 13:39:45]#str='I am chaoge,hello world!'#取出0和10索引的字符[root@oldboy_python ~ 13:40:42]#echo ${str:0:11}I am chaoge</code></pre><p>查找字符索引</p><pre><code>[root@oldboy_python ~ 13:45:02]#str='I am chaoge,hello world!'[root@oldboy_python ~ 13:46:20]#echo `expr index "$str" e`11</code></pre><pre><code></code></pre><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装之python开发</title>
      <link href="2019/11/15/Linux/Ubuntu%E5%AE%89%E8%A3%85%E4%B9%8Bpython%E5%BC%80%E5%8F%91/"/>
      <url>2019/11/15/Linux/Ubuntu%E5%AE%89%E8%A3%85%E4%B9%8Bpython%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu安装之python开发"><a href="#Ubuntu安装之python开发" class="headerlink" title="Ubuntu安装之python开发"></a><a href="https://www.cnblogs.com/pyyu/p/9900100.html">Ubuntu安装之python开发</a></h1><p>什么？？公司要用Ubuntu(乌班图)？不会用？？怎么进行python开发？？？ </p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181102234826274-1090648545.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181103110824916-662123880.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181103110854741-1122135979.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181103110906518-1242690910.png" alt="img"></p><pre><code>乌班图操作系统下载地址：http://releases.ubuntu.com/18.04/ubuntu-18.04.1-desktop-amd64.iso</code></pre><p>  安装ubuntu</p><h2 id="第一步：准备好vmware虚拟机"><a href="#第一步：准备好vmware虚拟机" class="headerlink" title="第一步：准备好vmware虚拟机"></a>第一步：准备好vmware虚拟机</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113165258990-1315543038.png" alt="img">自行解决。。。</p><h2 id="第二步：安装ubuntu"><a href="#第二步：安装ubuntu" class="headerlink" title="第二步：安装ubuntu"></a>第二步：安装ubuntu</h2><p>[**详细安装过程**](<a href="https://www.cnblogs.com/pyyu/p/%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">https://www.cnblogs.com/pyyu/p/详细安装过程</a>  <a href="https://blog.csdn.net/u013142781/article/details/50529030">https://blog.csdn.net/u013142781/article/details/50529030</a>)</p><p>[**<a href="https://blog.csdn.net/u013142781/article/details/50529030**]">https://blog.csdn.net/u013142781/article/details/50529030**]</a>(<a href="https://www.cnblogs.com/pyyu/p/%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">https://www.cnblogs.com/pyyu/p/详细安装过程</a>  <a href="https://blog.csdn.net/u013142781/article/details/50529030">https://blog.csdn.net/u013142781/article/details/50529030</a>)</p><pre><code>1.设置好用户的账号密码2.可以自行通过sudo su - 切换root用户3.学习ubuntu相关命令</code></pre><p><strong>需要注意vmware和ubuntu的兼容性</strong> </p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181116090244808-1235344275.png" alt="img"></h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181116090251677-591155084.png" alt="img"></p><p> 然后安装</p><h2 id="第三步：安装pycharm"><a href="#第三步：安装pycharm" class="headerlink" title="第三步：安装pycharm"></a>第三步：安装pycharm</h2><pre><code>pycharm之linux版本下载地址：https://download.jetbrains.8686c.com/python/pycharm-community-2018.2.4.tar.gz</code></pre><p>下载好后查看</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113175052930-1118218842.png" alt="img"></p><p>解压缩pycharm</p><pre><code>yuchao@ubuntu:/tmp$ tar zxvf pycharm-professional-2018.2.4.tar.gz </code></pre><p>解压缩后进入文件夹</p><pre><code>cd /tmp/pycharm-2018.2.4/bin</code></pre><p>执行脚本，启动pycharm</p><pre><code> source pycharm.sh</code></pre><h2 id="第四步：配置桌面快捷启动pycharm"><a href="#第四步：配置桌面快捷启动pycharm" class="headerlink" title="第四步：配置桌面快捷启动pycharm"></a>第四步：配置桌面快捷启动pycharm</h2><ol><li>在桌面创建一个文本文件，名为Pycharm.desktop</li><li>在文件中添加内容</li></ol><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[Desktop Entry]Version=1.0Type=ApplicationName=PycharmIcon=/home/yuchao/Downloads/pycharm-professional-2018.2.4/pycharm-2018.2.4/bin/pycharm.pngExec=/home/yuchao/Downloads/pycharm-professional-2018.2.4/pycharm-2018.2.4/bin/pycharm.shMimeType=application/x-py;Name[en_US]=pycharm</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180101050-1773939019.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180146241-1107980216.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180156223-1099359137.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181113180218672-58584960.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware与Centos系统安装</title>
      <link href="2019/11/15/Linux/VMware%E4%B8%8ECentos%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
      <url>2019/11/15/Linux/VMware%E4%B8%8ECentos%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="VMware与Centos系统安装"><a href="#VMware与Centos系统安装" class="headerlink" title="VMware与Centos系统安装"></a><a href="https://www.cnblogs.com/pyyu/articles/9313587.html">VMware与Centos系统安装</a></h1><h1 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h1><pre><code>1.Linux发行版的选择2.vmware创建一个虚拟机(centos)3.安装配置centos74.xshell配置连接虚拟机(centos)</code></pre><h1 id="选择性"><a href="#选择性" class="headerlink" title="选择性"></a>选择性</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>pc可以选择    -纯系统 Linux/windows    -双系统    Windows+Linux    -虚拟化技术    Windows+vmware workstation服务器    -物理机纯系统    -物理机+vmware（vmware esxi）    -物理机+docker安装    -简易安装    -自定义安装    -快照</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="下载centos系统ISO镜像"><a href="#下载centos系统ISO镜像" class="headerlink" title="下载centos系统ISO镜像"></a>下载centos系统ISO镜像</h1><p>要安装centos系统，就必须得有centos系统软件安装程序，可以通过浏览器访问centos官网<a href="http://www.centos.org,然后找到downloads/">http://www.centos.org，然后找到Downloads</a>  - &gt;  mirrors链接，点击后进入下载，但是由于这是国外的网址，下载速度肯定受限。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715143157429-375252113.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715143401449-1969739566.png" alt="img"></p><p>因此可以使用国内的镜像源</p><pre><code>https://opsx.alibaba.com/mirror#阿里云官方镜像站iso下载地址（此DVD映像包含可以使用该软件安装的所有软件包安装程序。这是大多数用户的推荐图像。）：https://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1804.iso</code></pre><p>为什么要选择64位操作系统？</p><pre><code>目前绝大多数生产环境，使用的都是64位操作Centos操作系统</code></pre><p>32位与64位系统的定位与区别？</p><pre><code>64位操作系统的设计定位是：满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域，这些领域共同特性就是需要大量的系统内存。32位操作系统是为普通用户设计的。</code></pre><p>区别二：</p><pre><code>64位操作系统只能安装在64位（cpu必须是64位的）电脑上（cpu必须是64位的），并且只针对64位的软件才能发挥其最佳的性能。32位操作系统既可以安装在32位（32位cpu）电脑上，也可以安装在64位电脑上。当然了32位操作系统是无法发挥出64位硬件性能的。</code></pre><p>区别三: 运算速度</p><pre><code>64位---&gt; 8车道大马路32位---&gt; 4车道马路</code></pre><p>区别四：支持的最大内存不同</p><pre><code>32位系统---&gt;4GB内存只能用3.5Gb64位系统 支持更大内存</code></pre><h1 id="安装VMware虚拟机"><a href="#安装VMware虚拟机" class="headerlink" title="安装VMware虚拟机"></a>安装VMware虚拟机</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>vmware是什么？有了这个软件，大家就不需要为了学习linux特意再去买一台电脑了，虚拟机能让用户在一台机器上模拟出多个操作系统的软件，一般的机器配置足够胜任虚拟机的任务。虚拟机不但可以虚拟出硬件资源，把实验环境与真机文件分离保证数据安全，更nb的是当你手残删掉系统核心配置时，还能有”快照“的功能，立即恢复到出错前的状态，省去装机的超长时间。。。。(Windows用户)VMware Workstation是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。下载激活地址：http://www.zdfans.com/html/5928.html(Mac用户) VMware fusion简单的说，虚拟机（virtual Machine）软件就是一套特殊的软件，同时可以用“多个操作系统”虚拟出硬件+操作系统==服务器+OS误区：学Linux不需要再物理机上安装，费时费力，采用虚拟机是最合适的方式</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715143727078-1973552951.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715144020795-347208669.png" alt="img"></p><p>Linux学习环境推荐电脑配置：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>笔记本电脑：1.内存8G2.磁盘500G SATA或者120G SSD3.i3,i5,i7处理器</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="为什么要通过VM虚拟机学习Linux？"><a href="#为什么要通过VM虚拟机学习Linux？" class="headerlink" title="为什么要通过VM虚拟机学习Linux？"></a>为什么要通过VM虚拟机学习Linux？</h1><p>什么？你又和我说搞双系统？老铁你的小霸王，打开windows需要5分钟。。双系统。。。。还是算了吧</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715145848386-170456558.png" alt="img"></p><ul><li><p>利用虚拟机搭建Linux学习环境简单方便、容易上手，最重要的是虚拟机模拟的Linux和真实服务器几乎无区别，以后工作了，也都是ssh连接到服务器，而不是坐在0度的机房操控服务器。因此虚拟机来模拟环境是最接近工作环境的</p></li><li><p>搭建Linux集群或者需要模拟多台服务器通信的时候，可以同时开启好几台虚拟机（前提本身机器硬件足够，虚拟机配置也选择较低的情况），虚拟机可以轻松满足多机器的需求。</p></li><li><p>自己租服务器？是个不错的选择，可以搭建Linux环境，并且用作个人开发学习使用。但是得花钱呀。。。。</p></li></ul><ul><li>很容易修改虚拟机（服务器）的配置，且不会影响自己的电脑，想删除虚拟机也不会影响电脑，因为虚拟机只是运行在电脑上的一个程序（一堆文件）</li></ul><h1 id="超哥手把手教你装虚拟机"><a href="#超哥手把手教你装虚拟机" class="headerlink" title="超哥手把手教你装虚拟机"></a>超哥手把手教你装虚拟机</h1><h2 id="1-准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）"><a href="#1-准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）" class="headerlink" title="1.准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）"></a>1.准备vmware软件，当前超哥演示的是windows环境，macos环境并没有提及，有需要的小伙伴可以私聊（老男孩教育）</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715150948154-930825626.png" alt="img"></p><h2 id="2-解压软件包，当前选择的是vm12"><a href="#2-解压软件包，当前选择的是vm12" class="headerlink" title="2.解压软件包，当前选择的是vm12"></a>2.解压软件包，当前选择的是vm12</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715151320079-929742541.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715151607034-1026981038.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715151741581-1899830534.png" alt="img"></p><p>全部“下一步”，安装即可，，这里无须说多</p><h2 id="3-安装好vmware虚拟机后，开始安装Linux"><a href="#3-安装好vmware虚拟机后，开始安装Linux" class="headerlink" title="3.安装好vmware虚拟机后，开始安装Linux"></a>3.安装好vmware虚拟机后，开始安装Linux</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152026777-201342832.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152153353-1601275196.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152350739-1942472916.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152728654-1117395886.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715152928358-1607419151.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153142008-1600108425.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153233511-1274559113.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153329986-358960099.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153431500-1893205158.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153519327-1692747100.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153545015-961592455.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153625011-560747017.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153803366-947490800.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715153924367-823293158.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715154205447-631511630.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715154433369-2106760403.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715154709752-2106936658.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715160600181-1513557331.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715161126939-657824379.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715161346434-790183842.png" alt="img"></p><h1 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h1><p>此时进入这个黑乎乎的界面，输入root账号与密码，成功进入linux系统</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715162003636-607799263.png" alt="img"></p><h1 id="确保你的Linux支持虚拟化"><a href="#确保你的Linux支持虚拟化" class="headerlink" title="确保你的Linux支持虚拟化"></a>确保你的Linux支持虚拟化</h1><p>　　安装 RHEL 7 或 CentOS 7 系统时，大家的电脑的 CPU 需要支持 VT(Virtualization Technology，虚拟化技术)。所谓 VT，指的是让单台计算机能够分割出多个独立资源区， 并让每个资源区按照需要模拟出系统的一项技术，其本质就是通过中间层实现计算机 资源的管理和再分配，让系统资源的利用率最大化。其实只要您的电脑不是五六年前 买的，价格不低于三千元，它的 CPU 就肯定会支持 VT 的。如果开启虚拟机后依然提 示“CPU 不支持 VT 技术”等报错信息，请重启电脑并进入到 BIOS 中把 VT 虚拟化功 能开启即可。</p><h1 id="你又忘了root密码？？？"><a href="#你又忘了root密码？？？" class="headerlink" title="你又忘了root密码？？？"></a>你又忘了root密码？？？</h1><p>　　针对好多好多同学经常忘记root密码。。。超哥这里给你整理怎么重置root密码！！</p><p>　　重启 Linux 系统主机并出现引导界面时，按下键盘上的 e 键进入内核编辑界面</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200454981-296642965.png" alt="img"></p><p>在 linux16 参数这行的最后面追加“rd.break”参数，然后按下 Ctrl + X 组合键来运行修 改过的内核程序</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200602854-2067722898.png" alt="img"></p><p>大约 30 秒过后，进入到系统的紧急求援模式，</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200630932-1408889196.png" alt="img"></p><p>依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux 系统了 </p><pre><code> mount -o remount,rw /sysroot    chroot /sysroot    passwd    touch /.autorelabelexit reboot</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822200710908-118130154.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos下redis安全相关</title>
      <link href="2019/11/15/Linux/centos%E4%B8%8Bredis%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"/>
      <url>2019/11/15/Linux/centos%E4%B8%8Bredis%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="centos下redis安全相关"><a href="#centos下redis安全相关" class="headerlink" title="centos下redis安全相关"></a><a href="https://www.cnblogs.com/pyyu/p/9515937.html">centos下redis安全相关</a></h1><p>博文背景：</p><p>由于发现众多同学，在使用云服务器时，安装的redis3.0+版本都关闭了protected-mode，因而都遭遇了挖矿病毒的攻击，使得服务器99%的占用率！！</p><p>因此我们在使用redis时候，最好更改默认端口，并且使用redis密码登录。</p><p>（1）redis没有用户概念，redis只有密码<br>（2）redis默认在工作在保护模式下。不允许远程任何用户登录的（protected-mode）</p><p>redis.conf设置</p><pre><code>protected-mode yes   #打开保护模式port 6380  #更改默认启动端口requirepass xxxxxx   #设置redis启动密码，xxxx是自定义的密码</code></pre><p>启动redis服务端</p><pre><code>redis-server /opt/redis-4.0.10/redis.conf &amp;     #指定配置文件启动redis，且后台启动</code></pre><p>使用密码登录redis，使用6380端口</p><p>方法1，使用这个</p><pre><code>[root@oldboy_python ~ 09:48:41]#redis-cli -p 6380127.0.0.1:6380&gt; auth xxxxOK</code></pre><p>方法2，此方案不安全，容易暴露密码</p><pre><code>[root@oldboy_python ~ 09:49:46]#redis-cli -p 6380 -a xxxxWarning: Using a password with '-a' option on the command line interface may not be safe.127.0.0.1:6380&gt; pingPONG</code></pre><p>补充</p><p>检查redis是否设置了密码</p><p>127.0.0.1:6380&gt; CONFIG get requirepass</p><ol><li>“requirepass”</li><li>“xxxxxx”</li></ol><p>如果没有，也可以给redis设置密码（命令方式）</p><pre><code>CONFIG set requirepass "xxxxxx"</code></pre><p>因此你的redis就不容易被黑客入侵了。</p><p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1a36zff5cc86l">https://cloud.tencent.com/developer/support-plan?invite_code=1a36zff5cc86l</a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx负载均衡</title>
      <link href="2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a><a href="https://www.cnblogs.com/pyyu/p/10004633.html">nginx负载均衡</a></h1><ul><li><a href="https://www.cnblogs.com/pyyu/p/10004583.html">集群概念</a></li><li><a href="https://www.cnblogs.com/pyyu/p/10004670.html">负载均衡</a></li><li><a href="https://www.cnblogs.com/pyyu/p/10004681.html">nginx负载均衡</a></li></ul><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx负载均衡实验</title>
      <link href="2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E9%AA%8C/"/>
      <url>2019/11/15/Linux/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx负载均衡实验"><a href="#nginx负载均衡实验" class="headerlink" title="nginx负载均衡实验"></a><a href="https://www.cnblogs.com/pyyu/p/10004681.html">nginx负载均衡实验</a></h1><h1 id="Nginx负载均衡概述"><a href="#Nginx负载均衡概述" class="headerlink" title="Nginx负载均衡概述"></a>Nginx负载均衡概述</h1><pre><code>Web服务器，直接面向用户，往往要承载大量并发请求，单台服务器难以负荷，我使用多台WEB服务器组成集群，前端使用Nginx负载均衡，将请求分散的打到我们的后端服务器集群中，实现负载的分发。那么会大大提升系统的吞吐率、请求性能、高容灾</code></pre><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122233808543-706880577.png" alt="img"></p><p>Nginx要实现负载均衡需要用到proxy_pass代理模块配置</p><p>Nginx负载均衡与Nginx代理不同地方在于</p><p>Nginx代理仅代理一台服务器，而Nginx负载均衡则是将客户端请求代理转发至一组upstream虚拟服务池</p><p>Nginx可以配置代理多台服务器，当一台服务器宕机之后，仍能保持系统可用。</p><h1 id="upstream配置"><a href="#upstream配置" class="headerlink" title="upstream配置"></a>upstream配置</h1><p>在nginx.conf &gt; http 区域中</p><pre><code>upstream django {       server 10.0.0.10:8000;       server 10.0.0.11:9000;}</code></pre><p>在nginx.conf &gt; http 区域 &gt;  server区域  &gt; location配置中</p><p>添加proxy_pass</p><pre><code>location / {            root   html;            index  index.html index.htm;            proxy_pass http://django;}</code></pre><p>此时初步负载均衡已经完成，upstream默认按照轮训方式负载，每个请求按时间顺序逐一分配到后端节点。</p><h1 id="upstream分配策略"><a href="#upstream分配策略" class="headerlink" title="upstream分配策略"></a>upstream分配策略</h1><p>weight 权重</p><pre><code>upstream django {       server 10.0.0.10:8000 weight=5;       server 10.0.0.11:9000 weight=10;#这个节点访问比率是大于8000的}</code></pre><p>ip_hash</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器upstream django {　　　　ip_hash;       server 10.0.0.10:8000;       server 10.0.0.11:9000;}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>backup</strong></p><p><strong>在非backup机器繁忙或者宕机时，请求backup机器，因此机器默认压力最小</strong></p><pre><code>upstream django {       server 10.0.0.10:8000 weight=5;       server 10.0.0.11:9000;       server node.oldboy.com:8080 backup;}</code></pre><h1 id="负载均衡实验环境规划"><a href="#负载均衡实验环境规划" class="headerlink" title="负载均衡实验环境规划"></a>负载均衡实验环境规划</h1><pre><code>角色            ip                    主机名lb01        192.168.119.10        lb01    web01        192.168.119.11        web01web02        192.168.119.12        web02</code></pre><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><pre><code>iptables -Fsed  -i 's/enforcing/disabled/' /etc/selinux/configsystemctl stop firewalldsystemctl disable firewalld</code></pre><h2 id="一、web01服务器配置nginx，创建index-html"><a href="#一、web01服务器配置nginx，创建index-html" class="headerlink" title="一、web01服务器配置nginx，创建index.html"></a>一、web01服务器配置nginx，创建index.html</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>server {        listen       80;        server_name  192.168.119.11;        location / {        root /node;            index  index.html index.htm;        }}mkdir /nodeecho 'i am web01' &gt; /node/index.html#启动NGINX./sbgin/nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="二、web01服务器配置nginx-创建index-html"><a href="#二、web01服务器配置nginx-创建index-html" class="headerlink" title="二、web01服务器配置nginx,创建index.html"></a>二、web01服务器配置nginx,创建index.html</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>server {    listen       80;    server_name  192.168.119.12;    location / {        root /node;        index  index.html index.htm;}mkdir /nodeecho 'i am web02...' &gt; /node/index.html#启动nginx./sbing/nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="三、配置lb01服务器的nginx负载均衡"><a href="#三、配置lb01服务器的nginx负载均衡" class="headerlink" title="三、配置lb01服务器的nginx负载均衡"></a>三、配置lb01服务器的nginx负载均衡</h2><p>1.检查lb01的 nginx.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    upstream node {    　　server 192.168.119.11:80;    　　server 192.168.119.12:80;}    server {        listen       80;        server_name 192.168.119.10;        location / {        　　proxy_pass http://node;        　　include proxy_params;  #需要手动创建        }    }}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2.手动创建proxy_params文件，文件中存放代理的请求头相关参数</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@lb01 conf]# cat /opt/nginx/conf/proxy_paramsproxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_connect_timeout 30;proxy_send_timeout 60;proxy_read_timeout 60;proxy_buffering on;proxy_buffer_size 32k;proxy_buffers 4 128k;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>启动lb01负载均衡nginx服务./sbin/nginx</code></pre><h2 id="四、访问lb01节点nginx，反复刷新"><a href="#四、访问lb01节点nginx，反复刷新" class="headerlink" title="四、访问lb01节点nginx，反复刷新"></a>四、访问lb01节点nginx，反复刷新</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123114552274-506631111.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123114606575-1476598164.png" alt="img"></p><h1 id="五、nginx负载均衡调度算法"><a href="#五、nginx负载均衡调度算法" class="headerlink" title="五、nginx负载均衡调度算法"></a>五、nginx负载均衡调度算法</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>调度算法   　　 概述轮询    　　　　按时间顺序逐一分配到不同的后端服务器(默认)weight  　　   加权轮询,weight值越大,分配到的访问几率越高ip_hash   　　 每个请求按访问IP的hash结果分配,这样来自同一IP的固定访问一个后端服务器url_hash   　  按照访问URL的hash结果来分配请求,是每个URL定向到同一个后端服务器least_conn    最少链接数,那个机器链接数少就分发</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>1.轮询(不做配置，默认轮询)</p><p>2.weight权重(优先级)</p><p>3.ip_hash配置，根据客户端ip哈希分配，不能和weight一起用</p><h1 id="六、nginx动静分离负载均衡"><a href="#六、nginx动静分离负载均衡" class="headerlink" title="六、nginx动静分离负载均衡"></a>六、nginx动静分离负载均衡</h1><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123121107048-1594518031.png" alt="img"></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><pre><code>系统                 服务                软件                ip地址centos7(lb01)                负载均衡            nginx proxy        192.168.119.10centos7(web01)                静态资源            nginx静态资源        192.168.119.11centos7(web02)                动态资源            django            192.168.119.12</code></pre><h2 id="一、在web01机器上，配置静态资源，图片等"><a href="#一、在web01机器上，配置静态资源，图片等" class="headerlink" title="一、在web01机器上，配置静态资源，图片等"></a>一、在web01机器上，配置静态资源，图片等</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>cat nginx.confserver {        listen       80;        server_name  192.168.119.11;        #定义网页根目录         root /code;        #定义了静态资源        index index.html;#域名匹配，所有的png、jpg、gif请求资源，都去/root/code/images底下找         location ~* .*\.(png|jpg|gif)$ {                root /code/images;        }    #重启nginx./sbin/nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#创建目录mkdir -p /code/images#准备首页文件[root@web01  /code]$cat index.htmlstatic files...#准备静态文件，图片[root@web01  /code/images]$wget http://pythonav.cn/av/girlone.jpg^C[root@web01  /code/images]$lsgirlone.jpg</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="二、在web02配置动态请求，准备一个flask程序和静态资源转发"><a href="#二、在web02配置动态请求，准备一个flask程序和静态资源转发" class="headerlink" title="二、在web02配置动态请求，准备一个flask程序和静态资源转发"></a>二、在web02配置动态请求，准备一个flask程序和静态资源转发</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>cat  nginx.conf#静态资源地址upstream static {server 192.168.119.11:80;}#flask动态请求upstream flask {server 192.168.119.12:8080;}    server {        listen       80;        server_name  192.168.119.12;　　　　　　#当请求到达192.168.119.12:80/时，转发给flask的8080应用        location / {            proxy_pass http://flask;            include proxy_params;        }　　　　　　#当判断资源请求是 192.168.119.12/girl.jpg时候，转发请求给static地址池的服务器192.168.119.11/        location ~ .*\.(png|jpg|gif)$ {　　　　　　　　proxy_pass http://static;include proxy_params;}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>准备flask应用,flask.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>from flask import Flaskapp=Flask(__name__)@app.route('/')def hello():    return "i am flask....from nginx"if __name__=="__main__":    app.run(host='0.0.0.0',port=8080)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>后台运行flask程序</p><pre><code>python flask-web.py &amp;</code></pre><h2 id="三、在负载均衡服务器lb01上测试访问192-168-119-10"><a href="#三、在负载均衡服务器lb01上测试访问192-168-119-10" class="headerlink" title="三、在负载均衡服务器lb01上测试访问192.168.119.10"></a>三、在负载均衡服务器lb01上测试访问192.168.119.10</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123164434807-990604537.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123164441415-1872980063.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181123164506188-1615595481.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python开发之virtualenv与virtualenvwrapper讲解</title>
      <link href="2019/11/15/Linux/python%E5%BC%80%E5%8F%91%E4%B9%8Bvirtualenv%E4%B8%8Evirtualenvwrapper%E8%AE%B2%E8%A7%A3/"/>
      <url>2019/11/15/Linux/python%E5%BC%80%E5%8F%91%E4%B9%8Bvirtualenv%E4%B8%8Evirtualenvwrapper%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="python开发之virtualenv与virtualenvwrapper讲解"><a href="#python开发之virtualenv与virtualenvwrapper讲解" class="headerlink" title="python开发之virtualenv与virtualenvwrapper讲解"></a><a href="https://www.cnblogs.com/pyyu/p/9015317.html">python开发之virtualenv与virtualenvwrapper讲解</a></h1><p><strong>在使用 Python 开发的过程中，工程一多，难免会碰到不同的工程依赖不同版本的库的问题；</strong></p><p><strong>亦或者是在开发过程中不想让物理环境里充斥各种各样的库，引发未来的依赖灾难。</strong></p><p><strong>此时，我们需要对于不同的工程使用不同的虚拟环境来保持开发环境以及宿主环境的清洁。</strong></p><p><strong>这里，就要隆重介绍 virtualenv，一个可以帮助我们管理不同 Python 环境的绝好工具。</strong></p><p><strong>virtualenv 可以在系统中建立多个不同并且相互不干扰的虚拟环境。</strong></p><h1 id="一、Linux下安装、配置virtualenv"><a href="#一、Linux下安装、配置virtualenv" class="headerlink" title="一、Linux下安装、配置virtualenv"></a>一、Linux下安装、配置virtualenv</h1><pre><code>#指定清华源下载pip的包pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple virtualenv#升级pip工具pip3 install --upgrade pip</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.安装virtualenvpip3 install virtualenv 2.创建目录mkdir Myprojectcd Myproject3.创建独立运行环境-命名virtualenv --no-site-packages --python=python3  venv#得到独立第三方包的环境，并且指定解释器是python34.进入虚拟环境source venv/bin/activate#此时进入虚拟环境(venv)Myproject5.安装第三方包(venv)Myproject: pip3 install django==1.9.8#此时pip的包都会安装到venv环境下，venv是针对Myproject创建的6.退出venv环境deactivate命令7.virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="二、确保开发环境的一致性"><a href="#二、确保开发环境的一致性" class="headerlink" title="二、确保开发环境的一致性"></a>二、确保开发环境的一致性</h2><pre><code>1.假设我们在本地开发环境，准备好了项目+依赖包环境2.现在需要将项目上传至服务器，上线发布3.那么就要保证服务器的python环境一致性</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>解决方案：1.通过命令保证环境的一致性，导出当前python环境的包pip3 freeze &gt; requirements.txt   这将会创建一个 requirements.txt 文件，其中包含了当前环境中所有包及 各自的版本的简单列表。可以使用 “pip list”在不产生requirements文件的情况下， 查看已安装包的列表。2.上传至服务器后，在服务器下创建virtualenv，在venv中导入项目所需的模块依赖pip3 install -r requirements.txt</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="三、虚拟环境之virtualenvwrapper"><a href="#三、虚拟环境之virtualenvwrapper" class="headerlink" title="三、虚拟环境之virtualenvwrapper"></a>三、虚拟环境之virtualenvwrapper</h1><p><strong>virtualenv 的一个最大的缺点就是：</strong></p><p><strong>每次开启虚拟环境之前要去虚拟环境所在目录下的 bin 目录下 source 一下 activate，这就需要我们记住每个虚拟环境所在的目录。</strong></p><p><strong>并且还有可能你忘记了虚拟环境放在哪。。。</strong></p><ul><li>一种可行的解决方案是，将所有的虚拟环境目录全都集中起来，例如/opt/all_venv/，并且针对不同的目录做不同的事。</li><li>使用virtualenvwrapper管理你的虚拟环境（virtualenv），其实他就是统一管理虚拟环境的目录，并且省去了source的步骤。</li></ul><h2 id="步骤1：安装virtualenvwrapper"><a href="#步骤1：安装virtualenvwrapper" class="headerlink" title="步骤1：安装virtualenvwrapper"></a>步骤1：安装virtualenvwrapper</h2><pre><code>pip3 install virtualenvwrapper</code></pre><h2 id="步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper"><a href="#步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper" class="headerlink" title="步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper"></a>步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>把下面两行代码添加到 ~/.bashrc文件中打开文件vim ~/.bashrc写入以下两行代码export WORKON_HOME=~/Envs   #设置virtualenv的统一管理目录export VIRTUALENVWRAPPER_VIRTUALENV_ARGS='--no-site-packages'   #添加virtualenvwrapper的参数，生成干净隔绝的环境export VIRTUALENVWRAPPER_PYTHON=/opt/python347/bin/python3     #指定python解释器source /opt/python34/bin/virtualenvwrapper.sh #执行virtualenvwrapper安装脚本读取文件，使得生效，此时已经可以使用virtalenvwrappersource ~/.bashrc</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="步骤3：基本使用virtualenvwrapper"><a href="#步骤3：基本使用virtualenvwrapper" class="headerlink" title="步骤3：基本使用virtualenvwrapper"></a>步骤3：基本使用virtualenvwrapper</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>创建一个虚拟环境：$ mkvirtualenv my_django115这会在 ~/Envs 中创建 my_django115 文件夹。在虚拟环境上工作：激活虚拟环境my_django115$ workon my_django115再创建一个新的虚拟环境$ mkvirtualenv my_django2virtualenvwrapper 提供环境名字的tab补全功能。当有很多环境， 并且很难记住它们的名字时，这就显得很有用。workon还可以任意停止你当前的环境，可以在多个虚拟环境中来回切换workon django1.15workon django2.0也可以手动停止虚拟环境deactivate删除虚拟环境，需要先退出虚拟环境rmvirtualenv my_django115</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="步骤四：常用其他命令"><a href="#步骤四：常用其他命令" class="headerlink" title="步骤四：常用其他命令"></a>步骤四：常用其他命令</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>lsvirtualenv列举所有的环境。cdvirtualenv导航到当前激活的虚拟环境的目录中，比如说这样您就能够浏览它的 site-packages 。cdsitepackages和上面的类似，但是是直接进入到 site-packages 目录中。lssitepackages显示 site-packages 目录中的内容。完整官网介绍：https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180726113018954-757644711.png" alt="img"></p><h2 id="二、Mac下创建pycharm"><a href="#二、Mac下创建pycharm" class="headerlink" title="二、Mac下创建pycharm"></a>二、Mac下创建pycharm</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509165253912-1953506088.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180514111707923-1338423208.png" alt="img"></p><h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509165438463-1744082688.png" alt="img"></p><h2 id="第三步：此时这里的Django环境是虚拟环境的版本"><a href="#第三步：此时这里的Django环境是虚拟环境的版本" class="headerlink" title="第三步：此时这里的Django环境是虚拟环境的版本"></a>第三步：此时这里的Django环境是虚拟环境的版本</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509165546752-145926924.png" alt="img"></p><h2 id="第四步：检查venv下的django版本"><a href="#第四步：检查venv下的django版本" class="headerlink" title="第四步：检查venv下的django版本"></a>第四步：检查venv下的django版本</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509165801924-773808653.png" alt="img"></p><h2 id="第五步：添加已创建的虚拟环境venv的python解释器，至pycharm，用于创建1-98指定版本的django"><a href="#第五步：添加已创建的虚拟环境venv的python解释器，至pycharm，用于创建1-98指定版本的django" class="headerlink" title="第五步：添加已创建的虚拟环境venv的python解释器，至pycharm，用于创建1.98指定版本的django"></a>第五步：添加已创建的虚拟环境venv的python解释器，至pycharm，用于创建1.98指定版本的django</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509171128359-1783396835.png" alt="img"></p><h2 id="第六步：成功启动1-98版本的django"><a href="#第六步：成功启动1-98版本的django" class="headerlink" title="第六步：成功启动1.98版本的django"></a>第六步：成功启动1.98版本的django</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180509171411218-1986171670.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-cluster配置</title>
      <link href="2019/11/15/Linux/redis-cluster%E9%85%8D%E7%BD%AE/"/>
      <url>2019/11/15/Linux/redis-cluster%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="redis-cluster配置"><a href="#redis-cluster配置" class="headerlink" title="redis-cluster配置"></a><a href="https://www.cnblogs.com/pyyu/p/9844093.html">redis-cluster配置</a></h1><h1 id="为什么要用redis-cluster"><a href="#为什么要用redis-cluster" class="headerlink" title="为什么要用redis-cluster"></a>为什么要用redis-cluster</h1><h2 id="1-并发问题"><a href="#1-并发问题" class="headerlink" title="1.并发问题"></a>1.并发问题</h2><pre><code>redis官方生成可以达到 10万/每秒,每秒执行10万条命令假如业务需要每秒100万的命令执行呢？</code></pre><h2 id="2-数据量太大"><a href="#2-数据量太大" class="headerlink" title="2.数据量太大"></a>2.数据量太大</h2><p>一台服务器内存正常是16~256G，假如你的业务需要500G内存，</p><p>新浪微博作为世界上最大的redis存储，就超过1TB的数据，去哪买这么大的内存条？各大公司有自己的解决方案，推出各自的集群功能，核心思想都是将数据分片（sharding）存储在多个redis实例中，每一片就是一个redis实例。</p><pre><code>各大企业集群方案：twemproxy由Twitter开源Codis由豌豆荚开发，基于GO和C开发redis-cluster官方3.0版本后的集群方案</code></pre><p>解决方案如下</p><ol><li>配置一个超级牛逼的计算机，超大内存，超强cpu，但是问题是。。。。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024160915096-209591231.png" alt="img"></p><p>2.正确的应该是考虑分布式，加机器，把数据分到不同的位置，分摊集中式的压力，<strong>一堆机器做一件事</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024161047230-851823170.png" alt="img"></p><h1 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h1><p>redis3.0集群采用P2P模式，完全去中心化，将redis所有的key分成了16384个槽位，每个redis实例负责一部分slot，集群中的所有信息通过节点数据交换而更新。</p><pre><code>redis实例集群主要思想是将redis数据的key进行散列，通过hash函数特定的key会映射到指定的redis节点上</code></pre><h1 id="数据分布原理图"><a href="#数据分布原理图" class="headerlink" title="数据分布原理图"></a>数据分布原理图</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181125134928388-1528161304.png" alt="img"></p><h3 id="数据分布理论"><a href="#数据分布理论" class="headerlink" title="数据分布理论"></a>数据分布理论</h3><p>分布式数据库首要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整个数据的一个子集。</p><p>常见的分区规则有哈希分区和顺序分区。<code>Redis Cluster</code>采用哈希分区规则，因此接下来会讨论哈希分区规则。</p><ul><li>节点取余分区</li><li>一致性哈希分区</li><li><strong>虚拟槽分区(redis-cluster采用的方式)</strong></li></ul><h2 id="顺序分区"><a href="#顺序分区" class="headerlink" title="顺序分区"></a>顺序分区</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024161255329-1946317777.png" alt="img"></p><h2 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h2><p>节点取余</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024161354680-200751267.png" alt="img"></p><p>例如按照节点取余的方式，分三个节点</p><p>1~100的数据对3取余，可以分为三类</p><ul><li>余数为0</li><li>余数为1</li><li>余数为2</li></ul><p>那么同样的分4个节点就是hash(key)%4</p><p>节点取余的优点是简单，客户端分片直接是哈希+取余</p><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>客户端进行分片，哈希+顺时针取余</p><h2 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h2><p><code>Redis Cluster</code>采用虚拟槽分区</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有的数据映射到一个固定范围内的整数集合，整数定义为槽（slot）。</p><p><strong>Redis Cluster槽的范围是0 ～ 16383。</strong></p><p><strong>槽是集群内数据管理和迁移的基本单位。</strong>采用大范围的槽的主要目的是为了方便数据的拆分和集群的扩展，</p><p><strong>每个节点负责一定数量的槽。</strong></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181125140406355-792376591.png" alt="img"></p><h1 id="搭建redis-cluster"><a href="#搭建redis-cluster" class="headerlink" title="搭建redis cluster"></a>搭建redis cluster</h1><p>搭建集群分为几部</p><ul><li>准备节点（几匹马儿）</li><li>节点通信（几匹马儿分配主从）</li><li>分配槽位给节点（slot分配给马儿）</li></ul><p>redis-cluster集群架构</p><pre><code>多个服务端，负责读写，彼此通信，redis指定了16384个槽。多匹马儿，负责运输数据，马儿分配16384个槽位，管理数据。ruby的脚本自动就把分配槽位这事做了</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181024170727913-1418417703.png" alt="img"></p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p>官方提供通过ruby语言的脚本一键安装</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h2><p>通过配置，开启redis-cluster</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>port 7000daemonize yesdir "/opt/redis/data"logfile "7000.log"dbfilename "dump-7000.rdb"cluster-enabled yes   #开启集群模式cluster-config-file nodes-7000.conf　　#集群内部的配置文件cluster-require-full-coverage no　　#redis cluster需要16384个slot都正常的时候才能对外提供服务，换句话说，只要任何一个slot异常那么整个cluster不对外提供服务。 因此生产环境一般为no</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>redis支持多实例的功能，我们在单机演示集群搭建，需要6个实例，三个是主节点，三个是从节点，数量为6个节点才能保证高可用的集群。</p><p><strong>每个节点仅仅是端口运行的不同！</strong></p><pre><code>[root@yugo /opt/redis/config 17:12:30]#lsredis-7000.conf  redis-7002.conf  redis-7004.confredis-7001.conf  redis-7003.conf  redis-7005.conf#确保每个配置文件中的端口修改！！</code></pre><h2 id="2-运行redis实例"><a href="#2-运行redis实例" class="headerlink" title="2.运行redis实例"></a>2.运行redis实例</h2><p>创建6个节点的redis实例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code> 1855  2018-10-24 15:46:01 redis-server redis-7000.conf 1856  2018-10-24 15:46:13 redis-server redis-7001.conf 1857  2018-10-24 15:46:16 redis-server redis-7002.conf 1858  2018-10-24 15:46:18 redis-server redis-7003.conf 1859  2018-10-24 15:46:20 redis-server redis-7004.conf 1860  2018-10-24 15:46:23 redis-server redis-7005.conf</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>检查日志文件</p><pre><code>cat 7000.log</code></pre><p>检查redis服务的端口、进程</p><pre><code>netstat -tunlp|grep redisps -ef|grep redis</code></pre><p><strong>此时集群还不可用</strong>，可以通过登录redis查看</p><pre><code>redis-cli -p 7000set hello world(error)CLUSTERDOWN The cluster is down</code></pre><h2 id="3-创建开启redis-cluster"><a href="#3-创建开启redis-cluster" class="headerlink" title="3.创建开启redis-cluster"></a>3.创建开启redis-cluster</h2><h2 id="准备ruby环境"><a href="#准备ruby环境" class="headerlink" title="准备ruby环境"></a>准备ruby环境</h2><ol><li>下载、编译、安装Ruby</li><li>安装rubygem redis</li><li>安装redis-trib.rb命令</li></ol><p>第一步，安装ruby(这些命令可以放入一个sh脚本文件里)</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#下载rubywget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz#安装rubytar -xvf ruby-2.3.1.tar.gz./configure --prefix=/opt/ruby/make &amp;&amp; make install#准备一个ruby命令#准备一个gem软件包管理命令#拷贝ruby命令到path下/usr/local/rubycp /opt/ruby/bin/ruby /usr/local/cp bin/gem /usr/local/bin</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>安装ruby gem 包管理工具</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>wget http://rubygems.org/downloads/redis-3.3.0.gemgem install -l redis-3.3.0.gem#查看gem有哪些包gem list -- check redis gem</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>安装redis-trib.rb命令</p><pre><code>[root@yugo /opt/redis/src 18:38:13]#cp /opt/redis/src/redis-trib.rb /usr/local/bin/</code></pre><h2 id="一键开启redis-cluster集群"><a href="#一键开启redis-cluster集群" class="headerlink" title="一键开启redis-cluster集群"></a>一键开启redis-cluster集群</h2><pre><code>#每个主节点，有一个从节点，代表--replicas 1redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005#集群自动分配主从关系  7000、7001、7002为 7003、7004、7005 主动关系</code></pre><h1 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>redis-cli -p 7000 cluster info  redis-cli -p 7000 cluster nodes  #等同于查看nodes-7000.conf文件节点信息集群主节点状态redis-cli -p 7000 cluster nodes | grep master集群从节点状态redis-cli -p 7000 cluster nodes | grep slave</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>安装完毕后，检查集群状态</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@yugo /opt/redis/src 18:42:14]#redis-cli -p 7000 cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:10468cluster_stats_messages_pong_sent:10558cluster_stats_messages_sent:21026cluster_stats_messages_ping_received:10553cluster_stats_messages_pong_received:10468cluster_stats_messages_meet_received:5cluster_stats_messages_received:21026</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>测试写入集群数据，登录集群必须使用redis-cli -c -p 7000必须加上-c参数</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:7000&gt; set name chao     -&gt; Redirected to slot [5798] located at 127.0.0.1:7001       OK127.0.0.1:7001&gt; exit[root@yugo /opt/redis/src 18:46:07]#redis-cli -c -p 7000127.0.0.1:7000&gt; pingPONG127.0.0.1:7000&gt; keys *(empty list or set)127.0.0.1:7000&gt; get name-&gt; Redirected to slot [5798] located at 127.0.0.1:7001"chao"</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>集群ok</p><p>工作原理：</p><p>redis客户端任意访问一个redis实例，如果数据不在该实例中，通过重定向引导客户端访问所需要的redis实例</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python操作redis集群</title>
      <link href="2019/11/15/Linux/python%E6%93%8D%E4%BD%9Credis%E9%9B%86%E7%BE%A4%20/"/>
      <url>2019/11/15/Linux/python%E6%93%8D%E4%BD%9Credis%E9%9B%86%E7%BE%A4%20/</url>
      
        <content type="html"><![CDATA[<h1 id="python操作redis集群"><a href="#python操作redis集群" class="headerlink" title="python操作redis集群"></a><a href="https://www.cnblogs.com/pyyu/p/10015776.html">python操作redis集群</a></h1><p>strictRedis对象方法用于连接redis</p><p>指定主机地址，port与服务器连接，默认db是0，redis默认数据库有16个，在配置文件中指定database 16</p><p>上代码</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1、对redis的单实例进行连接操作根据不同的实例方法，与redis的命令对应python3&gt;&gt;&gt;import redis&gt;&gt;&gt;r = redis.StrictRedis(host='localhost', port=6379, db=0,password='root')&gt;&gt;&gt;r.set('lufei', 'guojialei')True&gt;&gt;&gt;r.get('lufei')'bar'增删改查</code></pre><p>&gt;&gt;&gt; conn=redis.StrictRedis()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; conn.set(“name1”,”alex1”)<br>True<br>&gt;&gt;&gt; conn.set(“name2”,”wupeiqi”)<br>True<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; conn.set(“name1”,”alex666”)<br>True<br>&gt;&gt;&gt; conn.delete(“name2”,”name1”)<br>2</p><p>&gt;&gt;&gt; conn.keys()<br>[b’name3’, b’name2’, b’name1’]</p><pre><code>--------------------2、sentinel集群连接并操作[root@db01 ~]# redis-server /data/6380/redis.conf[root@db01 ~]# redis-server /data/6381/redis.conf[root@db01 ~]# redis-server /data/6382/redis.conf [root@db01 ~]# redis-sentinel /data/26380/sentinel.conf &amp;--------------------------------## 导入redis sentinel包&gt;&gt;&gt; from redis.sentinel import Sentinel  ##指定sentinel的地址和端口号&gt;&gt;&gt; sentinel = Sentinel([('localhost', 26380)], socket_timeout=0.1)  ##测试，获取以下主库和从库的信息&gt;&gt;&gt; sentinel.discover_master('mymaster')  &gt;&gt;&gt; sentinel.discover_slaves('mymaster')  ##配置读写分离#写节点&gt;&gt;&gt; master = sentinel.master_for('mymaster', socket_timeout=0.1)  #读节点&gt;&gt;&gt; slave = sentinel.slave_for('mymaster', socket_timeout=0.1)  ###读写分离测试   key     &gt;&gt;&gt; master.set('oldboy', '123')  &gt;&gt;&gt; slave.get('oldboy')  '123'----------------------redis cluster的连接并操作（python2.7.2以上版本才支持redis cluster，我们选择的是3.5）https://github.com/Grokzen/redis-py-cluster3、python连接rediscluster集群测试使用python3&gt;&gt;&gt; from rediscluster import StrictRedisCluster  &gt;&gt;&gt; startup_nodes = [{"host": "127.0.0.1", "port": "7000"}]  ### Note: decode_responses must be set to True when used with python3  &gt;&gt;&gt; rc = StrictRedisCluster(startup_nodes=startup_nodes, decode_responses=True)  &gt;&gt;&gt; rc.set("foo", "bar")  True  &gt;&gt;&gt;   'bar'----------------------</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="redis存储session"><a href="#redis存储session" class="headerlink" title="redis存储session"></a>redis存储session</h2><p>django-redis-sessions 官方文档：<a href="https://pypi.org/project/django-redis-sessions/">https://pypi.org/project/django-redis-sessions/</a></p><p>dango-redis 官方文档：<a href="http://niwinz.github.io/django-redis/latest/#_configure_as_cache_backend">http://niwinz.github.io/django-redis/latest/#_configure_as_cache_backend</a></p><p>安装模块</p><pre><code>安装模块 pip3 install django-redis-sessions或者pip3 install django-redis</code></pre><p>本文这里用的是django 2.0语法，创建django项目</p><pre><code>django-admin startproject mydjango</code></pre><p>修改settings.py文件</p><p>写入</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>CACHES = {    "default": {        "BACKEND": "django_redis.cache.RedisCache",        "LOCATION": "redis://127.0.0.1:6379/0",        "OPTIONS": {            "CLIENT_CLASS": "django_redis.client.DefaultClient",            "PASSWORD": "",#             "PARSER_CLASS": "redis.connection.HiredisParser",#             "SOCKET_TIMEOUT": 10,#             "CONNECTION_POOL_CLASS_KWARGS": {#                 "max_connections": 2,#             }        }    }}#SESSION_COOKIE_AGE = 30 * 60 #设置session过期时间为30分钟SESSION_ENGINE = 'django.contrib.sessions.backends.cache'</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>创建app01</p><pre><code>django-admin startapp app01</code></pre><p>编写session视图函数 app01.views</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>from django.shortcuts import render,HttpResponsedef set_session(request):    request.session['username']='chaoge'    request.session['age']=18    return HttpResponse("设置sesson成功")def get_session(request):    username=request.session['username']    age = request.session['age']    return HttpResponse(username+":"+str(age))</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>添加url路由</p><p>vim mydjango/urls.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>from django.contrib import adminfrom django.urls import pathfrom app01 import viewsurlpatterns = [    path('set_session/',views.set_session),    path('get_session/',views.get_session),    path('admin/', admin.site.urls),]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>确保启动redis服务端，默认方式启动</p><pre><code>redis-server &amp;redis-cli 连接无误发送ping命令得到pong即可</code></pre><p>启动django</p><pre><code>python3 manage.py runserver 0.0.0.0:8000</code></pre><p>访问视图，设置一条session信息，存入redis数据库</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190323161551235-1043972135.png" alt="img"></p><p>访问视图，获取session信息</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190323161710547-1955920838.png" alt="img"></p><p>检查redis数据库，是否存在一条key</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; keys *1) ":1:django.contrib.sessions.cachep220moqvxclz2hyjqmbybqs3v8ck2i39"获取这个key的值</code></pre><p>127.0.0.1:6379&gt; get :1:django.contrib.sessions.cachep220moqvxclz2hyjqmbybqs3v8ck2i39<br>“\x80\x04\x95!\x00\x00\x00\x00\x00\x00\x00}\x94(\x8c\busername\x94\x8c\x06chaoge\x94\x8c\x03age\x94K\x12u.”</p><pre><code></code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-sentinel主从复制高可用</title>
      <link href="2019/11/15/Linux/redis-sentinel%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>2019/11/15/Linux/redis-sentinel%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="redis-sentinel主从复制高可用"><a href="#redis-sentinel主从复制高可用" class="headerlink" title="redis-sentinel主从复制高可用"></a><a href="https://www.cnblogs.com/pyyu/p/9718679.html">redis-sentinel主从复制高可用</a></h1><h1 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis-Sentinel"></a>Redis-Sentinel</h1><pre><code>Redis-Sentinel是redis官方推荐的高可用性解决方案，当用redis作master-slave的高可用时，如果master本身宕机，redis本身或者客户端都没有实现主从切换的功能。而redis-sentinel就是一个独立运行的进程，用于监控多个master-slave集群，自动发现master宕机，进行自动切换slave &gt; master。</code></pre><p>sentinel主要功能如下：</p><ul><li>不时的监控redis是否良好运行，如果节点不可达就会对节点进行下线标识</li><li>如果被标识的是主节点，sentinel就会和其他的sentinel节点“协商”，如果其他节点也人为主节点不可达，就会选举一个sentinel节点来完成自动故障转义</li><li>在master-slave进行切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换</li></ul><h1 id="Sentinel的工作方式："><a href="#Sentinel的工作方式：" class="headerlink" title="Sentinel的工作方式："></a>Sentinel的工作方式：</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">sentinel公作方式</p><h1 id="redis主从复制背景问题"><a href="#redis主从复制背景问题" class="headerlink" title="redis主从复制背景问题"></a>redis主从复制背景问题</h1><p><code>Redis</code>主从复制可将主节点数据同步给从节点，从节点此时有两个作用：</p><ul><li>一旦主节点宕机，从节点作为主节点的备份可以随时顶上来。</li><li>扩展主节点的读能力，分担主节点读压力。</li></ul><p>但是问题是：</p><ul><li>一旦主节点宕机，从节点上位，那么需要人为修改所有应用方的主节点地址（改为新的master地址），还需要命令所有从节点复制新的主节点</li></ul><p>那么这个问题，redis-sentinel就可以解决了</p><h1 id="主从复制架构"><a href="#主从复制架构" class="headerlink" title="主从复制架构"></a>主从复制架构</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928114913282-867816204.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928115021716-2071889796.png" alt="img"></p><h1 id="Redis-Sentinel架构"><a href="#Redis-Sentinel架构" class="headerlink" title="Redis Sentinel架构"></a>Redis Sentinel架构</h1><p>redis的一个进程，但是不存储数据，只是监控redis</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181124181822218-1125753774.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928115711245-1503702880.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928145626051-1360651849.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180928145734973-1288883859.png" alt="img"></p><h1 id="redis命令整理"><a href="#redis命令整理" class="headerlink" title="redis命令整理"></a>redis命令整理</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>官网地址：http://redisdoc.com/redis-cli info #查看redis数据库信息redis-cli info replication #查看redis的复制授权信息redis-cli info sentinel   #查看redis的哨兵信息</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><p><strong>本实验是在测试环境下，考虑到学生机器较弱，因此只准备一台linux服务器用作环境！！</strong></p><p>服务器环境，一台即可完成操作</p><pre><code>master 192.168.119.10</code></pre><p>所有配置文件如下</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181107174748993-868053884.png" alt="img"></p><h3 id="主节点master的redis-6379-conf"><a href="#主节点master的redis-6379-conf" class="headerlink" title="主节点master的redis-6379.conf"></a>主节点master的redis-6379.conf</h3><pre><code>port 6379daemonize yeslogfile "6379.log"dbfilename "dump-6379.rdb"dir "/var/redis/data/"</code></pre><h3 id="从节点slave的redis-6380-conf"><a href="#从节点slave的redis-6380-conf" class="headerlink" title="从节点slave的redis-6380.conf"></a>从节点slave的redis-6380.conf</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>port 6380daemonize yeslogfile "6380.log"dbfilename "dump-6380.rdb"dir "/var/redis/data/" slaveof 127.0.0.1 6379      // 从属主节点</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="从节点slave的redis-6381-conf"><a href="#从节点slave的redis-6381-conf" class="headerlink" title="从节点slave的redis-6381.conf"></a>从节点slave的redis-6381.conf</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>port 6381daemonize yeslogfile "6380.log"dbfilename "dump-6380.rdb"dir "/var/redis/data/" slaveof 127.0.0.1 6379      // 从属主节点</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="启动redis主节点"><a href="#启动redis主节点" class="headerlink" title="启动redis主节点"></a>启动redis主节点</h3><pre><code>redis-server /etc/redis-6379.conf</code></pre><h3 id="测试redis主节点是否通信"><a href="#测试redis主节点是否通信" class="headerlink" title="测试redis主节点是否通信"></a>测试redis主节点是否通信</h3><pre><code>redis-cli  ping</code></pre><h2 id="启动两slave节点"><a href="#启动两slave节点" class="headerlink" title="启动两slave节点"></a>启动两slave节点</h2><p>还记得上面超哥的截图吗？总体redis配置文件如下，6379为master，6380和6381为slave</p><pre><code>-rw-r--r-- 1 root root 145 Nov  7 17:44 /etc/redis-6379.conf      #这个为主，port是6379-rw-r--r-- 1 root root  93 Nov  7 17:42 /etc/redis-6380.conf　　　 # 这个是从，port6380，并且得加上新的参数slaveof-rw-r--r-- 1 root root 115 Nov  7 17:42 /etc/redis-6381.conf      # 这个是从，port6381，并且得加上新的参数slaveof</code></pre><p>redis-6380.conf  slave配置文件详解，6381端口的配置文件，仅仅和6380端口不一样</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>port 6380daemonize yeslogfile "6379.log"dbfilename "dump-6379.rdb"dir "/var/redis/data"# Generated by CONFIG REWRITEslaveof 127.0.0.1 6379</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">redis.conf详解–补充–</p><h3 id="启动slave从节点的redis服务"><a href="#启动slave从节点的redis服务" class="headerlink" title="启动slave从节点的redis服务"></a>启动slave从节点的redis服务</h3><pre><code>[root@master 192.168.119.10 ~]$redis-server /etc/redis-6380.conf[root@master 192.168.119.10 ~]$redis-server /etc/redis-6381.conf</code></pre><h3 id="验证从节点的redis服务"><a href="#验证从节点的redis服务" class="headerlink" title="验证从节点的redis服务"></a>验证从节点的redis服务</h3><pre><code>[root@master  ~]$redis-cli   -p 6380 pingPONG[root@master  ~]$redis-cli   -p 6381 pingPONG</code></pre><h2 id="确定主从关系"><a href="#确定主从关系" class="headerlink" title="确定主从关系"></a>确定主从关系</h2><p>在主节点上查看主从通信关系</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@master ~]# redis-cli  -p 6379 info replication# Replicationrole:masterconnected_slaves:2slave0:ip=192.168.119.10,port=6380,state=online,offset=407,lag=0slave1:ip=192.168.119.10,port=6381,state=online,offset=407,lag=0master_repl_offset:407repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:406</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>在从节点上查看主从关系（6380、6379）</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@slave 192.168.119.11 ~]$redis-cli  -p 6380 info replication# Replicationrole:slavemaster_host:192.168.119.10master_port:6379master_link_status:upmaster_last_io_seconds_ago:3master_sync_in_progress:0slave_repl_offset:505slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>此时可以在master上写入数据，在slave上查看数据，此时主从复制配置完成</strong></p><h1 id="开始配置Redis-Sentinel"><a href="#开始配置Redis-Sentinel" class="headerlink" title="开始配置Redis Sentinel"></a>开始配置Redis Sentinel</h1><p>超哥实验的环境是单独一台linux，192.168.119.10</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@master tmp]# ll /etc/redis-*-rw-r--r-- 1 root root 145 Nov  7 17:44 /etc/redis-6379.conf-rw-r--r-- 1 root root  93 Nov  7 17:42 /etc/redis-6380.conf-rw-r--r-- 1 root root 115 Nov  7 17:42 /etc/redis-6381.conf-rw-r--r-- 1 root root 556 Nov  7 17:42 /etc/redis-sentinel-26379.conf-rw-r--r-- 1 root root 556 Nov  7 17:42 /etc/redis-sentinel-26380.conf-rw-r--r-- 1 root root 556 Nov  7 17:42 /etc/redis-sentinel-26381.conf</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>redis-sentinel-26379.conf配置文件写入如下信息</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>// Sentinel节点的端口port 26379  dir /var/redis/data/logfile "26379.log"// 当前Sentinel节点监控 192.168.119.10:6379 这个主节点// 2代表判断主节点失败至少需要2个Sentinel节点节点同意// mymaster是主节点的别名sentinel monitor mymaster 192.168.119.10 6379 2//每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过30000毫秒30s且没有回复，则判定不可达sentinel down-after-milliseconds mymaster 30000//当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1sentinel parallel-syncs mymaster 1//故障转移超时时间为180000毫秒sentinel failover-timeout mymaster 180000</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>redis-sentinel-26380.conf和redis-sentinel-26381.conf的配置仅仅差异是port(端口)的不同。然后启动三个sentinel哨兵redis-sentinel /etc/redis-sentinel-26379.confredis-sentinel /etc/redis-sentinel-26380.confredis-sentinel /etc/redis-sentinel-26381.conf</code></pre><p>监控拓扑图</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181116091956977-1189113564.png" alt="img"></p><p>此时查看哨兵是否成功通信</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@master ~]# redis-cli -p 26379  info sentinel# Sentinelsentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name=mymaster,status=ok,address=192.168.119.10:6379,slaves=2,sentinels=3#看到最后一条信息正确即成功了哨兵，哨兵主节点名字叫做mymaster，状态ok，监控地址是192.168.119.10:6379，有两个从节点，3个哨兵</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="redis高可用故障实验"><a href="#redis高可用故障实验" class="headerlink" title="redis高可用故障实验"></a>redis高可用故障实验</h1><p>大致思路</p><ul><li><p>杀掉主节点的redis进程6379端口，观察从节点是否会进行新的master选举，进行切换</p></li><li><p>重新恢复旧的“master”节点，查看此时的redis身份</p><p>首先查看三个redis的进程状态</p></li></ul><pre><code>ps -ef|grep redis</code></pre><p>检查三个节点的复制身份状态</p><p>第一个</p><pre><code>[root@master tmp]# redis-cli -p 6381 info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6380</code></pre><p>第二个</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@master tmp]# redis-cli -p 6380 info replication# Replicationrole:masterconnected_slaves:2slave0:ip=127.0.0.1,port=6381,state=online,offset=54386,lag=0slave1:ip=127.0.0.1,port=6379,state=online,offset=54253,lag=0</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>第三个</p><pre><code>[root@master tmp]# redis-cli -p 6379 info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6380</code></pre><p><strong>此时，干掉master！！！然后等待其他两个节点是否能自动被哨兵sentienl，切换为master节点</strong></p><pre><code>ps -ef|grep 6380   #干掉master进程</code></pre><p>此时查看两个slave的状态</p><p><strong>精髓就是查看一个参数</strong></p><pre><code>master_link_down_since_seconds:13</code></pre><p><strong>稍等片刻之后，发现slave节点成为master节点！！</strong></p><pre><code>[root@master tmp]# redis-cli -p 6379 info replication# Replicationrole:masterconnected_slaves:1slave0:ip=127.0.0.1,port=6381,state=online,offset=41814,lag=1</code></pre><p><strong>大功告成！！开心！！！</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis不重启，切换RDB备份到AOF备份</title>
      <link href="2019/11/15/Linux/redis%E4%B8%8D%E9%87%8D%E5%90%AF%EF%BC%8C%E5%88%87%E6%8D%A2RDB%E5%A4%87%E4%BB%BD%E5%88%B0AOF%E5%A4%87%E4%BB%BD/"/>
      <url>2019/11/15/Linux/redis%E4%B8%8D%E9%87%8D%E5%90%AF%EF%BC%8C%E5%88%87%E6%8D%A2RDB%E5%A4%87%E4%BB%BD%E5%88%B0AOF%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="redis不重启，切换RDB备份到AOF备份"><a href="#redis不重启，切换RDB备份到AOF备份" class="headerlink" title="redis不重启，切换RDB备份到AOF备份"></a><a href="https://www.cnblogs.com/pyyu/p/10061526.html">redis不重启，切换RDB备份到AOF备份</a></h1><h1 id="确保redis版本在2-2以上"><a href="#确保redis版本在2-2以上" class="headerlink" title="确保redis版本在2.2以上"></a>确保redis版本在2.2以上</h1><pre><code>[root@pyyuc /data 22:23:30]#redis-server -vRedis server v=4.0.10 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=64cb6afcf41664c</code></pre><p>本文在redis4.0中，通过config set命令，达到不重启redis服务，从RDB持久化切换为AOF</p><h1 id="实验环境准备"><a href="#实验环境准备" class="headerlink" title="实验环境准备"></a>实验环境准备</h1><p>redis.conf服务端配置文件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>daemonize yesport 6379logfile /data/6379/redis.logdir /data/6379dbfilename  dbmp.rdbsave 900 1                    #rdb机制 每900秒 有1个修改记录save 300 10                    #每300秒        10个修改记录save 60  10000                #每60秒内        10000修改记录</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>启动redis服务端</p><pre><code>redis-server redis.conf</code></pre><p>登录redis-cli插入数据，手动持久化</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; set name chaogeOK127.0.0.1:6379&gt; set age 18OK127.0.0.1:6379&gt; set addr shaheOK127.0.0.1:6379&gt; saveOK</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>检查RDB文件</p><pre><code>[root@pyyuc /data 22:34:16]#ls 6379/dbmp.rdb  redis.log</code></pre><h1 id="备份这个rdb文件，保证数据安全"><a href="#备份这个rdb文件，保证数据安全" class="headerlink" title="备份这个rdb文件，保证数据安全"></a>备份这个rdb文件，保证数据安全</h1><pre><code>[root@pyyuc /data/6379 22:35:38]#cp dbmp.rdb /opt/</code></pre><h1 id="执行命令，开启AOF持久化"><a href="#执行命令，开启AOF持久化" class="headerlink" title="执行命令，开启AOF持久化"></a>执行命令，开启AOF持久化</h1><pre><code>127.0.0.1:6379&gt; CONFIG set appendonly yes   #开启AOF功能OK127.0.0.1:6379&gt; CONFIG SET save ""  #关闭RDB功能OK</code></pre><h1 id="确保数据库的key数量正确"><a href="#确保数据库的key数量正确" class="headerlink" title="确保数据库的key数量正确"></a>确保数据库的key数量正确</h1><pre><code>127.0.0.1:6379&gt; keys *1) "addr"2) "age"3) "name"</code></pre><h1 id="确保插入新的key，AOF文件会记录"><a href="#确保插入新的key，AOF文件会记录" class="headerlink" title="确保插入新的key，AOF文件会记录"></a>确保插入新的key，AOF文件会记录</h1><pre><code>127.0.0.1:6379&gt; set title golangOK</code></pre><p><strong>此时RDB已经正确切换AOF，注意还得修改redis.conf添加AOF设置，不然重启后，通过config set的配置将丢失</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从同步</title>
      <link href="2019/11/15/Linux/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
      <url>2019/11/15/Linux/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="redis主从同步"><a href="#redis主从同步" class="headerlink" title="redis主从同步"></a><a href="https://www.cnblogs.com/pyyu/p/10012904.html">redis主从同步</a></h1><h1 id="redis主从同步-1"><a href="#redis主从同步-1" class="headerlink" title="redis主从同步"></a>redis主从同步</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180922122856003-755522114.png" alt="img"></p><p>原理：<br>\1. 从服务器向主服务器发送 SYNC 命令。<br>\2. 接到 SYNC 命令的主服务器会调用BGSAVE 命令，创建一个 RDB 文件，并使用缓冲区记录接下来执行的所有写命令。<br>\3. 当主服务器执行完 BGSAVE 命令时，它会向从服务器发送 RDB 文件，而从服务器则会接收并载入这个文件。<br>\4. 主服务器将缓冲区储存的所有写命令发送给从服务器执行。</p><p>-————<br>1、在开启主从复制的时候，使用的是RDB方式的，同步主从数据的<br>2、同步开始之后，通过主库命令传播的方式，主动的复制方式实现<br>3、2.8以后实现PSYNC的机制，实现断线重连</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>6380.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1、环境：准备两个或两个以上redis实例mkdir /data/638{0..2}  #创建6380 6381 6382文件夹配置文件示例：vim   /data/6380/redis.confport 6380daemonize yespidfile /data/6380/redis.pidloglevel noticelogfile "/data/6380/redis.log"dbfilename dump.rdbdir /data/6380protected-mode no</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>6381.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>vim   /data/6381/redis.confport 6381daemonize yespidfile /data/6381/redis.pidloglevel noticelogfile "/data/6381/redis.log"dbfilename dump.rdbdir /data/6381protected-mode no</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>6382.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>port 6382daemonize yespidfile /data/6382/redis.pidloglevel noticelogfile "/data/6382/redis.log"dbfilename dump.rdbdir /data/6382protected-mode no</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>启动三个redis实例</p><pre><code>redis-server /data/6380/redis.confredis-server /data/6381/redis.confredis-server /data/6382/redis.conf</code></pre><p>主从规划</p><pre><code>主节点：6380从节点：6381、6382</code></pre><h1 id="配置主从同步"><a href="#配置主从同步" class="headerlink" title="配置主从同步"></a>配置主从同步</h1><p>6381/6382命令行</p><p>redis-cli -p 6381<br>SLAVEOF 127.0.0.1 6380  #指明主的地址</p><p>redis-cli -p 6382<br>SLAVEOF 127.0.0.1 6380  #指明主的地址</p><p>检查主从状态</p><p>从库：</p><pre><code>127.0.0.1:6382&gt; info replication127.0.0.1:6381&gt; info replication</code></pre><p>主库：</p><pre><code>127.0.0.1:6380&gt; info replication</code></pre><h1 id="测试写入数据，主库写入数据，检查从库数据"><a href="#测试写入数据，主库写入数据，检查从库数据" class="headerlink" title="测试写入数据，主库写入数据，检查从库数据"></a>测试写入数据，主库写入数据，检查从库数据</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>主127.0.0.1:6380&gt; set name chaoge从127.0.0.1:6381&gt;get name </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="手动进行主从复制故障切换"><a href="#手动进行主从复制故障切换" class="headerlink" title="手动进行主从复制故障切换"></a>手动进行主从复制故障切换</h1><pre><code>#关闭主库6380redis-cli -p 6380shutdown</code></pre><p>检查从库主从信息，此时master_link_status:down </p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>redis-cli -p 6381info replicationredis-cli -p 6382info replication</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>既然主库挂了，我想要在6381 6382之间选一个新的主库</strong></p><p><strong>1.关闭6381的从库身份</strong></p><pre><code>redis-cli -p 6381info replicationslaveof no one</code></pre><p><strong>2.将6382设为6381的从库</strong></p><pre><code>6382连接到6381：[root@db03 ~]# redis-cli -p 6382127.0.0.1:6382&gt; SLAVEOF no one127.0.0.1:6382&gt; SLAVEOF 127.0.0.1 6381</code></pre><p>3.检查6382，6381的主从信息</p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis发布订阅</title>
      <link href="2019/11/15/Linux/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%20/"/>
      <url>2019/11/15/Linux/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%20/</url>
      
        <content type="html"><![CDATA[<h1 id="redis发布订阅"><a href="#redis发布订阅" class="headerlink" title="redis发布订阅"></a><a href="https://www.cnblogs.com/pyyu/p/10013703.html">redis发布订阅</a></h1><h1 id="发布publish"><a href="#发布publish" class="headerlink" title="发布publish"></a>发布publish</h1><h1 id="订阅subscribe"><a href="#订阅subscribe" class="headerlink" title="订阅subscribe"></a>订阅subscribe</h1><p>Redis 通过 PUBLISH 、 SUBSCRIBE 等命令实现了订阅与发布模式。</p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181124214144677-1561158557.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181124213748132-1685790439.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181124215053216-993504589.png" alt="img"></p><p><strong>举例1：</strong></p><p><strong>qq群的公告，单个发布者，多个收听者</strong></p><h1 id="发布-订阅-实验"><a href="#发布-订阅-实验" class="headerlink" title="发布/订阅 实验"></a>发布/订阅 实验</h1><p>发布订阅的命令</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>PUBLISH channel msg    将信息 message 发送到指定的频道 channelSUBSCRIBE channel [channel ...]    订阅频道，可以同时订阅多个频道UNSUBSCRIBE [channel ...]    取消订阅指定的频道, 如果不指定频道，则会取消订阅所有频道PSUBSCRIBE pattern [pattern ...]    订阅一个或多个符合给定模式的频道，每个模式以 * 作为匹配符，比如 it* 匹配所    有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有    以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类PUNSUBSCRIBE [pattern [pattern ...]]    退订指定的规则, 如果没有参数则会退订所有规则PUBSUB subcommand [argument [argument ...]]    查看订阅与发布系统状态注意：使用发布订阅模式实现的消息队列，当有客户端订阅channel后只能收到后续发布到该频道的消息，之前发送的不会缓存，必须Provider和Consumer同时在线。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="发布订阅："><a href="#发布订阅：" class="headerlink" title="发布订阅："></a>发布订阅：</h1><p><strong>窗口1，启动两个redis-cli窗口，均订阅diantai 频道（channel）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181125020630178-1661625415.png" alt="img"></p><p><strong>窗口2，启动发布者向频道 diantai发送消息</strong></p><pre><code>[root@web02 ~]# redis-cli127.0.0.1:6379&gt; PUBLISH diantai 'jinyewugenglaiwojia'(integer) 2</code></pre><h4 id="窗口3，查看订阅者的消息状态"><a href="#窗口3，查看订阅者的消息状态" class="headerlink" title="窗口3，查看订阅者的消息状态"></a>窗口3，查看订阅者的消息状态</h4><h1 id="订阅一个或者多个符合模式的频道"><a href="#订阅一个或者多个符合模式的频道" class="headerlink" title="订阅一个或者多个符合模式的频道"></a>订阅一个或者多个符合模式的频道</h1><p><strong>窗口1，启动两个redis-cli窗口，均订阅 wang*频道（channel）</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; PSUBSCRIBE wang*Reading messages... (press Ctrl-C to quit)1) "psubscribe"2) "wang*"3) (integer) 11) "pmessage"2) "wang*"3) "wangbaoqiang"4) "jintian zhennanshou "</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>窗口2，启动redis-cli窗口，均订阅wang*频道</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; PSUBSCRIBE wang*Reading messages... (press Ctrl-C to quit)1) "psubscribe"2) "wang*"3) (integer) 11) "pmessage"2) "wang*"3) "wangbaoqiang"4) "jintian zhennanshou "</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>窗口3，发布者消息</p><pre><code>[root@web02 ~]# redis-cli127.0.0.1:6379&gt; PUBLISH wangbaoqiang "jintian zhennanshou "(integer) 2</code></pre><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化RDB与AOF</title>
      <link href="2019/11/15/Linux/redis%E6%8C%81%E4%B9%85%E5%8C%96RDB%E4%B8%8EAOF/"/>
      <url>2019/11/15/Linux/redis%E6%8C%81%E4%B9%85%E5%8C%96RDB%E4%B8%8EAOF/</url>
      
        <content type="html"><![CDATA[<h1 id="redis持久化RDB与AOF"><a href="#redis持久化RDB与AOF" class="headerlink" title="redis持久化RDB与AOF"></a><a href="https://www.cnblogs.com/pyyu/p/10009493.html">redis持久化RDB与AOF</a></h1><h1 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h1><p><code>Redis</code>是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题，<code>Redis</code>提供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。</p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p><code>redis</code>提供了<code>RDB持久化</code>的功能，这个功能可以将<code>redis</code>在内存中的的状态保存到硬盘中，它可以<strong>手动执行。</strong></p><p>也可以再<code>redis.conf</code>中配置，<strong>定期执行</strong>。</p><p>RDB持久化产生的RDB文件是一个<strong>经过压缩</strong>的<strong>二进制文件</strong>，这个文件被保存在硬盘中，redis可以通过这个文件还原数据库当时的状态。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>RDB(持久化)内存数据保存到磁盘在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）优点：速度快，适合做备份，主从复制就是基于RDB持久化功能实现rdb通过再redis中使用save命令触发 rdbrdb配置参数：dir /data/6379/dbfilename  dbmp.rdb每过900秒 有1个操作就进行持久化save 900秒  1个修改类的操作save 300秒  10个操作save 60秒  10000个操作save  900 1save 300 10save 60  10000</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="redis持久化之RDB实践"><a href="#redis持久化之RDB实践" class="headerlink" title="redis持久化之RDB实践"></a>redis持久化之RDB实践</h1><p>1.启动redis服务端,准备配置文件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>daemonize yesport 6379logfile /data/6379/redis.logdir /data/6379              #定义持久化文件存储位置dbfilename  dbmp.rdb        #rdb持久化文件bind 10.0.0.10  127.0.0.1    #redis绑定地址requirepass redhat            #redis登录密码save 900 1                    #rdb机制 每900秒 有1个修改记录save 300 10                    #每300秒        10个修改记录save 60  10000                #每60秒内        10000修改记录</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2.启动redis服务端</p><p>3.登录redis设置一个key</p><pre><code>redis-cli -a redhat</code></pre><p>4.此时检查目录，/data/6379底下没有dbmp.rdb文件</p><p>5.通过save触发持久化，将数据写入RDB文件</p><pre><code>127.0.0.1:6379&gt; set age 18OK127.0.0.1:6379&gt; saveOK</code></pre><h1 id="redis持久化之AOF"><a href="#redis持久化之AOF" class="headerlink" title="redis持久化之AOF"></a>redis持久化之AOF</h1><p>AOF（append-only log file）<br>记录服务器执行的所有变更操作命令（例如set del等），并在服务器启动时，通过重新执行这些命令来还原数据集<br>AOF 文件中的命令全部以redis协议的格式保存，新命令追加到文件末尾。<br>优点：最大程序保证数据不丢<br>缺点：日志记录非常大</p><pre><code>redis-client   写入数据  &gt;  redis-server   同步命令   &gt;  AOF文件</code></pre><p>配置参数</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>AOF持久化配置，两条参数appendonly yesappendfsync  always    总是修改类的操作             everysec   每秒做一次持久化             no     依赖于系统自带的缓存大小机制</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>1.准备aof配置文件 redis.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>daemonize yesport 6379logfile /data/6379/redis.logdir /data/6379dbfilename  dbmp.rdbrequirepass redhatsave 900 1save 300 10save 60  10000appendonly yesappendfsync everysec</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2.启动redis服务</p><pre><code>redis-server /etc/redis.conf</code></pre><p>3.检查redis数据目录/data/6379/是否产生了aof文件</p><pre><code>[root@web02 6379]# lsappendonly.aof  dbmp.rdb  redis.log</code></pre><p>4.登录redis-cli，写入数据，实时检查aof文件信息</p><pre><code>[root@web02 6379]# tail -f appendonly.aof</code></pre><p>5.设置新key，检查aof信息，然后关闭redis，检查数据是否持久化</p><pre><code>redis-cli -a redhat shutdownredis-server /etc/redis.confredis-cli -a redhat</code></pre><p><strong>redis 持久化方式有哪些？有什么区别？</strong></p><p><strong>rdb：基于快照的持久化，速度更快，一般用作备份，主从复制也是依赖于rdb持久化功能</strong></p><p><strong>aof：以追加的方式记录redis操作日志的文件。可以最大程度的保证redis数据安全，类似于mysql的binlog</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/loading.gif" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis面试题</title>
      <link href="2019/11/15/Linux/redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2019/11/15/Linux/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="redis面试题"><a href="#redis面试题" class="headerlink" title="redis面试题"></a><a href="https://www.cnblogs.com/pyyu/p/10061551.html">redis面试题</a></h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);">![复制代码](./redis面试题 - py鱼 - 博客园_files/copycode.gif)</a></p><pre><code>redis和memcached比较？redis中数据库默认是多少个db 及作用？python操作redis的模块？如果redis中的某个列表中的数据量非常大，如果实现循环显示每一个值？redis如何实现主从复制？以及数据同步机制？redis中的sentinel的作用？如何实现redis集群？redis中默认有多少个哈希槽？简述redis的有哪几种持久化策略及比较？列举redis支持的过期策略。MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中都是热点数据？ 写代码，基于redis的列表实现 先进先出、后进先出队列、优先级队列。如何基于redis实现消息队列？如何基于redis实现发布和订阅？以及发布订阅和消息队列的区别？什么是codis及作用？什么是twemproxy及作用？写代码实现redis事务操作。redis中的watch的命令的作用？基于redis如何实现商城商品数量计数器？简述redis分布式锁和redlock的实现机制。什么是一致性哈希？Python中是否有相应模块？如何高效的找到redis中所有以oldboy开头的key？</code></pre><p><a href="javascript:void(0);">![复制代码](./redis面试题 - py鱼 - 博客园_files/copycode.gif)</a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><p>标签: <a href="https://www.cnblogs.com/pyyu/tag/redis/">redis</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim与程序员</title>
      <link href="2019/11/15/Linux/vim%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
      <url>2019/11/15/Linux/vim%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%91%98/</url>
      
        <content type="html"><![CDATA[<h1 id="vim与程序员"><a href="#vim与程序员" class="headerlink" title="vim与程序员"></a><a href="https://www.cnblogs.com/pyyu/p/9460649.html">vim与程序员</a></h1><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><h2 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h2><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><h2 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h2><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p><h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令</p><p>移动光标</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>w(e)　　移动光标到下一个单词b　　　　移动到光标上一个单词数字0　　移动到本行开头$　　　　移动光标到本行结尾H　　　　移动光标到屏幕首行M　　　　移动到光标到屏幕的中间一行L　　　　移动光标到屏幕的尾行gg　　　 移动光标到文档的首行G　　　　移动光标到文档尾行ctrl + f　　下一页ctrl + b　　上一页`.　　移动光标到上一次的修改行</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>查找</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>/chaoge     在整篇文档中搜索chaoge字符串,向下查找?chaoge     在整篇文档中搜索chaoge字符串,向上查找*        查找整个文档，匹配光标所在的所有单词,按下n查找下一处,N上一处#        查找整个文档，匹配光标所在的所有单词,按下n查找下一处,N上一处gd        找到光标所在单词匹配的单词，并停留在非注释的第一个匹配上%　　　　找到括号的另一半！！</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>复制，删除，粘贴</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>yy    拷贝光标所在行dd    删除光标所在行D     删除当前光标到行尾的内容dG    删除当前行到文档尾部的内容p     粘贴yy所复制的内容x　　 删除光标所在的字符u     撤销上一步的操作</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>数字与命令</p><pre><code>3yy　　　　拷贝光标所在的3行5dd　　　　删除光标所在5行</code></pre><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>在命令模式下按下字母i</p><p>即可进入输入模式，可以编写代码啦。。。<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180811205203749-926055983.png" alt="img"></p><h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>在命令模式下输入冒号（英文的:），就进入了底线命令模式，在底线命令模式下可以输入单个或多个字符的命令，常用命令有：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>:q!     强制退出:wq!    强制写入退出:set nu 显示行号:数字　　调到数字那行随时按下esc可以退出底线命令模式</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="vim工作模式"><a href="#vim工作模式" class="headerlink" title="vim工作模式"></a>vim工作模式</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180811210511725-46034130.png" alt="img"></p><h2 id="vim按键"><a href="#vim按键" class="headerlink" title="vim按键"></a>vim按键</h2><p>移动光标</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>移动光标的方法h 或 向左箭头键(←)    光标向左移动一个字符j 或 向下箭头键(↓)    光标向下移动一个字符k 或 向上箭头键(↑)    光标向上移动一个字符l 或 向右箭头键(→)    光标向右移动一个字符向下移动5行　　　　　　5j向右移动10字符　　　　10ln(space)　　　　按下数字n,例如10，然后按下空格，光标会向右移动10个字符</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>底线命令</p><pre><code>:! command    暂时离开vim指令模式，执行command的结果例如  :!ip a    临时看一下ip信息，然后可以回到vim:set nu　　　　显示vim行号:set nonu　　　　取消行号</code></pre><p>更多nb的vim用法请看菜鸟教程：<a href="http://www.runoob.com/linux/linux-vim.html">http://www.runoob.com/linux/linux-vim.html</a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue+uwsgi+nginx部署路飞学城</title>
      <link href="2019/11/15/Linux/vue+uwsgi+nginx%E9%83%A8%E7%BD%B2%E8%B7%AF%E9%A3%9E%E5%AD%A6%E5%9F%8E/"/>
      <url>2019/11/15/Linux/vue+uwsgi+nginx%E9%83%A8%E7%BD%B2%E8%B7%AF%E9%A3%9E%E5%AD%A6%E5%9F%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-uwsgi-nginx部署路飞学城"><a href="#vue-uwsgi-nginx部署路飞学城" class="headerlink" title="vue+uwsgi+nginx部署路飞学城"></a><a href="https://www.cnblogs.com/pyyu/p/10160874.html">vue+uwsgi+nginx部署路飞学城</a></h1><p><strong>有一天，老男孩的苑日天给我发来了两个神秘代码，听说是和mjj的结晶</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181222120654157-615683769.png" alt="img"></strong></p><p>超哥将这两个代码，放到了一个网站上，大家可以自行下载</p><pre><code>路飞学城django代码https://files.cnblogs.com/files/pyyu/luffy_boy.zipvue代码https://files.cnblogs.com/files/pyyu/07-luffy_project_01.zip</code></pre><h1 id="一、将代码搞到服务器上"><a href="#一、将代码搞到服务器上" class="headerlink" title="一、将代码搞到服务器上"></a>一、将代码搞到服务器上</h1><pre><code>在linux上直接下载wget https://files.cnblogs.com/files/pyyu/luffy_boy.zipwget https://files.cnblogs.com/files/pyyu/07-luffy_project_01.zip在window上下载，通过lrzsz，或者xftp传输到linux服务器上</code></pre><h1 id="二、先从前端vue搞起"><a href="#二、先从前端vue搞起" class="headerlink" title="二、先从前端vue搞起"></a>二、先从前端vue搞起</h1><h2 id="要在服务器上，编译打包vue项目，必须得有node环境"><a href="#要在服务器上，编译打包vue项目，必须得有node环境" class="headerlink" title="要在服务器上，编译打包vue项目，必须得有node环境"></a>要在服务器上，编译打包vue项目，必须得有node环境</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>下载node二进制包，此包已经包含node，不需要再编译wget https://nodejs.org/download/release/v8.6.0/node-v8.6.0-linux-x64.tar.gz解压缩tar -zxvf node-v8.6.0-linux-x64.tar.gz进入node文件夹[root@web02 opt]# cd node-v8.6.0-linux-x64/[root@web02 node-v8.6.0-linux-x64]# lsbin  CHANGELOG.md  etc  include  lib  LICENSE  README.md  share[root@web02 node-v8.6.0-linux-x64]# ls binnode  npm  npx[root@web02 node-v8.6.0-linux-x64]# ./bin/node -vv8.6.0[root@web02 node-v8.6.0-linux-x64]# ./bin/npm -v5.3.0</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>将node命令，添加至linux环境变量,修改/etc/profile，写入</p><pre><code>PATH=$PATH:/opt/node-v8.6.0-linux-x64/bin</code></pre><p>读取文件，生效PATH</p><pre><code>source /etc/profile</code></pre><p>测试path</p><pre><code>[root@web02 node-v8.6.0-linux-x64]# node -vv8.6.0[root@web02 node-v8.6.0-linux-x64]# npm -v5.3.0</code></pre><h2 id="node环境有了，安装node模块，以及打包node项目"><a href="#node环境有了，安装node模块，以及打包node项目" class="headerlink" title="node环境有了，安装node模块，以及打包node项目"></a>node环境有了，安装node模块，以及打包node项目</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>进入vue源码目录cd 07-luffy_project_01/安装vue模块，默认去装package.json的模块内容，如果出现模块安装失败，手动再装npm install 此时注意，你本地写的vue代码，接口很可能连接的服务器地址有问题，注意Axios.POST提交的地址，一定得发送给django应用（如果用了nginx，就发送给nginx的入口端口）超哥这里为了试验方便，将vue项目和django项目放在了一台服务器，通过nginx反向代理功能(8000端口)，转发vue请求给django(9000)准备编译打包vue项目，替换配置文件所有地址，改为服务器地址sed -i 's/127.0.0.1/192.168.119.12/g' /opt/07-luffy_project_01/src/restful/api.js确保vue的route模式是history路径：opt/luffy/07-luffy_project_01/src/router/index.js</code></pre><p>export default new Router({<br>linkActiveClass:’is-active’,<br>mode: ‘history’,//改成history模式</p><pre><code>此时打包vue项目，生成一个dist静态文件夹npm run build检查dist文件夹[root@web02 07-luffy_project_01]# ls dist/index.html static</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="至此vue代码就结束了，只需要让nginx配置，找到vue的index-html首页文件即可"><a href="#至此vue代码就结束了，只需要让nginx配置，找到vue的index-html首页文件即可" class="headerlink" title="至此vue代码就结束了，只需要让nginx配置，找到vue的index.html首页文件即可"></a>至此vue代码就结束了，只需要让nginx配置，找到vue的index.html首页文件即可</h2><p>nginx这里不做解释，编译安装好即可</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>server {　　　　 #用户访问域名或者ip，默认是nginx的80端口        listen       80;        server_name  192.168.119.12;　　　　 #url匹配  /   也就是请求地址是192.168.119.12时，进入此location，返回vue的dist下index.html路飞学城首页        location / {        root /opt/07-luffy_project_01/dist;        index index.html;        }    }</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="三、配置后端代码，解决虚拟环境，保证项目干净隔离"><a href="#三、配置后端代码，解决虚拟环境，保证项目干净隔离" class="headerlink" title="三、配置后端代码，解决虚拟环境，保证项目干净隔离"></a>三、配置后端代码，解决虚拟环境，保证项目干净隔离</h1><h2 id="激活虚拟环境venv1，在虚拟环境下，安装路飞项目所需的依赖模块"><a href="#激活虚拟环境venv1，在虚拟环境下，安装路飞项目所需的依赖模块" class="headerlink" title="激活虚拟环境venv1，在虚拟环境下，安装路飞项目所需的依赖模块"></a>激活虚拟环境venv1，在虚拟环境下，安装路飞项目所需的依赖模块</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p>[root@web02 opt]# cat requirements.txt<br>certifi==2018.11.29<br>chardet==3.0.4<br>crypto==1.4.1<br>Django==2.1.4<br>django-redis==4.10.0<br>django-rest-framework==0.1.0<br>djangorestframework==3.9.0<br>idna==2.8<br>Naked==0.1.31<br>pycrypto==2.6.1<br>pytz==2018.7<br>PyYAML==3.13<br>redis==3.0.1<br>requests==2.21.0<br>shellescape==3.4.1<br>urllib3==1.24.1<br>uWSGI==2.0.17.1</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="这个路飞代码数据库用的是sqllite，不需要配置数据库了"><a href="#这个路飞代码数据库用的是sqllite，不需要配置数据库了" class="headerlink" title="这个路飞代码数据库用的是sqllite，不需要配置数据库了"></a>这个路飞代码数据库用的是sqllite，不需要配置数据库了</h2><h2 id="购物车用都的是redis，因此要启动服务器的redis-server服务端"><a href="#购物车用都的是redis，因此要启动服务器的redis-server服务端" class="headerlink" title="购物车用都的是redis，因此要启动服务器的redis-server服务端"></a>购物车用都的是redis，因此要启动服务器的redis-server服务端</h2><pre><code>redis-server /etc/redis.confps -ef|grep redisredis-server *:6379</code></pre><h2 id="通过uwsgi启动路飞项目"><a href="#通过uwsgi启动路飞项目" class="headerlink" title="通过uwsgi启动路飞项目"></a>通过uwsgi启动路飞项目</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[uwsgi]# Django-related settings# the base directory (full path)chdir           = /opt/luffy_boy# Django's wsgi filemodule          = luffy_boy.wsgi# the virtualenv (full path)home            = /opt/venv1# process-related settings# mastermaster          = true# maximum number of worker processesprocesses       = 1# the socket (use the full path to be safesocket          = 0.0.0.0:9000# clear environment on exitvacuum          = true#后台运行uwsgidaemonize=yes</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>(venv1) [root@web02 opt]# uwsgi --ini luffy_boy/uwsgi.ini</code></pre><h1 id="四、配置nginx，此步重要"><a href="#四、配置nginx，此步重要" class="headerlink" title="四、配置nginx，此步重要"></a>四、配置nginx，此步重要</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>worker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    server {        listen       80;        server_name  192.168.119.12;        location / {        root /opt/07-luffy_project_01/dist;        index index.html;　　　　#这一条参数确保vue页面刷新时候，不会出现404页面　　　　  try_files $uri $uri/ /index.html;        }        error_page   500 502 503 504  /50x.html;        location = /50x.html {           root   html;        }    }server {listen       8000;        server_name  192.168.119.12;        location / {        uwsgi_pass 0.0.0.0:9000;        include /opt/nginx/conf/uwsgi_params;        }        location /static {        alias /opt/static;}}}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190403225637482-516969019.png" alt="img"></p><h1 id="项目访问"><a href="#项目访问" class="headerlink" title="项目访问"></a>项目访问</h1><p>测试账号密码</p><pre><code>alexalex3714</code></pre><p>目前代码功能演示，演示流程：</p><ol><li>登录alex账号</li><li>选择免费课程，django框架学习</li><li>添加课程到购物车，检查alex账号的购物车记录，添加成功后再redis有数据</li></ol><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181222140116496-1744706649.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181222140143224-929686301.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用服务安装部署</title>
      <link href="2019/11/15/Linux/%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%20/"/>
      <url>2019/11/15/Linux/%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%20/</url>
      
        <content type="html"><![CDATA[<h1 id="常用服务安装部署"><a href="#常用服务安装部署" class="headerlink" title="常用服务安装部署"></a><a href="https://www.cnblogs.com/pyyu/articles/9365054.html">常用服务安装部署</a></h1><p>学了前面的Linux基础，想必童鞋们是不是更感兴趣了？接下来就学习常用服务部署吧！</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180725113018094-1739773585.png" alt="img"></p><p>安装环境：</p><p>centos7 + vmware + xshell</p><h1 id="MYSQL-mariadb"><a href="#MYSQL-mariadb" class="headerlink" title="MYSQL(mariadb)"></a>MYSQL(mariadb)</h1><p><a href="https://www.cnblogs.com/pyyu/p/9467289.html">点我就能找到mysql文章</a></p><p><a href="https://www.cnblogs.com/pyyu/p/9467289.html">https://www.cnblogs.com/pyyu/p/9467289.html</a></p><h3 id="Python操作redis"><a href="#Python操作redis" class="headerlink" title="Python操作redis"></a>Python操作redis</h3><p><a href="https://www.cnblogs.com/pyyu/p/6964593.html">文章地址。。。。https://www.cnblogs.com/pyyu/p/6964593.html</a></p><h1 id="Python编译安装"><a href="#Python编译安装" class="headerlink" title="Python编译安装"></a>Python编译安装</h1><p>先放个龟叔再说</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180725172043904-589577892.png" alt="img"></p><p>centos7默认是装有python的，咱们先看一下</p><pre><code>#检查python版本[root@oldboy_python ~ 17:23:54]#python -VPython 2.7.5</code></pre><p>再放一张图，《震惊，python2.7不再维护！》</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180725172647585-1118586195.png" alt="img"></p><p>好了，咱们开始python3之旅。</p><p>安装python连接地址：</p><p>⬇️⬇️⬇️⬇️⬇️</p><p><a href="https://www.cnblogs.com/pyyu/p/7402145.html"> 这里看超哥另外一篇文章：https://www.cnblogs.com/pyyu/p/7402145.html</a></p><h3 id="Python之Linux下的virtualenv"><a href="#Python之Linux下的virtualenv" class="headerlink" title="Python之Linux下的virtualenv"></a>Python之Linux下的virtualenv</h3><p><a href="https://www.cnblogs.com/pyyu/p/9015317.html">这里请看超哥的另另另一篇文章。。。请点击https://www.cnblogs.com/pyyu/p/9015317.html</a></p><h3 id="Ipython解释器"><a href="#Ipython解释器" class="headerlink" title="Ipython解释器"></a>Ipython解释器</h3><p><a href="https://www.cnblogs.com/pyyu/p/8467239.html">老套路。。文章地址。。https://www.cnblogs.com/pyyu/p/8467239.html</a></p><h1 id="Web服务基础"><a href="#Web服务基础" class="headerlink" title="Web服务基础"></a>Web服务基础</h1><p><a href="https://www.cnblogs.com/pyyu/p/9467256.html">请点击超哥文章 https://www.cnblogs.com/pyyu/p/9467256.html</a></p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><a href="https://www.cnblogs.com/pyyu/p/9468680.html">同样的，我又写了一篇博客https://www.cnblogs.com/pyyu/p/9468680.html</a></p><h1 id="Saltstack"><a href="#Saltstack" class="headerlink" title="Saltstack"></a>Saltstack</h1><p>对于运维人员来说，反复复杂的工作很烦，效率低，还容易出错。而传统运维也想着自动化运维的方向进行发展，</p><p>而saltstack则是在自动化运维上非常好用的工具，saltstack是python开发的一款自动化运维工具，可以批量管理操作主机，</p><p>远程执行脚本等功能。完全开源，还可以设置web管理界面，更简单的管理大量服务器。</p><p><a href="https://www.cnblogs.com/pyyu/p/9465608.html">saltstack请点超哥文章 https://www.cnblogs.com/pyyu/p/9465608.html</a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡</title>
      <link href="2019/11/15/Linux/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2019/11/15/Linux/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><a href="https://www.cnblogs.com/pyyu/p/10004670.html">负载均衡</a></h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122231803127-188968722.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122231837300-1361831847.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122231933322-1866836813.png" alt="img"></p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122232211243-1810845203.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器核心知识</title>
      <link href="2019/11/15/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/"/>
      <url>2019/11/15/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器核心知识"><a href="#服务器核心知识" class="headerlink" title="服务器核心知识"></a><a href="https://www.cnblogs.com/pyyu/articles/9306498.html">服务器核心知识</a></h1><h1 id="电脑：辅助人脑的工具"><a href="#电脑：辅助人脑的工具" class="headerlink" title="电脑：辅助人脑的工具"></a>电脑：辅助人脑的工具</h1><p>现在的人们几乎无时无刻都会碰电脑！不管是桌上型电脑(桌机)、笔记型电脑(笔电)、平板电脑、智慧型手机等等，这些东西都算是电脑。虽然接触的这么多，但是，你了解电脑里面的元件有什么吗？以桌机来说，电脑的机壳里面含有什么元件？不同的电脑可以应用在哪些工作？你生活周遭有哪些电器用品内部是含有电脑相关元件的？底下我们就来谈一谈这些东西呢！</p><p>所谓的电脑就是一种计算机，而计算机其实是：『接受使用者输入指令与资料，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的资讯』。因此，只要有输入设备(不管是键盘还是触控式萤幕)及输出设备(例如电脑萤幕或直接由印表机列印出来)，让你可以输入资料使该机器产生资讯的，那就是一部计算机了。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713170254010-1384037084.png" alt="img"></p><p>好了，根据这个定义你知道哪些东西是计算机了吗？其实包括一般商店用的简易型加减乘除计算机、打电话用的手机、开车用的卫星定位系统(GPS)、提款用的提款机(ATM)、你上课会使用的桌上型个人电脑、外出可能会带的笔记型电脑(包括notebook与netbook)，还有近几年(2015前后)非常热门的平板电脑与智慧型手机，甚至是未来可能会大流行的单版电脑(Xapple pi, banana pi, Raspberry pi, )与智慧型手表，甚至于更多的智慧型穿戴式电脑等等，这些都是计算机喔！</p><h1 id="电脑硬件的组成"><a href="#电脑硬件的组成" class="headerlink" title="电脑硬件的组成"></a>电脑硬件的组成</h1><p>关于电脑的硬件组成部分，其实你可以观察你的桌上型电脑来分析一下，依外观来说这家伙主要可分为三部分，分别是：</p><ul><li>输入单元：包括键盘、滑鼠、读卡机、扫描器、手写板、触控萤幕等等一堆；</li><li>主机部分：这个就是系统单元，被主机机壳保护住了，里面含有一堆板子、CPU 与主记忆体等；</li><li>输出单元：例如萤幕、印表机等等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713171537631-1809727816.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713171851138-1771444594.png" alt="img"></p><p>我们主要透过输入设备如滑鼠与键盘来将一些资料输入到主机里面，然后再由主机的功能处理成为图表或文章等资讯后， 将结果传输到输出设备，如萤幕或印表机上面。那主机里面含有什么元件呢？如果你曾经拆开过电脑主机机壳(包括拆开你的智慧型手机也一样喔！)， 会发现其实主机里面最重要的就是一片主机板，上面安插了中央处理器(CPU) 以及主记忆体、硬碟(或记忆卡) 还有一些介面卡装置而已。当然大部分智慧型手机是将这些元件直接焊接在主机板上面而不是插卡啦！</p><p>整部主机的重点在于中央处理器(Central Processing Unit, CPU)，CPU为一个具有特定功能的晶片，里头含有微指令集，如果你想要让主机进行什么特异的功能，就得要参考这颗CPU是否有相关内建的微指令集才可以。由于CPU的工作主要在于管理与运算，因此在CPU内又可分为两个主要的单元，分别是： 算数逻辑单元与控制单元。其中算数逻辑单元主要负责程式运算与逻辑判断，控制单元则主要在协调各周边元件与各单元间的工作。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713171318343-935396731.png" alt="img"></p><p> 如果不是很了解电脑的运作流程的话，超哥拿个简单的想法来思考好了～假设电脑是一个人体，那么每个元件对应到那个地方呢？可以这样思考：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713172033769-828999659.png" alt="img"></p><ul><li><ul><li>CPU=脑袋瓜子：每个人会作的事情都不一样(微指令集的差异)，但主要都是透过脑袋瓜子来进行判断与控制身体各部分的活动；</li></ul></li></ul><ul><li>主记忆体=脑袋中放置正在被思考的资料的区块：在实际活动过程中，我们的脑袋瓜子需要有外界刺激的资料(例如光线、环境、语言等)来分析，那这些互动资料暂时存放的地方就是主记忆体，主要是用来提供给脑袋瓜子判断用的资讯。</li></ul><ul><li>硬碟=脑袋中放置回忆的记忆区块：跟刚刚的主记忆体不同，主记忆体是提供脑袋目前要思考与处理的资讯，但是有些生活琐事或其他没有要立刻处理的事情，就当成回忆先放置到脑袋的记忆深处吧！那就是硬碟！主要目的是将重要的资料记录起来，以便未来将这些重要的经验再次的使用；</li></ul><ul><li>主机板=神经系统：好像人类的神经一样，将所有重要的元件连接起来，包括手脚的活动都是脑袋瓜子发布命令后，透过神经(主机板)传导给手脚来进行活动啊！</li></ul><ul><li>各项周边设备=人体与外界沟通的手、脚、皮肤、眼睛等：就好像手脚一般，是人体与外界互动的重要关键！</li></ul><ul><li>显示卡=脑袋中的影像：将来自眼睛的刺激转成影像后在脑袋中呈现，所以显示卡所产生的资料来源也是CPU控制的。</li></ul><ul><li>电源供应器(Power)=心脏：所有的元件要能运作得要有足够的电力供给才行！这电力供给就好像心脏一样，如果心脏不够力， 那么全身也就无法动弹的！心脏不稳定呢？那你的身体当然可能断断续续的～不稳定！</li></ul><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>既然是人体的心脏，保障电源供应，就需要质量好的电源，生产环境中单个核心服务器最好是双电源AB线路。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713181956232-702248856.png" alt="img">一个接220V电路，一个可能接蓄电池UPS(不间断电源)</p><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>常见品牌：Intel、AMD，想当于人体的大脑</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713182302966-365568243.png" alt="img"></p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>是CPU和磁盘之间的缓冲设备，也叫临时存储器（存放数据），断电时数据丢失</p><p>一般程序运行时会被调度到内存中执行，服务器关闭或程序关闭后，数据从内存中释放掉。</p><h1 id="电脑用途的分类"><a href="#电脑用途的分类" class="headerlink" title="电脑用途的分类"></a>电脑用途的分类</h1><p>知道了电脑的基本组成与周边装置，也知道其实电脑的CPU种类非常的多，再来我们想要了解的是，电脑如何分类？电脑的分类非常多种，如果以电脑的复杂度与运算能力进行分类的话，主要可以分为这几类：</p><ul><li>超级电脑(Supercomputer)<br>超级电脑是运作速度最快的电脑，但是他的维护、操作费用也最高！主要是用于需要有高速计算的计画中。例如：国防军事、气象预测、太空科技，用在模拟的领域较多。详情也可以参考：国家高速网路与计算中心<a href="http://www.nchc.org.tw的介绍！至于全世界最快速的前500大超级电脑，则请参考：http://www.top500.org。">http://www.nchc.org.tw的介绍！至于全世界最快速的前500大超级电脑，则请参考：http://www.top500.org。</a></li></ul><ul><li>大型电脑(Mainframe Computer)<br>大型电脑通常也具有数个高速的CPU，功能上虽不及超级电脑，但也可用来处理大量资料与复杂的运算。例如大型企业的主机、全国性的证券交易所等每天需要处理数百万笔资料的企业机构，或者是大型企业的资料库伺服器等等。</li></ul><ul><li>迷你电脑(Minicomputer)<br>迷你电脑仍保有大型电脑同时支援多使用者的特性，但是主机可以放在一般作业场所，不必像前两个大型电脑需要特殊的空调场所。通常用来作为科学研究、工程分析与工厂的流程管理等。</li></ul><ul><li>工作站(Workstation)<br>工作站的价格又比迷你电脑便宜许多，是针对特殊用途而设计的电脑。在个人电脑的效能还没有提升到目前的状况之前，工作站电脑的性能/价格比是所有电脑当中较佳的，因此在学术研究与工程分析方面相当常见。</li></ul><ul><li>微电脑(Microcomputer)<br>个人电脑就属于这部份的电脑分类，也是我们本章主要探讨的目标！体积最小，价格最低，但功能还是五脏俱全的！大致又可分为桌上型、笔记型等等。</li></ul><p>若光以效能来说，目前的个人电脑效能已经够快了，甚至已经比工作站等级以上的电脑运算速度还要快！但是工作站电脑强调的是稳定不当机，并且运算过程要完全正确，因此工作站以上等级的电脑在设计时的考量与个人电脑并不相同啦！这也是为啥工作站等级以上的电脑售价较贵的原因。</p><h1 id="互联网常见服务器介绍"><a href="#互联网常见服务器介绍" class="headerlink" title="互联网常见服务器介绍"></a>互联网常见服务器介绍</h1><ul><li>DELL（大多数公司在用）</li><li>HP</li><li>IBM（百度，银行，政府）（贵）</li><li>浪潮</li><li>联想</li></ul><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713173122015-49534006.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713173132503-1109947277.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713173144203-2074797004.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713173152695-2057793362.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713173157433-1476434922.png" alt="img"></p><pre><code>服务器：服务器指的是网络中能对其他机器提供某些服务的计算机系统，相对普通PC，服务器指的是高性能计算机，稳定性、安全性要求更高服务器的高性能体现在高速的运转能力，长时间的可靠运行，强大的数据吞吐能力</code></pre><h1 id="服务器分类"><a href="#服务器分类" class="headerlink" title="服务器分类"></a>服务器分类</h1><p>包括大型机、小型机和UNIX服务器，价格昂贵，体系封闭，但是稳定性极强，性能强、主要用在金融、电信等大型企业核心系统中。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713174119173-633412683.png" alt="img"></p><p>也就是通常所说的PC服务器，价格便宜、兼容性好，稳定性差，不够安全，常用在中小型企业。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713175036433-2114482575.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125230708904-468128064.png" alt="img"></p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713180745824-1590408429.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180713180829127-1124381468.png" alt="img"></p><pre><code>机房托管服务器是按照服务器的厚度来收费的，每一个机柜规格有限，标准机柜可以放16台1u服务器，如果你的服务器太厚太大，机柜能放的服务器就少一些</code></pre><p>1U 单位是==unit==厚度是4.45cm</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>计算机必须有的组成部分（cpu、硬盘、内存、电源）</li><li>服务器 &gt; 个人台式机　　 -稳定性更高</li></ul><h1 id="一张图告诉你Linux的发展"><a href="#一张图告诉你Linux的发展" class="headerlink" title="一张图告诉你Linux的发展"></a>一张图告诉你Linux的发展</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715135607990-2010815445.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程连接Linux</title>
      <link href="2019/11/15/Linux/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux/"/>
      <url>2019/11/15/Linux/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="远程连接Linux"><a href="#远程连接Linux" class="headerlink" title="远程连接Linux"></a><a href="https://www.cnblogs.com/pyyu/articles/9336967.html">远程连接Linux</a></h1><h1 id="为什么要远程连接Linux"><a href="#为什么要远程连接Linux" class="headerlink" title="为什么要远程连接Linux"></a>为什么要远程连接Linux</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719154016950-1152125979.png" alt="img"></p><p>在实际的工作场景中，虚拟机界面或者物理服务器本地的终端都是很少接触的，因为服务器装完系统之后，都要拉倒IDC机房托管，如果是购买的云主机，那更碰不到服务器本体了，只能通过远程连接的方式管理自己的Linux系统。</p><p>因此在装好Linux系统之后，使用的第一步应该是配置好客户端软件（ssh软件进行连接）连接Linux系统。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719153631094-251712022.png" alt="img"></p><p>通过什么软件呢?</p><pre><code>XshellSecureCRT</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719154235581-2125715142.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719154318705-1547939912.png" alt="img"></p><h1 id="远程连接必备的知识"><a href="#远程连接必备的知识" class="headerlink" title="远程连接必备的知识"></a>远程连接必备的知识</h1><h2 id="ip地址-gt-服务器的位置"><a href="#ip地址-gt-服务器的位置" class="headerlink" title="ip地址 > 服务器的位置"></a>ip地址 &gt; 服务器的位置</h2><p>互联网上的计算机都会有一个唯一的32位的ip地址，如同家里的门牌号，对应到服务器的位置。</p><pre><code>我们找人，可以通过身份证号码对应某个人那我们找到某台服务器，也必须是通过IP地址</code></pre><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>（针对自己班级/家庭所在环境）里也有预留的ip地址，一般是192/10/172开头，局域网的IP地址也是唯一的。</p><p>windows查看ip通过命令：</p><pre><code>在cmd终端敲下：ipconfig查看“以太网适配器 本地连接  IPv4”的Ip地址就是自身网线的ip地址了</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719162511173-460357524.png" alt="img"></p><p>Linux查看ip方式：</p><pre><code>方式1：ip addr方式2: ifconfig</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719163059131-1219363710.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719163142174-1538611416.png" alt="img"></p><h3 id="外网Ip"><a href="#外网Ip" class="headerlink" title="外网Ip"></a>外网Ip</h3><p>全世界哪里都可以访问,</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322174744611-1777854956.png" alt="img"></p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322175446227-1742675363.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322175511569-334397356.png" alt="img"></p><h1 id="虚拟机网络配置"><a href="#虚拟机网络配置" class="headerlink" title="虚拟机网络配置"></a>虚拟机网络配置</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>host only 仅主机 单机模式，了解即可电脑pc   &gt;  皇帝虚拟机   &gt;   老百姓老百姓被皇帝控制，无法与外届通信nat模式(网络地址转换)电脑pc  &gt;    皇帝nat     &gt;    宰相虚拟机    &gt;    老百姓老百姓的房子是宰相分配的 与皇帝无关虚拟机的ip是nat分配的，电脑环境无论怎么变化，都不会影响虚拟机好处：在家，在学校，在公司，使用虚拟机，ip地址都不会变化桥接电脑pc    &gt;    皇帝虚拟机   &gt;    老百姓只要更换了一波皇帝，老百姓房子都得换只要换了个教室，插上网线，ip就变了好处：不用配置坏处：更换ip麻烦</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h3><p>电脑宿主机的ip在局域网内是唯一的，选择了NAT模式创建虚拟机，虚拟机就是一个新的局域网</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719164228534-1434464564.png" alt="img"></p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>用此模式，就是局域网中一台独立的主机，它可以访问该类网段任意一台机器，</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719163802323-746976700.png" alt="img"></p><h3 id="仅主机模式"><a href="#仅主机模式" class="headerlink" title="仅主机模式"></a>仅主机模式</h3><p>单机模式</p><h1 id="端口的概念"><a href="#端口的概念" class="headerlink" title="端口的概念"></a>端口的概念</h1><p>一台服务器可以有一个ip地址，例如是192.168.11.1，服务器是需要对外提供服务的，例如web服务，FTP服务。那么仅凭ip地址，主机无法区分不同的服务，ip地址和网络服务是一对多的关系，一个ip提供多个服务，因此就有了“端口号”来区分不同的服务器的。</p><p>端口（port）的设计规定是有65536这么多端口，每个端口对应唯一的程序，0-1024端口之间被操作系统占用，因此开发人员能使用的是1024-65536区间的端口。</p><p><strong>通过IP地址可以访问到网络中的　　计算机。</strong></p><p><strong>通过port端口可以找到　　计算机上的应用程序。</strong></p><pre><code>ftp:23dns:53http:80https:443ssh:22</code></pre><h1 id="协议的概念"><a href="#协议的概念" class="headerlink" title="协议的概念"></a>协议的概念</h1><p>protocol是为网络中的数据交换而建立的规则、标准或者约定，两个实体要通信，必须有同一种语言。</p><pre><code>常见协议有超文本传输协议（HTTP）、文件传输协议（FTP），简单邮件传输协议（SMTP）、网络通信协议（TCP）、用户数据报协议（UDP）</code></pre><p>总结</p><table><thead><tr><th>ip</th><th>ip地址</th><th>找人，找服务器</th></tr></thead><tbody><tr><td>port</td><td>端口号</td><td>提供什么服务</td></tr><tr><td>protocol</td><td>协议</td><td>说什么语言</td></tr></tbody></table><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322180552823-582838157.png" alt="img"></h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322183618085-1154002790.png" alt="img"></p><pre><code>ssh root@ip -p port</code></pre><h1 id="第一次连接Linux"><a href="#第一次连接Linux" class="headerlink" title="第一次连接Linux"></a>第一次连接Linux</h1><pre><code>1.下载Xshell2.命令：ssh ip  (默认22端口)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719171347474-978460122.png" alt="img"></p><p>那么问题来了。。。。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716124814657-1978698000.png" alt="img"></p><p>这个黑乎乎的是个什么玩意？</p><pre><code>Linux终端也称为虚拟控制台，Linux终端采用字符命令方式工作，用户通过键盘输入命令，通过Linux终端对系统进行控制Linux是一个多用户、多任务、支持多线程和多CPU的操作系统</code></pre><h1 id="Linux切换虚拟终端"><a href="#Linux切换虚拟终端" class="headerlink" title="Linux切换虚拟终端"></a>Linux切换虚拟终端</h1><pre><code>ctrl+Alt+F[1~6]，如想切换到第二号虚拟终端，则同时按Ctrl+Alt+F2掌握普通用户登录后系统的提示符：$掌握root用户登录后系统的提示符：#</code></pre><h1 id="查看终端信息shell命令"><a href="#查看终端信息shell命令" class="headerlink" title="查看终端信息shell命令"></a>查看终端信息shell命令</h1><p>那么如何查看当前Linux的终端有哪些呢？</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180716125329262-533037247.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>命令，解释tty    查看当前终端who am i 仅显示当前用户正在使用的终端和登录时间w       查看所有终端（功能最全,显示用户名，终端标记，登录时间，负载等信息）</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="https-www-cnblogs-com-pyyu-p-9689138-html"><a href="#https-www-cnblogs-com-pyyu-p-9689138-html" class="headerlink" title="https://www.cnblogs.com/pyyu/p/9689138.html"></a><a href="https://www.cnblogs.com/pyyu/p/9689138.html">https://www.cnblogs.com/pyyu/p/9689138.html</a></h1><p>配置nat网络</p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="配置SSHD服务"><a href="#配置SSHD服务" class="headerlink" title="配置SSHD服务"></a>配置SSHD服务</h1><p>　　SSH(Secure Shell)是一种能够以安全的方式提供远程登录的协议，也是目前远程管理 Linux 系统的首选方式。在此之前，一般使用 FTP 或 Telnet 来进行远程登录。但是因为它们 以明文的形式在网络中传输账户密码和数据信息，因此很不安全，很容易受到黑客发起的中 间人攻击，这轻则篡改传输的数据信息，重则直接抓取服务器的账户密码。</p><p>　　想要使用 SSH 协议来远程管理 Linux 系统，则需要部署配置 sshd 服务程序。sshd 是基于 SSH 协议开发的一款远程管理服务程序，不仅使用起来方便快捷，而且能够提供两种安全验证的方法:</p><ol><li>基于口令的验证——-用账号和密码登录</li><li>基于密钥的验证——-需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，并与服务器中的公钥进行比较；</li></ol><p>超哥之前说过“Linux一切接文件”，也就是在Linux系统中修改服务程序，都得去修改它对应的配置文件，sshd程序的配置文件是/etc/ssh/sshd_config，检查配置文件参数</p><pre><code>grep -v '^#' /etc/ssh/sshd_config |grep -v '^$'</code></pre><p>在RHEL7系统中，已经默认安装启动了SSHD服务，</p><h3 id="使用密码登录"><a href="#使用密码登录" class="headerlink" title="使用密码登录"></a>使用密码登录</h3><pre><code>ssh 192.168.12.15</code></pre><h3 id="基于口令的认证"><a href="#基于口令的认证" class="headerlink" title="基于口令的认证"></a>基于口令的认证</h3><p>1.在第一次登录的时候，系统会出现下面的提示信息：</p><pre><code>The authenticity of host 'ssh-server.example.com (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)?</code></pre><p>上面的信息说的是：无法确认主机ssh-server.example.com（12.18.429.21）的真实性，不过知道它的公钥指纹，是否继续连接？</p><p>输入yes之后，那么该host key会被加入到Client的known_hosts中，格式如下</p><pre><code>pyyuc.cn,123.206.16.61 ecdsa-sha2-nistp256....</code></pre><p>终端提示如下:</p><pre><code>Warning: Permanently added 'ssh-server.example.com,12.18.429.21' (RSA) to the list of known hosts. Password: (enter password) </code></pre><p>提示该host已经被确认，并追加到文件known_hosts中，然后就要输入密码，之后的流程如图</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180827093858656-309568316.png" alt="img"></p><pre><code>私钥是server端独有的，即使client的信息泄露，也没有私钥进行解密，保证数据安全。</code></pre><h3 id="使用安全秘钥"><a href="#使用安全秘钥" class="headerlink" title="使用安全秘钥"></a>使用安全秘钥</h3><p>加密是对信息进行编码和解码的技术，它通过一定的算法将原本可以直接阅读的铭文信息转换成密文。密钥就是密文的钥匙，有私钥和公钥之分。</p><p>在数据传输时，担心被他人监听或截获，就可以在传输前先使用公钥对数据加密处理，然后再传送。这样只有掌握私钥的用户才能解密这段数据，除此之外的其让人即使截取了数据，也很难将其破解成明文。</p><h3 id="基于公钥的免密登录"><a href="#基于公钥的免密登录" class="headerlink" title="基于公钥的免密登录"></a>基于公钥的免密登录</h3><p>1.在客户端主机生成“秘钥对”</p><pre><code>ssh-keygen   </code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180823115908741-820799678.png" alt="img"></p><p>2.第二步：吧客户端主机中生成的公钥文件传送至远程主机：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180823120052910-272864911.png" alt="img"></p><p>3.对服务器端进行设置，使其只能允许秘钥登录，拒绝口令登录，然后重启sshd服务</p><pre><code>vim /etc/ssh/sshd_configPasswordAuthentication nosystemctl restart sshd</code></pre><p>4.在客户端即可免密登录服务器了</p><pre><code>ssh root@123.206.16.61</code></pre><p>课后作业</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1)    开启Linux操作系统，要求以root用户登录GNOME图形界面，语言支持选择为汉语2)    使用快捷键切换到虚拟终端2，使用普通用户身份登录，查看系统提示符3)    使用命令退出虚拟终端2上登录的用户4)    使用快捷键切换到虚拟终端5，使用管理员身份登录，查看系统提示符5)    使用命令退出虚拟终端5上登录的用户6)    切回图形界面，右单击桌面打开终端，输入关闭系统的命令7)　　 成功设置服务器免密登录</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群概念</title>
      <link href="2019/11/15/Linux/%E9%9B%86%E7%BE%A4%E6%A6%82%E5%BF%B5/"/>
      <url>2019/11/15/Linux/%E9%9B%86%E7%BE%A4%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="集群概念"><a href="#集群概念" class="headerlink" title="集群概念"></a><a href="https://www.cnblogs.com/pyyu/p/10004583.html">集群概念</a></h1><h1 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a>集群介绍</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122230112691-215677333.png" alt="img"></p><h1 id="为什么要用集群"><a href="#为什么要用集群" class="headerlink" title="为什么要用集群"></a>为什么要用集群</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122230313496-1470967009.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122230413534-1410833717.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122230618886-81082450.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122230808138-55125260.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122230919797-346777092.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122230939969-38791017.png" alt="img"></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux入门</title>
      <link href="2019/11/15/Linux/Linux%E5%85%A5%E9%97%A8/"/>
      <url>2019/11/15/Linux/Linux%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx入门与实战"><a href="#nginx入门与实战" class="headerlink" title="nginx入门与实战"></a><a href="https://www.cnblogs.com/pyyu/p/9468680.html">nginx入门与实战</a></h1><h1 id="网站服务"><a href="#网站服务" class="headerlink" title="网站服务"></a>网站服务</h1><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181014124743540-1325157612.png" alt="img"></h1><p> 想必我们大多数人都是通过访问网站而开始接触互联网的吧。我们平时访问的网站服务 就是 Web 网络服务，一般是指允许用户通过浏览器访问到互联网中各种资源的服务。</p><p>Web 网络服务是一种被动访问的服务程序，即只有接收到互联网中其他主机发出的 请求后才会响应，最终用于提供服务程序的 Web 服务器会通过 HTTP(超文本传输协议)或 HTTPS(安全超文本传输协议)把请求的内容传送给用户。</p><p>目前能够提供 Web 网络服务的程序有 IIS、Nginx 和 Apache 等。其中，IIS(Internet Information Services，互联网信息服务)是 Windows 系统中默认的 Web 服务程序</p><p>2004 年 10 月 4 日，为俄罗斯知名门户站点而开发的 Web 服务程序 Nginx 横空出世。 Nginx 程序作为一款轻量级的网站服务软件，因其稳定性和丰富的功能而快速占领服务器市 场，但 Nginx 最被认可的还当是系统资源消耗低且并发能力强，因此得到了国内诸如新浪、 网易、腾讯等门户站的青睐。</p><h1 id="web服务器和web框架的关系"><a href="#web服务器和web框架的关系" class="headerlink" title="web服务器和web框架的关系"></a>web服务器和web框架的关系</h1><p>web服务器（nginx）：接收HTTP请求（例如<a href="http://www.pythonav.cn/xiaocang.jpg%EF%BC%89%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE">www.pythonav.cn/xiaocang.jpg）并返回数据</a></p><p>web框架（django，flask）：开发web应用程序，处理接收到的数据</p><h1 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h1><h2 id="nginx是什么"><a href="#nginx是什么" class="headerlink" title="nginx是什么"></a>nginx是什么</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。它是一个俄罗斯人lgor sysoev开发的，作者将源代码开源出来供全球使用。nginx比它大哥apache性能改进许多，nginx占用的系统资源更少，支持更高的并发连接，有更高的访问效率。nginx不但是一个优秀的web服务软件，还可以作为反向代理，负载均衡，以及缓存服务使用。安装更为简单，方便，灵活。nginx可以说是非常nb了</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>面试回答nginx技巧</p><pre><code>支持高并发，能支持几万并发连接资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M可以做http反向代理和负载均衡支持异步网络i/o事件模型epoll</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180813155012063-443835808.png" alt="img"></p><p>Tengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。</p><h3 id="安装环境准备"><a href="#安装环境准备" class="headerlink" title="安装环境准备"></a>安装环境准备</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>一. gcc 安装安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：yum install gcc-c++二. PCRE pcre-devel 安装PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：yum install -y pcre pcre-devel三. zlib 安装zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。yum install -y zlib zlib-devel四. OpenSSL 安装OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。yum install gcc patch libffi-devel python-devel  zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel openssl openssl-devel -y</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="安装-启动nginx"><a href="#安装-启动nginx" class="headerlink" title="安装,启动nginx"></a>安装,启动nginx</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.下载源码包wget -c https://nginx.org/download/nginx-1.12.0.tar.gz2.解压缩源码tar -zxvf nginx-1.12.0.tar.gz3.配置，编译安装  开启nginx状态监测功能./configure --prefix=/opt/nginx1-12/ --with-http_ssl_module --with-http_stub_status_module make &amp;&amp; make install 4.启动nginx，进入sbin目录,找到nginx启动命令cd sbin./nginx #启动./nginx -s stop #关闭./nginx -s reload #重新加载</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="安装完成后检测服务"><a href="#安装完成后检测服务" class="headerlink" title="安装完成后检测服务"></a>安装完成后检测服务</h3><pre><code>netstat -tunlp |grep 80curl -I 127.0.0.1#如果访问不了，检查selinux，iptables</code></pre><h3 id="部署一个web站点"><a href="#部署一个web站点" class="headerlink" title="部署一个web站点"></a>部署一个web站点</h3><p>nginx默认站点是Nginx目录下的html文件夹，这里可以从nginx.conf中查到</p><pre><code> location /{            root   html;  #这里是默认的站点html文件夹，也就是 /opt/nginx1-12/html/文件夹下的内容            index  index.html index.htm; #站点首页文件名是index.html        }</code></pre><p>如果要部署网站业务数据，只需要把开发好的程序全放到html目录下即可</p><pre><code>[root@oldboy_python /tmp 11:34:52]#ls /opt/nginx1-12/html/index.html  jssts.jpeg  lhy.mp4  man.jpg  wget-log</code></pre><p>因此只需要通过域名/资源，即可访问</p><pre><code>http://www.pyyuc.cn/man.jpg</code></pre><h3 id="Nginx的目录结构"><a href="#Nginx的目录结构" class="headerlink" title="Nginx的目录结构"></a>Nginx的目录结构</h3><pre><code>[root@oldboy_python /opt/nginx1-12 11:44:02]#lsclient_body_temp  conf  fastcgi_temp  html  logs  proxy_temp  sbin  scgi_temp  static  uwsgi_temp</code></pre><ul><li>conf 存放nginx所有配置文件的目录,主要nginx.conf</li><li>html 存放nginx默认站点的目录，如index.html、error.html等</li><li>logs 存放nginx默认日志的目录，如error.log access.log</li><li>sbin 存放nginx主命令的目录,sbin/nginx</li></ul><h3 id="Nginx主配置文件解析"><a href="#Nginx主配置文件解析" class="headerlink" title="Nginx主配置文件解析"></a>Nginx主配置文件解析</h3><p>Nginx主配置文件<code>/etc/nginx/nginx.conf</code>是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。一般，每个区块以一对大括号<code>{}</code>来表示开始与结束。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">nginx.conf详解 </p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>CoreModule核心模块user www;                       #Nginx进程所使用的用户worker_processes 1;             #Nginx运行的work进程数量(建议与CPU数量一致或auto)error_log /log/nginx/error.log  #Nginx错误日志存放路径pid /var/run/nginx.pid          #Nginx服务运行后产生的pid进程号</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>events事件模块events {                worker_connections  //每个worker进程支持的最大连接数    use epool;          //事件驱动模型, epoll默认}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>http内核模块//公共的配置定义在http{}http {  //http层开始...        //使用Server配置网站, 每个Server{}代表一个网站(简称虚拟主机)    'server' {        listen       80;        //监听端口, 默认80        server_name  localhost; //提供服务的域名或主机名        access_log host.access.log  //访问日志        //控制网站访问路径        'location' / {            root   /usr/share/nginx/html;   //存放网站代码路径            index  index.html index.htm;    //服务器返回的默认页面文件        }        //指定错误代码, 统一定义错误页面, 错误代码重定向到新的Locaiton        error_page   500 502 503 504  /50x.html;    }    ...    //第二个虚拟主机配置    'server' {    ...    }    include /etc/nginx/conf.d/*.conf;  //包含/etc/nginx/conf.d/目录下所有以.conf结尾的文件}   //http层结束</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="Nginx虚拟主机"><a href="#Nginx虚拟主机" class="headerlink" title="Nginx虚拟主机"></a>Nginx虚拟主机</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181014162827193-835597809.png" alt="img"></p><p>如果每台linux服务器只运行了一个小网站，那么人气低，流量小的草根站长需要承担高额的服务器租赁费，也造成了硬件资源浪费。</p><p>虚拟主机就是将一台服务器分割成多个“虚拟服务器”，每个站点使用各自的硬盘空间，由于省资源，省钱，众多网站都使用虚拟主机来部署网站。</p><pre><code>虚拟主机的概念就是在web服务里的一个独立的网站站点，这个站点对应独立的域名（IP），具有独立的程序和资源目录，可以独立的对外提供服务。这个独立的站点配置是在nginx.conf中使用server{}代码块标签来表示一个虚拟主机。Nginx支持多个server{}标签，即支持多个虚拟主机站点。</code></pre><p>虚拟主机类型</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>基于域名的虚拟主机通过不同的域名区分不同的虚拟主机，是企业应用最广的虚拟主机。基于端口的虚拟主机通过不同的端口来区分不同的虚拟主机，一般用作企业内部网站，不对外直接提供服务的后台，例如www.pythonav.cn:9000基于IP的虚拟主机通过不同的IP区分不同的虚拟主机，此类比较少见，一般业务需要多IP的常见都会在负载均衡中绑定VIP</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="Nginx状态信息（status）配置"><a href="#Nginx状态信息（status）配置" class="headerlink" title="Nginx状态信息（status）配置"></a>Nginx状态信息（status）配置</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>Nginx状态信息（status）配置及信息详解    nginx与php-fpm一样内建了一个状态页，对于想了解nginx的状态以及监控nginx非常有帮助。为了后续的zabbix监控，我们需要先了解一下nginx的状态页。Nginx状态信息（status）介绍    Nginx软件在编译时又一个with-http_stub_status_module模块，这个模块功能是记录Nginx的基本访问状态信息，让使用者了解Nginx的工作状态。要想使用状态模块，在编译时必须增加--with-http_stub_status_module参数。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>监测你的nginx是否安装了status模块</p><pre><code>[root@master conf]# /opt/nginx/sbin/nginx -Vnginx version: nginx/1.12.0built by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC)configure arguments: --prefix=/opt/nginx/ --with-http_stub_status_module</code></pre><p>启动status状态功能，修改配置文件</p><pre><code>#在访问ip/status的时候，进入状态功能        location /status {　　　　　　　　#开启nginx状态功能             stub_status on;}            </code></pre><p>平滑重启nginx</p><pre><code>./sbin/nginx -s reload</code></pre><p>访问status页面</p><p><strong><a href="http://192.168.119.10/status">http://192.168.119.10/status</a></strong></p><p><strong>通过ab压测命令检测</strong></p><pre><code>yum -y install httpd-tools</code></pre><p><strong>-n requests #执行的请求数，即一共发起多少请求。</strong></p><p><strong>-c concurrency #请求并发数。</strong></p><p><strong>-k #启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。</strong></p><p><strong>ab -kc 1000 -n 100000 <a href="http://192.168.119.10/">http://192.168.119.10/</a></strong></p><h2 id="status页面解析"><a href="#status页面解析" class="headerlink" title="status页面解析"></a>status页面解析</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122120642385-594889775.png" alt="img"></p><h3 id="基于域名的多虚拟主机实战"><a href="#基于域名的多虚拟主机实战" class="headerlink" title="基于域名的多虚拟主机实战"></a>基于域名的多虚拟主机实战</h3><p>nginx可以自动识别用户请求的域名，根据不同的域名请求服务器传输不同的内容，只需要保证服务器上有一个可用的ip地址，配置好dns解析服务。</p><p>/etc/hosts是linux系统中本地dns解析的配置文件，同样可以达到域名访问效果</p><p>修改nginx.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 14:33:16]#egrep -v '#|^$' /opt/nginx1-12/conf/nginx.confworker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  logs/access.log  main;    sendfile        on;    keepalive_timeout  65;    server {        listen       80;        server_name  www.pyyuc.cn;        location /{            root   html/pyyuc;            index  index.html index.htm;        }    }}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>上述代码配置了一个<a href="http://www.pyyuc.cn域名的站点,虚拟主机的部分就是server{}里的内容/">www.pyyuc.cn域名的站点，虚拟主机的部分就是server{}里的内容</a></p><h3 id="创建pyyuc-cn的站点目录和文件"><a href="#创建pyyuc-cn的站点目录和文件" class="headerlink" title="创建pyyuc.cn的站点目录和文件"></a>创建pyyuc.cn的站点目录和文件</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python /opt/nginx1-12/html 14:36:08]#mkdir pyyuc</code></pre><p>[root@oldboy_python /opt/nginx1-12/html 14:36:18]#echo “<meta charset="utf8">我是pyyuc站点” &gt; pyyuc/index.html<br>[root@oldboy_python /opt/nginx1-12/html 14:37:21]#cat pyyuc/index.html</p><meta charset="utf8">我是pyyuc站点<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>上述作用创建了一个html/pyyuc站点目录，对应于虚拟主机配置文件里的root根目录的设置html/pyyuc</p><p>然后生成一个首页文件index.html，内容是“我是pyyuc站点”</p><h3 id="检查nginx语法重新加载nginx"><a href="#检查nginx语法重新加载nginx" class="headerlink" title="检查nginx语法重新加载nginx"></a>检查nginx语法重新加载nginx</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p>[root@oldboy_python /opt/nginx1-12/html 14:37:28]#../sbin/nginx -t<br>nginx: the configuration file /opt/nginx1-12/conf/nginx.conf syntax is ok<br>nginx: configuration file /opt/nginx1-12/conf/nginx.conf test is successful</p><p>#平滑重启nginx</p><p>[root@oldboy_python /opt/nginx1-12/html 14:39:18]#../sbin/nginx -s reload</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>检查nginx端口，进程，访问pyyuc虚拟站点</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python /opt/nginx1-12/html 14:40:02]#netstat -tunlp|grep nginx[root@oldboy_python /opt/nginx1-12/html 14:40:29]#ps -ef|grep nginx#我这里是有dns解析，没有的话则需要/etc/hosts解析#成功配置了pyyuc虚拟主机站点[root@oldboy_python /opt/nginx1-12/html 14:41:37]#curl www.pyyuc.cn&lt;meta charset=utf8&gt;我是pyyuc站点</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="配置多个域名的虚拟主机"><a href="#配置多个域名的虚拟主机" class="headerlink" title="配置多个域名的虚拟主机"></a>配置多个域名的虚拟主机</h3><p>其实就是新增一个server{}虚拟主机</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>egrep -v '#|^$' /opt/nginx1-12/conf/nginx.confworker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  logs/access.log  main;    sendfile        on;    keepalive_timeout  65;    server {        listen       80;        server_name  www.pyyuc.cn;        location /{            root   html/pyyuc;            index  index.html index.htm;        }}    server {        listen       80;        server_name  www.pythonav.cn;        location /{            root   html/pythonav;            index  index.html index.htm;        }}    }</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>创建pythonav虚拟主机站点的目录和文件</p><pre><code>[root@oldboy_python /opt/nginx1-12 14:47:21]#mkdir -p /opt/nginx1-12/html/pythonav[root@oldboy_python /opt/nginx1-12 14:49:33]#echo "&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内"&gt; /opt/nginx1-12/html/pythonav/index.html[root@oldboy_python /opt/nginx1-12 14:50:44]#./sbin/nginx -tnginx: the configuration file /opt/nginx1-12/conf/nginx.conf syntax is oknginx: configuration file /opt/nginx1-12/conf/nginx.conf test is successful[root@oldboy_python /opt/nginx1-12 14:51:32]#./sbin/nginx -s reload</code></pre><h3 id="大功告成，基于域名的虚拟主机实战搞定"><a href="#大功告成，基于域名的虚拟主机实战搞定" class="headerlink" title="大功告成，基于域名的虚拟主机实战搞定"></a>大功告成，基于域名的虚拟主机实战搞定</h3><pre><code>[root@oldboy_python /opt/nginx1-12 14:52:12]#curl www.pythonav.cn&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内[root@oldboy_python /opt/nginx1-12 14:52:40]#curl www.pyyuc.cn&lt;meta charset=utf8&gt;我是pyyuc站点</code></pre><h3 id="nginx访问日志（access-log）"><a href="#nginx访问日志（access-log）" class="headerlink" title="nginx访问日志（access_log）"></a>nginx访问日志（access_log）</h3><p>日志功能对每个用户访问网站的日志信息记录到指定的日志文件里，开发运维人员可以分析用户的浏览器行为，此功能由ngx_http_log_module模块负责，官网地址是：</p><p><a href="http://nginx.org/en/docs/http/ngx_http_log_module.html">http://nginx.org/en/docs/http/ngx_http_log_module.html</a></p><p>控制日志的参数</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>log_format    记录日志的格式，可定义多种格式accsss_log    指定日志文件的路径以及格式</code></pre><p>　　log_format main ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>　　‘$status $body_bytes_sent “$http_referer” ‘<br>　　‘“$http_user_agent” “$http_x_forwarded_for”‘;</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>对应参数解析</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>$remote_addr    记录客户端ip$remote_user    远程用户，没有就是 “-”$time_local 　　 对应[14/Aug/2018:18:46:52 +0800]$request　　　 　对应请求信息"GET /favicon.ico HTTP/1.1"$status　　　  　状态码$body_bytes_sent　　571字节 请求体的大小$http_referer　　对应“-”　　由于是直接输入浏览器就是 -$http_user_agent　　客户端身份信息$http_x_forwarded_for　　记录客户端的来源真实ip 97.64.34.118</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>日志效果如下</p><pre><code>66.102.6.6 - - [14/Aug/2018:18:46:52 +0800] "GET /favicon.ico HTTP/1.1" 404 571 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.75 Safari/537.36 Google Favicon" "97.64.34.118"</code></pre><p> nginx.conf默认配置</p><pre><code>    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  logs/access.log  main;</code></pre><p>日志格式配置定义</p><pre><code>log_format是日志关键字参数，不能变main是日志格式指定的标签，记录日志时通过main标签选择指定的格式。 </code></pre><h3 id="nginx限制网站来源IP访问"><a href="#nginx限制网站来源IP访问" class="headerlink" title="nginx限制网站来源IP访问"></a>nginx限制网站来源IP访问</h3><pre><code>如果哪天发现你的nginx很慢，或者检查access.log时候，有一个some body疯狂请求你的nginx server，那么可以禁止这个IP访问</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>限制ip或ip段访问禁止访问/av/底下的资源location /av {deny 122.71.240.254;#alias /opt/nginx1-12/html/av;allow 10.1.1.0/16;  }</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="Nginx错误页面优化"><a href="#Nginx错误页面优化" class="headerlink" title="Nginx错误页面优化"></a>Nginx错误页面优化</h3><p>在网站运行过程中，可能因为页面不存在等原因，导致网站无法正常响应请求，此时web服务会返回系统的错误码，但是默认的错误页面很不友好。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180827175121359-563259509.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180827175138926-1789396134.png" alt="img"></p><p>因此我们可以将404，403等页面的错误信息重定向到网站首页或者其他指定的页面，提升用户访问体验。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>server {        listen       80;        server_name  www.pythonav.cn;        root html/pythonav;        location /{            index  index.html index.htm;        }　　　　　　#在pythonav路径下的40x.html错误页面        error_page 400 403 404 405 /40x.html;        }</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>40x.html</p><pre><code>&lt;img style='width:100%;height:100%;' src=https://pic1.zhimg.com/80/v2-77a9281a2bebc7a2ea5e02577af266a8_hd.png&gt;</code></pre><p>此时访问<a href="http://www.pythonav.cn/asdasd%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%B7%B2%E7%BB%8F%E4%BC%98%E5%8C%96%E4%BA%86">www.pythonav.cn/asdasd错误页面已经优化了</a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180827180853418-2031222076.png" alt="img"> </p><h2 id="Nginx代理"><a href="#Nginx代理" class="headerlink" title="Nginx代理"></a>Nginx代理</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181118212452965-931575034.png" alt="img"></p><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p><strong>正向代理，也就是传说中的代理,他的工作原理就像一个跳板（VPN），简单的说：</strong></p><p><strong>我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181118222300086-1972487571.png" alt="img"></strong></p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p><strong>对于客户端而言，代理服务器就像是原始服务器。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181118222354608-408861475.png" alt="img"></p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181207105156894-1355683898.png" alt="img"></p><p>nginx实现负载均衡的组件</p><pre><code>ngx_http_proxy_module    proxy代理模块，用于把请求抛给服务器节点或者upstream服务器池</code></pre><h3 id="实现一个简单的反向代理"><a href="#实现一个简单的反向代理" class="headerlink" title="实现一个简单的反向代理"></a>实现一个简单的反向代理</h3><p>机器准备，两台服务器</p><pre><code>master  192.168.11.63　　主负载slave   192.168.11.64　　web1</code></pre><p>主负载均衡节点的配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">nginx.conf</p><p>检查语法并启动nginx</p><pre><code>[root@master 192.168.11.63 /opt/nginx1-12]$/opt/nginx1-12/sbin/nginx -tnginx: the configuration file /opt/nginx1-12/conf/nginx.conf syntax is oknginx: configuration file /opt/nginx1-12/conf/nginx.conf test is successful</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#启动nginx[root@master 192.168.11.63 /opt/nginx1-12]$/opt/nginx1-12/sbin/nginx#检查端口[root@master 192.168.11.63 /opt/nginx1-12]$netstat -tunlp|grep nginxtcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8921/nginx: master</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>此时访问master的服务器192.168.11.63:80地址，已经会将请求转发给slave的80端口</p><p>除了页面效果的展示以外，还可以通过log(access.log)查看代理效果</p><p>master端日志</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180815104957353-316783693.png" alt="img"></p><p>slave端日志</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180815105056409-841189714.png" alt="img"></p><h1 id="nginx语法之location详解"><a href="#nginx语法之location详解" class="headerlink" title="nginx语法之location详解"></a>nginx语法之location详解</h1><p><a href="https://www.cnblogs.com/pyyu/p/10085444.html"><strong>戳我</strong></a></p><p><a href="https://www.cnblogs.com/pyyu/p/10085444.html"><strong>https://www.cnblogs.com/pyyu/p/10085444.html</strong></a></p><h1 id="Keepalived高可用软件"><a href="#Keepalived高可用软件" class="headerlink" title="Keepalived高可用软件"></a>Keepalived高可用软件</h1><p>什么是keepalived</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>Keepalived是一个用C语言编写的路由软件。该项目的主要目标是为Linux系统和基于Linux的基础架构提供简单而强大的负载均衡和高可用性设施。 还可以作为其他服务（nginx，mysql）的高可用软件keepalived主要通过vrrp协议实现高可用功能。vrrp叫（virtual router redundancy protocol）虚拟路由器冗余协议，目的为了解决单点故障问题，他可以保证个别节点宕机时。整个网络可以不间断的运行。 </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>高可用故障切换原理</p><pre><code>在keepalived工作时，主master节点会不断的向备节点发送心跳消息，告诉备节点自己还活着，当master节点故障时，就无法发送心跳消息，备节点就无法检测到来自master的心跳了，于是调用自身的接管程序，接管master节点的ip资源以及服务，当master主节点恢复时，备backup节点又会释放接管的ip资源和服务，回复到原本的备节点角色。</code></pre><p>1.硬件环境准备</p><pre><code>实验环境应该最好是4台虚拟机，环境有限因此用2台机器masterslave</code></pre><p>2.centos系统和nginx代理环境</p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell基本命令</title>
      <link href="2019/11/15/Linux/Shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%20/"/>
      <url>2019/11/15/Linux/Shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%20/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell基本命令"><a href="#Shell基本命令" class="headerlink" title="Shell基本命令"></a><a href="https://www.cnblogs.com/pyyu/articles/9314206.html">Shell基本命令</a></h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面咱们已经成功安装了Linux系统–centos7，那么现在跟着超哥奔向Linux的大门。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180715162356125-179638825.png" alt="img"></p><p> Linux命令行的组成结构</p><pre><code>[root@oldboy_python ~]# [root@oldboy_python ~]# [root@oldboy_python ~]# [root@oldboy_python ~]# [root@oldboy_python ~]# </code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719175259770-1837332137.png" alt="img"></p><h2 id="Linux系统命令操作语法格式"><a href="#Linux系统命令操作语法格式" class="headerlink" title="Linux系统命令操作语法格式"></a>Linux系统命令操作语法格式</h2><table><thead><tr><th>命令</th><th>空格</th><th>参数</th><th>空格</th><th>【文件或路径】需要处理的内容</th></tr></thead><tbody><tr><td>rm</td><td></td><td>-rf</td><td></td><td>/tmp/*</td></tr><tr><td>ls</td><td></td><td>-la</td><td></td><td>/home</td></tr><tr><td>结婚</td><td></td><td>-没车没房</td><td></td><td>女的就行</td></tr><tr><td>结婚</td><td></td><td>-有车有房</td><td></td><td>白富美</td></tr></tbody></table><p>1.一般情况下，【参数】是可选的，一些情况下【文件或路径】也是可选的</p><p>2.参数 &gt; 同一个命令，跟上不同的参数执行不同的功能</p><p>执行linux命令，添加参数的目的是让命令更加贴切实际工作的需要！</p><p>linux命令，参数之间，普遍应该用一个或多个空格分割！</p><h3 id="创建一个目录-oldboy"><a href="#创建一个目录-oldboy" class="headerlink" title="创建一个目录  /oldboy"></a>创建一个目录  /oldboy</h3><p>windows下：</p><pre><code>鼠标右击 &gt; 新建文件夹</code></pre><p>Linux下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>make directory &gt; mk dir &gt; mkdir-------------------------------mkdir /oldboy-------------------------------cd /mkdir oldboy#递归创建a/b   c/dmkdir -p a/b c/d#递归创建test/a,b,c,d四个目录mkdir -p test/{a,b,c,d}#递归创建文件夹a/b/c/d/emkdir -p a/b/c/d/e</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="查看目录-oldboy"><a href="#查看目录-oldboy" class="headerlink" title="查看目录 /oldboy"></a>查看目录 /oldboy</h3><pre><code>#显示/oldboy下的内容ls /oldboy</code></pre><h3 id="改变当前的目录-位置"><a href="#改变当前的目录-位置" class="headerlink" title="改变当前的目录/位置"></a>改变当前的目录/位置</h3><pre><code>cd /homecd ~cd -</code></pre><p>换来换去的，迷路了怎么办？我到底在哪个目录？<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719225842151-1402123888.png" alt="img"></p><h3 id="打印当前工作目录"><a href="#打印当前工作目录" class="headerlink" title="打印当前工作目录"></a>打印当前工作目录</h3><pre><code>#打印当前工作目录pwd </code></pre><h3 id="创建文件或者修改文件时间戳-文件属性"><a href="#创建文件或者修改文件时间戳-文件属性" class="headerlink" title="创建文件或者修改文件时间戳(文件属性)"></a>创建文件或者修改文件时间戳(文件属性)</h3><p>创建文本</p><p>修改文件的修改时间</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#修改文件的更改时间，很多黑客就会在恶意修改文件之后再修改成之前的时间ls -l echo 'sb' &gt;&gt; xxx.pytouch -t'07101530' 1.txt#触摸touch xxx.py</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>显示文件或文件系统的状态。#用法 stat  [参数]  文件参数列表：-L, --dereference     跟随链接  -f, --file-system     显示文件系统状态而非文件状态  -c --format=格式      使用指定输出格式代替默认值，每用一次指定格式换一新行      --printf=格式     类似 --format，但是会解释反斜杠转义符，不使用换行作                                输出结尾。如果您仍希望使用换行，可以在格式中                                加入"\n"  -t, --terse           使用简洁格式输出      --help            显示此帮助信息并退出      --version         显示版本信息并退出格式化输出参数：  %a    八进制权限  %A   用可读性较好的方式输出权限#实例1[root@master tmp]# stat 1.txt  File: '1.txt'  Size: 0             Blocks: 0          IO Block: 4096   regular empty fileDevice: fd00h/64768d    Inode: 17348002    Links: 1(权限)Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)(最近访问)Access: 2018-07-10 15:30:00.000000000 +0800(最近更改)Modify: 2018-07-10 15:30:00.000000000 +0800(最近改动)Change: 2018-11-07 15:38:36.400989868 +0800 Birth: -#实例2，显示文件权限</code></pre><p>[root@master tmp]# stat -c %a 1.txt<br>644<br>[root@master tmp]# stat -c %A 1.txt<br>-rw-r–r–</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#方法，命令vivim使用vi打开oldboy.py,默认是命令模式，需要输入a/i进入编辑模式,然后输入文本"Life is short,i use python"按下esc键，回到命令模式输入  :wq!  强制保存退出w write 写入q quit 退出! 强制或者  :x 保存退出------:q  不保存退出:q! 不保存强制退出</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat命令用于查看纯文本文件（常用于内容较少的）</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#查看文件，显示行号cat -n xxx.py#猫,查看文件cat xxx.py#在每一行的结尾加上$符[root@master tmp]# cat -E 1.txt#追加文字到文件cat &gt;&gt;/tmp/oldboy.txt &lt;&lt; EOF唧唧复唧唧木兰开飞机开的什么机波音747EOF</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h3><p>1.more命令用于查看内容较多的文本，例如要看一个很长的配置文件，cat查看内容屏幕会快速翻滚到结尾。</p><p>2.more命令查看文本会以百分比形式告知已经看到了多少，使用回车键向下读取内容</p><pre><code>more /etc/passwd按下空格space是翻页按下b键是上一页回车键向下读取内容</code></pre><h3 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h3><pre><code>1.tab键    用于自动补全命令/文件名/目录名2.ctrl + l　　清理终端显示 3.clear/cls  清理终端显示4.ctrl + c 终止当前操作</code></pre><h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><p>echo命令用于在终端输出字符串或变量提取后的值，格式是“echo 【字符串|$变量】”</p><pre><code>#默认吧内容显示到终端上    echo "超哥666"#超哥平时比较低调，不想让别人知道他666，怎么办？要么把“超哥666”写入到文件里！echo "超哥666" &gt; /tmp/chaoge.txtecho $PATH #取出打印PATH的值</code></pre><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>输入/输出 重定向符号1.&gt;&gt;    追加重定向，把文字追加到文件的结尾2.&gt;     重定向符号，清空原文件所有内容，然后把文字覆盖到文件末尾3.&lt;     输入重定向4.&lt;&lt;    将输入结果输入重定向echo "oldboy-python666" &gt; /tmp/oldboy.txtecho "chaoge666" &gt;&gt; /tmp/oldboy.txtcat &gt;&gt;/tmp/oldboy.txt &lt;&lt; EOF------------------------------------我想把命令执行的结果信息，写入到文件中ip addr &gt; /tmp/network.txt   #标准输出重定向 把命令执行结果信息，放入到文件中3.通配符  ls -l /etc/us*</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="复制-拷贝-命令"><a href="#复制-拷贝-命令" class="headerlink" title="复制(拷贝)命令"></a>复制(拷贝)命令</h3><p>windows复制</p><pre><code>可以说是相当简单了ctrl + c 复制ctrl + v 黏贴</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180722203308705-1349994308.png" alt="img"></p><p>Linux</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>复制 &gt; copy &gt; cp#移动xxx.py到/tmp目录下cp xxx.py /tmp/#移动xxx.py顺便改名为chaoge.pycp xxx.py /tmp/chaoge.pyLinux下面很多命令，一般没有办法直接处理文件夹,因此需要加上（参数） cp -r 递归,复制目录以及目录的子孙后代cp -p 复制文件，同时保持文件属性不变    可以用statcp -a 相当于-pdr#递归复制test文件夹，为test2cp -r test test2cp是个好命令，操作文件前，先备份cp main.py main.py.bak</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h3><p>什么？移动命令？<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180722204735323-823435686.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>移动（搬家）命令  &gt; move &gt; mvcd /home#把老男孩从沙河这破地方，搬到朝阳去mv /home/shahe/oldboy /tmp/chaoyang文件/文件夹改名mv x.log xx.log</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>删除  &gt; remove &gt; rm参数  -i  需要删除确认　　　-f  强制删除     -r  递归删除目录和内容     cd /tmprm oldboy.py#默认有提示删除，需要输入yrm -f oldboy.py #不需要提示,强制删除#rm默认无法删除目录，需要跟上参数-rrm -rf /tmp/oldboy/--------友情提醒:初学者使用rm命令，随时快照虚拟机</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#Linux里如何找到需要的文件 例如 oldboy.pyfind 在哪里(目录) 什么类型（文件类型） 叫什么名字（文件名）参数-name 按照文件名查找文件-type 查找某一类型的文件，诸如：b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。s - socket文件find /tmp/ -type f  -name "oldboy.py"#找出/tmp所有以 .txt 结尾的文件find /tmp/ -type f -name "*.txt"#找到/etc下所有名字以host开头的文件find /etc -name 'host*'#找到/opt上一个名为settings.pyfind /opt -name 'settings.py'</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>Linux提供的管道符“|”讲两条命令隔开，管道符左边命令的输出会作为管道符右边命令的输入。常见用法：#检查python程序是否启动ps -ef|grep "python"#找到/tmp目录下所有txt文件ls /tmp|grep '.txt'#检查nginx的端口是否存活netstat -tunlp |grep nginx</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>命令格式： 命令A | 命令B</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180723112243978-2082425629.png" alt="img"></p><p>grep</p><p>(global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>语法：grep [参数] [--color=auto] [字符串] filename参数详解:-i : 忽略大小写-n : 输出行号-v : 反向选择--color = auto : 给关键词部分添加颜色grep "我要找什么" /tmp/oldboy.txt#排除 -v，排除我要找的东西grep -v "我要找什么 /tmp/oldboy.txt</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>例题，找出/etc/passwd下root用户所在行，以及行号，显示颜色</p><pre><code>cat /etc/passwd |grep '^root' --color=auto -n</code></pre><p>找出/etc/passwd所有不允许登录的用户</p><pre><code>grep /sbin/nologin /etc/passwd</code></pre><p>找到/etc/passwd的所有与mysql有关行，行号</p><pre><code>cat /etc/passwd |grep 'mysql' -n</code></pre><p>head、tail命令</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>head显示文件前几行，默认前10行tail显示文件后几行，默认后10行#查看前两行head -2 /tmp/oldboy.txt#查看后两行tail -2 /tmp/oldboy.txt#持续刷新显示tail -f xx.log#显示文件10-30行head -30 /tmp/oldboy.txt |tail -21</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">sed</p><h3 id="别名alias命令"><a href="#别名alias命令" class="headerlink" title="别名alias命令"></a>别名alias命令</h3><p>Linux在使用rm（删除）、cp（覆盖）、mv（搬家）等命令的时候，必须非常小心，因为这些命令都是“炸弹”，想必大家都听过“删库到跑路”，一言不合“rm -rf /”，假如你真的这么做了，那么。。。上帝保佑你</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180723150150746-1954940096.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>Linux如何提示你，在使用这些命令时候，提醒你小心呢？#查看系统别名alias默认别名</code></pre><p>alias cp=’cp -i’<br>alias egrep=’egrep –color=auto’<br>alias fgrep=’fgrep –color=auto’<br>alias grep=’grep –color=auto’<br>alias l.=’ls -d .* –color=auto’<br>alias ll=’ls -l –color=auto’<br>alias ls=’ls –color=auto’<br>alias mv=’mv -i’<br>alias rm=’rm -i’<br>alias which=’alias | /usr/bin/which –tty-only –read-alias –show-dot –show-tilde’</p><p>别名作用是：</p><p>我们在linux中使用cp时候相当于执行了cp -i<br>-i：删除已有文件或目录之前先询问用户；</p><p>#别名用比较危险的操作,防止你犯错 </p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="为rm设置别名"><a href="#为rm设置别名" class="headerlink" title="为rm设置别名"></a>为rm设置别名</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#让系统显示 do not use rmecho do not use rm#设置rm别名alias rm='echo do not use rm'#设置别名永久生效,写入到/etc/profile(针对登录用户的合同，设置环境变量)vim /etc/profile #编辑文件G　　快速到达最后一行o　　当前行下一行，创建一个新行，进入编辑模式source /etc/profile #读取文件（合同生效）---------------#取消别名unalias rm</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><pre><code>which命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。which pwdwhich python</code></pre><p>实例</p><pre><code>which python       #python命令在哪/usr/bin/python    #命令文件绝对路径</code></pre><h3 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h3><p>Linux scp命令用于Linux之间复制文件和目录。</p><p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p><pre><code>语法scp 【可选参数】 本地源文件 远程文件标记</code></pre><p>参数</p><pre><code>-r :递归复制整个目录-v:详细方式输出-q:不显示传输进度条-C：允许压缩</code></pre><p>实例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#传输本地文件到远程地址scp 本地文件  远程用户名@远程ip:远程文件夹/scp 本地文件  远程用户名@远程ip:远程文件夹/远程文件名scp /tmp/chaoge.py root@192.168.1.155:/home/scp /tmp/chaoge.py root@192.168.1.155:/home/chaoge_python.pyscp -r  本地文件夹  远程用户名@远程ip:远程文件夹/scp -r /tmp/oldboy root@192.168.1.155:/home/oldboy#复制远程文件到本地scp root@192.168.1.155:/home/oldboy.txt /tmp/oldboy.txtscp -r root@192.168.1.155:/home/oldboy /home/</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h3><p>Linux du命令用于显示目录或文件的大小。</p><p>du会显示指定的目录或文件所占用的磁盘空间。</p><pre><code>用法du 【参数】【文件或目录】-s 显示总计-h 以k，M,G为单位显示，可读性强</code></pre><p>实例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>显示目录或文件所占空间#什么都不跟，代表显示当前目录所有文件大小du   #显示/home的总大小du -sh /home</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p>top 命令用于动态地监视进程活动与系统负载等信息</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180726152524664-102686644.png" alt="img"></p><p>我们来分析一下图片信息</p><p>统计信息区</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>第一行 (uptime)系统时间 主机运行时间 用户连接数(who) 系统1，5，15分钟的平均负载第二行:进程信息进程总数 正在运行的进程数 睡眠的进程数 停止的进程数 僵尸进程数第三行:cpu信息1.5 us：用户空间所占CPU百分比0.9 sy：内核空间占用CPU百分比0.0 ni：用户进程空间内改变过优先级的进程占用CPU百分比97.5 id：空闲CPU百分比0.2 wa：等待输入输出的CPU时间百分比0.0 hi：硬件CPU中断占用百分比0.0 si：软中断占用百分比0.0 st：虚拟机占用百分比</code></pre><p>第四行：内存信息（与第五行的信息类似与free命令）</p><ul><li>8053444 total：物理内存总量</li><li>7779224 used：已使用的内存总量</li><li>274220 free：空闲的内存总量（free+used=total）</li><li>359212 buffers：用作内核缓存的内存量</li></ul><pre><code>第五行：swap信息8265724 total：交换分区总量33840 used：已使用的交换分区总量8231884 free：空闲交换区总量4358088 cached Mem：缓冲的交换区总量，内存中的内容被换出到交换区，然后又被换入到内存，但是使用过的交换区没有被覆盖，交换区的这些内容已存在于内存中的交换区的大小，相应的内存再次被换出时可不必再对交换区写入。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h3><p>给文件加锁，只能写入数据，无法删除文件</p><pre><code>chattr +a test.pychattr -a test.py</code></pre><h3 id="lsattr命令"><a href="#lsattr命令" class="headerlink" title="lsattr命令"></a>lsattr命令</h3><p>查看文件隐藏属性</p><pre><code>lsattr test.py</code></pre><h3 id="童鞋们常会遇见的问题："><a href="#童鞋们常会遇见的问题：" class="headerlink" title="童鞋们常会遇见的问题："></a>童鞋们常会遇见的问题：</h3><pre><code>问题1：yudanL:~ yuchao$ cd~-bash: cd~: command not found</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719231146173-2096935463.png" alt="img"></p><pre><code>问题2：yudanL:~ yuchao$ cd /oldboy-bash: cd: /oldboy: No such file or directory</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180719231247106-1369199146.png" alt="img"></p><h2 id="linux时间同步"><a href="#linux时间同步" class="headerlink" title="linux时间同步"></a>linux时间同步</h2><p>linux的date命令可以显示当前时间或者设置系统时间</p><p>查看当前时间</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180811174435526-1179655187.png" alt="img"></p><p>格式化输出</p><pre><code>-d    --date=string    显示指定的时间，而不是当前时间以年-月-日显示当前时间date +"%Y-%m-%d"以年-月-日 时分秒 显示当前时间date +"%Y-%m-%d %T"在Linux下系统时间和硬件时间不会自动同步，在Linux运行过程中，系统时间和硬件时间以异步的方式运行，互不干扰。硬件时间的运行，是靠Bios电池来运行，而系统时间是用CPU tick来维持的。在系统开机时候，会从Bios中获取硬件时间，设置为系统时间</code></pre><p>硬件始终的查看</p><pre><code>[root@oldboy_python ~ 10:19:04]#hwclock2018年08月27日 星期一 10时23分03秒  -0.528004 秒</code></pre><p>同步系统时间和硬件时间，可以用hwclock命令</p><pre><code>//以系统时间为基准，修改硬件时间[root@oldboy_python ~ 10:29:07]#hwclock -w//以硬件时间为基准，修改系统时间[root@oldboy_python ~ 10:29:21]#hwclock -s</code></pre><h1 id="日历命令"><a href="#日历命令" class="headerlink" title="日历命令"></a>日历命令</h1><p>cal命令</p><p>calendar查看日志的意思 -y 查看一年的日历</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>yugoMBP:~ yuchao$ cal     March 2019Su Mo Tu We Th Fr Sa                1  2 3  4  5  6  7  8  910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 3031</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="Ntp时间服务器"><a href="#Ntp时间服务器" class="headerlink" title="Ntp时间服务器"></a>Ntp时间服务器</h1><pre><code>时间对于人类来说是密不可少的，时间就是金钱。因此对于服务器时间的把控非常重要，如果系统的时间不对，那么对于每一个文件的操作都是错误的。</code></pre><p>关于时间服务器的配置文件，有如下几种</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>/bin/date     用于 Linux 时间 (软件时钟) 的修改与显示的指令；/sbin/hwclock　　用于 BIOS 时钟 (硬件时钟) 的修改与显示的指令。 这是一个 root 才能执行的指令，因为 Linux 系统上面 BIOS 时间与 Linux 系统时间是分开的，所以使用 date 这个指令调整了时间之后，还需要使用 hwclock 才能将修改过后的时间写入 BIOS 当中！/usr/sbin/ntpd： 主要提供 NTP 服务的程序啰！配置文件为 /etc/ntp.conf/usr/sbin/ntpdate： 用于客户端的时间校正，如果你没有要启用 NTP 而仅想要使用 NTP Client 功能的话，那么只会用到这个指令而已啦！</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>由于我们只需要用作客户端更新时间</p><pre><code>ntpdate -u ntp.aliyun.com</code></pre><h3 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h3><pre><code>wget命令用于在终端下载网络文件参数是 wget [参数] 下载地址wget -r -p http://www.luffycity.com#递归下载路飞所有资源，保存到www.luffycity.com文件中</code></pre><h2 id="开关机命令"><a href="#开关机命令" class="headerlink" title="开关机命令"></a>开关机命令</h2><pre><code>reboot命令用于重启机器poweroff用于关闭系统</code></pre><h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.如何先进入/home/oldboy目录，然后再进入/home/python目录？2.如何在/home.python目录，执行/home/my_first.py文件?3.互相提问相对路径和绝对路径4.向my_first.py文件中写入"Lift is short,I use python"5.请用一条命令创建/tmp/oldboy/python/s116.只查看oldboy_python.txt文件（50行）内20到30行内容 7.找一下python命令在哪8.将rm命令改为"echo do not use rm"9.同桌互相传输文件，使用scp命令10.查看/var/log/文件大小</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>Tip:</p><pre><code>http://linux.51yip.com/http://man.linuxde.net/Linux命令查询手册Linux终端下  esc  + .  可以获取上次文件名</code></pre><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx+uWSGI+django+virtualenv+supervisor发布web服务器</title>
      <link href="2019/11/15/Linux/nginx+uWSGI+django+virtualenv+supervisor%E5%8F%91%E5%B8%83web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>2019/11/15/Linux/nginx+uWSGI+django+virtualenv+supervisor%E5%8F%91%E5%B8%83web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx-uWSGI-django-virtualenv-supervisor发布web服务器"><a href="#nginx-uWSGI-django-virtualenv-supervisor发布web服务器" class="headerlink" title="nginx+uWSGI+django+virtualenv+supervisor发布web服务器"></a><a href="https://www.cnblogs.com/pyyu/p/9481344.html">nginx+uWSGI+django+virtualenv+supervisor发布web服务器</a></h1><h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>WSGI是Web服务器网关接口。它是一个规范，描述了Web服务器如何与Web应用程序通信，以及Web应用程序如何链接在一起以处理一个请求，（接收请求，处理请求，响应请求）基于wsgi运行的框架有bottle,DJango,Flask,用于解析动态HTTP请求支持WSGI的服务器    wsgiref        python自带的web服务器    Gunicorn        用于linux的 python wsgi Http服务器，常用于各种django，flask结合部署服务器。    mode_wsgi        实现了Apache与wsgi应用程序的结合    uWSGI        C语言开发，快速，自我修复，开发人员友好的WSGI服务器，用于Python Web应用程序的专业部署和开发。在部署python程序web应用程序时，可以根据性能的需求，选择合适的wsgi server，不同的wsgi server区别在于并发支持上，有单线程，多进程，多线程，协程的区别，其功能还是近似，无非是请求路由，执行对应的函数，返回处理结果。Django部署Django的主要部署平台是 WSGI，这是用于Web服务器和应用程序的Python标准。Django的 startproject管理命令设置一个简单的默认WSGI配置，可以根据需要为您的项目进行调整，并指示任何符合WSGI的应用程序服务器使用。application 使用WSGI部署的关键概念是应用程序服务器用于与代码通信的 application 可调用。它通常在服务器可访问的Python模块中作为名为 application 的对象提供。startproject 命令创建包含这样的 application 可调用的文件 &lt;project_name&gt;/wsgi.py. ，它被Django的开发服务器和生产WSGI部署使用。WSGI服务器从其配置中获取 application 可调用的路径。 Django的内置服务器，即 runserver 命令，从 WSGI_APPLICATION 设置读取它。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">为什么要用nginx,uwsgi</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">13期课程笔记</p><p>nginx官网</p><pre><code>http://nginx.org/en/</code></pre><p>nginx有关uwsgi模块介绍</p><pre><code>http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html</code></pre><p>大家都学过了django，用django写了各种功能，写了bbs项目，写了路飞学城。</p><p>咱们都知道django是一个web框架，方便我们快速开发web程序，http请求的动态数据就是由web框架来提供处理的。</p><p>前面超哥也对nginx简单的介绍了，本文将nginx、WSGI、uwsgi、uWSGI、django这几个关系梳理一下。</p><pre><code>wsgi    全称web server gateway interface，wsgi不是服务器，也不是python模块，只是一种协议，描述web server如何和web application通信的规则。运行在wsgi上的web框架有bottle，flask，djangouwsgi    和wsgi一样是通信协议，是uWSGI服务器的单独协议，用于定义传输信息的类型uWSGI    是一个web服务器，实现了WSGI协议，uwsgi协议。anginx    web服务器，更加安全，更好的处理处理静态资源，缓存功能，负载均衡，因此nginx的强劲性能，配合uWSGI服务器会更加安全，性能有保障。django 高级的python web框架，用于快速开发，解决web开发的大部分麻烦，程序员可以更专注业务逻辑，无须重新造轮子</code></pre><h3 id="逻辑图"><a href="#逻辑图" class="headerlink" title="逻辑图"></a>逻辑图</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190301090118328-1036894206.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181117155443429-1430917061.png" alt="img"></p><p>web服务器</p><pre><code>传统的c/s架构，请求的过程是客户端 &gt; 服务器 服务器 &gt; 客户端服务器就是：1.接收请求 2.处理请求 3.返回响应</code></pre><p>web框架层</p><pre><code>HTTP的动态数据交给web框架，例如django遵循MTV模式处理请求。HTTp协议使用url定位资源，urls.py将路由请求交给views视图处理，然后返回一个结果，完成一次请求。web框架使用者只需要处理业务的逻辑即可。</code></pre><p>如果将一次通信转化为“对话”的过程</p><p>Nginx：hello wsgi，我刚收到一个请求，你准备下然后让django来处理吧</p><p>WSGI：好的nginx，我马上设置环境变量，然后把请求交给django</p><p>Django：谢谢WSGI，我处理完请求马上给你响应结果</p><p>WSGI：好的，我在等着</p><p>Django：搞定啦，麻烦wsgi吧响应结果传递给nginx</p><p>WSGI：太棒了，nginx，响应结果请收好，已经按照要求传递给你了</p><p>nginx：好滴。我把响应交给用户。合作愉快</p><h1 id="Django-Nginx-uwsgi-安装配置"><a href="#Django-Nginx-uwsgi-安装配置" class="headerlink" title="Django Nginx+uwsgi 安装配置"></a>Django Nginx+uwsgi 安装配置</h1><p>在前面的章节中我们使用 <strong>python manage.py runserver</strong> 来运行服务器。这只适用测试环境中使用。</p><p>正式发布的服务，需要一个可以稳定而持续的服务器。</p><h4 id="基础开发环境配置"><a href="#基础开发环境配置" class="headerlink" title="基础开发环境配置"></a>基础开发环境配置</h4><pre><code>yum groupinstall "Development tools"yum install zlib-devel bzip2-devel pcre-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel</code></pre><h4 id="提前安装好python3环境"><a href="#提前安装好python3环境" class="headerlink" title="提前安装好python3环境"></a>提前安装好python3环境</h4><pre><code>https://www.cnblogs.com/pyyu/p/7402145.html</code></pre><h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><pre><code>请确保你的虚拟环境正常工作https://www.cnblogs.com/pyyu/p/9015317.html</code></pre><h4 id="安装django1-11"><a href="#安装django1-11" class="headerlink" title="安装django1.11"></a>安装django1.11</h4><pre><code>pip3 install django==1.11#创建django项目mysitedjango-admin startproject mysite#创建app01python3 manage.py startapp app01</code></pre><p>mysite/settings.py</p><pre><code>#settings.py设置ALLOWED_HOSTS = ['*']install app01</code></pre><p>mysite/urls.py</p><pre><code>from app01 import viewsurlpatterns = [    url(r'^admin/', admin.site.urls),    url(r'^hello_django/', views.hello),]</code></pre><p>app01/views.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>from django.shortcuts import render,HttpResponse# Create your views here.def hello(request):    print('request is :',request)    return HttpResponse('django is ok ')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h4 id="安装uWSGI"><a href="#安装uWSGI" class="headerlink" title="安装uWSGI"></a>安装uWSGI</h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>进入虚拟环境venv，安装uwsgi(venv) [root@slave 192.168.11.64 /opt]$pip3 install uwsgi检查uwsgi版本(venv) [root@slave 192.168.11.64 /opt]$uwsgi --version2.0.17.1#检查uwsgi python版本uwsgi --python-version</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>运行简单的uWSGI</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#启动一个pythonuwsgi --http :8000 --wsgi-file test.py</code></pre><ul><li><code>http :8000</code>: 使用http协议，端口8000</li><li><code>wsgi-file test.py</code>: 加载指定的文件，test.py</li></ul><pre><code>#test.pydef application(env, start_response):    start_response('200 OK', [('Content-Type','text/html')])    return [b"Hello World"] # python3</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>uWsgi热加载python程序</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>在启动命令后面加上参数uwsgi --http :8088 --module mysite.wsgi --py-autoreload=1 #发布命令command= /home/venv/bin/uwsgi --uwsgi 0.0.0.0:8000 --chdir /opt/mysite --home=/home/venv --module mysite.wsgi#此时修改django代码，uWSGI会自动加载django程序，页面生效</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>运行django程序</p><pre><code>#mysite/wsgi.py  确保找到这个文件uwsgi --http :8000 --module mysite.wsgi</code></pre><ul><li><code>module mysite.wsgi</code>: 加载指定的wsgi模块</li></ul><p>uwsgi配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">uwsgi.ini</p><h4 id="指定配置文件启动命令"><a href="#指定配置文件启动命令" class="headerlink" title="指定配置文件启动命令"></a>指定配置文件启动命令</h4><pre><code>uwsgi --ini  /etc/uwsgi_nginx.ini</code></pre><h4 id="配置nginx结合uWSGI"><a href="#配置nginx结合uWSGI" class="headerlink" title="配置nginx结合uWSGI"></a>配置nginx结合uWSGI</h4><p>配置nginx.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>worker_processes  1;error_log  logs/error.log;pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  logs/access.log  main;    sendfile        on;    keepalive_timeout  65;　　#nginx反向代理uwsgi    server {        listen       80;        server_name  192.168.11.64;        location / {　　　　  #nginx自带ngx_http_uwsgi_module模块，起到nginx和uwsgi交互作用         #通过uwsgi_pass设置服务器地址和协议，讲动态请求转发给uwsgi处理         include  /opt/nginx1-12/conf/uwsgi_params;         uwsgi_pass 0.0.0.0:8000;            root   html;            index  index.html index.htm;        }　　　　  #nginx处理静态页面资源　　　　  location /static{　　　　　　　　alias /opt/nginx1-12/static;　　　         }　　　　　#nginx处理媒体资源　　　　　location /media{　　　　　　　　alias /opt/nginx1-12/media;　　         }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>配置完启动nginx</p><h1 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h1><p>supervisor 是基于 python 的任务管理工具，用来自动运行各种后台任务，当然你也能直接利用 nohup 命令使任务自动后台运行，但如果要重启任务，每次都自己手动 kill 掉任务进程，这样很繁琐，而且一旦程序错误导致进程退出的话，系统也无法自动重载任务。</p><p>这里超哥要配置基于virtualenv的supervisor</p><p>由于supervisor在python3下无法使用，因此只能用python2去下载！！！！！！</p><pre><code>#注意此时已经退出虚拟环境了！！！！！yum install python-setuptoolseasy_install supervisor</code></pre><p>通过命令生成supervisor的配支文件</p><pre><code>echo_supervisord_conf &gt; /etc/supervisord.conf</code></pre><p>然后再/etc/supervisord.conf末尾添加上如下代码！！！！！！</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>supervisord.conf配置文件参数解释[program:xx]是被管理的进程配置参数，xx是进程的名称[program:xx]command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令autostart=true       ; 在supervisord启动的时候也自动启动startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启startretries=3       ; 启动失败自动重试次数，默认是3user=tomcat          ; 用哪个用户启动进程，默认是rootpriority=999         ; 进程启动优先级，默认999，值小的优先启动redirect_stderr=true ; 把stderr重定向到stdout，默认falsestdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MBstdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.outstopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[program:my]#command=/opt/venv/bin/uwsgi --ini  /etc/uwsgi_nginx.ini  #这里是结合virtualenv的命令 和supervisor的精髓！！！！command= /home/venv/bin/uwsgi --uwsgi 0.0.0.0:8000 --chdir /opt/mysite --home=/home/venv --module mysite.wsgi#--home指的是虚拟环境目录  --module找到 mysite/wsgi.py   </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>最后启动supervisor，完成uWSGI启动django，nginx反向代理</p><pre><code>supervisord -c /etc/supervisord.conf #启动supervisorsupervisorctl -c /etxc/supervisord.conf restart my  #重启my项目supervisorctl -c /etc/supervisord.conf [start|stop|restart] [program-name|all]</code></pre><p> 重新加载supervisor</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>一、添加好配置文件后二、更新新的配置到supervisord    supervisorctl update三、重新启动配置中的所有程序supervisorctl reload四、启动某个进程(program_name=你配置中写的程序名称)supervisorctl start program_name五、查看正在守候的进程supervisorctl六、停止某一进程 (program_name=你配置中写的程序名称)pervisorctl stop program_name七、重启某一进程 (program_name=你配置中写的程序名称)supervisorctl restart program_name八、停止全部进程supervisorctl stop all注意：显示用stop停止掉的进程，用reload或者update都不会自动重启。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="django的静态文件与nginx配置"><a href="#django的静态文件与nginx配置" class="headerlink" title="django的静态文件与nginx配置"></a>django的静态文件与nginx配置</h1><p>mysite/settings.py</p><pre><code>STATIC_ROOT='/opt/nginx1-12/static'STATIC_URL = '/static/'STATICFILES_DIRS=[    os.path.join(BASE_DIR,"static"),]</code></pre><p>上述的参数STATIC_ROOT用在哪？</p><p>通过python3 manage.py collectstatic 收集所有你使用的静态文件保存到STATIC_ROOT！</p><pre><code>STATIC_ROOT 文件夹 是用来将所有STATICFILES_DIRS中所有文件夹中的文件，以及各app中static中的文件都复制过来# 把这些文件放到一起是为了用nginx等部署的时候更方便</code></pre><p>参考文档：<a href="http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html">http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html</a></p><p> uwsgi热加载：<a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/Management.html">https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/Management.html</a></p><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx入门与实战</title>
      <link href="2019/11/15/Linux/nginx%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%20/"/>
      <url>2019/11/15/Linux/nginx%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%20/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx入门与实战"><a href="#nginx入门与实战" class="headerlink" title="nginx入门与实战"></a><a href="https://www.cnblogs.com/pyyu/p/9468680.html">nginx入门与实战</a></h1><h1 id="网站服务"><a href="#网站服务" class="headerlink" title="网站服务"></a>网站服务</h1><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181014124743540-1325157612.png" alt="img"></h1><p> 想必我们大多数人都是通过访问网站而开始接触互联网的吧。我们平时访问的网站服务 就是 Web 网络服务，一般是指允许用户通过浏览器访问到互联网中各种资源的服务。</p><p>Web 网络服务是一种被动访问的服务程序，即只有接收到互联网中其他主机发出的 请求后才会响应，最终用于提供服务程序的 Web 服务器会通过 HTTP(超文本传输协议)或 HTTPS(安全超文本传输协议)把请求的内容传送给用户。</p><p>目前能够提供 Web 网络服务的程序有 IIS、Nginx 和 Apache 等。其中，IIS(Internet Information Services，互联网信息服务)是 Windows 系统中默认的 Web 服务程序</p><p>2004 年 10 月 4 日，为俄罗斯知名门户站点而开发的 Web 服务程序 Nginx 横空出世。 Nginx 程序作为一款轻量级的网站服务软件，因其稳定性和丰富的功能而快速占领服务器市 场，但 Nginx 最被认可的还当是系统资源消耗低且并发能力强，因此得到了国内诸如新浪、 网易、腾讯等门户站的青睐。</p><h1 id="web服务器和web框架的关系"><a href="#web服务器和web框架的关系" class="headerlink" title="web服务器和web框架的关系"></a>web服务器和web框架的关系</h1><p>web服务器（nginx）：接收HTTP请求（例如<a href="http://www.pythonav.cn/xiaocang.jpg%EF%BC%89%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE">www.pythonav.cn/xiaocang.jpg）并返回数据</a></p><p>web框架（django，flask）：开发web应用程序，处理接收到的数据</p><h1 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h1><h2 id="nginx是什么"><a href="#nginx是什么" class="headerlink" title="nginx是什么"></a>nginx是什么</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。它是一个俄罗斯人lgor sysoev开发的，作者将源代码开源出来供全球使用。nginx比它大哥apache性能改进许多，nginx占用的系统资源更少，支持更高的并发连接，有更高的访问效率。nginx不但是一个优秀的web服务软件，还可以作为反向代理，负载均衡，以及缓存服务使用。安装更为简单，方便，灵活。nginx可以说是非常nb了</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>面试回答nginx技巧</p><pre><code>支持高并发，能支持几万并发连接资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M可以做http反向代理和负载均衡支持异步网络i/o事件模型epoll</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180813155012063-443835808.png" alt="img"></p><p>Tengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。</p><h3 id="安装环境准备"><a href="#安装环境准备" class="headerlink" title="安装环境准备"></a>安装环境准备</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>一. gcc 安装安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：yum install gcc-c++二. PCRE pcre-devel 安装PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：yum install -y pcre pcre-devel三. zlib 安装zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。yum install -y zlib zlib-devel四. OpenSSL 安装OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。yum install gcc patch libffi-devel python-devel  zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel openssl openssl-devel -y</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="安装-启动nginx"><a href="#安装-启动nginx" class="headerlink" title="安装,启动nginx"></a>安装,启动nginx</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.下载源码包wget -c https://nginx.org/download/nginx-1.12.0.tar.gz2.解压缩源码tar -zxvf nginx-1.12.0.tar.gz3.配置，编译安装  开启nginx状态监测功能./configure --prefix=/opt/nginx1-12/ --with-http_ssl_module --with-http_stub_status_module make &amp;&amp; make install 4.启动nginx，进入sbin目录,找到nginx启动命令cd sbin./nginx #启动./nginx -s stop #关闭./nginx -s reload #重新加载</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="安装完成后检测服务"><a href="#安装完成后检测服务" class="headerlink" title="安装完成后检测服务"></a>安装完成后检测服务</h3><pre><code>netstat -tunlp |grep 80curl -I 127.0.0.1#如果访问不了，检查selinux，iptables</code></pre><h3 id="部署一个web站点"><a href="#部署一个web站点" class="headerlink" title="部署一个web站点"></a>部署一个web站点</h3><p>nginx默认站点是Nginx目录下的html文件夹，这里可以从nginx.conf中查到</p><pre><code> location /{            root   html;  #这里是默认的站点html文件夹，也就是 /opt/nginx1-12/html/文件夹下的内容            index  index.html index.htm; #站点首页文件名是index.html        }</code></pre><p>如果要部署网站业务数据，只需要把开发好的程序全放到html目录下即可</p><pre><code>[root@oldboy_python /tmp 11:34:52]#ls /opt/nginx1-12/html/index.html  jssts.jpeg  lhy.mp4  man.jpg  wget-log</code></pre><p>因此只需要通过域名/资源，即可访问</p><pre><code>http://www.pyyuc.cn/man.jpg</code></pre><h3 id="Nginx的目录结构"><a href="#Nginx的目录结构" class="headerlink" title="Nginx的目录结构"></a>Nginx的目录结构</h3><pre><code>[root@oldboy_python /opt/nginx1-12 11:44:02]#lsclient_body_temp  conf  fastcgi_temp  html  logs  proxy_temp  sbin  scgi_temp  static  uwsgi_temp</code></pre><ul><li>conf 存放nginx所有配置文件的目录,主要nginx.conf</li><li>html 存放nginx默认站点的目录，如index.html、error.html等</li><li>logs 存放nginx默认日志的目录，如error.log access.log</li><li>sbin 存放nginx主命令的目录,sbin/nginx</li></ul><h3 id="Nginx主配置文件解析"><a href="#Nginx主配置文件解析" class="headerlink" title="Nginx主配置文件解析"></a>Nginx主配置文件解析</h3><p>Nginx主配置文件<code>/etc/nginx/nginx.conf</code>是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。一般，每个区块以一对大括号<code>{}</code>来表示开始与结束。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">nginx.conf详解 </p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>CoreModule核心模块user www;                       #Nginx进程所使用的用户worker_processes 1;             #Nginx运行的work进程数量(建议与CPU数量一致或auto)error_log /log/nginx/error.log  #Nginx错误日志存放路径pid /var/run/nginx.pid          #Nginx服务运行后产生的pid进程号</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>events事件模块events {                worker_connections  //每个worker进程支持的最大连接数    use epool;          //事件驱动模型, epoll默认}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>http内核模块//公共的配置定义在http{}http {  //http层开始...        //使用Server配置网站, 每个Server{}代表一个网站(简称虚拟主机)    'server' {        listen       80;        //监听端口, 默认80        server_name  localhost; //提供服务的域名或主机名        access_log host.access.log  //访问日志        //控制网站访问路径        'location' / {            root   /usr/share/nginx/html;   //存放网站代码路径            index  index.html index.htm;    //服务器返回的默认页面文件        }        //指定错误代码, 统一定义错误页面, 错误代码重定向到新的Locaiton        error_page   500 502 503 504  /50x.html;    }    ...    //第二个虚拟主机配置    'server' {    ...    }    include /etc/nginx/conf.d/*.conf;  //包含/etc/nginx/conf.d/目录下所有以.conf结尾的文件}   //http层结束</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="Nginx虚拟主机"><a href="#Nginx虚拟主机" class="headerlink" title="Nginx虚拟主机"></a>Nginx虚拟主机</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181014162827193-835597809.png" alt="img"></p><p>如果每台linux服务器只运行了一个小网站，那么人气低，流量小的草根站长需要承担高额的服务器租赁费，也造成了硬件资源浪费。</p><p>虚拟主机就是将一台服务器分割成多个“虚拟服务器”，每个站点使用各自的硬盘空间，由于省资源，省钱，众多网站都使用虚拟主机来部署网站。</p><pre><code>虚拟主机的概念就是在web服务里的一个独立的网站站点，这个站点对应独立的域名（IP），具有独立的程序和资源目录，可以独立的对外提供服务。这个独立的站点配置是在nginx.conf中使用server{}代码块标签来表示一个虚拟主机。Nginx支持多个server{}标签，即支持多个虚拟主机站点。</code></pre><p>虚拟主机类型</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>基于域名的虚拟主机通过不同的域名区分不同的虚拟主机，是企业应用最广的虚拟主机。基于端口的虚拟主机通过不同的端口来区分不同的虚拟主机，一般用作企业内部网站，不对外直接提供服务的后台，例如www.pythonav.cn:9000基于IP的虚拟主机通过不同的IP区分不同的虚拟主机，此类比较少见，一般业务需要多IP的常见都会在负载均衡中绑定VIP</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="Nginx状态信息（status）配置"><a href="#Nginx状态信息（status）配置" class="headerlink" title="Nginx状态信息（status）配置"></a>Nginx状态信息（status）配置</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>Nginx状态信息（status）配置及信息详解    nginx与php-fpm一样内建了一个状态页，对于想了解nginx的状态以及监控nginx非常有帮助。为了后续的zabbix监控，我们需要先了解一下nginx的状态页。Nginx状态信息（status）介绍    Nginx软件在编译时又一个with-http_stub_status_module模块，这个模块功能是记录Nginx的基本访问状态信息，让使用者了解Nginx的工作状态。要想使用状态模块，在编译时必须增加--with-http_stub_status_module参数。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>监测你的nginx是否安装了status模块</p><pre><code>[root@master conf]# /opt/nginx/sbin/nginx -Vnginx version: nginx/1.12.0built by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC)configure arguments: --prefix=/opt/nginx/ --with-http_stub_status_module</code></pre><p>启动status状态功能，修改配置文件</p><pre><code>#在访问ip/status的时候，进入状态功能        location /status {　　　　　　　　#开启nginx状态功能             stub_status on;}            </code></pre><p>平滑重启nginx</p><pre><code>./sbin/nginx -s reload</code></pre><p>访问status页面</p><p><strong><a href="http://192.168.119.10/status">http://192.168.119.10/status</a></strong></p><p><strong>通过ab压测命令检测</strong></p><pre><code>yum -y install httpd-tools</code></pre><p><strong>-n requests #执行的请求数，即一共发起多少请求。</strong></p><p><strong>-c concurrency #请求并发数。</strong></p><p><strong>-k #启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。</strong></p><p><strong>ab -kc 1000 -n 100000 <a href="http://192.168.119.10/">http://192.168.119.10/</a></strong></p><h2 id="status页面解析"><a href="#status页面解析" class="headerlink" title="status页面解析"></a>status页面解析</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122120642385-594889775.png" alt="img"></p><h3 id="基于域名的多虚拟主机实战"><a href="#基于域名的多虚拟主机实战" class="headerlink" title="基于域名的多虚拟主机实战"></a>基于域名的多虚拟主机实战</h3><p>nginx可以自动识别用户请求的域名，根据不同的域名请求服务器传输不同的内容，只需要保证服务器上有一个可用的ip地址，配置好dns解析服务。</p><p>/etc/hosts是linux系统中本地dns解析的配置文件，同样可以达到域名访问效果</p><p>修改nginx.conf</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 14:33:16]#egrep -v '#|^$' /opt/nginx1-12/conf/nginx.confworker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  logs/access.log  main;    sendfile        on;    keepalive_timeout  65;    server {        listen       80;        server_name  www.pyyuc.cn;        location /{            root   html/pyyuc;            index  index.html index.htm;        }    }}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>上述代码配置了一个<a href="http://www.pyyuc.cn域名的站点,虚拟主机的部分就是server{}里的内容/">www.pyyuc.cn域名的站点，虚拟主机的部分就是server{}里的内容</a></p><h3 id="创建pyyuc-cn的站点目录和文件"><a href="#创建pyyuc-cn的站点目录和文件" class="headerlink" title="创建pyyuc.cn的站点目录和文件"></a>创建pyyuc.cn的站点目录和文件</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python /opt/nginx1-12/html 14:36:08]#mkdir pyyuc</code></pre><p>[root@oldboy_python /opt/nginx1-12/html 14:36:18]#echo “<meta charset="utf8">我是pyyuc站点” &gt; pyyuc/index.html<br>[root@oldboy_python /opt/nginx1-12/html 14:37:21]#cat pyyuc/index.html</p><meta charset="utf8">我是pyyuc站点<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>上述作用创建了一个html/pyyuc站点目录，对应于虚拟主机配置文件里的root根目录的设置html/pyyuc</p><p>然后生成一个首页文件index.html，内容是“我是pyyuc站点”</p><h3 id="检查nginx语法重新加载nginx"><a href="#检查nginx语法重新加载nginx" class="headerlink" title="检查nginx语法重新加载nginx"></a>检查nginx语法重新加载nginx</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p>[root@oldboy_python /opt/nginx1-12/html 14:37:28]#../sbin/nginx -t<br>nginx: the configuration file /opt/nginx1-12/conf/nginx.conf syntax is ok<br>nginx: configuration file /opt/nginx1-12/conf/nginx.conf test is successful</p><p>#平滑重启nginx</p><p>[root@oldboy_python /opt/nginx1-12/html 14:39:18]#../sbin/nginx -s reload</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>检查nginx端口，进程，访问pyyuc虚拟站点</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python /opt/nginx1-12/html 14:40:02]#netstat -tunlp|grep nginx[root@oldboy_python /opt/nginx1-12/html 14:40:29]#ps -ef|grep nginx#我这里是有dns解析，没有的话则需要/etc/hosts解析#成功配置了pyyuc虚拟主机站点[root@oldboy_python /opt/nginx1-12/html 14:41:37]#curl www.pyyuc.cn&lt;meta charset=utf8&gt;我是pyyuc站点</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="配置多个域名的虚拟主机"><a href="#配置多个域名的虚拟主机" class="headerlink" title="配置多个域名的虚拟主机"></a>配置多个域名的虚拟主机</h3><p>其实就是新增一个server{}虚拟主机</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>egrep -v '#|^$' /opt/nginx1-12/conf/nginx.confworker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  logs/access.log  main;    sendfile        on;    keepalive_timeout  65;    server {        listen       80;        server_name  www.pyyuc.cn;        location /{            root   html/pyyuc;            index  index.html index.htm;        }}    server {        listen       80;        server_name  www.pythonav.cn;        location /{            root   html/pythonav;            index  index.html index.htm;        }}    }</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>创建pythonav虚拟主机站点的目录和文件</p><pre><code>[root@oldboy_python /opt/nginx1-12 14:47:21]#mkdir -p /opt/nginx1-12/html/pythonav[root@oldboy_python /opt/nginx1-12 14:49:33]#echo "&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内"&gt; /opt/nginx1-12/html/pythonav/index.html[root@oldboy_python /opt/nginx1-12 14:50:44]#./sbin/nginx -tnginx: the configuration file /opt/nginx1-12/conf/nginx.conf syntax is oknginx: configuration file /opt/nginx1-12/conf/nginx.conf test is successful[root@oldboy_python /opt/nginx1-12 14:51:32]#./sbin/nginx -s reload</code></pre><h3 id="大功告成，基于域名的虚拟主机实战搞定"><a href="#大功告成，基于域名的虚拟主机实战搞定" class="headerlink" title="大功告成，基于域名的虚拟主机实战搞定"></a>大功告成，基于域名的虚拟主机实战搞定</h3><pre><code>[root@oldboy_python /opt/nginx1-12 14:52:12]#curl www.pythonav.cn&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内[root@oldboy_python /opt/nginx1-12 14:52:40]#curl www.pyyuc.cn&lt;meta charset=utf8&gt;我是pyyuc站点</code></pre><h3 id="nginx访问日志（access-log）"><a href="#nginx访问日志（access-log）" class="headerlink" title="nginx访问日志（access_log）"></a>nginx访问日志（access_log）</h3><p>日志功能对每个用户访问网站的日志信息记录到指定的日志文件里，开发运维人员可以分析用户的浏览器行为，此功能由ngx_http_log_module模块负责，官网地址是：</p><p><a href="http://nginx.org/en/docs/http/ngx_http_log_module.html">http://nginx.org/en/docs/http/ngx_http_log_module.html</a></p><p>控制日志的参数</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>log_format    记录日志的格式，可定义多种格式accsss_log    指定日志文件的路径以及格式</code></pre><p>　　log_format main ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>　　‘$status $body_bytes_sent “$http_referer” ‘<br>　　‘“$http_user_agent” “$http_x_forwarded_for”‘;</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>对应参数解析</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>$remote_addr    记录客户端ip$remote_user    远程用户，没有就是 “-”$time_local 　　 对应[14/Aug/2018:18:46:52 +0800]$request　　　 　对应请求信息"GET /favicon.ico HTTP/1.1"$status　　　  　状态码$body_bytes_sent　　571字节 请求体的大小$http_referer　　对应“-”　　由于是直接输入浏览器就是 -$http_user_agent　　客户端身份信息$http_x_forwarded_for　　记录客户端的来源真实ip 97.64.34.118</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>日志效果如下</p><pre><code>66.102.6.6 - - [14/Aug/2018:18:46:52 +0800] "GET /favicon.ico HTTP/1.1" 404 571 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.75 Safari/537.36 Google Favicon" "97.64.34.118"</code></pre><p> nginx.conf默认配置</p><pre><code>    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  logs/access.log  main;</code></pre><p>日志格式配置定义</p><pre><code>log_format是日志关键字参数，不能变main是日志格式指定的标签，记录日志时通过main标签选择指定的格式。 </code></pre><h3 id="nginx限制网站来源IP访问"><a href="#nginx限制网站来源IP访问" class="headerlink" title="nginx限制网站来源IP访问"></a>nginx限制网站来源IP访问</h3><pre><code>如果哪天发现你的nginx很慢，或者检查access.log时候，有一个some body疯狂请求你的nginx server，那么可以禁止这个IP访问</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>限制ip或ip段访问禁止访问/av/底下的资源location /av {deny 122.71.240.254;#alias /opt/nginx1-12/html/av;allow 10.1.1.0/16;  }</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="Nginx错误页面优化"><a href="#Nginx错误页面优化" class="headerlink" title="Nginx错误页面优化"></a>Nginx错误页面优化</h3><p>在网站运行过程中，可能因为页面不存在等原因，导致网站无法正常响应请求，此时web服务会返回系统的错误码，但是默认的错误页面很不友好。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180827175121359-563259509.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180827175138926-1789396134.png" alt="img"></p><p>因此我们可以将404，403等页面的错误信息重定向到网站首页或者其他指定的页面，提升用户访问体验。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>server {        listen       80;        server_name  www.pythonav.cn;        root html/pythonav;        location /{            index  index.html index.htm;        }　　　　　　#在pythonav路径下的40x.html错误页面        error_page 400 403 404 405 /40x.html;        }</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>40x.html</p><pre><code>&lt;img style='width:100%;height:100%;' src=https://pic1.zhimg.com/80/v2-77a9281a2bebc7a2ea5e02577af266a8_hd.png&gt;</code></pre><p>此时访问<a href="http://www.pythonav.cn/asdasd%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%B7%B2%E7%BB%8F%E4%BC%98%E5%8C%96%E4%BA%86">www.pythonav.cn/asdasd错误页面已经优化了</a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180827180853418-2031222076.png" alt="img"> </p><h2 id="Nginx代理"><a href="#Nginx代理" class="headerlink" title="Nginx代理"></a>Nginx代理</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181118212452965-931575034.png" alt="img"></p><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p><strong>正向代理，也就是传说中的代理,他的工作原理就像一个跳板（VPN），简单的说：</strong></p><p><strong>我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181118222300086-1972487571.png" alt="img"></strong></p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p><strong>对于客户端而言，代理服务器就像是原始服务器。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181118222354608-408861475.png" alt="img"></p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181207105156894-1355683898.png" alt="img"></p><p>nginx实现负载均衡的组件</p><pre><code>ngx_http_proxy_module    proxy代理模块，用于把请求抛给服务器节点或者upstream服务器池</code></pre><h3 id="实现一个简单的反向代理"><a href="#实现一个简单的反向代理" class="headerlink" title="实现一个简单的反向代理"></a>实现一个简单的反向代理</h3><p>机器准备，两台服务器</p><pre><code>master  192.168.11.63　　主负载slave   192.168.11.64　　web1</code></pre><p>主负载均衡节点的配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">nginx.conf</p><p>检查语法并启动nginx</p><pre><code>[root@master 192.168.11.63 /opt/nginx1-12]$/opt/nginx1-12/sbin/nginx -tnginx: the configuration file /opt/nginx1-12/conf/nginx.conf syntax is oknginx: configuration file /opt/nginx1-12/conf/nginx.conf test is successful</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#启动nginx[root@master 192.168.11.63 /opt/nginx1-12]$/opt/nginx1-12/sbin/nginx#检查端口[root@master 192.168.11.63 /opt/nginx1-12]$netstat -tunlp|grep nginxtcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8921/nginx: master</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>此时访问master的服务器192.168.11.63:80地址，已经会将请求转发给slave的80端口</p><p>除了页面效果的展示以外，还可以通过log(access.log)查看代理效果</p><p>master端日志</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180815104957353-316783693.png" alt="img"></p><p>slave端日志</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180815105056409-841189714.png" alt="img"></p><h1 id="nginx语法之location详解"><a href="#nginx语法之location详解" class="headerlink" title="nginx语法之location详解"></a>nginx语法之location详解</h1><p><a href="https://www.cnblogs.com/pyyu/p/10085444.html"><strong>戳我</strong></a></p><p><a href="https://www.cnblogs.com/pyyu/p/10085444.html"><strong>https://www.cnblogs.com/pyyu/p/10085444.html</strong></a></p><h1 id="Keepalived高可用软件"><a href="#Keepalived高可用软件" class="headerlink" title="Keepalived高可用软件"></a>Keepalived高可用软件</h1><p>什么是keepalived</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>Keepalived是一个用C语言编写的路由软件。该项目的主要目标是为Linux系统和基于Linux的基础架构提供简单而强大的负载均衡和高可用性设施。 还可以作为其他服务（nginx，mysql）的高可用软件keepalived主要通过vrrp协议实现高可用功能。vrrp叫（virtual router redundancy protocol）虚拟路由器冗余协议，目的为了解决单点故障问题，他可以保证个别节点宕机时。整个网络可以不间断的运行。 </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>高可用故障切换原理</p><pre><code>在keepalived工作时，主master节点会不断的向备节点发送心跳消息，告诉备节点自己还活着，当master节点故障时，就无法发送心跳消息，备节点就无法检测到来自master的心跳了，于是调用自身的接管程序，接管master节点的ip资源以及服务，当master主节点恢复时，备backup节点又会释放接管的ip资源和服务，回复到原本的备节点角色。</code></pre><p>1.硬件环境准备</p><pre><code>实验环境应该最好是4台虚拟机，环境有限因此用2台机器masterslave</code></pre><p>2.centos系统和nginx代理环境</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习</title>
      <link href="2019/11/15/Linux/redis%E5%AD%A6%E4%B9%A0/"/>
      <url>2019/11/15/Linux/redis%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="redis学习"><a href="#redis学习" class="headerlink" title="redis学习"></a><a href="https://www.cnblogs.com/pyyu/p/9467279.html">redis学习</a></h1><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>学名（not only sql）特点：存储结构与mysql这一种关系型数据库完全不同，nosql存储的是KV形式nosql有很多产品，都有自己的api和语法，以及业务场景产品种类：MongodbredisHbase hadoop</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="Nosql和sql的区别"><a href="#Nosql和sql的区别" class="headerlink" title="Nosql和sql的区别"></a>Nosql和sql的区别</h2><pre><code>应用场景不同，sql支持关系复杂的数据查询，nosql反之sql支持事务性，nosql不支持</code></pre><h3 id="redis特性"><a href="#redis特性" class="headerlink" title="redis特性"></a>redis特性</h3><pre><code>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件redis是c语言编写的，支持数据持久化，是key-value类型数据库。应用在缓存，队列系统中redis支持数据备份，也就是master-slave模式</code></pre><h2 id="redis优势"><a href="#redis优势" class="headerlink" title="redis优势"></a>redis优势</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>性能高，读取速度10万次每秒写入速度8万次每秒所有操作支持原子性用作缓存数据库，数据放在内存中替代某些场景下的mysql，如社交类app大型系统中，可以存储session信息，购物车订单</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180725121843504-1677691199.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180922122158473-1498915902.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180922122242786-528252216.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180922122438789-1026288726.png" alt="img"></p><h1 id="yum安装redis"><a href="#yum安装redis" class="headerlink" title="yum安装redis"></a>yum安装redis</h1><p>1.yum安装</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#前提得配置好阿里云yum源，epel源#查看是否有redis包yum list redis#安装redisyum install redis -y#安装好，启动redissystemctl start redis</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2.检测redis是否工作</p><pre><code>redis-cli    #redis 客户端工具#进入交互式环境后，执行ping，返回pong表示安装成功127.0.0.1:6379&gt; pingPONG</code></pre><h2 id="源码安装redis，编译安装"><a href="#源码安装redis，编译安装" class="headerlink" title="源码安装redis，编译安装"></a>源码安装redis，编译安装</h2><p>大家用过yum，是相当省事好用吧，为什么还要学习源码安装？<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180725122753794-1978331159.png" alt="img"></p><p>有人说编译安装性能好？错</p><p>编译安装的优势是：</p><ul><li>编译安装时可以指定扩展的module（模块），php、apache、nginx都是一样有很多第三方扩展模块，如mysql，编译安装时候，如果需要就定制存储引擎（innodb，还是MyIASM）</li><li>编译安装可以统一安装路径，linux软件约定安装目录在/opt/下面</li><li>软件仓库版本一般比较低，编译源码安装可以根据需求，安装最新的版本</li></ul><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.下载redis源码wget http://download.redis.io/releases/redis-4.0.10.tar.gz2.解压缩tar -zxf redis-4.0.10.tar.gz3.切换redis源码目录cd redis-4.0.10.tar.gz4.编译源文件make 5.编译好后，src/目录下有编译好的redis指令6.make install 安装到指定目录，默认在/usr/local/bin</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>redis可执行文件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>./redis-benchmark //用于进行redis性能测试的工具./redis-check-dump //用于修复出问题的dump.rdb文件./redis-cli //redis的客户端./redis-server //redis的服务端./redis-check-aof //用于修复出问题的AOF文件./redis-sentinel //用于集群管理</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="redis配置文件"><a href="#redis配置文件" class="headerlink" title="redis配置文件"></a>redis配置文件</h2><pre><code>redis配置文件名为redis.conf 这个文件可以自定义</code></pre><h2 id="redis-conf核心配置项"><a href="#redis-conf核心配置项" class="headerlink" title="redis.conf核心配置项"></a>redis.conf核心配置项</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>绑定ip，如需要远程访问，需要填写服务器ipbind 127.0.0.1  端口，redis启动端口port 守护进程方式运行daemonize yesrdb数据文件dbfilename dump.rdb数据文件存放路径dir /var/lib/redis/日志文件logfile /var/log/redis/redis-server.log主从复制slaveof </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="启动redis服务端"><a href="#启动redis服务端" class="headerlink" title="启动redis服务端"></a>启动redis服务端</h2><pre><code>启动redis非常简单，直接./redis-server就可以启动服务端了，还可以用下面的方法指定要加载的配置文件：./redis-server ../redis.conf默认情况下，redis-server会以非daemon的方式来运行，且默认服务端口为6379。</code></pre><p>使用redis客户端</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#执行客户端命令即可进入./redis-cli  #测试是否连接上redis127.0.0.1:6379 &gt; ping返回pong代表连接上了//用set来设置key、value127.0.0.1:6379 &gt; set name "chaoge"OK//get获取name的值127.0.0.1:6379 &gt; get name"chaoge"</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>redis是一种高级的key：value存储系统，其中value支持五种数据类型字符串（strings）散列（hashes）列表（lists）集合（sets）有序集合（sorted sets）</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>基本命令</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>keys *         查看所有keytype key      查看key类型expire key seconds    过期时间ttl key     查看key过期剩余时间        -2表示key已经不存在了persist     取消key的过期时间   -1表示key存在，没有过期时间exists key     判断key存在    存在返回1    否则0del keys     删除key    可以删除多个dbsize         计算key的数量</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>数据结构示例</p><h4 id="1-strings类型"><a href="#1-strings类型" class="headerlink" title="1.strings类型"></a>1.strings类型</h4><ul><li>set 　　设置key</li><li>get   获取key</li><li>append  追加string</li><li>mset   设置多个键值对</li><li>mget   获取多个键值对</li><li>del  删除key</li><li>incr  递增+1</li><li>decr  递减-1</li></ul><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; set name 'yu'   #设置keyOK127.0.0.1:6379&gt; get name　　　　#获取value"yu"127.0.0.1:6379&gt; set name 'yuchao'　　#覆盖keyOK127.0.0.1:6379&gt; get name　　　　#获取value"yuchao"127.0.0.1:6379&gt; append name ' dsb' 　　#追加key的string(integer) 10127.0.0.1:6379&gt; get name　　#获取value"yuchao dsb"127.0.0.1:6379&gt; mset user1 'alex' user2 'xiaopeiqi'　　　　#设置多个键值对OK127.0.0.1:6379&gt; get user1　　　　#获取value"alex"127.0.0.1:6379&gt; get user2　　　　#获取value"xiaopeiqi"127.0.0.1:6379&gt; keys *　　　　　　#找到所有key1) "user2"2) "name"3) "user1"127.0.0.1:6379&gt; mget user1 user2 name   #获取多个value1) "alex"2) "xiaopeiqi"3) "yuchao dsb"127.0.0.1:6379&gt; del name　　　　　　　　#删除key(integer) 1127.0.0.1:6379&gt; get name　　　　　　　　#获取不存在的value，为nil(nil)127.0.0.1:6379&gt; set num 10　　　　#string类型实际上不仅仅包括字符串类型，还包括整型，浮点型。redis可对整个字符串或字符串一部分进行操作，而对于整型/浮点型可进行自增、自减操作。OK　　　　127.0.0.1:6379&gt; get num"10"127.0.0.1:6379&gt; incr num　　　　#给num string 加一 INCR 命令将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值，可以用作计数器(integer) 11127.0.0.1:6379&gt; get num　　"11"127.0.0.1:6379&gt; decr num　　　　　　#递减1  (integer) 10127.0.0.1:6379&gt; decr num　　　　#递减1(integer) 9127.0.0.1:6379&gt; get num"9"</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="2-list类型"><a href="#2-list类型" class="headerlink" title="2.list类型"></a>2.list类型</h3><ul><li>lpush         从列表左边插</li><li>rpush         从列表右边插</li><li>lrange          获取一定长度的元素  lrange key  start stop</li><li>ltrim               截取一定长度列表</li><li>lpop                 删除最左边一个元素</li><li>rpop                     删除最右边一个元素</li><li>lpushx/rpushx                key存在则添加值，不存在不处理</li></ul><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>lpush duilie 'alex' 'peiqi' 'ritian'  #新建一个duilie，从左边放入三个元素llen duilie  #查看duilie长度lrange duilie 0 -1  #查看duilie所有元素rpush duilie 'chaoge'   #从右边插入chaogelpushx duilie2  'dsb'  #key存在则添加 dsb元素，key不存在则不作处理ltrim duilie 0 2  #截取队列的值，从索引0取到2，删除其余的元素lpop #删除左边的第一个rpop #删除右边的第一个</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="3-sets集合类型"><a href="#3-sets集合类型" class="headerlink" title="3.sets集合类型"></a>3.sets集合类型</h3><p>redis的集合，是一种无序的集合，集合中的元素没有先后顺序。</p><p>集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。我们来看例子：</p><ul><li>sadd/srem   添加/删除 元素</li><li>sismember   判断是否为set的一个元素</li><li>smembers    返回集合所有的成员</li><li>sdiff             返回一个集合和其他集合的差异</li><li>sinter           返回几个集合的交集</li><li>sunion          返回几个集合的并集</li></ul><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>sadd zoo  wupeiqi yuanhao  #添加集合，有三个元素，不加引号就当做字符串处理smembers zoo  #查看集合zoo成员srem zoo  wupeiqi #删除zoo里面的alexsismember zoo wupeiqi  #返回改是否是zoo的成员信息，不存在返回0，存在返回1sadd zoo wupeiqi   #再把wupeiqi加入zoosmembers zoo  #查看zoo成员sadd zoo2 wupeiqi mjj #添加新集合zoo2sdiff zoo zoo2 #找出集合zoo中有的，而zoo2中没有的元素sdiff zoo2  zoo  #找出zoo2中有，而zoo没有的元素sinter zoo zoo1   #找出zoo和zoo1的交集，都有的元素sunion  zoo zoo1  #找出zoo和zoo1的并集，所有的不重复的元素</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="4-有序集合"><a href="#4-有序集合" class="headerlink" title="4.有序集合"></a>4.有序集合</h3><p><strong>都是以z开头的命令</strong></p><p>用来保存需要排序的数据，例如排行榜，成绩，工资等。</p><p>实例</p><p>利用有序集合的排序，排序学生的成绩</p><pre><code>127.0.0.1:6379&gt; ZADD mid_test 70 "alex"(integer) 1127.0.0.1:6379&gt; ZADD mid_test 80 "wusir"(integer) 1127.0.0.1:6379&gt; ZADD mid_test 99 "yuyu"</code></pre><p>排行榜，zreverange 倒叙   zrange正序</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; ZREVRANGE mid_test 0 -1 withscores1) "yuyu"2) "99"3) "wusir"4) "80"5) "xiaofneg"6) "75"7) "alex"8) "70"127.0.0.1:6379&gt; ZRANGE mid_test 0 -1 withscores1) "alex"2) "70"3) "xiaofneg"4) "75"5) "wusir"6) "80"7) "yuyu"8) "99"</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>移除有序集合mid_test中的成员，xiaofeng给移除掉</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; ZREM mid_test xiaofneg(integer) 1127.0.0.1:6379&gt; ZRANGE mid_test 0 -1 withscores1) "alex"2) "70"3) "wusir"4) "80"5) "yuyu"6) "99"</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>返回有序集合mid_test的基数</p><pre><code>127.0.0.1:6379&gt; ZCARD mid_test(integer) 3</code></pre><p>返回成员的score值</p><pre><code>127.0.0.1:6379&gt; ZSCORE mid_test alex"70"</code></pre><p>zrank返回有序集合中，成员的排名。默认按score，从小到大排序。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>127.0.0.1:6379&gt; ZRANGE mid_test 0 -1 withscores1) "alex"2) "70"3) "wusir"4) "80"5) "yuyu"6) "99"127.0.0.1:6379&gt;127.0.0.1:6379&gt;127.0.0.1:6379&gt; ZRANK mid_test wusir(integer) 1127.0.0.1:6379&gt; ZRANK mid_test yuyu(integer) 2</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="5-哈希数据结构"><a href="#5-哈希数据结构" class="headerlink" title="5.哈希数据结构"></a>5.哈希数据结构</h3><p>哈希结构就是  <strong>k1   -&gt;  k1 : v1     如同字典 套字典  { k1 : { k2: v2 }  }   ，取出v2 必须  k1，取出k2</strong></p><p>hashes即哈希。哈希是从redis-2.0.0版本之后才有的数据结构。</p><p>hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。</p><ul><li>hset 设置散列值</li><li>hget  获取散列值</li><li>hmset  设置多对散列值</li><li>hmget  获取多对散列值</li><li>hsetnx   如果散列已经存在，则不设置（防止覆盖key）</li><li>hkeys     返回所有keys</li><li>hvals     返回所有values</li><li>hlen      返回散列包含域（field）的数量</li><li>hdel     删除散列指定的域（field）</li><li>hexists    判断是否存在</li></ul><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>redis hash是一个string类型的field和value的映射表语法  hset key field value  hset news1   title "first news title" #设置第一条新闻 news的id为1，添加数据title的值是"first news title"hset news1 content "news content"    #添加一个conntent内容hget news1 title   #获取news:1的标题hget news1  content  #获取news的内容hmget news1  title content   #获取多对news:1的 值hmset news2 title "second news title" content "second Contents2"   #设置第二条新闻news:2 多个fieldhmget news2 title  content #获取news:2的多个值hkeys news1   #获取新闻news:1的所有keyhvals news1   #获取新闻news:1的所有值hlen news1    #获取新闻news:1的长度hdel news1 title   #删除新闻news:1的titlehlen news1     #看下新闻news:1的长度hexists news1 title    #判断新闻1中是否有title，不存在返回0，存在返回1</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="redis安全"><a href="#redis安全" class="headerlink" title="redis安全"></a>redis安全</h1><p><a href="https://www.cnblogs.com/pyyu/p/9515937.html">请看博客https://www.cnblogs.com/pyyu/p/9515937.html</a></p><h1 id="redis-sentinel实战"><a href="#redis-sentinel实战" class="headerlink" title="redis-sentinel实战"></a>redis-sentinel实战</h1><p><a href="https://www.cnblogs.com/pyyu/p/9718679.html">点我啊，超哥的博客</a></p><p><a href="https://www.cnblogs.com/pyyu/p/9718679.html">https://www.cnblogs.com/pyyu/p/9718679.html</a></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列rabbitmq</title>
      <link href="2019/11/15/Linux/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq/"/>
      <url>2019/11/15/Linux/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列rabbitmq"><a href="#消息队列rabbitmq" class="headerlink" title="消息队列rabbitmq"></a><a href="https://www.cnblogs.com/pyyu/p/10318053.html">消息队列rabbitmq</a></h1><h1 id="为什么用消息队列"><a href="#为什么用消息队列" class="headerlink" title="为什么用消息队列"></a>为什么用消息队列</h1><p>举例</p><pre><code>比如在一个企业里，技术老大接到boss的任务，技术老大把这个任务拆分成多个小任务，完成所有的小任务就算搞定整个任务了。那么在执行这些小任务的时候，可能有一个环节很费时间，并且优先级很低，推迟完成也不影响整个任务运转，那么技术老大就会将这个很费时间，且不重要的任务，丢给他的小弟去解决，自己继续完成其他任务。</code></pre><p>转化为计算机思想</p><pre><code>那个技术老大就是一个 程序系统，那个小弟就是消息队列。当程序系统发现某些任务耗费时间且优先级较低，迟点完成也不影响整个任务，就把这个任务丢给消息队列。</code></pre><p>场景</p><pre><code>在程序系统中，例如外卖系统，订单系统，库存系统，优先级较高发红包，发邮件，发短信，app消息推送等任务优先级很低，很适合交给消息队列去处理，以便于程序系统更快的处理其他请求。</code></pre><p>消息队列工作流程</p><pre><code>消息队列一般有三个角色：队列服务端队列生产者队列消费者消息队列工作流程就如同一个流水线，有产品加工，一个输送带，一个打包产品输送带就是 不停运转的消息队列服务端加工产品的就是 队列生产者在传输带结尾打包产品的 就是队列消费者</code></pre><p>队列产品</p><pre><code>RabbitMQErlang编写的消息队列产品，企业级消息队列软件，支持消息负载均衡，数据持久化等。ZeroMQ saltstack软件使用此消息，速度最快。Rediskey-value的系统，也支持队列数据结构，轻量级消息队列Kafka由Scala编写，目标是为处理实时数据提供一个统一、高通量、低等待的平台</code></pre><p>一个app系统消息队列工作流程</p><pre><code>消费者，一个后台进程，不断的去检测消息队列中是否有消息，有消息就取走，开启新线程去处理业务，如果没有一会再来</code></pre><h2 id="消息队列作用"><a href="#消息队列作用" class="headerlink" title="消息队列作用"></a>消息队列作用</h2><p>1）程序解耦</p><p>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><p>2）冗余：</p><p>消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。</p><p>许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p><p>3）峰值处理能力：</p><p>(大白话，就是本来公司业务只需要5台机器，但是临时的秒杀活动，5台机器肯定受不了这个压力，我们又不可能将整体服务器架构提升到10台，那在秒杀活动后，机器不就浪费了吗？因此引入消息队列)</p><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。</p><p>如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。</p><p>使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p><p>4）可恢复性：</p><p>系统的一部分组件失效时，不会影响到整个系统。</p><p>消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p><p>5）顺序保证：</p><p>在大多使用场景下，数据处理的顺序都很重要。</p><p>大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka保证一个Partition内的消息的有序性）</p><p>6）缓冲：</p><p>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p><p>7）异步通信：</p><p>很多时候，用户不想也不需要立即处理消息。比如发红包，发短信等流程。</p><p>消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="rabbitMQ"><a href="#rabbitMQ" class="headerlink" title="rabbitMQ"></a>rabbitMQ</h1><h1 id="1-你了解的消息队列"><a href="#1-你了解的消息队列" class="headerlink" title="1. 你了解的消息队列"></a>1. 你了解的消息队列</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>生活里的消息队列，如同邮局的邮箱，如果没邮箱的话，邮件必须找到邮件那个人，递给他，才玩完成，那这个任务会处理的很麻烦，很慢，效率很低但是如果有了邮箱，邮件直接丢给邮箱，用户只需要去邮箱里面去找，有没有邮件，有就拿走，没有就下次再来，这样可以极大的提升邮件收发效率！</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>rabbitmq是一个消息代理，它接收和转发消息，可以理解为是生活的邮局。你可以将邮件放在邮箱里，你可以确定有邮递员会发送邮件给收件人。概括：rabbitmq是接收，存储，转发数据的。官方教程：http://www.rabbitmq.com/tutorials/tutorial-one-python.html</code></pre><p>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</p><p>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p><h1 id="2-公司在什么情况下会用消息队列"><a href="#2-公司在什么情况下会用消息队列" class="headerlink" title="2. 公司在什么情况下会用消息队列?"></a>2. 公司在什么情况下会用消息队列?</h1><h3 id="1-电商订单"><a href="#1-电商订单" class="headerlink" title="1.电商订单"></a>1.电商订单</h3><p>想必同学们都点过外卖，点击下单后的业务逻辑可能包括：检查库存、生成单据、发红包、短信通知等，如果这些业务同步执行，完成下单率会非常低，如发红包，短信通知等不必要的流程，异步执行即可。</p><p>此时使用MQ，可以在核心流程（扣减库存、生成订单记录）等完成后发送消息到MQ，快速结束本次流程。消费者拉取MQ消息时，发现红包、短信等消息时，再进行处理。</p><p>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093411988-542157523.png" alt="img"></p><p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p3.png?lastModify=1548379963" alt="img"></p><p>这种做法有一个缺点:</p><ul><li>当库存系统出现故障时,订单就会失败。(这样马云将少赚好多好多钱钱。。。。)</li><li>订单系统和库存系统高耦合.</li></ul><pre><code>引入消息队列</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093422429-531587085.png" alt="img"></p><p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p4.png?lastModify=1548379963" alt="img"></p><ul><li>订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</li><li>库存系统:订阅下单的消息,获取下单消息,进行库操作。 就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失(马云这下高兴了，钞票快快的来呀~~).</li></ul><h3 id="2-秒杀活动"><a href="#2-秒杀活动" class="headerlink" title="2.秒杀活动"></a>2.秒杀活动</h3><p>流量削峰一般在秒杀活动中应用广泛 场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。 作用: 1.可以控制活动人数，超过此一定阀值的订单直接丢弃(怪不得我一次秒杀都没抢到过。。。。。wtf？？？)</p><p>2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单)</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093446896-525958645.png" alt="img"></p><p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p5.png?lastModify=1548379963" alt="img"></p><p>3.用户的请求，服务器接收到之后，写入消息队列，超过定义的阈值就直接丢弃请求，或者跳转错误页面。</p><p>4.业务系统取出队列中的消息，再做后续处理。</p><h1 id="3-rabbitMQ安装"><a href="#3-rabbitMQ安装" class="headerlink" title="3. rabbitMQ安装"></a>3. rabbitMQ安装</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>rabbitmq-server服务端1.下载centos源wget -O /etc/yum.repos.d/CentOS-Base.repo   http://mirrors.cloud.tencent.com/repo/centos7_base.repo2.下载epel源wget -O /etc/yum.repos.d/epel.repo http://mirrors.cloud.tencent.com/repo/epel-7.repo3.清空yum缓存并且生成新的yum缓存yum clean allyum makecache4.安装erlang   $ yum -y install erlang5.安装RabbitMQ   $ yum -y install rabbitmq-server6.启动(无用户名密码):    systemctl start/stop/restart/status rabbitmq-server设置rabbitmq账号密码，以及角色权限设置# 设置新用户yugo 密码123sudo rabbitmqctl add_user yugo 123# 设置用户为administrator角色sudo rabbitmqctl set_user_tags yugo administrator# 设置权限，允许对所有的队列都有权限对何种资源具有配置、写、读的权限通过正则表达式来匹配，具体命令如下：set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;sudo rabbitmqctl set_permissions -p "/" yugo ".*" ".*" ".*"#重启服务生效设置service rabbitmq-server start/stop/restartrabbitmq相关命令// 新建用户rabbitmqctl add_user {用户名} {密码}// 设置权限rabbitmqctl set_user_tags {用户名} {权限}// 查看用户列表rabbitmqctl list_users// 为用户授权添加 Virtual Hosts ：    rabbitmqctl add_vhost &lt;vhost&gt;    // 删除用户rabbitmqctl delete_user Username// 修改用户的密码rabbitmqctl change_password Username Newpassword// 删除 Virtual Hosts ：    rabbitmqctl delete_vhost &lt;vhost&gt;    // 添加 Users ：    rabbitmqctl add_user &lt;username&gt; &lt;password&gt;    rabbitmqctl set_user_tags &lt;username&gt; &lt;tag&gt; ...    rabbitmqctl set_permissions [-p &lt;vhost&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;    // 删除 Users ：    delete_user &lt;username&gt;   // 使用户user1具有vhost1这个virtual host中所有资源的配置、写、读权限以便管理其中的资源rabbitmqctl  set_permissions -p vhost1 user1 '.*' '.*' '.*' // 查看权限rabbitmqctl list_user_permissions user1rabbitmqctl list_permissions -p vhost1// 清除权限rabbitmqctl clear_permissions [-p VHostPath] User//清空队列步骤rabbitmqctl reset 需要提前关闭应用rabbitmqctl stop_app ，然后再清空队列，启动应用rabbitmqctl start_app此时查看队列rabbitmqctl list_queues查看所有的exchange：                              rabbitmqctl list_exchanges查看所有的queue：                                 rabbitmqctl list_queues查看所有的用户：                                   rabbitmqctl list_users查看所有的绑定（exchange和queue的绑定信息）：         rabbitmqctl list_bindings查看消息确认信息：rabbitmqctl list_queues name messages_ready messages_unacknowledged查看RabbitMQ状态，包括版本号等信息：rabbitmqctl status#开启web界面rabbitmqrabbitmq-plugins enable rabbitmq_management#访问web界面http://server-name:15672/</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="RabbitMQ组件解释"><a href="#RabbitMQ组件解释" class="headerlink" title="RabbitMQ组件解释"></a>RabbitMQ组件解释</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>AMQPAMQP协议是一个高级抽象层消息通信协议，RabbitMQ是AMQP协议的实现。它主要包括以下组件：</code></pre><p>1.Server(broker): 接受客户端连接，实现AMQP消息队列和路由功能的进程。</p><pre><code></code></pre><p>2.Virtual Host:其实是一个虚拟概念，类似于权限控制组，一个Virtual Host里面可以有若干个Exchange和Queue，但是权限控制的最小粒度是Virtual Host</p><pre><code></code></pre><p>3.Exchange:接受生产者发送的消息，并根据Binding规则将消息路由给服务器中的队列。ExchangeType决定了Exchange路由消息的行为，例如，在RabbitMQ中，ExchangeType有direct、Fanout和Topic三种，不同类型的Exchange路由的行为是不一样的。</p><pre><code></code></pre><p>4.Message Queue：消息队列，用于存储还未被消费者消费的消息。</p><pre><code></code></pre><p>5.Message: 由Header和Body组成，Header是由生产者添加的各种属性的集合，包括Message是否被持久化、由哪个Message Queue接受、优先级是多少等。而Body是真正需要传输的APP数据。</p><pre><code></code></pre><p>6.Binding:Binding联系了Exchange与Message Queue。Exchange在与多个Message Queue发生Binding后会生成一张路由表，路由表中存储着Message Queue所需消息的限制条件即Binding Key。当Exchange收到Message时会解析其Header得到Routing Key，Exchange根据Routing Key与Exchange Type将Message路由到Message Queue。Binding Key由Consumer在Binding Exchange与Message Queue时指定，而Routing Key由Producer发送Message时指定，两者的匹配方式由Exchange Type决定。 </p><pre><code></code></pre><p>7.Connection:连接，对于RabbitMQ而言，其实就是一个位于客户端和Broker之间的TCP连接。</p><pre><code></code></pre><p>8.Channel:信道，仅仅创建了客户端到Broker之间的连接后，客户端还是不能发送消息的。需要为每一个Connection创建Channel，AMQP协议规定只有通过Channel才能执行AMQP的命令。一个Connection可以包含多个Channel。之所以需要Channel，是因为TCP连接的建立和释放都是十分昂贵的，如果一个客户端每一个线程都需要与Broker交互，如果每一个线程都建立一个TCP连接，暂且不考虑TCP连接是否浪费，就算操作系统也无法承受每秒建立如此多的TCP连接。RabbitMQ建议客户端线程之间不要共用Channel，至少要保证共用Channel的线程发送消息必须是串行的，但是建议尽量共用Connection。</p><pre><code></code></pre><p>9.Command:AMQP的命令，客户端通过Command完成与AMQP服务器的交互来实现自身的逻辑。例如在RabbitMQ中，客户端可以通过publish命令发送消息，txSelect开启一个事务，txCommit提交一个事务。</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="python客户端"><a href="#python客户端" class="headerlink" title="python客户端"></a>python客户端</h1><pre><code>// rabbitmq官方推荐的python客户端pika模块pip3 install pika</code></pre><h2 id="应用场景1：单发送单接收"><a href="#应用场景1：单发送单接收" class="headerlink" title="应用场景1：单发送单接收"></a>应用场景1：单发送单接收</h2><h2 id="生产-消费者模型"><a href="#生产-消费者模型" class="headerlink" title="生产-消费者模型"></a>生产-消费者模型</h2><pre><code>P   是生产者C   是消费者中间hello是消息队列可以有多个P、多个CP发送消息给hello队列，C消费者从队列中获取消息，默认轮询方式</code></pre><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190318104310784-1782839265.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093518791-776768428.png" alt="img"></p><p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p1.png?lastModify=1548379963" alt="img"></p><p><strong>生产者send.py</strong></p><pre><code>我们的第一个程序send.py将向队列发送一条消息。我们需要做的第一件事是建立与RabbitMQ服务器的连接。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#!/usr/bin/env pythonimport pika# 创建凭证，使用rabbitmq用户密码登录# 去邮局取邮件，必须得验证身份credentials = pika.PlainCredentials("s14","123")# 新建连接，这里localhost可以更换为服务器ip# 找到这个邮局，等于连接上服务器connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))# 创建频道# 建造一个大邮箱，隶属于这家邮局的邮箱，就是个连接channel = connection.channel()# 声明一个队列，用于接收消息，队列名字叫“水许传”channel.queue_declare(queue='水许传')# 注意在rabbitmq中，消息想要发送给队列，必须经过交换(exchange)，初学可以使用空字符串交换(exchange='')，它允许我们精确的指定发送给哪个队列(routing_key=''),参数body值发送的数据channel.basic_publish(exchange='',                      routing_key='水许传',                      body='武松又去打老虎啦2')print("已经发送了消息")# 程序退出前，确保刷新网络缓冲以及消息发送给rabbitmq，需要关闭本次连接connection.close()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code></code></pre><p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p2.png?lastModify=1548379963" alt="img"></p><p><strong>可以同时存在多个接受者，等待接收队列的消息，默认是轮训方式分配消息</strong></p><p><strong>接受者receive.py，可以运行多次，运行多个消费者</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>import pika# 建立与rabbitmq的连接credentials = pika.PlainCredentials("s14","123")connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))channel = connection.channel()channel.queue_declare(queue="水许传")def callbak(ch,method,properties,body):    print("消费者接收到了任务：%r"%body.decode("utf8"))# 有消息来临，立即执行callbak，没有消息则夯住，等待消息# 老百姓开始去邮箱取邮件啦，队列名字是水许传channel.basic_consume(callbak,queue="水许传",no_ack=True)# 开始消费，接收消息channel.start_consuming()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>练习：</p><p>分别启动生产者、两个消费者，往队列发送数据，查看消费者的结果</p><h1 id="应用场景2：单发送多接收"><a href="#应用场景2：单发送多接收" class="headerlink" title="应用场景2：单发送多接收"></a>应用场景2：单发送多接收</h1><p>使用场景：一个发送端，多个接收端，如分布式的任务派发。为了保证消息发送的可靠性，不丢失消息，使消息持久化了。同时为了防止接收端在处理消息时down掉，只有在消息处理完成后才发送ack消息。</p><h1 id="rabbitmq消息确认之ack"><a href="#rabbitmq消息确认之ack" class="headerlink" title="rabbitmq消息确认之ack"></a>rabbitmq消息确认之ack</h1><p>官网资料：<a href="http://www.rabbitmq.com/tutorials/tutorial-two-python.html">http://www.rabbitmq.com/tutorials/tutorial-two-python.html</a></p><pre><code>默认情况下，生产者发送数据给队列，消费者取出消息后，数据将被清除。特殊情况，如果消费者处理过程中，出现错误，数据处理没有完成，那么这段数据将从队列丢失</code></pre><h2 id="no-ack机制"><a href="#no-ack机制" class="headerlink" title="no-ack机制"></a>no-ack机制</h2><p><code>不确认机制</code>也就是说每次消费者接收到数据后，不管是否处理完毕，rabbitmq-server都会把这个消息标记完成，从队列中删除</p><h2 id="ACK机制"><a href="#ACK机制" class="headerlink" title="ACK机制"></a>ACK机制</h2><p>ACK机制用于保证消费者如果拿了队列的消息，<code>客户端</code>处理时出错了，那么队列中仍然还存在这个消息，提供下一位消费者继续取</p><p>流程</p><pre><code>1.生产者无须变动，发送消息2.消费者如果no_ack=True啊，数据消费后如果出错就会丢失反之no_ack=False，数据消费如果出错，数据也不会丢失3.ack机制在消费者代码中演示</code></pre><p>生产者.py <code>只负责发送数据即可，无须变动</code></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#!/usr/bin/env pythonimport pika# 创建凭证，使用rabbitmq用户密码登录# 去邮局取邮件，必须得验证身份credentials = pika.PlainCredentials("s14","123")# 新建连接，这里localhost可以更换为服务器ip# 找到这个邮局，等于连接上服务器connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))# 创建频道# 建造一个大邮箱，隶属于这家邮局的邮箱，就是个连接channel = connection.channel()# 新建一个hello队列，用于接收消息# 这个邮箱可以收发各个班级的邮件，通过channel.queue_declare(queue='金品没')# 注意在rabbitmq中，消息想要发送给队列，必须经过交换(exchange)，初学可以使用空字符串交换(exchange='')，它允许我们精确的指定发送给哪个队列(routing_key=''),参数body值发送的数据channel.basic_publish(exchange='',                      routing_key='金品没',                      body='潘金莲又出去。。。')print("已经发送了消息")# 程序退出前，确保刷新网络缓冲以及消息发送给rabbitmq，需要关闭本次连接connection.close()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>消费者.py<code>给与ack回复</code></p><p>拿到消息必须给rabbitmq服务端回复ack信息，否则消息不会被删除，防止客户端出错，数据丢失</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>import pikacredentials = pika.PlainCredentials("s14","123")connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))channel = connection.channel()# 声明一个队列(创建一个队列)channel.queue_declare(queue='金品没')def callback(ch, method, properties, body):    print("消费者接受到了任务: %r" % body.decode("utf-8"))    # int('asdfasdf')    # 我告诉rabbitmq服务端，我已经取走了消息    # 回复方式在这    ch.basic_ack(delivery_tag=method.delivery_tag)# 关闭no_ack，代表给与服务端ack回复，确认给与回复channel.basic_consume(callback,queue='金品没',no_ack=False)channel.start_consuming()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>演示1.执行生产者，向队列写入数据，产生一个新队列queue2.重启服务端，队列丢失3.开启生产者数据持久化后，重启rabbitmq，队列不丢失4.依旧可以读取数据</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>消息的可靠性是RabbitMQ的一大特色，那么RabbitMQ是如何保证消息可靠性的呢——消息持久化。 为了保证RabbitMQ在退出或者crash等异常情况下数据没有丢失，需要将queue，exchange和Message都持久化。</p><p>生产者.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>import pika# 无密码# connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61'))# 有密码credentials = pika.PlainCredentials("s14","123")connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))channel = connection.channel()# 声明一个队列(创建一个队列)# 默认此队列不支持持久化，如果服务挂掉，数据丢失# durable=True 开启持久化，必须新开启一个队列，原本的队列已经不支持持久化了'''实现rabbitmq持久化条件 delivery_mode=2使用durable=True声明queue是持久化'''channel.queue_declare(queue='LOL',durable=True)channel.basic_publish(exchange='',                      routing_key='LOL', # 消息队列名称                      body='德玛西亚万岁',                      # 支持数据持久化                      properties=pika.BasicProperties(                          delivery_mode=2,#代表消息是持久的  2                      )                      )connection.close()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code></code></pre><p>消费者.py</p><pre><code></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>import pikacredentials = pika.PlainCredentials("s14","123")connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.119.10',credentials=credentials))channel = connection.channel()# 确保队列持久化channel.queue_declare(queue='LOL',durable=True)'''必须确保给与服务端消息回复，代表我已经消费了数据，否则数据一直持久化，不会消失'''def callback(ch, method, properties, body):    print("消费者接受到了任务: %r" % body.decode("utf-8"))    # 模拟代码报错    # int('asdfasdf')    # 此处报错，没有给予回复，保证客户端挂掉，数据不丢失    # 告诉服务端，我已经取走了数据，否则数据一直存在    ch.basic_ack(delivery_tag=method.delivery_tag)# 关闭no_ack，代表给与回复确认channel.basic_consume(callback,queue='LOL',no_ack=False)channel.start_consuming()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="Exchange模型"><a href="#Exchange模型" class="headerlink" title="Exchange模型"></a>Exchange模型</h1><p>rabbitmq发送消息首先是发给exchange，然后再通过exchange发送消息给队列（queue）</p><p>exchange有四种模式</p><p><strong>fanout</strong></p><p>exchange将消息发送给和该exchange连接的所有queue；也就是所谓的广播模式；此模式下忽略routing_key；</p><p><strong>direct</strong></p><p>路由模式，通过routing_key将消息发送给对应的queue; 如下面这句即可设置exchange为direct模式，只有routing_key为“black”时才将其发送到队列queue_name；<code>channel.queue_bind(exchange=exchange_name,queue=queue_name,routing_key='black')</code></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093542406-227376628.png" alt="img"></p><p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p8.png?lastModify=1548379963" alt="img"></p><p>在上图中，Q1和Q2可以绑定同一个key，如绑定routing_key=‘KeySame’，那么收到routing_key为KeySame的消息时将会同时发送给Q1和Q2，退化为广播模式；</p><p><strong>top</strong></p><p>topic模式类似于direct模式，只是其中的routing_key变成了一个有“.”分隔的字符串，“.”将字符串分割成几个单词，每个单词代表一个条件；</p><p><strong>headers</strong></p><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。</p><p>官方教程：<a href="http://www.rabbitmq.com/tutorials/tutorial-three-python.html">http://www.rabbitmq.com/tutorials/tutorial-three-python.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093553696-841323657.png" alt="img"></p><p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p61.png?lastModify=1548379963" alt="img"></p><p>发布订阅和简单的消息队列区别在于，发布订阅会将消息发送给所有的订阅者，而消息队列中的数据被消费一次便消失。所以，RabbitMQ实现发布和订阅时，会为每一个订阅者创建一个队列，而发布者发布消息时，会将消息放置在所有相关队列中。</p><pre><code># fanout所有的队列放一份/给某些队列发# 传送消息的模式# 与exchange有关的模式都发exchange_type = fanout消费者_订阅.py</code></pre><p>可以运行多次，运行多个消费者，等待消息</p><pre><code>import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# exchange='m1',exchange(秘书)的名称# exchange_type='fanout' , 秘书工作方式将消息发送给所有的队列channel.exchange_declare(exchange='m1',exchange_type='fanout')# 随机生成一个队列result = channel.queue_declare(exclusive=True)queue_name = result.method.queue# 让exchange和queque进行绑定.channel.queue_bind(exchange='m1',queue=queue_name)def callback(ch, method, properties, body):    print("消费者接受到了任务: %r" % body)channel.basic_consume(callback,queue=queue_name,no_ack=True)channel.start_consuming()生产者_发布者.py# -*- coding: utf-8 -*-# __author__ = "yugo"import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# 指定exchangechannel.exchange_declare(exchange='m1',exchange_type='fanout')channel.basic_publish(exchange='m1',                      routing_key='',# 这里不再指定队列，由exchange分配,如果是fanout模式，每一个队列放一份                      body='haohaio')connection.close()</code></pre><p>实例</p><pre><code>1.可以运行多个消费者，相当于有多个滴滴司机，等待着Exchange同一个电台发消息2.运行发布者，发送消息给Exchange，查看是否给所有的队列(滴滴司机)发送了消息</code></pre><h1 id="关键字发布Exchange"><a href="#关键字发布Exchange" class="headerlink" title="关键字发布Exchange"></a>关键字发布Exchange</h1><p>之前事例，发送消息时明确指定某个队列并向其中发送消息，RabbitMQ还支持根据关键字发送，即：队列绑定关键字，发送者将数据根据关键字发送到消息exchange，exchange根据 关键字 判定应该将数据发送至指定队列。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125093607392-697752958.png" alt="img"></p><p><img src="file:///Users/yuchao/Gobook/Chapter12/pic/p7.png?lastModify=1548379963" alt="img"></p><p><strong>消费者1.py</strong></p><p>路由关键字是sb,alex</p><pre><code># -*- coding: utf-8 -*-# __author__ = "maple"import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# exchange='m1',exchange(秘书)的名称# exchange_type='fanout' , 秘书工作方式将消息发送给所有的队列channel.exchange_declare(exchange='m2',exchange_type='direct')# 随机生成一个队列,队列退出时，删除这个队列result = channel.queue_declare(exclusive=True)queue_name = result.method.queue# 让exchange和queque进行绑定，只要channel.queue_bind(exchange='m2',queue=queue_name,routing_key='alex')channel.queue_bind(exchange='m2',queue=queue_name,routing_key='sb')def callback(ch, method, properties, body):    print("消费者接受到了任务: %r" % body)channel.basic_consume(callback,queue=queue_name,no_ack=True)channel.start_consuming()</code></pre><p>消费者2.py</p><p>路由关键字sb</p><pre><code># -*- coding: utf-8 -*-# __author__ = "maple"import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# exchange='m1',exchange(秘书)的名称# exchange_type='fanout' , 秘书工作方式将消息发送给所有的队列channel.exchange_declare(exchange='m2',exchange_type='direct')# 随机生成一个队列result = channel.queue_declare(exclusive=True)queue_name = result.method.queue# 让exchange和queque进行绑定.channel.queue_bind(exchange='m2',queue=queue_name,routing_key='sb')def callback(ch, method, properties, body):    print("消费者接受到了任务: %r" % body)channel.basic_consume(callback,queue=queue_name,no_ack=True)channel.start_consuming()</code></pre><p>生产者.py</p><p>发送消息给匹配的路由，sb或者alex</p><pre><code># -*- coding: utf-8 -*-# __author__ = "yugo"import pikacredentials = pika.PlainCredentials("root","123")connection = pika.BlockingConnection(pika.ConnectionParameters('123.206.16.61',credentials=credentials))channel = connection.channel()# 路由模式的交换机会发送给绑定的key和routing_key匹配的队列channel.exchange_declare(exchange='m2',exchange_type='direct')# 发送消息，给有关sb的路由关键字channel.basic_publish(exchange='m2',                      routing_key='sb',                      body='aaaalexlaolelaodi')connection.close()</code></pre><h1 id="RPC之远程过程调用"><a href="#RPC之远程过程调用" class="headerlink" title="RPC之远程过程调用"></a>RPC之远程过程调用</h1><p><strong>将一个函数运行在远程计算机上并且等待获取那里的结果，这个称作远程过程调用（Remote Procedure Call）或者 RPC。</strong></p><p>RPC<strong>是一个计算机通信协议。</strong></p><p><strong>比喻</strong></p><pre><code>将计算机服务运行理解为厨师做饭，厨师想做一个小葱拌豆腐，厨师需要洗小葱、切豆腐、调汁、凉拌。他一个人完成所有的事，如同古老的集中式应用，一台计算机做所有的事。制作小葱拌豆腐{    厨师&gt;洗小葱&gt;切豆腐&gt;凉拌}</code></pre><p><code>rpc</code>应用场景</p><pre><code>而如今，饭店做大了，有钱了，专职分工来干活，不再是厨师单打独斗，备菜师傅准备小葱、豆腐，切菜师傅切小葱、豆腐，厨师只负责调味，完成食品。制作小葱拌豆腐{    备菜师&gt;洗菜    切菜师&gt;切菜    厨师&gt;调味}</code></pre><p>此时一件事好多人在做，厨师就得和其他人沟通，通知备菜、洗菜师傅的这个动作就是远程过程调用（RPC）。</p><p>这个过程在计算机系统中，一个电商的下单过程，涉及物流、支付、库存、红包等多个系统，多个系统又在多个服务器上，由不同的技术团队负责，整个下单过程，需要所有团队进行远程调用。</p><pre><code>下单{    库存&gt;减少库存    支付&gt;扣款    红包&gt;减免红包    物流&gt;生成订单}</code></pre><h3 id="到底什么是rpc"><a href="#到底什么是rpc" class="headerlink" title="到底什么是rpc"></a>到底什么是rpc</h3><pre><code>rpc指的是在计算机A上的进程，调用另外一台计算机B的进程，A上的进程被挂起，B上的被调用进程开始执行后，产生返回值给A，A继续执行。调用方可以通过参数将信息传递给被调用方，而后通过返回结果得到信息，这个过程对于开发人员来说是透明的。如同厨师一样，服务员把菜单给后厨，厨师告诉洗菜人，备菜人，开始工作，完成工作后，整个过程对于服务员是透明的，他完全不用管后厨是怎么把菜做好的。</code></pre><p>由于服务在不同的机器上，远程调用必经网络通信，调用服务必须写一坨网络通信代码，很容易出错且很复杂，因此就出现了RPC框架。</p><pre><code>阿里巴巴的 Dubbo     java新浪的     Motan    java谷歌的     gRPC     多语言Apache      thrift  多语言rpc封装了数据的序列化，反序列化，以及传输协议</code></pre><h2 id="python实现RPC"><a href="#python实现RPC" class="headerlink" title="python实现RPC"></a>python实现RPC</h2><p>利用RabbitMQ构建一个RPC系统，包含了客户端和RPC服务器，依旧使用pika模块</p><h3 id="Callback-queue-回调队列"><a href="#Callback-queue-回调队列" class="headerlink" title="Callback queue 回调队列"></a>Callback queue 回调队列</h3><p>一个客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址<code>reply_to</code>。</p><h3 id="Correlation-id-关联标识"><a href="#Correlation-id-关联标识" class="headerlink" title="Correlation id 关联标识"></a>Correlation id 关联标识</h3><p>一个客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有<code>correlation_id</code>属性，这样客户端在回调队列中根据<code>correlation_id</code>字段的值就可以分辨此响应属于哪个请求。</p><pre><code>客户端发送请求：某个应用将请求信息交给客户端，然后客户端发送RPC请求，在发送RPC请求到RPC请求队列时，客户端至少发送带有reply_to以及correlation_id两个属性的信息服务器端工作流： 等待接受客户端发来RPC请求，当请求出现的时候，服务器从RPC请求队列中取出请求，然后处理后，将响应发送到reply_to指定的回调队列中客户端接受处理结果： 客户端等待回调队列中出现响应，当响应出现时，它会根据响应中correlation_id字段的值，将其返回给对应的应用过程1.启动rpc客户端，等待接收数据到来，来了之后就进行处理，再将结果丢进队列2.启动rpc服务端，发起请求</code></pre><pre><code>rpc_server.py</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>import pikaimport uuidclass FibonacciRpcClient(object):    def __init__(self):        # 客户端启动时，创建回调队列，会开启会话用于发送RPC请求以及接受响应        # 建立连接，指定服务器的ip地址        self.connection = pika.BlockingConnection(pika.ConnectionParameters(            host='192.168.119.10'))        # 建立一个会话，每个channel代表一个会话任务        self.channel = self.connection.channel()        # 声明回调队列，再次声明的原因是，服务器和客户端可能先后开启，该声明是幂等的，多次声明，但只生效一次        #exclusive=True 参数是指只对首次声明它的连接可见        #exclusive=True 会在连接断开的时候，自动删除        result = self.channel.queue_declare(exclusive=True)        # 将次队列指定为当前客户端的回调队列        self.callback_queue = result.method.queue        # 客户端订阅回调队列，当回调队列中有响应时，调用`on_response`方法对响应进行处理;        self.channel.basic_consume(self.on_response, no_ack=True,                                   queue=self.callback_queue)    # 对回调队列中的响应进行处理的函数    def on_response(self, ch, method, props, body):        if self.corr_id == props.correlation_id:            self.response = body    # 发出RPC请求    # 例如这里服务端就是一个切菜师傅，菜切好了，需要传递给洗菜师傅，这个过程是发送rpc请求    def call(self, n):        # 初始化 response        self.response = None        # 生成correlation_id 关联标识，通过python的uuid库，生成全局唯一标识ID，保证时间空间唯一性        self.corr_id = str(uuid.uuid4())        # 发送RPC请求内容到RPC请求队列`s14rpc`，同时发送的还有`reply_to`和`correlation_id`        self.channel.basic_publish(exchange='',                                   routing_key='s14rpc',                                   properties=pika.BasicProperties(                                       reply_to=self.callback_queue,                                       correlation_id=self.corr_id,                                   ),                                   body=str(n))        while self.response is None:            self.connection.process_data_events()        return int(self.response)# 建立客户端fibonacci_rpc = FibonacciRpcClient()# 发送RPC请求，丢进rpc队列，等待客户端处理完毕，给与响应print("发送了请求sum(99)")response = fibonacci_rpc.call(99)print("得到远程结果响应%r" % response)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code></code></pre><p>rpc_client.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>import pika# 建立连接，服务器地址为localhost，可指定ip地址connection = pika.BlockingConnection(pika.ConnectionParameters(    host='192.168.119.10'))# 建立会话channel = connection.channel()# 声明RPC请求队列channel.queue_declare(queue='s14rpc')# 模拟一个进程，例如切菜师傅，等着洗菜师傅传递数据def sum(n):    n+=100    return n# 对RPC请求队列中的请求进行处理def on_request(ch, method, props, body):    print(body,type(body))    n = int(body)    print(" 正在处理sum(%s)" % n)    # 调用数据处理方法    response = sum(n)    # 将处理结果(响应)发送到回调队列    ch.basic_publish(exchange='',                     # reply_to代表回复目标                     routing_key=props.reply_to,                     # correlation_id（关联标识）：用来将RPC的响应和请求关联起来。                     properties=pika.BasicProperties(correlation_id= \                                                         props.correlation_id),                     body=str(response))    ch.basic_ack(delivery_tag=method.delivery_tag)# 负载均衡，同一时刻发送给该服务器的请求不超过一个channel.basic_qos(prefetch_count=1)channel.basic_consume(on_request, queue='s14rpc')print("等待接收rpc请求")#开始消费channel.start_consuming()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统基础优化及常用命令</title>
      <link href="2019/11/15/Linux/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2019/11/15/Linux/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统基础优化及常用命令"><a href="#Linux系统基础优化及常用命令" class="headerlink" title="Linux系统基础优化及常用命令"></a><a href="https://www.cnblogs.com/pyyu/articles/9355477.html">Linux系统基础优化及常用命令</a></h1><h1 id="Linux基础系统优化"><a href="#Linux基础系统优化" class="headerlink" title="Linux基础系统优化"></a>Linux基础系统优化</h1><p>引言没有，只有一张图。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180723164656135-60382160.png" alt="img"></p><p>Linux的网络功能相当强悍，一时之间我们无法了解所有的网络命令，在配置服务器基础环境时，先了解下网络参数设定命令。</p><ul><li>ifconfig　　查询、设置网卡和ip等参数</li><li>ifup,ifdown    脚本命令，更简单的方式启动关闭网络</li><li>ip　　符合指令，直接修改上述功能</li></ul><pre><code>在我们刚装好linux的时候，需要用xshell进行远程连接，那就得获取ip地址，有时候网卡默认是没启动的，Linux也就拿不到ip地址，因此我们得手动启动网卡#编辑网卡配置文件vim /etc/sysconfig/network-scripts/ifcfg-eth0 #修改配置参数ONBOOT=yes</code></pre><h3 id="网卡配置文件详解"><a href="#网卡配置文件详解" class="headerlink" title="网卡配置文件详解"></a>网卡配置文件详解</h3><p>如下</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>网络配置文件：/etc/sysconfig/network网络接口配置文件：/etc/sysconfig/network-scripts/ifcfg-INTERFACE_NAMEDEVICE=: 关联的设备名称，要与文件名的后半部“INTERFACE_NAME”保持一致; BOOTPROTO={static|none|dhcp|bootp}: 引导协议；要使用静态地址，使用static或none；dhcp表示使用DHCP服务器获取地址；IPADDR=: IP地址NETMASK=：子网掩码GATEWAY=：设定默认网关；ONBOOT=：开机时是否自动激活此网络接口；HWADDR=： 硬件地址，要与硬件中的地址保持一致；可省；USERCTL={yes|no}: 是否允许普通用户控制此接口；PEERDNS={yes|no}: 是否在BOOTPROTO为dhcp时接受由DHCP服务器指定的DNS地址；</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="ifup-ifdown命令"><a href="#ifup-ifdown命令" class="headerlink" title="ifup,ifdown命令"></a>ifup,ifdown命令</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>启动/关闭一块网卡ifup eth0ifdown eth0---如果关闭网卡，xshell会怎样?</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h3><pre><code>ifconfig 查看网卡的ip地址</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180723170115394-866303539.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>直接输入ifconfig会列出已经启动的网卡，也可以输入ifconfig eth0单独显示eth0的信息各选项解释是：eth0    网卡的代号 lo        回环地址loopbackinet    IPv4的Ip地址netmask    子网掩码broadcast    广播地址RX/TX     流量发/收情况     tx是发送（transport），rx是接收(receive)packets     数据包数errors     数据包错误数dropped    数据包有问题被丢弃的数量collisions    数据包碰撞情况，数值太多代表网络状况差</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="ifup-ifdown命令-1"><a href="#ifup-ifdown命令-1" class="headerlink" title="ifup,ifdown命令"></a>ifup,ifdown命令</h3><pre><code>ifup和ifdown是直接连接到/etc/sysconfig/network-scripts目录下搜索对应的网卡文件，例如ifcfg-eth0然后加以设置</code></pre><h3 id="ip命令"><a href="#ip命令" class="headerlink" title="ip命令"></a>ip命令</h3><pre><code>ip是一个命令，不是TCP/IP那个ip，这个ip命令是结合了ifconfig和route两个命令的功能。ip addr show #查看ip信息</code></pre><p>了解了如何查看网卡信息，接下来查看系统信息。</p><p>你的系统是什么版本？</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#查看系统版本信息cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) #查看内核版本号uname -r3.10.0-693.el7.x86_64#查看系统多少位uname -mx86_64#查看内核所有信息uname -a</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="用户管理与文件权限篇"><a href="#用户管理与文件权限篇" class="headerlink" title="用户管理与文件权限篇"></a>用户管理与文件权限篇</h1><pre><code>现代操作系统一般属于多用户的操作系统，也就是说，同一台机器可以为多个用户建立账户，一般这些用户都是为普通用户，这些普通用户能同时登录这台计算机，计算机对这些用户分配一定的资源。普通用户在所分配到的资源内进行各自的操作，相互之间不受影响。但是这些普通用户的权限是有限制的，且用户太多的话，管理就不便，从而引入root用户。此用户是唯一的，且拥有系统的所有权限。root用户所在的组称为root组。“组”是具有相似权限的多个用户的集合。</code></pre><p> root的权利</p><pre><code>Linux系统的特性就是可以满足多个用户，同时工作，因此Linux系统必须具备很好的安全性。在安装RHEL7时设置的root管理员密码，这个root管理员就是所有UNIX系统中的超级用户，它拥有最高的系统所有权，能够管理系统的各项功能，如添加/删除用户，启动/关闭进程，开启/禁用硬件设备等等。因此“能力越大，责任越大”，root权限必须很好的掌握，否则一个错误的命令可能会摧毁整个系统。</code></pre><p>root为什么叫root？</p><pre><code>在Linux系统中，用户也有自己的UID身份账号且唯一系统管理员UID为0系统用户UID为1~999    Linux安装的服务程序都会创建独有的用户负责运行。普通用户UID从1000开始：由管理员创建</code></pre><p>用户组GID</p><pre><code>为了方便管理属于同一组的用户，Linux 系统中还引入了用户组的概念。通过使用用 户组号码(GID，Group IDentification)，我们可以把多个用户加入到同一个组中，从而方 便为组中的用户统一规划权限或指定任务。假设有一个公司中有多个部门，每个部门中又 有很多员工。如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设 置权限。例如，可以通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的 数据库信息等。Linux管理员在创建用户时，将自动创建一个与其同名的用户组，这个用户组只有该用户一个人</code></pre><p>大家都知道windows下有管理员用户</p><p>这样<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180723173802667-335042747.png" alt="img"></p><p>或者这样<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180723173831369-432811551.png" alt="img"></p><p>Linux/unix是一个多用户、多任务的操作系统。</p><p>root：默认在Unix/linux操作系统中拥有最高的管理权限。可以理解为qq群的群主⬇️⬇️⬇️</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180723173656496-66841196.png" alt="img"></p><p>普通用户：是管理员或者具备管理权限的用户所创建的，只能读、看，不能增、删、改。</p><h3 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#添加用户useradd oldboy #设置密码       passwd redhatroot用户可以修改其他所有人的密码，且不需要验证</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><pre><code>su命令可以切换用户身份的需求，su - usernamesu命令中间的-号很重要，意味着完全切换到新的用户，即环境变量信息也变更为新用户的信息</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#先看下当前用户（我是谁）whoami#切换用户su - oldboy#退出用户登录logoutctrl + d</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><ul><li>一般情况下，在生产环境避免直接用root用户，除非有特殊系统维护需求，使用完立刻退回普通用户</li><li>非交互式设置密码(echo “redhat”|passwd –stdin oldboy &amp;&amp; history -c)</li></ul><pre><code>Tip:1.超级用户root切换普通用户无需密码,例如“群主”想踢谁就踢谁2.普通用户切换root，需要输入密码3.普通用户权限较小，只能基本查看信息4.$符号是普通用户命令提示符，#是超级管理员的提示符root是当前用户，oldboyedu是主机名，~代表当前路径，也是家目录</code></pre><p>groupadd命令</p><pre><code>group命令用于创建用户组，为了更加高效的指派系统中各个用户的权限，在工作中常常添加几个用户到一个组里面，这样可以针对一类用户安排权限。例如超哥以前在公司里，就负责添加openLDAP用户管理，偶尔台湾，美国的同事去上海协作，我就得给他们添加到it部门组里面，以至于他们有对服务器操作的权限。groupadd it_dep</code></pre><h3 id="userdel删除用户"><a href="#userdel删除用户" class="headerlink" title="userdel删除用户"></a>userdel删除用户</h3><pre><code>-f     强制删除用户-r    同事删除用户以及家目录userdel -r pyyu </code></pre><h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p><strong>sudo命令</strong>用来以其他身份来执行命令，预设的身份为root。在<code>/etc/sudoers</code>中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。</p><p>语法</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>sudo 【选项】【参数】-b：在后台执行指令；-h：显示帮助；-H：将HOME环境变量设为新身份的HOME环境变量；-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。-l：列出目前用户可执行与无法执行的指令；-p：改变询问密码的提示符号；-s&lt;shell&gt;：执行指定的shell；-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；-v：延长密码有效期限5分钟；-V ：显示版本信息。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>实例</p><p>这个sudo命令用在什么时候呢？</p><p>看图</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180727104201611-1737188153.png" alt="img"></p><p>怎么办？权限不够，这时候需要sudo ls /root  以root身份去运行，chaoge权利小，root总可以了吧!!</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180727104354250-942493622.png" alt="img"></p><p>这是由于配置sudo必须编辑/etc/sudoers文件，并且只有root才能修改，咱们可以通过visudo命令直接编辑sudoers文件，使用这个命令还可以检查语法，比直接编辑 vim /etc/sudoers更安全</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>visudo 编辑sudoers文件写入## Allow root to run any commands anywhereroot    ALL=(ALL)       ALLchaoge  ALL=(ALL)       ALL   #允许chaoge在任何地方，执行任何命令</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>此时切换chaoge用户#su命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。su - chaoge已经可以使用sudo ls /root 命令</code></pre><h2 id="文件与目录权限"><a href="#文件与目录权限" class="headerlink" title="文件与目录权限"></a>文件与目录权限</h2><p>Linux权限的目的是（保护账户的资料）</p><p>Linux权限主要依据三种身份来决定：</p><ul><li>user/owner 文件使用者,文件属于哪个用户</li><li>group 属组,文件属于哪个组</li><li>others 既不是user，也不再group，就是other，其他人</li></ul><h3 id="什么是权限"><a href="#什么是权限" class="headerlink" title="什么是权限"></a>什么是权限</h3><pre><code>在Linux中，每个文件都有所属的所有者，和所有组，并且规定了文件的所有者，所有组以及其他人对文件的，可读，可写，可执行等权限。对于目录的权限来说，可读是读取目录文件列表，可写是表示在目录内新增，修改，删除文件。可执行表示可以进入目录</code></pre><h3 id="Linux权限的观察"><a href="#Linux权限的观察" class="headerlink" title="Linux权限的观察"></a>Linux权限的观察</h3><p>使用一条命令查看权限</p><pre><code>ls -l /var/log/mysqld.log </code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180811155113844-356770043.png" alt="img"></p><p>解读上图：</p><ol><li>权限，第一个字母为文件类型，后续9个字母，每3个一组，是三种身份的权限</li><li>文件链接数</li><li>文件拥有者-属主</li><li>文件拥有组-属组</li><li>文件大小</li><li>最后一次被修改的时间日期</li><li>文件名 </li></ol><p>先来分析一下文件的类型</p><pre><code>-    一般文件d    文件夹l    软连接（快捷方式）b    块设备，存储媒体文件为主c    代表键盘,鼠标等设备</code></pre><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><pre><code>r    read可读，可以用cat等命令查看w    write写入，可以编辑或者删除这个文件x    executable    可以执行</code></pre><h2 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h2><p><strong>权限这里测试不要用root实验！！！！root太牛逼了</strong></p><p><strong>请用普通用户执行！！！！！测试文件、文件夹权限操作，请用普通用户！</strong></p><pre><code>r    可以对此目录执行ls列出所有文件w    可以在这个目录创建文件x    可以cd进入这个目录，或者查看详细信息</code></pre><p>权限与数字转化</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180823101551140-166203010.png" alt="img"> </p><pre><code>ls -l /var/log/mysqld.log -rw-r--r-- 1 mysql mysql 6735642 8月  11 14:19 /var/log/mysqld.log这个就代表mysqld.log文件属主是mysql，属组是mysql，只有mysql用户可以读取编写这个文件，其他人只能读此文件。</code></pre><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180823103030840-908829548.png" alt="img"></h3><h3 id="查看用户权限命令"><a href="#查看用户权限命令" class="headerlink" title="查看用户权限命令"></a>查看用户权限命令</h3><pre><code>id指令查看用户所属群主[root@oldboy_python ~ 16:34:52]#id rootuid=0(root) gid=0(root) 组=0(root)</code></pre><h3 id="修改文件权限属性"><a href="#修改文件权限属性" class="headerlink" title="修改文件权限属性"></a>修改文件权限属性</h3><pre><code>普通用户只能修改自己的文件名，时间与权限（注意）因此修改其他用户权限，只能用最nb的root用户</code></pre><p>#切换root用户</p><p>[pyyu@oldboy_python root]$ su -</p><pre><code>当前/tmp/pyyu.txt文件以存在，且信息是-rw-rw-r-- 1 pyyu pyyu    0 8月  11 16:41 pyyu.txt</code></pre><p>修改属主为root</p><p>chown</p><pre><code>[root@oldboy_python /tmp 16:43:12]#chown root pyyu.txt </code></pre><p>查看信息</p><pre><code>[root@oldboy_python /tmp 16:43:42]#ll pyyu.txt -rw-rw-r-- 1 root pyyu 0 8月  11 16:41 pyyu.txt</code></pre><p>修改属组</p><p>chgrp</p><pre><code>[root@oldboy_python /tmp 16:43:42]#ll pyyu.txt -rw-rw-r-- 1 root pyyu 0 8月  11 16:41 pyyu.txt[root@oldboy_python /tmp 16:44:59]#chgrp root pyyu.txt [root@oldboy_python /tmp 16:45:51]#ll pyyu.txt -rw-rw-r-- 1 root root 0 8月  11 16:41 pyyu.txt</code></pre><h3 id="文件权限-1"><a href="#文件权限-1" class="headerlink" title="文件权限"></a>文件权限</h3><p>我们已知三种身份权限（属主，属组，其他人），每种身份都有rwx的三种权限，系统还提供了数字计算权限。</p><pre><code>r    read          4w    write        2x    execute     1</code></pre><p>每种身份最低是0分，最高是r+w+x 7分</p><p>因此三种身份，最高权限是777，最低是000</p><pre><code>-rw-rw-r-- 1 root root 0 8月  11 16:41 pyyu.txt因此可知pyyu.txt的权限是属主是6 r+w(4+2)属组是6　r+w(4+2)其他人是4　r(4)</code></pre><h3 id="修改权限的命令"><a href="#修改权限的命令" class="headerlink" title="修改权限的命令"></a>修改权限的命令</h3><p>chmod</p><pre><code>chmod [身份]　　 [参数] 　　[文件]　　　　u(user)　　 +(添加)　　　　　　g(group)　  -(减去)　　　　o(other)　　=(赋值)　　　　a(all)</code></pre><p>例如</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>当前权限-rw-rw-r-- 1 root root 0 8月  11 16:41 pyyu.txt方法1减去属主的写权限chmod u-w pyyu.txt查看权限-r--rw-r-- 1 root root 0 8月  11 16:41 pyyu.txt方法2属主添加可读可写可执行权限chmod 700 pyyu.txt属主可读可写可执行属组可读可执行其他人可读可执行chmod 755 pyyu.txt</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>修改文件名，修改文件更改日期</p><pre><code>mv pyyu.txt chaoge.txt#触摸，修改时间touch chaoge.txt</code></pre><h1 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h1><p>软连接也叫做符号链接，类似于windows的快捷方式。</p><p>常用于安装软件的快捷方式配置，如python，nginx等</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>ln -s 目标文件  软连接名1.存在文件/tmp/test.txt[root@master tmp]# ls -l-rw-r--r-- 1 root root     10 10月 15 21:23 test.txt2.在/home目录中建立软连接，指向/tmp/test.txt文件ln -s /tmp/test.txt my_test3.查看软连接信息lrwxrwxrwx 1 root root 13 10月 15 21:35 my_test -&gt; /tmp/test.txt4.通过软连接查看文件cat my_testmy_test只是/tmp/test.txt的一个别名，因此删除my_test不会影响/tmp/test.txt，但是删除了本尊，快捷方式就无意义不存在了</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>PS1变量</p><p>Linux命令提示符由PS1环境变量控制</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180723175136183-187264256.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~]# echo $PS1[\u@\h \W]\$可以自行调整全局变量/etc/profile文件用于永久生效 PS1='[\u@\h \W\t]\$'\d　　日期\H　　完整主机名\h　　主机名第一个名字\t　　时间24小时制HHMMSS\T　　时间12小时制\A　　时间24小时制HHMM\u　　当前用户账号名\v　　BASH的版本\w　　完整工作目录\W　　利用basename取得工作目录名\#　　下达的第几个命令\$　　提示字符，root为#，普通用户为$PS1 &gt; 变量名$PS1 &gt; 查看变量内容PS1=新内容 重新赋值变量赋值，查看name='chaoge'echo $namePS1显示ip地址export PS1="[\u@\h `/sbin/ifconfig ens33 | sed -nr 's/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p'` \w]\$"</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="tar解压命令"><a href="#tar解压命令" class="headerlink" title="tar解压命令"></a>tar解压命令</h2><p>人们发明了各种各样的包，无论是双肩包，或者是装在口袋，都是为了让“文件”更方便携带。linux的文件打包工具最出名的是tar。</p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322192003432-1512149003.png" alt="img"></p><pre><code> tar 命令：用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的</code></pre><p>语法</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>tar(选项)(参数)-A或--catenate：新增文件到以存在的备份文件；-B：设置区块大小；-c或--create：建立新的备份文件；-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-d：记录文件的差别；-x或--extract或--get：从备份文件中还原文件；-t或--list：列出备份文件的内容；-z或--gzip或--ungzip：通过gzip指令处理备份文件；-Z或--compress或--uncompress：通过compress指令处理备份文件；-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；-v或--verbose：显示指令执行过程；-r：添加文件到已经压缩的文件；-u：添加改变了和现有的文件到已经存在的压缩文件；-j：支持bzip2解压文件；-v：显示操作过程；-l：文件系统边界设置；-k：保留原有文件不覆盖；-m：保留文件不被覆盖；-w：确认压缩文件的正确性；-p或--same-permissions：用原来的文件权限还原文件；-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>实例</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190322193241069-23651309.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>tar -zxvf Python-3.7.0b3.tgz #解压tar -czvf oldboy.txt.tar.gz oldboy.txt #压缩oldboy.txt  上述命令等于 以下两条命令tar -cvf oldboy.tar oldboy.txtgzip oldboy.tartar -cf all_pic.tar *.jpg #压缩当前目录所有jpg结尾的文件tar -xjf xx.tar.bz2　　#解压缩bz2结尾的文件</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h3><pre><code>gzip用来压缩文件，是个使用广泛的压缩程序，被压缩的以".gz"扩展名gzip可以压缩较大的文件，以60%~70%压缩率来节省磁盘空间</code></pre><p>语法</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>-d或--decompress或----uncompress：解开压缩文件；-f或——force：强行压缩文件。-h或——help：在线帮助；-l或——list：列出压缩文件的相关信息；-L或——license：显示版本与版权信息；-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-v或——verbose：显示指令执行过程；</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>实例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>压缩当前目录所有文件为.gz文件gzip * 把上例中每个压缩的文件解压，并列出详细的信息gzip -dv *显示压缩文件的信息，并不解压gzip -l *压缩一个tar备份文件，扩展名是tar.gztar -cf my.tar my_first.pygzip -r my.tar</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h3><pre><code>netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。</code></pre><p> 语法【选项】</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>netstat [选项]-t或--tcp：显示TCP传输协议的连线状况；-u或--udp：显示UDP传输协议的连线状况；-n或--numeric：直接使用ip地址，而不通过域名服务器；-l或--listening：显示监控中的服务器的Socket；-p或--programs：显示正在使用Socket的程序识别码和程序名称；-a或--all：显示所有连线中的Socket；</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>实例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 10:21:59]#netstat -tunlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      814/sshd            tcp6       0      0 :::111                  :::*                    LISTEN      2703/rpcbind        tcp6       0      0 :::3306                 :::*                    LISTEN      29269/mysqld        udp        0      0 0.0.0.0:758             0.0.0.0:*                           2703/rpcbind        udp        0      0 0.0.0.0:111             0.0.0.0:*                           2703/rpcbind        udp        0      0 10.141.32.137:123       0.0.0.0:*                           484/ntpd            udp        0      0 127.0.0.1:123           0.0.0.0:*                           484/ntpd            udp        0      0 0.0.0.0:123             0.0.0.0:*                           484/ntpd            udp6       0      0 :::758                  :::*                                2703/rpcbind        udp6       0      0 :::111                  :::*                                2703/rpcbind        udp6       0      0 :::123                  :::*                                484/ntpd  </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h3><p>ps 命令用于查看系统中的进程状态，格式为“ps [参数]”。</p><pre><code>ps　　命令常用参数-a     显示所有进程-u     用户以及其他详细信息-x    显示没有控制终端的进程</code></pre><h3 id="Kill命令"><a href="#Kill命令" class="headerlink" title="Kill命令"></a>Kill命令</h3><pre><code>kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。</code></pre><p>选项</p><pre><code>-a：当处理当前进程时，不限制命令名和进程号的对应关系；-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称；-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；-s &lt;信息名称或编号&gt;：指定要送出的信息；-u：指定用户。</code></pre><p>只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略，<strong>下面是常用的信号：</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>HUP     1    终端断线INT     2    中断（同 Ctrl + C）QUIT    3    退出（同 Ctrl + \）TERM   15    终止KILL    9    强制终止CONT   18    继续（与STOP相反， fg/bg命令）STOP   19    暂停（同 Ctrl + Z）</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>实例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>先用ps查找进程，然后用kill杀掉：ps -ef | grep vimroot      3268  2884  0 16:21 pts/1    00:00:00 vim install.logroot      3370  2822  0 16:21 pts/0    00:00:00 grep vimkill 3268</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h2><pre><code>通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这 些进程会比较麻烦，此时可以使用 killall 命令来批量结束某个服务程序带有的全部进程。例如nginx启动后有2个进程killall nginx </code></pre><h2 id="SELinux功能"><a href="#SELinux功能" class="headerlink" title="SELinux功能"></a>SELinux功能</h2><p>SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，这个功能管理员又爱又恨，大多数生产环境也是关闭的做法，安全手段使用其他方法。</p><pre><code>大多数ssh连接不上虚拟机，都是因为防火墙和selinux阻挡了</code></pre><p>永久关闭方式：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.修改配置文件，永久生效关闭selinuxcp /etc/selinux/config /etc/selinux/config.bak #修改前备份2.修改方式可以vim编辑,找到# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:#     enforcing - SELinux security policy is enforced.#     permissive - SELinux prints warnings instead of enforcing.#     disabled - No SELinux policy is loaded.SELINUX=disabled3.用sed替换sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config4.检查状态grep "SELINUX=disabled" /etc/selinux/config#出现结果即表示修改成功</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>临时关闭selinux(命令行修改，重启失效)：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>getenforce #获取selinux状态#修改selinux状态setenforce usage:  setenforce [ Enforcing | Permissive | 1 | 0 ]数字0 表示permissive，给出警告，不会阻止，等同disabled数字1表示enforcing，表示开启</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>Tip:</p><pre><code>修改selinux配置后，想要生效还得重启系统，技巧就是（修改配置文件+命令行修改，达到立即生效）生产环境的服务器是禁止随意重启的！！！！</code></pre><h2 id="iptables防火墙"><a href="#iptables防火墙" class="headerlink" title="iptables防火墙"></a>iptables防火墙</h2><p>在学习阶段，关闭防火墙可以更方便的学习，在企业环境中，一般只有配置外网ip的linux服务器才会开启防火墙，但是对于高并发流量的业务服务器仍然是不能开启的，会有很大性能损失，因此需要更nb的硬件防火墙。</p><p>关闭防火墙具体操作如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>centos7默认已经使用firewall作为防火墙了1.关闭防火墙systemctl status firewalld #查看防火墙状态systemctl stop firewalld    #关闭防火墙systemctl disable firewalld#关闭防火墙开机启动systemctl is-enabled firewalld.service#检查防火墙是否启动</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="Linux中文显示设置（防止中文乱码）"><a href="#Linux中文显示设置（防止中文乱码）" class="headerlink" title="Linux中文显示设置（防止中文乱码）"></a>Linux中文显示设置（防止中文乱码）</h2><p>此项优化为可选项，根据个人情况选择是否调整Linux系统的字符集，字符集就是一套文字符号以及编码。</p><p>Linux下常用字符集有：</p><ul><li>GBK　　实际企业应用较少</li><li>UTF-8　　广泛支持，MYSQL也使用UTF-8，企业广泛使用</li></ul><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#查看系统当前字符集echo $LANGlocale#检查xshell crt的字符集#命令修改字符集# vim /etc/profile.d/locale.shexport LC_CTYPE=zh_CN.UTF-8export LC_ALL=zh_CN.UTF-8# vim /etc/locale.confLANG=zh_CN.UTF-8# vim /etc/sysconfig/i18nLANG=zh_CN.UTF-8# vim /etc/environmentLANG=zh_CN.UTF-8LC_ALL=zh_CN.UTF-8</code></pre><p>英文版本</p><pre><code># vim /etc/profile.d/locale.shexport LC_CTYPE=en_US.UTF-8export LC_ALL=en_US.UTF-8# vim /etc/locale.confLANG=en_US.UTF-8# vim /etc/sysconfig/i18nLANG=en_US.UTF-8# vim /etc/environmentLANG=en_US.UTF-8LC_ALL=en_US.UTF-82.更改后查看系统语言变量locale</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>乱码核心解决办法</p><pre><code>1.系统字符集utf82.xshell字符集utf83.文件字符集一致zh_CN.UTF-8</code></pre><h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><p><strong>df命令</strong>用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>语法df(选项)(参数)-h或--human-readable：以可读性较高的方式来显示信息；-k或--kilobytes：指定区块大小为1024字节；-T或--print-type：显示文件系统的类型；--help：显示帮助；--version：显示版本信息。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>示例</p><pre><code>查看系统磁盘设备，默认是KB为单位：df使用-h选项以KB以上的单位来显示，可读性高：df -h</code></pre><h3 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/ContractedBlock.gif" alt="img">tree参数</p><h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><pre><code>[root@yugo /tmp 11:04:42]#hostnamectl set-hostname pyyuc[root@pyyuc ~ 11:05:12]#hostnamepyyuc</code></pre><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><pre><code>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。</code></pre><h3 id="查看Linux的dns，唯一配置文件"><a href="#查看Linux的dns，唯一配置文件" class="headerlink" title="查看Linux的dns，唯一配置文件"></a>查看Linux的dns，唯一配置文件</h3><pre><code>配置文件cat /etc/resolv.conf#dns服务器地址nameserver 119.29.29.29nameserver 223.5.5.5</code></pre><h3 id="本地强制dns解析文件-etc-hosts"><a href="#本地强制dns解析文件-etc-hosts" class="headerlink" title="本地强制dns解析文件/etc/hosts"></a>本地强制dns解析文件/etc/hosts</h3><pre><code>指定本地解析：/etc/hosts主机IP    主机名    主机别名127.0.0.1        www.pyyuc.cn        </code></pre><h3 id="nslookup命令"><a href="#nslookup命令" class="headerlink" title="nslookup命令"></a>nslookup命令</h3><p><strong>nslookup命令</strong>是常用域名查询工具，就是查DNS信息用的命令。</p><p>nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。</p><p>进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即<code>/etc/resolv.conf</code>的第一个dns地址）。或者输入<code>nslookup -nameserver/ip</code>。进入非交互模式，就直接输入<code>nslookup 域名</code>就可以了。</p><pre><code>#解析nslookup www.oldboyedu.com</code></pre><h3 id="计划任务crond服务"><a href="#计划任务crond服务" class="headerlink" title="计划任务crond服务"></a>计划任务crond服务</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20191018182719464-2020728975.gif" alt="img"></p><p>你每天是怎么起床的？有的人有女朋友，，或是男朋友，，而我是被穷醒的，，，</p><p><strong>什么是计划任务：</strong><br>后台运行，到了预定的时间就会自动执行的任务，前提是：事先手动将计划任务设定好。这就用到了crond服务</p><p><strong>crond服务相关的软件包</strong><br>[root@MiWiFi-R3-srv ~]# rpm -qa |grep cron<br>cronie-anacron-1.4.11-14.el7.x86_64<br>crontabs-1.11-6.20121102git.el7.noarch<br>cronie-1.4.11-14.el7.x86_64</p><p>这些包在最小化安装系统时就已经安装了，并且会开机自启动crond服务，并为我们提供好编写计划任务的crontab命令。</p><pre><code>crontab命令被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似</code></pre><p>语法</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>crontab （选项）（参数）-e：编辑该用户的计时器设置；-l：列出该用户的计时器设置；-r：删除该用户的计时器设置；-u&lt;用户名称&gt;：指定要设定计时器的用户名称。存放定时任务的文件/var/spool/cron</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>注意：</p><p>1 查看计划任务的执行：tail -f /var/log/cron</p><p>2 写计划任务时，命令必须加上绝对路径，否则会出现这种情况：从日志中看，确实触发了计划任务的执行，但是命令却没有执行成功，比如* * * * * reboot就会出现这种情况，需要将reboot写成/usr/sbin/reboot</p><p>\3.  计划任务执行的命令 是否存在，软件是否安装  </p><p>\4. 确保crontab服务运行  </p><pre><code>systemctl status cronps -ef|grep crond</code></pre><p><strong>5. 检测crontab是否开机启动</strong></p><pre><code>systemctl is-enabled crond</code></pre><p>crontab配置文件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# |  .------------- hour (0 - 23)# |  |  .---------- day of month (1 - 31)# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# |  |  |  |  |# *  *  *  *  * user-name  command to be executed　分 时  日 月  周</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code></code></pre><p>crontab任务配置基本格式：<br>*  *　 *　 *　 *　　command<br>分钟(0-59)　小时(0-23)　日期(1-31)　月份(1-12)　星期(0-6,0代表星期天)　 命令</p><pre><code></code></pre><p>第1列表示分钟1～59 每分钟用*或者 */1表示<br>第2列表示小时1～23（0表示0点）<br>第3列表示日期1～31<br>第4列表示月份1～12<br>第5列标识号星期0～6（0表示星期天）<br>第6列要运行的命令</p><ul><li><p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p></li><li><pre><code>30 08 * * *  每天8.30去上班  </code></pre></li><li><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p></li><li></li><li><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p></li><li></li><li><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p></li><li><p>*/3 * * * * /usr/sbin/ntpdate ntp1.aliyun.com  每隔三分钟执行下时间同步</p></li></ul><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181122101207846-1843670285.png" alt="img"></p><pre><code>每天8.30上班30 08 * * *  去上班每天12下班回家睡觉00 00 * * *   回家睡觉</code></pre><p>实例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>所有命令一定要用绝对路径来写！#每分钟执行一次命令* * * * * 命令#每小时的3,15分组执行命令3,15 * * * * 命令#在上午8-11点的第3和第15分钟执行3,15 8-11 * * * 命令#每晚21:30执行命令30 21 * * * 命令#没周六、日的1：30执行命令30 1 * * 6,0 命令#每周一到周五的凌晨1点，清空/tmp目录的所有文件0 1 * * 1-5 /usr/bin/rm -rf /tmp/*#每晚的21:30重启nginx30 21 * * * /opt/nginx/sbin/nginx -s reload#每月的1,10,22日的4:45重启nginx45 4 1,1,10,22 * * /opt/nginx/sbin/nginx -s reload#每个星期一的上午8点到11点的第3和15分钟执行命令3,15 8-11 * * 1 command</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><p><strong>软件包是什么</strong></p><pre><code>程序(软件)组成部分：    二进制程序  可执行命令    库     .so文件    配置文件    .conf    帮助文件    readme    /usr/share/man</code></pre><h3 id="windows程序"><a href="#windows程序" class="headerlink" title="windows程序"></a>windows程序</h3><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181102105433001-1622121729.png" alt="img"></p><h3 id="macos程序"><a href="#macos程序" class="headerlink" title="macos程序"></a>macos程序</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181102105505280-615660405.png" alt="img"> </p><p><strong>软件包顾名思义就是将应用程序、配置文件和数据打包的产物，所有的linux发行版都采用了某种形式的软件包系统，这使得linux软件管理和在windows下一样方便，suse、red hat、fedora等发行版都是用rpm包，Debian和Ubuntu则使用.deb格式的软件包。</strong></p><pre><code>mysql-5-3-4.rpmredis-3-4-3.rpmnginx2-3-2.rpm</code></pre><p>在早期系统运维中，安装软件是一件非常费事费力的事情。系统管理员不得不下载软件源代码编译软件，并且为了系统做各种调整。</p><p>尽管源代码编译形式的软件增强了用户定制的自由度，但是在小软件上耗费精力是缺乏效率的，于是软件包应运而生。</p><p>软件包管理可以将管理员从无休止的兼容问题中释放。yum工具就可以自动搜索依赖关系，并执行安装。</p><h3 id="RPM软件包管理器"><a href="#RPM软件包管理器" class="headerlink" title="RPM软件包管理器"></a>RPM软件包管理器</h3><p><strong>软件包管理器核心功能</strong></p><pre><code>1.制作软件包  .rpm2.安装、卸载、升级、查询、校验</code></pre><p>　　在 RPM(红帽软件包管理器)公布之前，要想在 Linux 系统中安装软件只能采取源码包 的方式安装。早期在 Linux 系统中安装程序是一件非常困难、耗费耐心的事情，而且大多数 的服务程序仅仅提供源代码，需要运维人员自行编译代码并解决许多的软件依赖关系，因此 要安装好一个服务程序，运维人员需要具备丰富知识、高超的技能，甚至良好的耐心。而且在 安装、升级、卸载服务程序时还要考虑到其他程序、库的依赖关系，所以在进行校验、安装、 卸载、查询、升级等管理软件操作时难度都非常大。</p><p>RPM 机制则为解决这些问题而设计的。RPM 有点像 Windows 系统中的控制面板，会建 立统一的数据库文件，详细记录软件信息并能够自动分析依赖关系。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181015220353445-718827471.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#现在要安装mysql#下载地址https://dev.mysql.com/downloads/mysql/安装软件的命令格式                rpm -ivh filename.rpm     # i表示安装   v显示详细过程  h以进度条显示升级软件的命令格式                rpm -Uvh filename.rpm卸载软件的命令格式                rpm -e filename.rpm查询软件描述信息的命令格式         rpm -qpi filename.rpm列出软件文件信息的命令格式         rpm -qpl filename.rpm查询文件属于哪个 RPM 的命令格式 　 rpm -qf filename</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="rpm安装软件"><a href="#rpm安装软件" class="headerlink" title="rpm安装软件"></a>rpm安装软件</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#下载软件包wget https://rpmfind.net/linux/centos/7.5.1804/os/x86_64/Packages/lrzsz-0.12.20-36.el7.x86_64.rpm#安装软件包[root@yugo /tmp 11:03:42]#rpm -ivh lrzsz-0.12.20-36.el7.x86_64.rpmPreparing...                          ################################# [100%]Updating / installing...   1:lrzsz-0.12.20-36.el7             ################################# [100%]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="rpm查询软件"><a href="#rpm查询软件" class="headerlink" title="rpm查询软件"></a>rpm查询软件</h3><pre><code>rpm -q lrzsz  #查询lrzsz是否安装rpm -qi lrzsz #查询lrzsz包的说明信息rpm -ql lrzsz #查询lrzsz包生成的文件列表rpm -qc nginx  #查询nginx安装生成后的配置文件路径rpm -qf /etc/nginx/fastcgi.conf  #查看这个文件由哪个rpm包安装</code></pre><h3 id="rpm升级软件"><a href="#rpm升级软件" class="headerlink" title="rpm升级软件"></a>rpm升级软件</h3><pre><code>rpm -Uvh /PATH/TO/NEW_PACKAGE_FILE: 如果装有老版本的，则升级；否则，则安装；rpm -Fvh /PATH/TO/NEW_PACKAGE_FILE：如果装有老版本的，则升级；否则，退出；</code></pre><h3 id="rpm卸载软件"><a href="#rpm卸载软件" class="headerlink" title="rpm卸载软件"></a>rpm卸载软件</h3><pre><code>rpm -e PACKAGE_NAME需要手动解决依赖不如 yum remove</code></pre><h3 id="rpm的依赖问题，因此不太好用"><a href="#rpm的依赖问题，因此不太好用" class="headerlink" title="rpm的依赖问题，因此不太好用"></a>rpm的依赖问题，因此不太好用</h3><p>其一，难以删除</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@pyyuc /tmp 11:42:01]#rpm -e nginxerror: Failed dependencies:    nginx is needed by (installed) nginx-mod-mail-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-http-perl-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-http-xslt-filter-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-http-image-filter-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-stream-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-http-geoip-1:1.12.2-2.el7.x86_64</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>其二，难以安装</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@pyyuc /tmp 11:45:07]#rpm -ivh zsh-5.6.2-9.6.2.aarch64.rpmwarning: zsh-5.6.2-9.6.2.aarch64.rpm: Header V3 RSA/SHA256 Signature, key ID 3dbdc284: NOKEYerror: Failed dependencies:    ld-linux-aarch64.so.1()(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    ld-linux-aarch64.so.1(GLIBC_2.17)(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    libdl.so.2(GLIBC_2.17)(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    libm.so.6(GLIBC_2.17)(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    libncursesw.so.6()(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    libtinfo.so.6()(64bit) is needed by zsh-5.6.2-9.6.2.aarch64</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>yum命令</p><p><strong>yum命令</strong>是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>尽管 RPM 能够帮助用户查询软件相关的依赖关系，但问题还是要运维人员自己来解决， 而有些大型软件可能与数十个程序都有依赖关系，在这种情况下安装软件会是非常痛苦的。 Yum 软件仓库便是为了进一步降低软件安装难度和复杂度而设计的技术。Yum 软件仓库可以 根据用户的要求分析出所需软件包及其相关的依赖关系，然后自动从服务器下载软件包并安 装到系统。</p><p>Yum 软件仓库中的 RPM 软件包可以是由红帽官方发布的，也可以是第三方发布的，当 然也可以是自己编写的。</p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822201405295-83195507.png" alt="img"></p><p>对比windows下的软件管理工具</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180724120649491-1286009706.png" alt="img"></p><p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>yum(选项)(参数)-h：显示帮助信息；-y：对所有的提问都回答“yes”；-c：指定配置文件；-q：安静模式；-v：详细模式；-d：设置调试等级（0-10）；-e：设置错误等级（0-10）；-R：设置yum处理一个命令的最大等待时间；-C：完全从缓存中运行，而不去下载或者更新任何头文件。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>实例</p><pre><code>部分常用的命令包括：自动搜索最快镜像插件　   yum install yum-fastestmirror</code></pre><h3 id="yum源配置"><a href="#yum源配置" class="headerlink" title="yum源配置"></a>yum源配置</h3><p>什么是yum源？</p><ul><li><ul><li>Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</li><li>说到yum源就必须说到linux系统中特有的依赖关系问题，yum就是为了解决依赖关系而存在的。yum源就相当是一个目录项，当我们使用yum机制安装软件时，若需要安装依赖软件，则yum机制就会根据在yum源中定义好的路径查找依赖软件，并将依赖软件安装好。</li><li>YUM是“Yellow dog Updater, Modified”的缩写，是一个软件包管理器，YUM从指定的地方（相关网站的rpm包地址或本地的rpm路径）自动下载RPM包并且安装，能够很好的解决依赖关系问题。</li><li>YUM的基本工作机制如下：<br>服务器端：在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内。<br>客户端：如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装。</li></ul></li></ul><p>yum源的目录</p><pre><code>#进入yum源目录cd /etc/yum.repos.d/#查看yum源文件ls -l</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180724121645358-251863304.png" alt="img"></p><p>配置阿里云yum源</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.好习惯，备份yum源mkdir repo_bakmv *.repo repo_bak/2.下载阿里云repo文件wget http://mirrors.aliyun.com/repo/Centos-7.repo3.清空yum缓存并且生成新的yum缓存yum clean allyum makecache4.安装软件扩展源yum install -y epel-release</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>yum repolist all        列出所有仓库yum list all            列出仓库所有软件包yum info 软件包名            查看软件包信息yum install 软件包名        安装软件包yum reinstall 软件包名    重新安装软件包yum update    软件包名        升级软件包yum remove    软件包名        移除软件包yum clean all            清楚所有仓库缓存yum check-update        检查可以更新的软件包yum grouplist            查看系统中已安装的软件包yum groupinstall 软件包组    安装软件包组</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="系统服务管理命令"><a href="#系统服务管理命令" class="headerlink" title="系统服务管理命令"></a>系统服务管理命令</h1><pre><code>如果大家之前学习或者使用过RHEL6系统，应该已经习惯了service、chkconfig等命令来管理系统服务，但是在RHEL7系统中改变了systemctl来管理系统服务。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822203754689-685906448.png" alt="img"></p><p>设置开机启动相关</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180822203941017-626760489.png" alt="img"></p><h1 id="必须掌握的-etc下的linux目录知识"><a href="#必须掌握的-etc下的linux目录知识" class="headerlink" title="必须掌握的/etc下的linux目录知识"></a>必须掌握的/etc下的linux目录知识</h1><pre><code>/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#网卡配置文件/etc/sysconfig/network-script/ifcfg-eth0#修改机器名以及网卡，网管等配置/etc/sysconfig/network#linux的dns客户端配置文件，实现域名和ip的互相解析/etc/resolv.conf#本地dns解析文件,设定ip和域名的对应解析,开发测试最常用的临时域名解析/etc/hosts/#系统全局环境变量永久生效的配置文件,如PATH等/etc/profile#用户的环境变量~/.bash_profile ~/.bashrc#存放可执行程序的目录，大多是系统管理命令/usr/sbin#存放用户自编译安装软件的目录  &gt; 等同于C:\Program files （windows）/usr/local#关于处理器的信息,还可以top指令查看/proc/cpuinfo#查看内存信息，还可以free -m/proc/meminfo </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="Linux下安装程序的方法"><a href="#Linux下安装程序的方法" class="headerlink" title="Linux下安装程序的方法"></a>Linux下安装程序的方法</h1><ul><li>rpm -ivh 包名.rpm　　需要手动解决依赖关系</li><li>yum install 包名          yum自动处理依赖关系</li><li>编译安装（源码安装）</li></ul><h3 id="安装Lrzsz"><a href="#安装Lrzsz" class="headerlink" title="安装Lrzsz"></a>安装Lrzsz</h3><pre><code>#安装此软件，即可拖拽上传下载linux代码到windowsyum install lrzsz</code></pre><h1 id="服务器无法上网错误"><a href="#服务器无法上网错误" class="headerlink" title="服务器无法上网错误"></a>服务器无法上网错误</h1><pre><code>1.yum报错    Error couldn't resolve host 'mirrorlist.centos.org'2.ping www.baidu.com 看是否能上网3.如果百度不通，ping ip通了ping 119.29.29.29  ，说明dns有问题</code></pre><p>努力成为一个开发者 个人站点：<a href="http://www.pythonav.cn/">www.pythonav.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门</title>
      <link href="2019/11/15/Linux/docker%E5%85%A5%E9%97%A8%20/"/>
      <url>2019/11/15/Linux/docker%E5%85%A5%E9%97%A8%20/</url>
      
        <content type="html"><![CDATA[<h1 id="docker入门"><a href="#docker入门" class="headerlink" title="docker入门"></a><a href="https://www.cnblogs.com/pyyu/p/9485268.html">docker入门</a></h1><p>在学一门新知识的时候，超哥喜欢提问，why？what？how？</p><p>wiki资料</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181105223052338-2067669785.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180816085738689-837749833.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181105223124396-20527761.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180816085946742-868321449.png" alt="img"></p><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 使用 Google 公司推出的 Go 语言 进行开发实现。docker是linux容器的一种封装，提供简单易用的容器使用接口。它是最流行的Linux容器解决方案。docker的接口相当简单，用户可以方便的创建、销毁容器。docker将应用程序与程序的依赖，打包在一个文件里面。运行这个文件就会生成一个虚拟容器。程序运行在虚拟容器里，如同在真实物理机上运行一样，有了docker，就不用担心环境问题了。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="ocke用场景"><a href="#ocke用场景" class="headerlink" title="ocke用场景"></a>ocke用场景</h3><pre><code>web应用的自动化打包和发布自动化测试和持续集成、发布在服务型环境中部署和调整数据库或其他应用</code></pre><h1 id="为什么要用docker？"><a href="#为什么要用docker？" class="headerlink" title="为什么要用docker？"></a>为什么要用docker？</h1><p>我们先看看很久很久以前，服务器是怎么部署应用的！</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180922153951410-114250843.png" alt="img"></p><p>由于物理机的诸多问题，后来出现了虚拟机</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180922154359164-1082041085.png" alt="img"></p><pre><code>但是虚拟化也是有局限性的，每一个虚拟机都是一个完整的操作系统，要分配系统资源，虚拟机多道一定程度时，操作系统本身资源也就消耗殆尽，或者说必须扩容</code></pre><h1 id="docker与虚拟机的区别"><a href="#docker与虚拟机的区别" class="headerlink" title="docker与虚拟机的区别"></a>docker与虚拟机的区别</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181209142808149-1260563881.png" alt="img"></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="docker-VS-传统虚拟机"><a href="#docker-VS-传统虚拟机" class="headerlink" title="docker  VS 传统虚拟机"></a>docker  VS 传统虚拟机</h1><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 MB</td><td>一般为 GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h1 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h1><p>让开发人员最头疼的麻烦事之一就是环境配置了，每台计算机的环境都不相同，应该如何确保自己的程序换一台机器能运行起来呢？</p><p>用户必须确保的是：</p><ol><li>操作系统的相同</li><li>各种平台库和组件的安装</li><li>例如python依赖包，环境变量等</li></ol><p>如何一些低版本的依赖模块和当前环境不兼容，那就头疼了。。。。。</p><p>如果环境配置这么痛苦的话，换一台机器，就得重新配置一下，那么在安装软件的时候，带着原始环境一模一样的复制过来。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181209143400671-1287929772.png" alt="img"></p><p><strong>然而，开发和运维之间聊天一般是这样的</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20181209143438897-152229468.png" alt="img"></strong></p><h1 id="解决方案一-虚拟机"><a href="#解决方案一-虚拟机" class="headerlink" title="解决方案一 虚拟机"></a>解决方案一 虚拟机</h1><p> 虚拟机也可以制作模板，基于模板创建虚拟机，保证环境问题一致</p><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p><p>（1）资源占用多</p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p>（2）冗余步骤多</p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p>（3）启动慢</p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180922155740630-1447130345.png" alt="img"></p><h1 id="解决方案二-Linux容器"><a href="#解决方案二-Linux容器" class="headerlink" title="解决方案二  Linux容器"></a>解决方案二  Linux容器</h1><p><strong>现在:自从用上docker容器后，可以实现开发、测试和生产环境的统一化和标准化。</strong></p><p><strong>镜像作为标准的交付件，可在开发、测试和生产环境上以容器来运行，最终实现三套环境上的应用以及运行所依赖内容的完全一致。</strong></p><p> 由于虚拟机的诸多问题，Linux发展出了另一种虚拟化技术：Linux容器（Linux Containers，缩写LXC）</p><p><strong>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。在正常进程的外面套了一个保护层，对于容器里面进程来说，它接触的资源都是虚拟的，从而实现和底层系统的隔离。</strong></p><p>（1）启动快</p><p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p><p>（2）资源占用少</p><p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p><p>（3）体积小</p><p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180922113245731-202924980.png" alt="img"></p><h1 id="docker容器的优势"><a href="#docker容器的优势" class="headerlink" title="docker容器的优势"></a>docker容器的优势</h1><pre><code>更高效的利用系统资源由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统 资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传 统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运 行更多数量的应用。更快速的启动时间传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接 运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启 动时间。大大的节约了开发、测试、部署的时间。一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环 境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内 核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码 在我机器上没问题啊” 这类问题。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>持续交付和部署对开发和运维(DevOps)人员来说，最希望的就是一次创建或配置，可以在任意 地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员 可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系 统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环 境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>更轻松的迁移由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在 很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运 行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一 个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</code></pre><h1 id="工作中的虚拟化和容器"><a href="#工作中的虚拟化和容器" class="headerlink" title="工作中的虚拟化和容器"></a>工作中的虚拟化和容器</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180922162938061-1646086257.png" alt="img"></p><h1 id="docker三大概念"><a href="#docker三大概念" class="headerlink" title="docker三大概念"></a>docker三大概念</h1><pre><code>容器三大基本概念镜像 image容器 container仓库 repositorydocker整个生命周期就是这三个概念。</code></pre><p>docker镜像</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>Docker镜像就是一个只读的模板。例如：一个镜像可以包含一个完整的CentOS操作系统环境，里面仅安装了Apache或用户需要的其他应用程序。镜像可以用来创建Docker容器。Docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>image的分层存储</p><pre><code>因为镜像包含完整的root文件系统，体积是非常庞大的，因此docker在设计时按照Union FS的技术，将其设计为分层存储的架构。镜像不是ISO那种完整的打包文件，镜像只是一个虚拟的概念，他不是一个完整的文件，而是由一组文件组成，或者多组文件系统联合组成。</code></pre><p>docker容器(container)</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>image和container的关系，就像面向对象程序设计中的 类和实例一样，镜像是静态的定义（class），容器是镜像运行时的实体（object）。容器可以被创建、启动、停止、删除、暂停Docker利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的，保证安全的平台。可以把容器看做是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。注意：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>docker仓库(repository)</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>仓库是集中存放镜像文件的场所。有时候把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)。仓库分为公开仓库(Public)和私有仓库(Private)两种形式。最大的公开仓库是Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括Docker Pool等，可以提供大陆用户更稳定快读的访问。当用户创建了自己的镜像之后就可以使用push命令将它上传到公有或者私有仓库，这样下载在另外一台机器上使用这个镜像时候，只需需要从仓库上pull下来就可以了。注意：Docker仓库的概念跟Git类似，注册服务器可以理解为GitHub这样的托管服务。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="docker-Registry"><a href="#docker-Registry" class="headerlink" title="docker Registry"></a>docker Registry</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服 务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务 供用户管理私有镜像。最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并 拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相 关的镜像存储在这里;Google 的 Google Container Registry，Kubernetes 的镜像 使用的就是这个服务。由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针 对 Docker Hub 的镜像服务(Registry Mirror)，这些镜像服务被称为加速器。常见 的有 阿里云加速器、DaoCloud 加速器、灵雀云加速器等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从官方网站下载速度会提高很多。在后 面的章节中会有进一步如何配置加速器的讲解。国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓 库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="CentOS安装docker"><a href="#CentOS安装docker" class="headerlink" title="CentOS安装docker"></a>CentOS安装docker</h1><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script">请遵循官方安装方式！！！</a></p><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script">https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script</a></p><p>官方教程如下，最正确安装docker姿势</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.卸载旧版本sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine2.设置存储库sudo yum install -y yum-utils \  device-mapper-persistent-data \  lvm2sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo3.安装docker社区版sudo yum install docker-ce4.启动关闭dockersystemctl start docker</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>docker版本</p><pre><code>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。本文的介绍都针对社区版。</code></pre><p> 系统环境准备</p><pre><code>docker最低支持centos7且在64位平台上，内核版本在3.10以上</code></pre><p>[root@oldboy_python ~ 10:48:11]#uname -r<br>3.10.0-693.el7.x86_64</p><h1 id="Docker镜像加速器"><a href="#Docker镜像加速器" class="headerlink" title="Docker镜像加速器"></a>Docker镜像加速器</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>https://www.daocloud.io/mirror#accelerator-dochttps://www.cnblogs.com/pyyu/p/6925606.html#一条命令加速curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://95822026.m.daocloud.io</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="docker基础命令注释"><a href="#docker基础命令注释" class="headerlink" title="docker基础命令注释"></a>docker基础命令注释</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@docker ~]# docker --helpUsage:docker [OPTIONS] COMMAND [arg...]       docker daemon [ --help | ... ]       docker [ --help | -v | --version ]Aself-sufficient runtime for containers.Options:  --config=~/.docker              Location of client config files  #客户端配置文件的位置  -D, --debug=false               Enable debug mode  #启用Debug调试模式  -H, --host=[]                   Daemon socket(s) to connect to  #守护进程的套接字（Socket）连接  -h, --help=false                Print usage  #打印使用  -l, --log-level=info            Set the logging level  #设置日志级别  --tls=false                     Use TLS; implied by--tlsverify  #  --tlscacert=~/.docker/ca.pem    Trust certs signed only by this CA  #信任证书签名CA  --tlscert=~/.docker/cert.pem    Path to TLS certificate file  #TLS证书文件路径  --tlskey=~/.docker/key.pem      Path to TLS key file  #TLS密钥文件路径  --tlsverify=false               Use TLS and verify the remote  #使用TLS验证远程  -v, --version=false             Print version information and quit  #打印版本信息并退出Commands:    attach    Attach to a running container  #当前shell下attach连接指定运行镜像    build     Build an image from a Dockerfile  #通过Dockerfile定制镜像    commit    Create a new image from a container's changes  #提交当前容器为新的镜像    cp    Copy files/folders from a container to a HOSTDIR or to STDOUT  #从容器中拷贝指定文件或者目录到宿主机中    create    Create a new container  #创建一个新的容器，同run 但不启动容器    diff    Inspect changes on a container's filesystem  #查看docker容器变化    events    Get real time events from the server#从docker服务获取容器实时事件    exec    Run a command in a running container#在已存在的容器上运行命令    export    Export a container's filesystem as a tar archive  #导出容器的内容流作为一个tar归档文件(对应import)    history    Show the history of an image  #展示一个镜像形成历史    images    List images  #列出系统当前镜像    import    Import the contents from a tarball to create a filesystem image  #从tar包中的内容创建一个新的文件系统映像(对应export)    info    Display system-wide information  #显示系统相关信息    inspect    Return low-level information on a container or image  #查看容器详细信息    kill    Kill a running container  #kill指定docker容器    load    Load an image from a tar archive or STDIN  #从一个tar包中加载一个镜像(对应save)    login    Register or log in to a Docker registry#注册或者登陆一个docker源服务器    logout    Log out from a Docker registry  #从当前Docker registry退出    logs    Fetch the logs of a container  #输出当前容器日志信息    pause    Pause all processes within a container#暂停容器    port    List port mappings or a specific mapping for the CONTAINER  #查看映射端口对应的容器内部源端口    ps    List containers  #列出容器列表    pull    Pull an image or a repository from a registry  #从docker镜像源服务器拉取指定镜像或者库镜像    push    Push an image or a repository to a registry  #推送指定镜像或者库镜像至docker源服务器    rename    Rename a container  #重命名容器    restart    Restart a running container  #重启运行的容器    rm    Remove one or more containers  #移除一个或者多个容器    rmi    Remove one or more images  #移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除)    run    Run a command in a new container  #创建一个新的容器并运行一个命令    save    Save an image(s) to a tar archive#保存一个镜像为一个tar包(对应load)    search    Search the Docker Hub for images  #在dockerhub中搜索镜像    start    Start one or more stopped containers#启动容器    stats    Display a live stream of container(s) resource usage statistics  #统计容器使用资源    stop    Stop a running container  #停止容器    tag         Tag an image into a repository  #给源中镜像打标签    top       Display the running processes of a container #查看容器中运行的进程信息    unpause    Unpause all processes within a container  #取消暂停容器    version    Show the Docker version information#查看容器版本号    wait         Block until a container stops, then print its exit code  #截取容器停止时的退出状态值Run 'docker COMMAND --help' for more information on a command.  #运行docker命令在帮助可以获取更多信息</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="使用docker镜像"><a href="#使用docker镜像" class="headerlink" title="使用docker镜像"></a>使用docker镜像</h1><pre><code>从仓库获取镜像管理本地主机的镜像</code></pre><p>获取镜像</p><pre><code>从docker registry获取镜像的命令是docker pull。命令格式是：docker pull [选项][docker registry地址] 仓库名:标签docker register地址：地址的格式一般是 域名:端口，默认地址是docker hub仓库名：仓库名是两段格式，用户名/软件名，如果不写用户，默认docker hub用户名是library，也就是官方镜像</code></pre><p>镜像文件</p><pre><code>docker是把应用程序和其依赖打包在image文件里面，只有通过这个镜像文件才能生成docker容器。一个image文件可以生成多个容器实例。image文件是通用，可以共享的，为了节省时间，我们尽量</code></pre><p>列出服务器所有镜像文件</p><pre><code>#列出所有的image文件docker image ls#删除image文件docker image rm [imagename]</code></pre><h1 id="搜索docker镜像"><a href="#搜索docker镜像" class="headerlink" title="搜索docker镜像"></a>搜索docker镜像</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@docker ~]# docker search centos  #搜索所有centos的docker镜像INDEX                NAME(名称)                  DESCRIPTION(描述)                    STARS(下载次数)OFFICIAL(官方)        AUTOMATED(自动化)docker.io           docker.io/centos         The official build of CentOS.        1781               [OK]docker.io   docker.io/jdeathe/centos-ssh     CentOS-6 6.7 x86_64 /             14                                               [OK]……</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="获取docker镜像"><a href="#获取docker镜像" class="headerlink" title="获取docker镜像"></a>获取docker镜像</h1><pre><code>可以使用docker pull命令来从仓库获取所需要的镜像。下面的例子将从Docker Hub仓库下载一个Centos操作系统的镜像。[root@docker ~]# docker pull centos  #获取centos镜像[root@docker ~]# docker run -it centos /bin/bash  #完成后可以使用该镜像创建一个容器</code></pre><h1 id="查看docker镜像"><a href="#查看docker镜像" class="headerlink" title="查看docker镜像"></a>查看docker镜像</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>镜像的ID唯一标识了镜像，如果ID相同,说明是同一镜像。TAG信息来区分不同发行版本，如果不指定具体标记,默认使用latest标记信息。[root@docker ~]# docker images  #查看docker镜像REPOSITORY(来自那个仓库)       TAG(标签)            IMAGE ID(唯一ID)         CREATED(创建时间)         VIRTUAL SIZE(大小)docker.io/centos                   latest              60e65a8e4030           5days ago              196.6 MBdocker.io/nginx             latest              813e3731b203             13days ago             133.8 MB</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="删除-Docker-镜像"><a href="#删除-Docker-镜像" class="headerlink" title="删除**Docker**镜像"></a><strong>删除**</strong>Docker**<strong>镜像</strong></h1><pre><code>如果要移除本地的镜像,可以使用docker rmi命令(在删除镜像之前先用docker rm删除依赖于这个镜像的所有容器)。注意docker rm 命令是移除容器。[root@docker ~]# docker rmi imageID  #删除docker镜像</code></pre><h1 id="导出docker镜像"><a href="#导出docker镜像" class="headerlink" title="导出docker镜像"></a>导出docker镜像</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>如果要导出镜像到本地文件,可以使用docker save命令。[root@docker ~]# docker save centos &gt; /opt/centos.tar.gz  #导出docker镜像至本地[root@docker ~]# ll /opt/-rw-r--r--.1 root root 204205056 12月 30 09:53 centos.tar.gz</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="导入docker镜像"><a href="#导入docker镜像" class="headerlink" title="导入docker镜像"></a>导入docker镜像</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>可以使用docker load从本地文件中导入到本地docker镜像库[root@docker ~]# docker load &lt; /opt/centos.tar.gz   #导入本地镜像到docker镜像库[root@docker~]# docker images  #查看镜像导入情况REPOSITORY           TAG                 IMAGE ID            CREATED             VIRTUAL SIZEdocker.io/centos     latest              60e65a8e4030        5 days ago          196.6 MB</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="启动docker容器的方式"><a href="#启动docker容器的方式" class="headerlink" title="启动docker容器的方式"></a>启动docker容器的方式</h1><pre><code>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态(stopped)的容器重新启动。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</code></pre><h1 id="新建容器并且启动"><a href="#新建容器并且启动" class="headerlink" title="新建容器并且启动"></a>新建容器并且启动</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>所需要的命令主要为docker run例如,下面的命令输出一个hehe,之后终止容器。[root@docker ~]# docker run centos /bin/echo "hehe"  #这跟在本地直接执行 /bin/echo'hehe' hehe[root@docker ~]# docker run --name mydocker -it centos /bin/bash#启动一个bash终端,允许用户进行交互。[root@1c6c3f38ea07 /]# pwd/[root@1c6c3f38ea07 /]# lsanaconda-post.log  bindev  etc  homelib  lib64  lost+foundmedia  mnt  optproc  root  runsbin  srv  systmp  usr  var--name:给容器定义一个名称-i:则让容器的标准输入保持打开。-t:让Docker分配一个伪终端,并绑定到容器的标准输入上/bin/bash:执行一个命令</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>当利用docker run来创建容器时，Docker在后台运行的标准操作包括</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>检查本地是否存在指定的镜像，不存在就从公有仓库下载利用镜像创建并启动一个容器分配一个文件系统，并在只读的镜像层外面挂在一层可读写层从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去从地址池配置一个ip地址给容器执行用户指定的应用程序执行完毕后容器被终止</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="docker与”hello-docker”"><a href="#docker与”hello-docker”" class="headerlink" title="docker与”hello docker”"></a>docker与”hello docker”</h1><pre><code>hello world是程序员启蒙语言，我们通过最简单的image文件“hello-world”，来感受一下docker。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#获取镜像 hello-worlddocker pull hello-world#检查镜像docker images#运行image文件,可以用容器iddocker run hello-world#检查docker容器进程docker ps#检查所有运行过的容器docker ps -a</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>运行成功后，可以看到结果</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180816115230679-531746266.png" alt="img"></p><p>表示你已经成功运行了容器，hello world运行的容器会在完成后，自动终止</p><h1 id="运行一个ubuntu容器"><a href="#运行一个ubuntu容器" class="headerlink" title="运行一个ubuntu容器"></a>运行一个ubuntu容器</h1><p>咱们要在cenots7操作系统下，以docker下载一个ubuntu image文件，然后以image启动容器</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 11:52:22]#docker pull ubuntu:14.04#如图，乌班图的镜像下载，是下载每一层的文件Trying to pull repository docker.io/library/ubuntu ... 14.04: Pulling from docker.io/library/ubuntu8284e13a281d: Pull complete 26e1916a9297: Pull complete 4102fc66d4ab: Pull complete 1cf2b01777b2: Pull complete 7f7a2d5e04ed: Pull complete Digest: sha256:4851d1986c90c60f3b19009824c417c4a0426e9cf38ecfeb28598457cefe3f56Status: Downloaded newer image for docker.io/ubuntu:14.04</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>下载过程可以看出镜像是由多层存储构成的。下载也是一层一层，并非单一的文件。下载过程中给出每一层的前12位ID。下载结束后会给出sha246的文件一致性校验值。</code></pre><h2 id="运行这个乌班图容器！"><a href="#运行这个乌班图容器！" class="headerlink" title="运行这个乌班图容器！"></a>运行这个乌班图容器！</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 12:18:53]#docker run -it --rm ubuntu:14.04 bash#此时会进入交互式的shell界面，即可以使用乌班图操作系统root@3efbb2749d7c:/# cat /etc/os-release  NAME="Ubuntu"VERSION="14.04.5 LTS, Trusty Tahr"ID=ubuntuID_LIKE=debianPRETTY_NAME="Ubuntu 14.04.5 LTS"VERSION_ID="14.04"HOME_URL="http://www.ubuntu.com/"SUPPORT_URL="http://help.ubuntu.com/"BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"#使用exit退出容器exit</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>docker run就是运行容器的命令。参数 -it ： -i 是交互式操作，-t是终端 -rm  :   容器退出后将其删除。也可以不指定参数，手动docker rm，使用-rm可以避免浪费空间。 ubuntu:14.04   这指的是镜像文件 bash   :  指定用交互式的shell，因此需要bash命令</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="Docker与CentOS"><a href="#Docker与CentOS" class="headerlink" title="Docker与CentOS"></a>Docker与CentOS</h1><p>docker允许在容器内运行应用程序，使用docker run命令来在容器内运行应用程序。</p><pre><code>#加速docker镜像下载curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://95822026.m.daocloud.io</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 15:14:31]#docker pull docker.io/centosUsing default tag: latestTrying to pull repository docker.io/library/centos ...latest: Pulling from docker.io/library/centos256b176beaff: Pull completeDigest: sha256:fc2476ccae2a5186313f2d1dadb4a969d6d2d4c6b23fa98b6c7b0a1faad67685Status: Downloaded newer image for docker.io/centos:latest</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>运行一个交互式的容器</p><pre><code>[root@oldboy_python ~ 15:15:07]#docker run -it centos /bin/bash#此时进入docker容器[root@c72e9c40cfe2 /]# cat /etc/redhat-release</code></pre><p>参数解析：</p><ul><li>**-t:**在新容器内指定一个伪终端或终端。</li><li>**-i:**允许你对容器内的标准输入 (STDIN) 进行交互。</li></ul><pre><code>此时就进入了centos系统可以查看系统相关信息,内核版本信息cat /proc/versionls /</code></pre><p>此时想要退出容器，使用exit命令</p><h1 id="后台模式启动docker"><a href="#后台模式启动docker" class="headerlink" title="后台模式启动docker"></a>后台模式启动docker</h1><p>-d参数：后台运行容器，返回容器ID</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>[root@oldboy_python ~ 15:58:14]#docker run -d centos /bin/sh -c "while true;do echo hello centos; sleep 1;done"c0283f1077d16a2bf2597e269d51a02815334f7390f18a62ed7a4ba07f351b65#检查容器进程[root@oldboy_python ~ 15:58:22]#docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESc0283f1077d1        centos              "/bin/sh -c 'while..."   6 seconds ago       Up 5 seconds                            fervent_turing[root@oldboy_python ~ 15:58:28]#</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>查看容器内的标准输出</p><pre><code>docker logs c02</code></pre><p>停止容器</p><pre><code>docker stop c02#此时容器进程不存在docker ps </code></pre><p>启动容器</p><pre><code>docker start c02#检查容器进程docker ps删除容器docker rm c02</code></pre><p>Docker镜像常用命令</p><pre><code>docker images #列出所有本级镜像docker pull centos #获取新的centos镜像docker search nginx #搜索nginx镜像</code></pre><p>构建镜像</p><pre><code>1.通过commit修改镜像2.编写dockerfile</code></pre><h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>使用-d参数时，容器启动后会进入后台。某些时候需要进入容器进行操作,有很多种方法，包括使用docker attach命令或nsenter工具等。</p><pre><code>docker  exec -it 容器iddocker attach 容器id</code></pre><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="提交创建自定义的镜像-docker-container-commit"><a href="#提交创建自定义的镜像-docker-container-commit" class="headerlink" title="提交创建自定义的镜像(docker container commit)"></a>提交创建自定义的镜像(docker container commit)</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.我们进入交互式的centos容器中，发现没有vim命令docker run -it centos2.在当前容器中，安装一个vimyum install -y vim3.安装好vim之后，exit退出容器exit4.查看刚才安装好vim的容器记录docker container ls -a5.提交这个容器，创建新的imagedocker commit 059fdea031ba chaoyu/centos-vim6.查看镜像文件[root@master /home]docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEchaoyu/centos-vim   latest              fd2685ae25fe        5 minutes ago       348MB</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h1><p>容器中可以运行网络应用，但是要让外部也可以访问这些应用，可以通过-p或-P参数指定端口映射。</p><pre><code>-P 参数会随机映射端口到容器开放的网络端口[root@oldboy_python ~ 16:31:37]#docker run -d -P training/webapp python app.py</code></pre><p>检查映射的端口</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>#宿主机ip:32768 映射容器的5000端口[root@oldboy_python ~ 16:34:02]#docker ps -lCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMEScfd632821d7a        training/webapp     "python app.py"     21 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;5000/tcp   brave_fermi</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>查看容器日志信息</p><pre><code>#不间断显示logdocker logs -f cfd</code></pre><p>也可以通过-p参数指定映射端口</p><pre><code>#指定服务器的9000端口，映射到容器内的5000端口[root@oldboy_python ~ 16:46:13]#docker run -d -p 9000:5000 training/webapp python app.pyc0b5a6278d0f4f2e9b9eba8680451111d8b911b61de0c37ea64cb337aefb854e</code></pre><p>访问服务器的9000端口</p><p>(如果访问失败的话，检查自己的防火墙，以及云服务器的安全组)</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20180816164829039-1757764520.png" alt="img"></p><h3 id="查看指定容器的端口映射"><a href="#查看指定容器的端口映射" class="headerlink" title="查看指定容器的端口映射"></a>查看指定容器的端口映射</h3><pre><code>[root@oldboy_python ~ 16:49:01]#docker port c0b5000/tcp -&gt; 0.0.0.0:9000</code></pre><p>查看容器内的进程</p><pre><code>[root@oldboy_python ~ 16:49:05]#docker top c0bUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDroot                3926                3912                0                   16:46               ?                   00:00:00            python app.py</code></pre><h1 id="利用dockerfile定制镜像"><a href="#利用dockerfile定制镜像" class="headerlink" title="利用dockerfile定制镜像"></a>利用dockerfile定制镜像</h1><p>镜像是容器的基础，每次执行docker run的时候都会指定哪个镜像作为容器运行的基础。我们之前的例子都是使用来自docker hub的镜像，直接使用这些镜像只能满足一定的需求，当镜像无法满足我们的需求时，就得自定制这些镜像。</p><pre><code>镜像的定制就是定制每一层所添加的配置、文件。如果可以吧每一层修改、安装、构建、操作的命令都写入到一个脚本，用脚本来构建、定制镜像，这个脚本就是dockerfile。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令 构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>FROM scratch #制作base image 基础镜像，尽量使用官方的image作为base imageFROM centos #使用base imageFROM ubuntu:14.04 #带有tag的base imageLABEL version=“1.0” #容器元信息，帮助信息，Metadata，类似于代码注释LABEL maintainer=“yc_uuu@163.com"#对于复杂的RUN命令，避免无用的分层，多条命令用反斜线换行，合成一条命令！RUN yum update &amp;&amp; yum install -y vim \    Python-dev #反斜线换行RUN /bin/bash -c "source $HOME/.bashrc;echo $HOME”WORKDIR /root #相当于linux的cd命令，改变目录，尽量使用绝对路径！！！不要用RUN cdWORKDIR /test #如果没有就自动创建WORKDIR demo #再进入demo文件夹RUN pwd     #打印结果应该是/test/demoADD and COPY ADD hello /  #把本地文件添加到镜像中，吧本地的hello可执行文件拷贝到镜像的/目录ADD test.tar.gz /  #添加到根目录并解压WORKDIR /rootADD hello test/  #进入/root/ 添加hello可执行命令到test目录下，也就是/root/test/hello 一个绝对路径COPY hello test/  #等同于上述ADD效果ADD与COPY   - 优先使用COPY命令    -ADD除了COPY功能还有解压功能添加远程文件/目录使用curl或wgetENV #环境变量，尽可能使用ENV增加可维护性ENV MYSQL_VERSION 5.6 #设置一个mysql常量RUN yum install -y mysql-server=“${MYSQL_VERSION}” ------这里需要稍微理解一下了-------中级知识---先不讲VOLUME and EXPOSE 存储和网络RUN and CMD and ENTRYPOINTRUN：执行命令并创建新的Image LayerCMD：设置容器启动后默认执行的命令和参数ENTRYPOINT：设置容器启动时运行的命令Shell格式和Exec格式RUN yum install -y vimCMD echo ”hello docker”ENTRYPOINT echo “hello docker”Exec格式RUN [“apt-get”,”install”,”-y”,”vim”]CMD [“/bin/echo”,”hello docker”]ENTRYPOINT [“/bin/echo”,”hello docker”]通过shell格式去运行命令，会读取$name指令，而exec格式是仅仅的执行一个命令，而不是shell指令cat Dockerfile    FROM centos    ENV name Docker    ENTRYPOINT [“/bin/echo”,”hello $name”]#这个仅仅是执行echo命令，读取不了shell变量    ENTRYPOINT  [“/bin/bash”,”-c”,”echo hello $name"]CMD容器启动时默认执行的命令如果docker run指定了其他命令(docker run -it [image] /bin/bash )，CMD命令被忽略如果定义多个CMD，只有最后一个执行ENTRYPOINT让容器以应用程序或服务形式运行不会被忽略，一定会执行最佳实践：写一个shell脚本作为entrypointCOPY docker-entrypoint.sh /usr/local/binENTRYPOINT [“docker-entrypoint.sh]EXPOSE 27017CMD [“mongod”][root@master home]# more DockerfileFROm centosENV name Docker#CMD ["/bin/bash","-c","echo hello $name"]ENTRYPOINT ["/bin/bash","-c","echo hello $name”]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="发布docker-image到仓库"><a href="#发布docker-image到仓库" class="headerlink" title="发布docker image到仓库"></a>发布docker image到仓库</h1><p>第一种，docker hub公有镜像发布</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.docker提供了一个类似于github的仓库dockerhub,网址https://hub.docker.com/需要注册使用2.注册docker id后，在linux中登录dockerhubdocker login注意要保证image的tag是账户名，如果镜像名字不对，需要改一下tagdocker tag chaoyu/centos-vim yuchao163/centos-vim语法是：  docker tag   仓库名   yuchao163/仓库名3.推送docker image到dockerhubdocker push yuchao163/centps-cmd-exec:latest4.在dockerhub中检查镜像https://hub.docker.com/5.删除本地镜像，测试下载pull 镜像文件docker pull yuchao163/centos-entrypoint-exec</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>但是这种镜像仓库是公开的，其他人也是可以下载，并不安全，因此还可以使用docker registry官方提供的私有仓库</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>1.官方提供的私有仓库docker registry用法https://yeasy.gitbooks.io/docker_practice/repository/registry.html2.一条命令下载registry镜像并且启动私有仓库容器私有仓库会被创建在容器的/var/lib/registry下，因此通过-v参数将镜像文件存储到本地的/opt/data/registry下端口映射容器中的5000端口到宿主机的5000端口docker run -d \    -p 5000:5000 \    -v /opt/data/registry:/var/lib/registry \    registry3.检查启动的registry容器docker ps4.测试连接容器telnet 192.168.119.10 50005.修改镜像tag,以docker registry的地址端口开头docker tag hello-world:latest 192.168.119.10:5000/hello-world:latest6.查看docker镜像，找到registry的镜像docker images7.Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，这里必须写正确json数据[root@master /]# cat /etc/docker/daemon.json{"registry-mirrors": ["http://95822026.m.daocloud.io"],"insecure-registries":["192.168.119.10:5000"]}写入到docker服务中，写入到[Service]配置块中，加载此配置文件[root@master home]# grep 'EnvironmentFile=/etc/docker/daemon.json' /lib/systemd/system/docker.serviceEnvironmentFile=-/etc/docker/daemon.json8.修改了docker配置文件，重新加载dockersystemctl daemon-reload9.重启dockersystemctl restart docker10.重启了docker，刚才的registry容器进程挂掉了，因此重新启动它</code></pre><p>docker run –privileged=true -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry</p><pre><code>--privileged=true  docker容器的安全机制：设置特权级运行的容器11.推送本地镜像docker push 192.168.119.10:5000/hello-world12.由于docker registry没有web节目，但是提供了API数据官网教程：https://docs.docker.com/registry/spec/api/#listing-repositoriescurl http://192.168.119.10:5000/v2/_catalog或者浏览器访问http://192.168.119.10:5000/v2/_catalog13.删除本地镜像，从私有仓库中下载docker pull 192.168.119.10:5000/hello-world</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="打包flask程序与dockerfile"><a href="#打包flask程序与dockerfile" class="headerlink" title="打包flask程序与dockerfile"></a>打包flask程序与dockerfile</h1><p>超哥构建好的镜像，只要丢给武沛奇，说“小沛奇，拿去用吧，这个镜像你直接docker run就能用了，不需要你管环境问题了，有没有很崇拜我”，沛奇说，“超哥真牛逼”</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><pre><code>确保app.py和dockerfile在同一个目录！1.准备好app.py的flask程序[root@master home]# cat app.py#coding:utf8from flask import Flaskapp=Flask(__name__)@app.route('/')def hello():    return "hello docker"if __name__=="__main__":    app.run(host='0.0.0.0',port=8080)[root@master home]# lsapp.py  Dockerfile2.编写dockerfile</code></pre><p>FROM centos<br>COPY CentOS-Base.repo /etc/yum.repos.d/<br>COPY epel.repo /etc/yum.repos.d/<br>RUN yum clean all<br>RUN yum install python-setuptools -y<br>RUN easy_install flask<br>COPY s16-flask.py /opt/<br>WORKDIR /opt<br>EXPOSE 8080<br>CMD [“python”,”s16-flask.py”]</p><pre><code>3.构建镜像imagedocker build -t yuchao163/flask-hello-docker .4.查看创建好的imagesdocker image ls5.启动此flask-hello-docker容器，映射一个端口供外部访问docker run -d -p 8080:8080 yuchao163/flask-hello-docker6.检查运行的容器docker container ls</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="一致的开发环境"><a href="#一致的开发环境" class="headerlink" title="一致的开发环境"></a>一致的开发环境</h1><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/linux/1132884-20190125231548742-442897399.png" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 django ORM 练习题</title>
      <link href="2019/11/15/CRM/04%20Django%20ORM%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>2019/11/15/CRM/04%20Django%20ORM%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#_label0">目录</a></li></ul><p><a href="#_labelTop">回到顶部</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="https://www.cnblogs.com/maple-shaw/articles/9414626.html#_labelTop">回到顶部</a></p><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code># 书class Book(models.Model):    title = models.CharField(max_length=32)    publish_date = models.DateField(auto_now_add=True)    price = models.DecimalField(max_digits=5, decimal_places=2)    memo = models.TextField(null=True)    # 创建外键，关联publish    publisher = models.ForeignKey(to="Publisher")    # 创建多对多关联author    author = models.ManyToManyField(to="Author")    def __str__(self):        return "&lt;Book object: {} {}&gt;".format(self.id, self.title)# 出版社class Publisher(models.Model):    name = models.CharField(max_length=32)    city = models.CharField(max_length=32)    def __str__(self):        return "&lt;Publisher object: {} {}&gt;".format(self.id, self.name)# 作者class Author(models.Model):    name = models.CharField(max_length=32)    age = models.IntegerField()    phone = models.CharField(max_length=11)    def __str__(self):        return "&lt;Author object: {} {}&gt;".format(self.id, self.name)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9414626.html#_labelTop">回到顶部</a></p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>"""查找所有书名里包含金老板的书查找出版日期是2018年的书查找出版日期是2017年的书名查找价格大于10元的书查找价格大于10元的书名和价格查找memo字段是空的书查找在北京的出版社查找名字以沙河开头的出版社查找“沙河出版社”出版的所有书籍查找每个出版社出版价格最高的书籍价格查找每个出版社的名字以及出的书籍数量查找作者名字里面带“小”字的作者查找年龄大于30岁的作者查找手机号是155开头的作者查找手机号是155开头的作者的姓名和年龄查找每个作者写的价格最高的书籍价格查找每个作者的姓名以及出的书籍数量查找书名是“跟金老板学开车”的书的出版社查找书名是“跟金老板学开车”的书的出版社所在的城市查找书名是“跟金老板学开车”的书的出版社的名称查找书名是“跟金老板学开车”的书的出版社出版的其他书籍的名字和价格查找书名是“跟金老板学开车”的书的所有作者查找书名是“跟金老板学开车”的书的作者的年龄查找书名是“跟金老板学开车”的书的作者的手机号码查找书名是“跟金老板学开车”的书的作者们的姓名以及出版的所有书籍名称和价钱"""</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 django ORM</title>
      <link href="2019/11/15/CRM/04%20Django%E4%B9%8BORM/"/>
      <url>2019/11/15/CRM/04%20Django%E4%B9%8BORM/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#_label0">目录</a></li><li>ORM介绍<ul><li><a href="#_label1_0">ORM概念</a></li><li><a href="#_label1_1">ORM由来</a></li><li><a href="#_label1_2">ORM的优势</a></li><li><a href="#_label1_3">ORM的劣势</a></li><li><a href="#_label1_4">ORM总结</a></li></ul></li><li>Django中的ORM<ul><li><a href="#_label2_0">Django项目使用MySQL数据库</a></li><li><a href="#_label2_1">Model</a></li><li><a href="#_label2_2">快速入门 </a></li><li><a href="#_label2_3">字段 </a></li><li><a href="#_label2_4">自定义字段</a></li><li><a href="#_label2_5">字段参数</a></li><li><a href="#_label2_6">Model Meta参数</a></li><li><a href="#_label2_7">多表关系和参数</a></li><li><a href="#_label2_8">ORM操作</a></li></ul></li></ul><p><a href="#_labelTop">回到顶部</a></p><h2 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h2><h1 id="Object-Relational-Mapping-ORM"><a href="#Object-Relational-Mapping-ORM" class="headerlink" title="Object Relational Mapping(ORM)"></a>Object Relational Mapping(ORM)</h1><p><a href="https://www.cnblogs.com/maple-shaw/articles/9323320.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="ORM介绍"><a href="#ORM介绍" class="headerlink" title="ORM介绍"></a>ORM介绍</h2><p>对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。</p><p>简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。</p><p>ORM在业务逻辑层和数据库层之间充当了桥梁的作用。</p><p>让我们从O/R开始。字母O起源于”对象”(Object)，而R则来自于”关系”(Relational)。</p><p>几乎所有的软件开发过程中都会涉及到对象和关系数据库。在用户层面和业务逻辑层面，我们是面向对象的。当对象的信息发生变化的时候，我们就需要把对象的信息保存在关系数据库中。</p><p>按照之前的方式来进行开发就会出现程序员会在自己的业务逻辑代码中夹杂很多SQL语句用来增加、读取、修改、删除相关数据，而这些代码通常都是极其相似或者重复的。</p><p>ORM解决的主要问题是对象和关系的映射。它通常将一个类和一张表一一对应，类的每个实例对应表中的一条记录，类的每个属性对应表中的每个字段。 </p><p>ORM提供了对数据库的映射，不用直接编写SQL代码，只需操作对象就能对数据库操作数据。</p><p>让软件开发人员专注于业务逻辑的处理，提高了开发效率。</p><p>ORM的缺点是会在一定程度上牺牲程序的执行效率。</p><p>ORM的操作是有限的，也就是ORM定义好的操作是可以完成的，一些复杂的查询操作是完成不了。</p><p>ORM用多了SQL语句就不会写了，关系数据库相关技能退化…</p><p>ORM只是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。</p><p>但我们不能指望某个工具能一劳永逸地解决所有问题，一些特殊问题还是需要特殊处理的。</p><p>但是在整个软件开发过程中需要特殊处理的情况应该都是很少的，否则所谓的工具也就失去了它存在的意义。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9323320.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Django中的ORM"><a href="#Django中的ORM" class="headerlink" title="Django中的ORM"></a>Django中的ORM</h2><p>\1. 在Django项目的settings.py文件中，配置数据库连接信息：</p><pre><code>`DATABASES ``=` `{``    ``"default"``: {``        ``"ENGINE"``: ``"django.db.backends.mysql"``,``        ``"NAME"``: ``"你的数据库名称"``,  ``# 需要自己手动创建数据库``        ``"USER"``: ``"数据库用户名"``,``        ``"PASSWORD"``: ``"数据库密码"``,``        ``"HOST"``: ``"数据库IP"``,``        ``"POST"``: ``3306``    ``}``}`</code></pre><p>\2. 在与Django项目同名的目录下的<strong>init</strong>.py文件中写如下代码，告诉Django使用pymysql模块连接MySQL数据库:</p><pre><code>`import` `pymysql` `pymysql.install_as_MySQLdb()`</code></pre><p>注：数据库迁移的时候出现一个警告</p><pre><code>WARNINGS: ?: (mysql.W002) MySQL Strict Mode is not set for database connection 'default'HINT: MySQL's Strict Mode fixes many data integrity problems in MySQL, such as data truncation upon insertion, by escalating warnings into errors. It is strongly recommended you activate it.</code></pre><p>在配置中多加一个OPTIONS参数：<a href="https://docs.djangoproject.com/en/1.11/ref/databases/#setting-sql-mode">Django官网解释</a></p><pre><code> 'OPTIONS': {    'init_command': "SET sql_mode='STRICT_TRANS_TABLES'"},</code></pre><p>在Django中model是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表。</p><p>基本情况：</p><ul><li>每个模型都是一个Python类，它是django.db.models.Model的子类。</li><li>模型的每个属性都代表一个数据库字段。</li><li>综上所述，Django为您提供了一个自动生成的数据库访问API，详询<a href="https://docs.djangoproject.com/en/1.11/topics/db/queries/">官方文档链接</a>。</li></ul><p>![img](./04 Django之ORM - maple-shaw - 博客园_files/867021-20180325235218756-104285201.png)</p><p>下面这个例子定义了一个 <strong>Person</strong> 模型，包含 <strong>first_name</strong> 和 <strong>last_name</strong>。</p><pre><code>`from` `django.db ``import` `models` `class` `Person(models.Model):``    ``first_name ``=` `models.CharField(max_length``=``30``)``    ``last_name ``=` `models.CharField(max_length``=``30``)`</code></pre><p><strong>first_name</strong> 和 <strong>last_name</strong> 是模型的字段。每个字段被指定为一个类属性，每个属性映射到一个数据库列。</p><p>上面的 <strong>Person</strong> 模型将会像这样创建一个数据库表：</p><pre><code>`CREATE` `TABLE` `myapp_person (``    ``"id"` `serial ``NOT` `NULL` `PRIMARY` `KEY``,``    ``"first_name"` `varchar``(30) ``NOT` `NULL``,``    ``"last_name"` `varchar``(30) ``NOT` `NULL``);`</code></pre><p>一些说明：</p><ul><li>表myapp_person的名称是自动生成的，如果你要自定义表名，需要在model的Meta类中指定 db_table 参数，强烈建议使用小写表名，特别是使用MySQL作为数据库时。</li><li>id字段是自动添加的，如果你想要指定自定义主键，只需在其中一个字段中指定 primary_key=True 即可。如果Django发现你已经明确地设置了Field.primary_key，它将不会添加自动ID列。</li><li>本示例中的CREATE TABLE SQL使用PostgreSQL语法进行格式化，但值得注意的是，Django会根据配置文件中指定的数据库类型来生成相应的SQL语句。</li><li>Django支持MySQL5.5及更高版本。</li></ul><p><strong>常用字段</strong> </p><p><strong>AutoField</strong></p><p>自增的整形字段，必填参数primary_key=True，则成为数据库的主键。无该字段时，django自动创建。</p><p>一个model不能有两个AutoField字段。</p><p><strong>IntegerField</strong></p><p>一个整数类型。数值的范围是 -2147483648 ~ 2147483647。</p><p><strong>CharField</strong></p><p>字符类型，必须提供max_length参数。max_length表示字符的长度。</p><p><strong>DateField</strong></p><p>日期类型，日期格式为YYYY-MM-DD，相当于Python中的datetime.date的实例。</p><p>参数：</p><ul><li>auto_now：每次修改时修改为当前日期时间。</li><li>auto_now_add：新创建对象时自动添加当前日期时间。</li></ul><p>auto_now和auto_now_add和default参数是互斥的，不能同时设置。</p><p><strong>DatetimeField</strong></p><p>日期时间字段，格式为YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]，相当于Python中的datetime.datetime的实例。</p><p>字段类型，详情可点击查询<a href="https://docs.djangoproject.com/en/1.11/ref/models/fields/#field-types">官网</a>。</p><p>![img](./04 Django之ORM - maple-shaw - 博客园_files/ContractedBlock.gif) 字段类型</p><p>自定义一个二进制字段，以及Django字段与数据库字段类型的对应关系。</p><p>![img](./04 Django之ORM - maple-shaw - 博客园_files/ContractedBlock.gif) View Code</p><p>自定义一个char类型字段：</p><pre><code>`class` `MyCharField(models.Field):``    ``"""``    ``自定义的char类型的字段类``    ``"""``    ``def` `__init__(``self``, max_length, ``*``args, ``*``*``kwargs):``        ``self``.max_length ``=` `max_length``        ``super``(MyCharField, ``self``).__init__(max_length``=``max_length, ``*``args, ``*``*``kwargs)` `    ``def` `db_type(``self``, connection):``        ``"""``        ``限定生成数据库表的字段类型为char，长度为max_length指定的值``        ``"""``        ``return` `'char(%s)'` `%` `self``.max_length`</code></pre><p>使用自定义char类型字段：</p><pre><code>`class` `Class(models.Model):``    ``id` `=` `models.AutoField(primary_key``=``True``)``    ``title ``=` `models.CharField(max_length``=``25``)``    ``# 使用自定义的char类型的字段``    ``cname ``=` `MyCharField(max_length``=``25``)`</code></pre><p>创建的表结构：</p><p>![img](./04 Django之ORM - maple-shaw - 博客园_files/867021-20180119164437990-1369210170.png)</p><p>字段参数，详情可点击查看<a href="https://docs.djangoproject.com/en/1.11/ref/models/fields/#field-options">官网</a>。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9323320.html#">+ View Code</a></p><p>这个不是很常用，如果你有特殊需要可以使用。详情点击查看<a href="https://docs.djangoproject.com/en/1.11/ref/models/options/#model-meta-options">官网</a>。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9323320.html#">+ View Code</a></p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9323320.html#">+ View Code</a></p><p>基本操作</p><pre><code>`# 增``models.Tb1.objects.create(c1``=``'xx'``, c2``=``'oo'``)   ``# 增加一条数据，可以接受字典类型数据 **kwargs``obj ``=` `models.Tb1(c1``=``'xx'``, c2``=``'oo'``)``obj.save()`  `# 查``models.Tb1.objects.get(``id``=``123``)  ``# 获取单条数据，不存在则报错（不建议）``models.Tb1.objects.``all``()  ``# 获取全部``models.Tb1.objects.``filter``(name``=``'seven'``)  ``# 获取指定条件的数据``models.Tb1.objects.exclude(name``=``'seven'``)  ``# 去除指定条件的数据`  `# 删``# models.Tb1.objects.filter(name='seven').delete()  # 删除指定条件的数据`  `# 改``models.Tb1.objects.``filter``(name``=``'seven'``).update(gender``=``'0'``)   ``# 将指定条件的数据更新，均支持 **kwargs``obj ``=` `models.Tb1.objects.get(``id``=``1``)``obj.c1 ``=` `'111'``obj.save()   ``# 修改单条数据`</code></pre><p>进阶操作</p><p>![img](./04 Django之ORM - maple-shaw - 博客园_files/ContractedBlock.gif) 进阶操作</p><p>高级操作</p><p>![img](./04 Django之ORM - maple-shaw - 博客园_files/ContractedBlock.gif) 高级操作</p><p>QuerySet相关方法</p><p>![img](./04 Django之ORM - maple-shaw - 博客园_files/ContractedBlock.gif) QuerySet方法大全</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 Django ORM操作</title>
      <link href="2019/11/15/CRM/04%20Django%20ORM%E6%93%8D%E4%BD%9C/"/>
      <url>2019/11/15/CRM/04%20Django%20ORM%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#_label0">目录</a></li><li>必知必会13条<ul><li><a href="#_label1_0">返回QuerySet对象的方法有</a></li><li><a href="#_label1_1">特殊的QuerySet</a></li><li><a href="#_label1_2">返回具体对象的</a></li><li><a href="#_label1_3">返回布尔值的方法有：</a></li><li><a href="#_label1_4">返回数字的方法有</a></li></ul></li><li><a href="#_label2">单表查询之神奇的双下划线</a></li><li>正向查找<ul><li><a href="#_label3_0">对象查找（跨表）</a></li><li><a href="#_label3_1">字段查找（跨表）</a></li></ul></li><li>反向操作<ul><li><a href="#_label4_0">对象查找</a></li><li><a href="#_label4_1">字段查找</a></li></ul></li><li>class RelatedManager<ul><li><a href="#_label5_0">方法</a></li></ul></li><li><a href="#_label6">聚合</a></li><li>分组<ul><li><a href="#_label7_0">更多示例：</a></li></ul></li><li><a href="#_label8">F查询</a></li><li><a href="#_label9">Q查询</a></li><li><a href="#_label10">Django ORM执行原生SQL</a></li><li><a href="#_label11">QuerySet方法大全</a></li></ul><p><a href="#_labelTop">回到顶部</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h1 id="一般操作"><a href="#一般操作" class="headerlink" title="一般操作"></a>一般操作</h1><p><a href="https://docs.djangoproject.com/en/1.11/ref/models/querysets/">看专业的官网文档，做专业的程序员！</a></p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="必知必会13条"><a href="#必知必会13条" class="headerlink" title="必知必会13条"></a>必知必会13条</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;1&gt; all():                 查询所有结果&lt;2&gt; get(**kwargs):         返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。&lt;3&gt; filter(**kwargs):      它包含了与所给筛选条件相匹配的对象&lt;4&gt; exclude(**kwargs):     它包含了与所给筛选条件不匹配的对象&lt;5&gt; values(*field):        返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列&lt;6&gt; values_list(*field):   它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列&lt;7&gt; order_by(*field):      对查询结果排序&lt;8&gt; reverse():             对查询结果反向排序，请注意reverse()通常只能在具有已定义顺序的QuerySet上调用(在model类的Meta中指定ordering或调用order_by()方法)。&lt;9&gt; distinct():            从返回结果中剔除重复纪录(如果你查询跨越多个表，可能在计算QuerySet时得到重复的结果。此时可以使用distinct()，注意只有在PostgreSQL中支持按字段去重。)&lt;10&gt; count():              返回数据库中匹配查询(QuerySet)的对象数量。&lt;11&gt; first():              返回第一条记录&lt;12&gt; last():               返回最后一条记录&lt;13&gt; exists():             如果QuerySet包含数据，就返回True，否则返回False</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>all()</p><p>filter()</p><p>exclude()</p><p>order_by()</p><p>reverse()</p><p>distinct()</p><p>values()       返回一个可迭代的字典序列</p><p>values_list() 返回一个可迭代的元祖序列</p><p>get()</p><p>first()</p><p>last()</p><p>exists()</p><p>count()</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="单表查询之神奇的双下划线"><a href="#单表查询之神奇的双下划线" class="headerlink" title="单表查询之神奇的双下划线"></a>单表查询之神奇的双下划线</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>models.Tb1.objects.filter(id__lt=10, id__gt=1)   # 获取id大于1 且 小于10的值models.Tb1.objects.filter(id__in=[11, 22, 33])   # 获取id等于11、22、33的数据models.Tb1.objects.exclude(id__in=[11, 22, 33])  # not inmodels.Tb1.objects.filter(name__contains="ven")  # 获取name字段包含"ven"的models.Tb1.objects.filter(name__icontains="ven") # icontains大小写不敏感models.Tb1.objects.filter(id__range=[1, 3])      # id范围是1到3的，等价于SQL的bettwen and类似的还有：startswith，istartswith, endswith, iendswith　date字段还可以：models.Class.objects.filter(first_day__year=2017)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="ForeignKey操作"><a href="#ForeignKey操作" class="headerlink" title="ForeignKey操作"></a>ForeignKey操作</h1><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="正向查找"><a href="#正向查找" class="headerlink" title="正向查找"></a>正向查找</h2><p>语法：</p><p><strong>对象**</strong>.<strong><strong>关联字段</strong></strong>.<strong>**字段</strong> </p><p>示例：</p><pre><code>book_obj = models.Book.objects.first()  # 第一本书对象print(book_obj.publisher)  # 得到这本书关联的出版社对象print(book_obj.publisher.name)  # 得到出版社对象的名称</code></pre><p>语法：</p><p><strong>关联字段**</strong>__**<strong>字段</strong></p><p>示例：</p><pre><code>print(models.Book.objects.values_list("publisher__name"))</code></pre><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="反向操作"><a href="#反向操作" class="headerlink" title="反向操作"></a>反向操作</h2><p>语法：</p><p><strong>obj.表名_set</strong></p><p>示例：</p><pre><code>publisher_obj = models.Publisher.objects.first()  # 找到第一个出版社对象books = publisher_obj.book_set.all()  # 找到第一个出版社出版的所有书titles = books.values_list("title")  # 找到第一个出版社出版的所有书的书名</code></pre><p>语法：</p><p><strong>表名__字段</strong></p><p>示例：</p><pre><code>titles = models.Publisher.objects.values_list("book__title")</code></pre><h1 id="ManyToManyField"><a href="#ManyToManyField" class="headerlink" title="ManyToManyField"></a>ManyToManyField</h1><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="class-RelatedManager"><a href="#class-RelatedManager" class="headerlink" title="class RelatedManager"></a>class RelatedManager</h2><p>“关联管理器”是在一对多或者多对多的关联上下文中使用的管理器。</p><p>它存在于下面两种情况：</p><ol><li>外键关系的反向查询</li><li>多对多关联关系</li></ol><p>简单来说就是当 点后面的对象 可能存在多个的时候就可以使用以下的方法。</p><p><strong>create()</strong></p><p>创建一个新的对象，保存对象，并将它添加到关联对象集之中，返回新创建的对象。</p><pre><code>&gt;&gt;&gt; import datetime&gt;&gt;&gt; models.Author.objects.first().book_set.create(title="番茄物语", publish_date=datetime.date.today())</code></pre><p><strong>add()</strong></p><p>把指定的model对象添加到关联对象集中。</p><p>添加对象</p><pre><code>&gt;&gt;&gt; author_objs = models.Author.objects.filter(id__lt=3)&gt;&gt;&gt; models.Book.objects.first().authors.add(*author_objs)</code></pre><p>添加id</p><pre><code>&gt;&gt;&gt; models.Book.objects.first().authors.add(*[1, 2])</code></pre><p><strong>set()</strong></p><p>更新model对象的关联对象。</p><pre><code>&gt;&gt;&gt; book_obj = models.Book.objects.first()&gt;&gt;&gt; book_obj.authors.set([2, 3])</code></pre><p><strong>remove()</strong></p><p>从关联对象集中移除执行的model对象</p><pre><code>&gt;&gt;&gt; book_obj = models.Book.objects.first()&gt;&gt;&gt; book_obj.authors.remove(3)</code></pre><p><strong>clear()</strong></p><p>从关联对象集中移除一切对象。</p><pre><code>&gt;&gt;&gt; book_obj = models.Book.objects.first()&gt;&gt;&gt; book_obj.authors.clear()</code></pre><p>注意：</p><p>对于ForeignKey对象，clear()和remove()方法仅在null=True时存在。</p><p><strong>举个例子：</strong></p><p>ForeignKey字段没设置null=True时，</p><pre><code>class Book(models.Model):    title = models.CharField(max_length=32)    publisher = models.ForeignKey(to=Publisher)</code></pre><p>没有clear()和remove()方法：</p><pre><code>&gt;&gt;&gt; models.Publisher.objects.first().book_set.clear()Traceback (most recent call last):  File "&lt;input&gt;", line 1, in &lt;module&gt;AttributeError: 'RelatedManager' object has no attribute 'clear'</code></pre><p>当ForeignKey字段设置null=True时，</p><pre><code>class Book(models.Model):    name = models.CharField(max_length=32)    publisher = models.ForeignKey(to=Class, null=True)</code></pre><p>此时就有clear()和remove()方法：</p><pre><code>&gt;&gt;&gt; models.Publisher.objects.first().book_set.clear()</code></pre><p>注意：</p><ol><li>对于所有类型的关联字段，add()、create()、remove()和clear(),set()都会马上更新数据库。换句话说，在关联的任何一端，都不需要再调用save()方法。</li></ol><h1 id="聚合查询和分组查询"><a href="#聚合查询和分组查询" class="headerlink" title="聚合查询和分组查询"></a>聚合查询和分组查询</h1><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p><code>aggregate()</code>是<code>QuerySet</code> 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。</p><p>键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。</p><p>用到的内置函数：</p><pre><code>from django.db.models import Avg, Sum, Max, Min, Count</code></pre><p>示例：</p><pre><code>&gt;&gt;&gt; from django.db.models import Avg, Sum, Max, Min, Count&gt;&gt;&gt; models.Book.objects.all().aggregate(Avg("price")){'price__avg': 13.233333}</code></pre><p>如果你想要为聚合值指定一个名称，可以向聚合子句提供它。</p><pre><code>&gt;&gt;&gt; models.Book.objects.aggregate(average_price=Avg('price')){'average_price': 13.233333}</code></pre><p>如果你希望生成不止一个聚合，你可以向<code>aggregate()</code>子句中添加另一个参数。所以，如果你也想知道所有图书价格的最大值和最小值，可以这样查询：</p><pre><code>&gt;&gt;&gt; models.Book.objects.all().aggregate(Avg("price"), Max("price"), Min("price")){'price__avg': 13.233333, 'price__max': Decimal('19.90'), 'price__min': Decimal('9.90')}</code></pre><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>我们在这里先复习一下SQL语句的分组。</p><p>假设现在有一张公司职员表：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180514155403768-1087669329.png" alt="img"></p><p> 我们使用原生SQL语句，按照部门分组求平均工资：</p><pre><code>select dept,AVG(salary) from employee group by dept;</code></pre><p>ORM查询:</p><pre><code>from django.db.models import AvgEmployee.objects.values("dept").annotate(avg=Avg("salary").values("dept", "avg")</code></pre><p>连表查询的分组：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180514160919597-548385320.png" alt="img">SQL查询：</p><pre><code>select dept.name,AVG(salary) from employee inner join dept on (employee.dept_id=dept.id) group by dept_id;</code></pre><p>ORM查询：</p><pre><code>from django.db.models import Avgmodels.Dept.objects.annotate(avg=Avg("employee__salary")).values("name", "avg")</code></pre><p>示例1：统计每一本书的作者个数</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>&gt;&gt;&gt; book_list = models.Book.objects.all().annotate(author_num=Count("author"))&gt;&gt;&gt; for obj in book_list:...     print(obj.author_num)...211</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>示例2：统计出每个出版社买的最便宜的书的价格</p><pre><code>&gt;&gt;&gt; publisher_list = models.Publisher.objects.annotate(min_price=Min("book__price"))&gt;&gt;&gt; for obj in publisher_list:...     print(obj.min_price)...     9.9019.90</code></pre><p>方法二：</p><pre><code>&gt;&gt;&gt; models.Book.objects.values("publisher__name").annotate(min_price=Min("price"))&lt;QuerySet [{'publisher__name': '沙河出版社', 'min_price': Decimal('9.90')}, {'publisher__name': '人民出版社', 'min_price': Decimal('19.90')}]&gt;</code></pre><p>示例3：统计不止一个作者的图书</p><pre><code>&gt;&gt;&gt; models.Book.objects.annotate(author_num=Count("author")).filter(author_num__gt=1)&lt;QuerySet [&lt;Book: 番茄物语&gt;]&gt;</code></pre><p>示例4：根据一本图书作者数量的多少对查询集 <code>QuerySet</code>进行排序</p><pre><code>&gt;&gt;&gt; models.Book.objects.annotate(author_num=Count("author")).order_by("author_num")&lt;QuerySet [&lt;Book: 香蕉物语&gt;, &lt;Book: 橘子物语&gt;, &lt;Book: 番茄物语&gt;]&gt;</code></pre><p>示例5：查询各个作者出的书的总价格</p><pre><code>&gt;&gt;&gt; models.Author.objects.annotate(sum_price=Sum("book__price")).values("name", "sum_price")&lt;QuerySet [{'name': '小精灵', 'sum_price': Decimal('9.90')}, {'name': '小仙女', 'sum_price': Decimal('29.80')}, {'name': '小魔女', 'sum_price': Decimal('9.90')}]&gt;</code></pre><h1 id="F查询和Q查询"><a href="#F查询和Q查询" class="headerlink" title="F查询和Q查询"></a>F查询和Q查询</h1><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="F查询"><a href="#F查询" class="headerlink" title="F查询"></a>F查询</h2><p>在上面所有的例子中，我们构造的过滤器都只是将字段值与某个常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？</p><p>Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。</p><p>示例1：</p><p>查询评论数大于收藏数的书籍</p><pre><code>from django.db.models import Fmodels.Book.objects.filter(commnet_num__gt=F('keep_num'))</code></pre><p>Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。</p><pre><code>models.Book.objects.filter(commnet_num__lt=F('keep_num')*2)</code></pre><p>修改操作也可以使用F函数,比如将每一本书的价格提高30元</p><pre><code>models.Book.objects.all().update(price=F("price")+30)</code></pre><p><strong>引申：</strong></p><p>如果要修改char字段咋办？</p><p>如：把所有书名后面加上(第一版)</p><pre><code>&gt;&gt;&gt; from django.db.models.functions import Concat&gt;&gt;&gt; from django.db.models import Value&gt;&gt;&gt; models.Book.objects.all().update(title=Concat(F("title"), Value("("), Value("第一版"), Value(")")))</code></pre><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Q查询"><a href="#Q查询" class="headerlink" title="Q查询"></a>Q查询</h2><p><code>filter()</code> 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如<code>OR</code>语句），你可以使用<code>Q对象</code>。</p><p>示例1：</p><p>查询作者名是小仙女或小魔女的</p><pre><code>models.Book.objects.filter(Q(authors__name="小仙女")|Q(authors__name="小魔女"))</code></pre><p>你可以组合<code>&amp;</code> 和<code>|</code>  操作符以及使用括号进行分组来编写任意复杂的<code>Q</code> 对象。同时，<code>Q</code> 对象可以使用<code>~</code> 操作符取反，这允许组合正常的查询和取反(<code>NOT</code>) 查询。</p><p>示例：查询作者名字是小仙女并且不是2018年出版的书的书名。</p><pre><code>&gt;&gt;&gt; models.Book.objects.filter(Q(author__name="小仙女") &amp; ~Q(publish_date__year=2018)).values_list("title")&lt;QuerySet [('番茄物语',)]&gt;</code></pre><p>查询函数可以混合使用<code>Q 对象</code>和关键字参数。所有提供给查询函数的参数（关键字参数或<code>Q</code> 对象）都将”AND”在一起。但是，如果出现<code>Q</code> 对象，它必须位于所有关键字参数的前面。</p><p>例如：查询出版年份是2017或2018，书名中带物语的所有书。</p><pre><code>&gt;&gt;&gt; models.Book.objects.filter(Q(publish_date__year=2018) | Q(publish_date__year=2017), title__icontains="物语")&lt;QuerySet [&lt;Book: 番茄物语&gt;, &lt;Book: 香蕉物语&gt;, &lt;Book: 橘子物语&gt;]&gt;</code></pre><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>import osif __name__ == '__main__':    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "BMS.settings")    import django    django.setup()    import datetime    from app01 import models    try:        from django.db import transaction        with transaction.atomic():            new_publisher = models.Publisher.objects.create(name="火星出版社")            models.Book.objects.create(title="橘子物语", publish_date=datetime.date.today(), publisher_id=10)  # 指定一个不存在的出版社id    except Exception as e:        print(str(e))</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="其他鲜为人知的操作（有个印象即可）"><a href="#其他鲜为人知的操作（有个印象即可）" class="headerlink" title="其他鲜为人知的操作（有个印象即可）"></a>其他鲜为人知的操作（有个印象即可）</h1><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Django-ORM执行原生SQL"><a href="#Django-ORM执行原生SQL" class="headerlink" title="Django ORM执行原生SQL"></a>Django ORM执行原生SQL</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> ORM 执行原生SQL的方法</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9403501.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="QuerySet方法大全"><a href="#QuerySet方法大全" class="headerlink" title="QuerySet方法大全"></a>QuerySet方法大全</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> QuerySet方法大全</p><h1 id="Django终端打印SQL语句"><a href="#Django终端打印SQL语句" class="headerlink" title="Django终端打印SQL语句"></a>Django终端打印SQL语句</h1><p>在Django项目的settings.py文件中，在最后复制粘贴如下代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>LOGGING = {    'version': 1,    'disable_existing_loggers': False,    'handlers': {        'console':{            'level':'DEBUG',            'class':'logging.StreamHandler',        },    },    'loggers': {        'django.db.backends': {            'handlers': ['console'],            'propagate': True,            'level':'DEBUG',        },    }}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>即为你的Django项目配置上一个名为<em>django.db.backends</em>的logger实例即可查看翻译后的SQL语句。 </p><h1 id="在Python脚本中调用Django环境"><a href="#在Python脚本中调用Django环境" class="headerlink" title="在Python脚本中调用Django环境"></a>在Python脚本中调用Django环境</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>import osif __name__ == '__main__':    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "BMS.settings")    import django    django.setup()    from app01 import models    books = models.Book.objects.all()    print(books)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 Django之模板</title>
      <link href="2019/11/15/CRM/03%20Django%E4%B9%8B%E6%A8%A1%E6%9D%BF%20/"/>
      <url>2019/11/15/CRM/03%20Django%E4%B9%8B%E6%A8%A1%E6%9D%BF%20/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-html"><code class="language-html">## 目录- [目录](#_label0)- 常用语法  - [变量](#_label1_0)  - [Filters](#_label1_1)  - [自定义filter](#_label1_2)  - [Tags](#_label1_3)  - [csrf_token](#_label1_4)  - [注释](#_label1_5)  - [注意事项](#_label1_6)- [母板](#_label2)- [继承母板](#_label3)- [块（block）](#_label4)- [组件](#_label5)- 静态文件相关  - [使用get_static_prefix](#_label6_0)  - [自定义simpletag](#_label6_1)  - [inclusion_tag](#_label6_2)[回到顶部](#_labelTop)## 目录# Django模板系统[官方文档](https://docs.djangoproject.com/en/1.11/ref/templates/language/)[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9333821.html#_labelTop)[回到顶部](#_labelTop)## 常用语法Django模板中只需要记两种特殊符号：{{  }}和 {% %}{{ }}表示变量，在模板渲染的时候替换成值，{% %}表示逻辑相关的操作。{{ 变量名 }}变量名由字母数字和下划线组成。点（.）在模板语言中有特殊的含义，用来获取对象的相应属性值。几个例子：view中代码：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)```def template_test(request):    l = [11, 22, 33]    d = {"name": "alex"}    class Person(object):        def __init__(self, name, age):            self.name = name            self.age = age        def dream(self):            return "{} is dream...".format(self.name)    Alex = Person(name="Alex", age=34)    Egon = Person(name="Egon", age=9000)    Eva_J = Person(name="Eva_J", age=18)    person_list = [Alex, Egon, Eva_J]    return render(request, "template_test.html", {"l": l, "d": d, "person_list": person_list})```[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)模板中支持的写法：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)```{# 取l中的第一个参数 #}{{ l.0 }}{# 取字典中key的值 #}{{ d.name }}{# 取对象的name属性 #}{{ person_list.0.name }}{# .操作只能调用不带参数的方法 #}{{ person_list.0.dream }}```[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)注：当模板系统遇到一个（.）时，会按照如下的顺序去查询：1. 在字典中查询2. 属性或者方法3. 数字索引翻译为过滤器，用来修改变量的显示结果。语法： {{ value|filter_name:参数 }}'|'左右没有空格没有空格没有空格**default**　　```{{ value|default:"nothing"}}```如果value值没传的话就显示nothing注：TEMPLATES的OPTIONS可以增加一个选项：string_if_invalid：'找不到'，可以替代default的的作用。**filesizeformat**将值格式化为一个 “人类可读的” 文件尺寸 （例如 '13 KB', '4.1 MB', '102 bytes', 等等）。例如：```{{ value|filesizeformat }}```如果 value 是 123456789，输出将会是 117.7 MB。**add**给变量加参数```{{ value|add:"2" }}```value是数字4，则输出结果为6。```{{ first|add:second }}```如果first是 [1,.2,3] ，second是 [4,5,6] ，那输出结果是 [1,2,3,4,5,6] 。**lower**小写```{{ value|lower }}```**upper**大写```{{ value|upper}}```**title**标题```{{ value|title }}```**ljust**左对齐```"{{ value|ljust:"10" }}"```**rjust**右对齐```"{{ value|rjust:"10" }}"```**center**居中```"{{ value|center:"15" }}"```**length**{{ value|length }}返回value的长度，如 value=['a', 'b', 'c', 'd']的话，就显示4.**slice**　　切片```{{value|slice:"2:-1"}}```**first**取第一个元素```{{ value|first }}```**last**取最后一个元素```{{ value|last }}```**join**使用字符串拼接列表。同python的str.join(list)。```{{ value|join:" // " }}```**truncatechars**如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“...”）结尾。参数：截断的字符数```{{ value|truncatechars:9}}```**date**日期格式化```{{ value|date:"Y-m-d H:i:s"}}```可格式化输出的字符：[点击查看](https://docs.djangoproject.com/en/1.11/ref/templates/builtins/#date)。**safe**Django的模板中会对HTML标签和JS等语法标签进行自动转义，原因显而易见，这样是为了安全。但是有的时候我们可能不希望这些HTML元素被转义，比如我们做一个内容管理系统，后台添加的文章中是经过修饰的，这些修饰可能是通过一个类似于FCKeditor编辑加注了HTML修饰符的文本，如果自动转义的话显示的就是保护HTML标签的源文件。为了在Django中关闭HTML的自动转义有两种方式，如果是一个单独的变量我们可以通过过滤器“|safe”的方式告诉Django这段代码是安全的不必转义。比如：value = "<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>#<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>点我<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>"```{{ value|safe}}```自定义过滤器只是带有一个或两个参数的Python函数:- 变量（输入）的值 - -不一定是一个字符串- 参数的值 - 这可以有一个默认值，或完全省略例如，在过滤器{{var | foo：“bar”}}中，过滤器**foo**将传递变量**var**和参数**“bar”**。自定义filter代码文件摆放位置：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)```app01/    __init__.py    models.py    templatetags/  # 在app01下面新建一个package package        __init__.py        app01_filters.py  # 建一个存放自定义filter的py文件    views.py```[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)编写自定义filter[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)```from django import templateregister = template.Library()@register.filterdef fill(value, arg):    return value.replace(" ", arg)@register.filter(name="addSB")def add_sb(value):    return "{} SB".format(value)```[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)使用自定义filter```{# 先导入我们自定义filter那个文件 #}{% load app01_filters %}{# 使用我们自定义的filter #}{{ somevariable|fill:"__" }}{{ d.name|addSB }}```**for**```<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>{% for user in user_list %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{ user.name }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>{% endfor %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>```for循环可用的一些参数：| Variable              | Description                          || --------------------- | ------------------------------------ || `forloop.counter`     | 当前循环的索引值（从1开始）          || `forloop.counter0`    | 当前循环的索引值（从0开始）          || `forloop.revcounter`  | 当前循环的倒序索引值（从1开始）      || `forloop.revcounter0` | 当前循环的倒序索引值（从0开始）      || `forloop.first`       | 当前循环是不是第一次循环（布尔值）   || `forloop.last`        | 当前循环是不是最后一次循环（布尔值） || `forloop.parentloop`  | 本层循环的外层循环                   |**for ... empty**[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)```<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>{% for user in user_list %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{ user.name }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>{% empty %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>空空如也<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>{% endfor %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>```[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)**if,elif和else**[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)```{% if user_list %}  用户人数：{{ user_list|length }}{% elif black_list %}  黑名单数：{{ black_list|length }}{% else %}  没有用户{% endif %}```[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)**当然也可以只有if和else**```{% if user_list|length > 5 %}  七座豪华SUV{% else %}    黄包车{% endif %}```if语句支持 and 、or、==、>、&lt;、!=、&lt;=、>=、in、not in、is、is not判断。**with**定义一个中间变量```{% with total=business.employees.count %}    {{ total }} employee{{ total|pluralize }}{% endwith %}```这个标签用于跨站请求伪造保护。在页面的form表单里面写上{% csrf_token %}```{# ... #}```\1. Django的模板语言不支持连续判断，即不支持以下写法：```{% if a > b > c %}...{% endif %}```\2. Django的模板语言中属性的优先级大于方法```def xx(request):    d = {"a": 1, "b": 2, "c": 3, "items": "100"}    return render(request, "xx.html", {"data": d})```如上，我们在使用render方法渲染一个页面的时候，传的字典d有一个key是items并且还有默认的 d.items() 方法，此时在模板语言中:```{{ data.items }}```默认会取d的items key的值。[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9333821.html#_labelTop)[回到顶部](#_labelTop)## 母板[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>x-ua-compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  {% block page-css %}    {% endblock %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>这是母板的标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>{% block page-main %}{% endblock %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>母板底部内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>{% block page-js %}{% endblock %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)注意：我们通常会在母板中定义页面专用的CSS块和JS块，方便子页面替换。[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9333821.html#_labelTop)[回到顶部](#_labelTop)## 继承母板在子页面中在页面最上方使用下面的语法来继承母板。```{% extends 'layouts.html' %}```[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9333821.html#_labelTop)[回到顶部](#_labelTop)## 块（block）通过在母板中使用`{% block  xxx %}`来定义"块"。在子页面中通过定义母板中的block名来对应替换母板中相应的内容。```{% block page-main %}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>世情薄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>人情恶<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>雨送黄昏花易落<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% endblock %}```[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9333821.html#_labelTop)[回到顶部](#_labelTop)## 组件可以将常用的页面内容如导航条，页尾信息等组件保存在单独的文件中，然后在需要使用的地方按如下语法导入即可。```{% include 'navbar.html' %}```[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9333821.html#_labelTop)[回到顶部](#_labelTop)## 静态文件相关```{% load static %}&lt;img src="{% static "images/hi.jpg" %}" alt="Hi!" />```引用JS文件时使用：```{% load static %}&lt;script src="{% static "mytest.js" %}"><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>```某个文件多处被用到可以存为一个变量```{% load static %}{% static "images/hi.jpg" as myphoto %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ myphoto }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>img</span><span class="token punctuation">></span></span>``````{% load static %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{% get_static_prefix %}images/hi.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Hi!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>```或者```{% load static %}{% get_static_prefix as STATIC_PREFIX %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ STATIC_PREFIX }}images/hi.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Hi!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ STATIC_PREFIX }}images/hi2.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Hello!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>```和自定义filter类似，只不过接收更灵活的参数。定义注册simple tag```@register.simple_tag(name="plus")def plus(a, b, c):    return "{} + {} + {}".format(a, b, c)```使用自定义simple tag```{% load app01_demo %}{# simple tag #}{% plus "1" "2" "abc" %}```多用于返回html代码片段示例：templatetags/my_inclusion.py[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)```from django import templateregister = template.Library()@register.inclusion_tag('result.html')def show_results(n):    n = 1 if n &lt; 1 else int(n)    data = ["第{}项".format(i) for i in range(1, n+1)]    return {"data": data}```[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)templates/result.html```<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  {% for choice in data %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{ choice }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  {% endfor %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>```templates/index.html[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>x-ua-compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>inclusion_tag test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>{% load my_inclusion %}{% show_results 10 %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](./03 Django之模板 - maple-shaw - 博客园_files/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 Django之视图</title>
      <link href="2019/11/15/CRM/02%20Django%E4%B9%8B%E8%A7%86%E5%9B%BE/"/>
      <url>2019/11/15/CRM/02%20Django%E4%B9%8B%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#_labelTop">回到顶部</a></p><h2 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h2><h1 id="Django的View（视图）"><a href="#Django的View（视图）" class="headerlink" title="Django的View（视图）"></a>Django的View（视图）</h1><p>一个视图函数（类），简称视图，是一个简单的Python 函数（类），它接受Web请求并且返回Web响应。</p><p>响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片。</p><p>无论视图本身包含什么逻辑，都要返回响应。代码写在哪里也无所谓，只要它在你当前项目目录下面。除此之外没有更多的要求了——可以说“没有什么神奇的地方”。为了将代码放在某处，大家约定成俗将视图放置在项目（project）或应用程序（app）目录中的名为<code>views.py</code>的文件中。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9285269.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="一个简单的视图"><a href="#一个简单的视图" class="headerlink" title="一个简单的视图"></a>一个简单的视图</h2><p>下面是一个以HTML文档的形式返回当前日期和时间的视图：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.http import HttpResponseimport datetimedef current_datetime(request):    now = datetime.datetime.now()    html = "&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;" % now    return HttpResponse(html)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>让我们来逐行解释下上面的代码：</p><ul><li><p>首先，我们从 <code>django.http</code>模块导入了<code>HttpResponse</code>类，以及Python的<code>datetime</code>库。</p></li><li><p>接着，我们定义了<code>current_datetime</code>函数。它就是视图函数。每个视图函数都使用<code>HttpRequest</code>对象作为第一个参数，并且通常称之为<code>request</code>。</p><p>注意，视图函数的名称并不重要；不需要用一个统一的命名方式来命名，以便让Django识别它。我们将其命名为<code>current_datetime</code>，是因为这个名称能够比较准确地反映出它实现的功能。</p></li><li><p>这个视图会返回一个<code>HttpResponse</code>对象，其中包含生成的响应。每个视图函数都负责返回一个<code>HttpResponse</code>对象。</p></li></ul><p>Django使用请求和响应对象来通过系统传递状态。</p><p>当浏览器向服务端请求一个页面时，Django创建一个HttpRequest对象，该对象包含关于请求的元数据。然后，Django加载相应的视图，将这个HttpRequest对象作为第一个参数传递给视图函数。</p><p>每个视图负责返回一个HttpResponse对象。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9285269.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="CBV和FBV"><a href="#CBV和FBV" class="headerlink" title="CBV和FBV"></a>CBV和FBV</h2><p>我们之前写过的都是基于函数的view，就叫FBV。还可以把view写成基于类的。</p><p>就拿我们之前写过的添加班级为例：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code># FBV版添加班级def add_class(request):    if request.method == "POST":        class_name = request.POST.get("class_name")        models.Classes.objects.create(name=class_name)        return redirect("/class_list/")    return render(request, "add_class.html")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code># CBV版添加班级from django.views import Viewclass AddClass(View):    def get(self, request):        return render(request, "add_class.html")    def post(self, request):        class_name = request.POST.get("class_name")        models.Classes.objects.create(name=class_name)        return redirect("/class_list/")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>注意：</p><p>使用CBV时，urls.py中也做对应的修改：</p><pre><code># urls.py中url(r'^add_class/$', views.AddClass.as_view()),</code></pre><p><a href="https://www.cnblogs.com/maple-shaw/articles/9285269.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="给视图加装饰器"><a href="#给视图加装饰器" class="headerlink" title="给视图加装饰器"></a>给视图加装饰器</h2><p>FBV本身就是一个函数，所以和给普通的函数加装饰器无差：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>def wrapper(func):    def inner(*args, **kwargs):        start_time = time.time()        ret = func(*args, **kwargs)        end_time = time.time()        print("used:", end_time-start_time)        return ret    return inner# FBV版添加班级@wrapperdef add_class(request):    if request.method == "POST":        class_name = request.POST.get("class_name")        models.Classes.objects.create(name=class_name)        return redirect("/class_list/")    return render(request, "add_class.html")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>类中的方法与独立函数不完全相同，因此不能直接将函数装饰器应用于类中的方法 ，我们需要先将其转换为方法装饰器。</p><p>Django中提供了method_decorator装饰器用于将函数装饰器转换为方法装饰器。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code># CBV版添加班级from django.views import Viewfrom django.utils.decorators import method_decoratorclass AddClass(View):    @method_decorator(wrapper)    def get(self, request):        return render(request, "add_class.html")    def post(self, request):        class_name = request.POST.get("class_name")        models.Classes.objects.create(name=class_name)        return redirect("/class_list/")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> 关于CBV的扩展阅读</p><h1 id="Request对象和Response对象"><a href="#Request对象和Response对象" class="headerlink" title="Request对象和Response对象"></a>Request对象和Response对象</h1><p><a href="https://www.cnblogs.com/maple-shaw/articles/9285269.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h2><p>当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。<br>Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。</p><p><a href="https://docs.djangoproject.com/en/1.11/ref/request-response/">官方文档</a></p><ul><li><p><strong>path_info</strong>     返回用户访问url，不包括域名</p></li><li><p><strong>method</strong>        请求中使用的HTTP方法的字符串表示，全大写表示。</p></li><li><p><strong>GET</strong>              包含所有HTTP  GET参数的类字典对象</p></li><li><p><strong>POST</strong>           包含所有HTTP POST参数的类字典对象</p></li><li><p><strong>body</strong>            请求体，byte类型 request.POST的数据就是从body里面提取到的</p></li></ul><p>所有的属性应该被认为是只读的，除非另有说明。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> request属性相关</p><p>上传文件示例</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> 上传文件示例代码</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> 请求相关方法</p><p>注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用：</p><pre><code>request.POST.getlist("hobby")</code></pre><p><a href="https://www.cnblogs.com/maple-shaw/articles/9285269.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><p>与由Django自动创建的HttpRequest对象相比，HttpResponse对象是我们的职责范围了。我们写的每个视图都需要实例化，填充和返回一个HttpResponse。</p><p>HttpResponse类位于django.http模块中。</p><p>传递字符串</p><pre><code>from django.http import HttpResponseresponse = HttpResponse("Here's the text of the Web page.")response = HttpResponse("Text only, please.", content_type="text/plain")</code></pre><p>设置或删除响应头信息</p><pre><code>response = HttpResponse()response['Content-Type'] = 'text/html; charset=UTF-8'del response['Content-Type']</code></pre><p>HttpResponse.content：响应内容</p><p>HttpResponse.charset：响应内容的编码</p><p>HttpResponse.status_code：响应的状态码</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9285269.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="JsonResponse对象"><a href="#JsonResponse对象" class="headerlink" title="JsonResponse对象"></a>JsonResponse对象</h2><p>JsonResponse是HttpResponse的子类，专门用来生成JSON编码的响应。</p><pre><code>from django.http import JsonResponseresponse = JsonResponse({'foo': 'bar'})print(response.content)b'{"foo": "bar"}'</code></pre><p>默认只能传递字典类型，如果要传递非字典类型需要设置一下safe关键字参数。</p><pre><code>response = JsonResponse([1, 2, 3], safe=False)</code></pre><p><a href="https://www.cnblogs.com/maple-shaw/articles/9285269.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Django-shortcut-functions"><a href="#Django-shortcut-functions" class="headerlink" title="Django shortcut functions"></a>Django shortcut functions</h2><p><a href="https://docs.djangoproject.com/en/1.11/topics/http/shortcuts/">官方文档</a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180329215116152-275073384.png" alt="img"></p><p>结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。</p><p>参数：</p><ul><li>request： 用于生成响应的请求对象。</li><li>template_name：要使用的模板的完整名称，可选的参数</li><li>context：添加到模板上下文的一个字典。默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。</li><li>content_type：生成的文档要使用的MIME类型。默认为 DEFAULT_CONTENT_TYPE 设置的值。默认为’text/html’</li><li>status：响应的状态码。默认为200。</li><li>useing: 用于加载模板的模板引擎的名称。</li></ul><p>一个简单的例子：</p><pre><code>from django.shortcuts import renderdef my_view(request):    # 视图的代码写在这里    return render(request, 'myapp/index.html', {'foo': 'bar'})</code></pre><p>上面的代码等于：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.http import HttpResponsefrom django.template import loaderdef my_view(request):    # 视图代码写在这里    t = loader.get_template('myapp/index.html')    c = {'foo': 'bar'}    return HttpResponse(t.render(c, request))</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>参数可以是：</p><ul><li>一个模型：将调用模型的<code>get_absolute_url()</code> 函数</li><li>一个视图，可以带有参数：将使用<code>urlresolvers.reverse</code> 来反向解析名称</li><li>一个绝对的或相对的URL，将原封不动的作为重定向的位置。</li></ul><p>默认返回一个临时的重定向；传递<code>permanent=True</code> 可以返回一个永久的重定向。</p><p>示例:<a href="http://python.usyiyi.cn/documents/django_182/topics/http/shortcuts.html#examples"></a></p><p>你可以用多种方式使用<code>redirect()</code> 函数。</p><p><strong>传递一个具体的ORM对象（了解即可）</strong></p><p>将调用具体ORM对象的<code>get_absolute_url()</code> 方法来获取重定向的URL：</p><pre><code>from django.shortcuts import redirectdef my_view(request):    ...    object = MyModel.objects.get(...)    return redirect(object)</code></pre><p><strong>传递一个视图的名称</strong></p><pre><code>def my_view(request):    ...    return redirect('some-view-name', foo='bar')</code></pre><p><strong>传递要重定向到的一个具体的网址</strong></p><pre><code>def my_view(request):    ...    return redirect('/some/url/')</code></pre><p><strong>当然也可以是一个完整的网址</strong></p><pre><code>def my_view(request):    ...    return redirect('http://example.com/')</code></pre><p>默认情况下，<code>redirect()</code> 返回一个临时重定向。以上所有的形式都接收一个<code>permanent</code> 参数；如果设置为<code>True</code>，将返回一个永久的重定向：</p><pre><code>def my_view(request):    ...    object = MyModel.objects.get(...)    return redirect(object, permanent=True)　　</code></pre><p><strong>扩展阅读：</strong> </p><p>临时重定向（响应状态码：302）和永久重定向（响应状态码：301）对普通用户来说是没什么区别的，它主要面向的是搜索引擎的机器人。</p><p>A页面临时重定向到B页面，那搜索引擎收录的就是A页面。</p><p>A页面永久重定向到B页面，那搜索引擎收录的就是B页面。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09 Django的认证系统</title>
      <link href="2019/11/15/CRM/09%20Django%E7%9A%84%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F/"/>
      <url>2019/11/15/CRM/09%20Django%E7%9A%84%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="录"><a href="#录" class="headerlink" title="录"></a>录</h2><ul><li><a href="#_label0">目录</a></li><li>auth模块<ul><li><a href="#_label1_0">authenticate()   </a></li><li><a href="#_label1_1">login(HttpRequest, user)</a></li><li><a href="#_label1_2">logout(request) </a></li><li><a href="#_label1_3">is_authenticated()</a></li><li><a href="#_label1_4">login_requierd()</a></li><li><a href="#_label1_5">create_user()</a></li><li><a href="#_label1_6">create_superuser()</a></li><li><a href="#_label1_7">check_password(password)</a></li><li><a href="#_label1_8">set_password(password)</a></li><li><a href="#_label1_9">User对象的属性</a></li></ul></li><li><a href="#_label2">扩展默认的auth_user表</a></li></ul><p><a href="#_labelTop">回到顶部</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h1 id="Django自带的用户认证"><a href="#Django自带的用户认证" class="headerlink" title="Django自带的用户认证"></a>Django自带的用户认证</h1><p>我们在开发一个网站的时候，无可避免的需要设计实现网站的用户系统。此时我们需要实现包括用户注册、用户登录、用户认证、注销、修改密码等功能，这还真是个麻烦的事情呢。</p><p>Django作为一个完美主义者的终极框架，当然也会想到用户的这些痛点。它内置了强大的用户认证系统–auth，它默认使用 auth_user 表来存储用户数据。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9537320.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="auth模块"><a href="#auth模块" class="headerlink" title="auth模块"></a>auth模块</h2><pre><code>from django.contrib import auth</code></pre><p>auth中提供了许多实用方法：</p><p>提供了用户认证功能，即验证用户名以及密码是否正确，一般需要username 、password两个关键字参数。</p><p>如果认证成功（用户名和密码正确有效），便会返回一个 User 对象。</p><p>authenticate()会在该 User 对象上设置一个属性来标识后端已经认证了该用户，且该信息在后续的登录过程中是需要的。</p><p>用法：</p><pre><code>user = auth.authenticate(request,username='theuser',password='thepassword')</code></pre><p>该函数接受一个HttpRequest对象，以及一个经过认证的User对象。</p><p>该函数实现一个用户登录的功能。它本质上会在后端为该用户生成相关session数据。</p><p>用法：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.contrib.auth import authenticate, logindef my_view(request):  username = request.POST['username']  password = request.POST['password']  user = authenticate(request, username=username, password=password)  if user is not None:    login(request, user)    # Redirect to a success page.    ...  else:    # Return an 'invalid login' error message.    ...</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>该函数接受一个HttpRequest对象，无返回值。</p><p>当调用该函数时，当前请求的session信息会全部清除。该用户即使没有登录，使用该函数也不会报错。</p><p>用法：</p><pre><code>from django.contrib.auth import logoutdef logout_view(request):  logout(request)  # Redirect to a success page.</code></pre><p>用来判断当前请求是否通过了认证。</p><p>用法：</p><pre><code>def my_view(request):  if not request.user.is_authenticated():    return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path))</code></pre><p>auth 给我们提供的一个装饰器工具，用来快捷的给某个视图添加登录校验。</p><p>用法：</p><pre><code>from django.contrib.auth.decorators import login_required@login_requireddef my_view(request):  ...</code></pre><p>若用户没有登录，则会跳转到django默认的 登录URL ‘/accounts/login/ ‘ 并传递当前访问url的绝对路径 (登陆成功后，会重定向到该路径)。</p><p>如果需要自定义登录的URL，则需要在settings.py文件中通过LOGIN_URL进行修改。</p><p>示例：</p><pre><code>LOGIN_URL = '/login/'  # 这里配置成你项目登录页面的路由</code></pre><p>auth 提供的一个创建新用户的方法，需要提供必要参数（username、password）等。</p><p>用法：</p><pre><code>from django.contrib.auth.models import Useruser = User.objects.create_user（username='用户名',password='密码',email='邮箱',...）</code></pre><p>auth 提供的一个创建新的超级用户的方法，需要提供必要参数（username、password）等。</p><p>用法：</p><pre><code>from django.contrib.auth.models import Useruser = User.objects.create_superuser（username='用户名',password='密码',email='邮箱',...）</code></pre><p>auth 提供的一个检查密码是否正确的方法，需要提供当前请求用户的密码。</p><p>密码正确返回True，否则返回False。</p><p>用法：</p><pre><code>ok = user.check_password('密码')</code></pre><p>auth 提供的一个修改密码的方法，接收 要设置的新密码 作为参数。</p><p>注意：设置完一定要调用用户对象的save方法！！！</p><p>用法：</p><pre><code>user.set_password(password='')user.save()</code></pre><p><strong>一个修改密码功能的简单示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> 修改密码示例</p><p>User对象属性：username， password</p><p>is_staff ： 用户是否拥有网站的管理权限.</p><p>is_active ： 是否允许用户登录, 设置为 False，可以在不删除用户的前提下禁止用户登录。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9537320.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="扩展默认的auth-user表"><a href="#扩展默认的auth-user表" class="headerlink" title="扩展默认的auth_user表"></a>扩展默认的auth_user表</h2><p>这内置的认证系统这么好用，但是auth_user表字段都是固定的那几个，我在项目中没法拿来直接使用啊！</p><p>比如，我想要加一个存储用户手机号的字段，怎么办？</p><p>聪明的你可能会想到新建另外一张表然后通过一对一和内置的auth_user表关联，这样虽然能满足要求但是有没有更好的实现方式呢？</p><p>答案是当然有了。</p><p>我们可以通过继承内置的 AbstractUser 类，来定义一个自己的Model类。</p><p>这样既能根据项目需求灵活的设计用户表，又能使用Django强大的认证系统了。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.contrib.auth.models import AbstractUserclass UserInfo(AbstractUser):    """    用户信息表    """    nid = models.AutoField(primary_key=True)    phone = models.CharField(max_length=11, null=True, unique=True)    def __str__(self):        return self.username</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>注意：</p><p>按上面的方式扩展了内置的auth_user表之后，一定要在settings.py中告诉Django，我现在使用我新定义的UserInfo表来做用户认证。写法如下：</p><pre><code># 引用Django自带的User表，继承使用时需要设置AUTH_USER_MODEL = "app名.UserInfo"</code></pre><p>再次注意：</p><p>一旦我们指定了新的认证系统所使用的表，我们就需要重新在数据库中创建该表，而不能继续使用原来默认的auth_user表了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础十之Form和ModelForm组件</title>
      <link href="2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B9%8BForm%E5%92%8CModelForm%E7%BB%84%E4%BB%B6/"/>
      <url>2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B9%8BForm%E5%92%8CModelForm%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-html"><code class="language-html">**本节目录**- [一 Form介绍](https://www.cnblogs.com/clschao/articles/10486468.html#part_1)- [二 Form常用字段和插件](https://www.cnblogs.com/clschao/articles/10486468.html#part_2)- [三 From所有内置字段](https://www.cnblogs.com/clschao/articles/10486468.html#part_3)- [四 字段校验](https://www.cnblogs.com/clschao/articles/10486468.html#part_4)- [五 Hook钩子方法](https://www.cnblogs.com/clschao/articles/10486468.html#part_5)- [六 进阶补充](https://www.cnblogs.com/clschao/articles/10486468.html#part_6)- [七 ModelForm](https://www.cnblogs.com/clschao/articles/10486468.html#part_7)- [八 xxx](https://www.cnblogs.com/clschao/articles/10486468.html#part_8)- ### 一 Form介绍　　　　我们之前在HTML页面中利用form表单向后端提交数据时，都会写一些获取用户输入的标签并且用form标签把它们包起来。　　与此同时我们在好多场景下都需要对用户的输入做校验，比如校验用户是否输入，输入的长度和格式等正不正确。如果用户输入的内容有错误就需要在页面上相应的位置显示对应的错误信息.。　　Django form组件就实现了上面所述的功能。　　总结一下，其实form组件的主要功能如下:　　　　生成页面可用的HTML标签　　　　对用户提交的数据进行校验　　　　保留上次输入内容　　## 普通方式手写注册功能### views.py[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```# 注册def register(request):    error_msg = ""    if request.method == "POST":        username = request.POST.get("name")        pwd = request.POST.get("pwd")        # 对注册信息做校验        if len(username) &lt; 6:            # 用户长度小于6位            error_msg = "用户名长度不能小于6位"        else:            # 将用户名和密码存到数据库            return HttpResponse("注册成功")    return render(request, "register.html", {"error_msg": error_msg})```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### login.html[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>注册页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/reg/<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    {% csrf_token %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        用户名:        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        密码：        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>注册<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{ error_msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 使用form组件实现注册功能### views.py　　　　　　先定义好一个RegForm类：```from django import forms# 按照Django form组件的要求自己写一个类class RegForm(forms.Form):    name = forms.CharField(label="用户名")    pwd = forms.CharField(label="密码")```　　　　　　再写一个视图函数：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```# 使用form组件实现注册方式def register2(request):    form_obj = RegForm()    if request.method == "POST":        # 实例化form对象的时候，把post提交过来的数据直接传进去        form_obj = RegForm(request.POST)        # 调用form_obj校验数据的方法        if form_obj.is_valid():            return HttpResponse("注册成功")    return render(request, "register2.html", {"form_obj": form_obj})```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### login2.html[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>注册2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/reg2/<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">novalidate</span> <span class="token attr-name">autocomplete</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>off<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        {% csrf_token %}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ form_obj.name.id_for_label }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{ form_obj.name.label }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>            {{ form_obj.name }} {{ form_obj.name.errors.0 }}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ form_obj.pwd.id_for_label }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{ form_obj.pwd.label }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>            {{ form_obj.pwd }} {{ form_obj.pwd.errors.0 }}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn btn-success<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>注册<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　看网页效果发现 也验证了form的功能：　　　　　　前端页面是form类的对象生成的                                      -->生成HTML标签功能　　　　　　当用户名和密码输入为空或输错之后 页面都会提示        -->用户提交校验功能　　　　　　当用户输错之后 再次输入 上次的内容还保留在input框   -->保留上次输入内容### 二 Form常用字段与插件　　　　创建Form类时，主要涉及到 【字段】 和 【插件】，字段用于对用户请求数据的验证，插件用于自动生成HTML;### initial　　　　初始值，input框里面的初始值。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    username = forms.CharField(        min_length=8,        label="用户名",        initial="张三"  # 设置默认值    )    pwd = forms.CharField(min_length=6, label="密码")```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### error_messages　　　　重写错误信息。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    username = forms.CharField(        min_length=8,        label="用户名",        initial="张三",        error_messages={            "required": "不能为空",            "invalid": "格式错误",            "min_length": "用户名最短8位"        }    )    pwd = forms.CharField(min_length=6, label="密码")```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### password[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    ...    pwd = forms.CharField(        min_length=6,        label="密码",        widget=forms.widgets.PasswordInput(attrs={'class': 'c1'}, render_value=True)    )```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### radioSelect　　　　单radio值为字符串[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    username = forms.CharField(        min_length=8,        label="用户名",        initial="张三",        error_messages={            "required": "不能为空",            "invalid": "格式错误",            "min_length": "用户名最短8位"        }    )    pwd = forms.CharField(min_length=6, label="密码")    gender = forms.fields.ChoiceField(        choices=((1, "男"), (2, "女"), (3, "保密")),        label="性别",        initial=3,        widget=forms.widgets.RadioSelect()    )```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 单选Select[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    ...    hobby = forms.fields.ChoiceField(        choices=((1, "篮球"), (2, "足球"), (3, "双色球"), ),        label="爱好",        initial=3,        widget=forms.widgets.Select()    )```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 多选Select[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    ...    hobby = forms.fields.MultipleChoiceField(        choices=((1, "篮球"), (2, "足球"), (3, "双色球"), ),        label="爱好",        initial=[1, 3],        widget=forms.widgets.SelectMultiple()    )```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 单选checkbox[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    ...    keep = forms.fields.ChoiceField(        label="是否记住密码",        initial="checked",        widget=forms.widgets.CheckboxInput()    )```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 多选checkbox[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    ...    hobby = forms.fields.MultipleChoiceField(        choices=((1, "篮球"), (2, "足球"), (3, "双色球"),),        label="爱好",        initial=[1, 3],        widget=forms.widgets.CheckboxSelectMultiple()    )```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### choice字段注意事项　　　　在使用选择标签时，需要注意choices的选项可以配置从数据库中获取，但是由于是静态字段 获取的值无法实时更新，需要重写构造方法从而实现choice实时更新。　　　　方式一：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```from django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsclass MyForm(Form):    user = fields.ChoiceField(        # choices=((1, '上海'), (2, '北京'),),        initial=2,        widget=widgets.Select    )    def __init__(self, *args, **kwargs):        super(MyForm,self).__init__(*args, **kwargs)        # self.fields['user'].choices = ((1, '上海'), (2, '北京'),)        # 或        self.fields['user'].choices = models.Classes.objects.all().values_list('id','caption')```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　方式二：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```from django import formsfrom django.forms import fieldsfrom django.forms import models as form_modelclass FInfo(forms.Form):    authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())  # 多选    # authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all())  # 单选```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　### 三 Form所有内置字段 内置字段：![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/ContractedBlock.gif) 内置字段### 四 字段校验### RegexValidator验证器[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```from django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsfrom django.core.validators import RegexValidatorclass MyForm(Form):    user = fields.CharField(        validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')],    )```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 自定义验证函数[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```import refrom django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsfrom django.core.exceptions import ValidationError# 自定义验证规则def mobile_validate(value):    mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$')    if not mobile_re.match(value):        raise ValidationError('手机号码格式错误')class PublishForm(Form):    title = fields.CharField(max_length=20,                            min_length=5,                            error_messages={'required': '标题不能为空',                                            'min_length': '标题最少为5个字符',                                            'max_length': '标题最多为20个字符'},                            widget=widgets.TextInput(attrs={'class': "form-control",                                                          'placeholder': '标题5-20个字符'}))    # 使用自定义验证规则    phone = fields.CharField(validators=[mobile_validate, ],                            error_messages={'required': '手机不能为空'},                            widget=widgets.TextInput(attrs={'class': "form-control",                                                          'placeholder': u'手机号码'}))    email = fields.EmailField(required=False,                            error_messages={'required': u'邮箱不能为空','invalid': u'邮箱格式错误'},                            widget=widgets.TextInput(attrs={'class': "form-control", 'placeholder': u'邮箱'}))```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 五 Hook钩子方法　　除了上面两种方式，我们还可以在Form类中定义钩子函数，来实现自定义的验证功能。### 局部钩子　　　　我们在Fom类中定义 clean_字段名() 方法，就能够实现对特定字段进行校验。　　　　举个例子：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    username = forms.CharField(        min_length=8,        label="用户名",        initial="张三",        error_messages={            "required": "不能为空",            "invalid": "格式错误",            "min_length": "用户名最短8位"        },        widget=forms.widgets.TextInput(attrs={"class": "form-control"})    )    ...    # 定义局部钩子，用来校验username字段    def clean_username(self):        value = self.cleaned_data.get("username")        if "666" in value:            raise ValidationError("光喊666是不行的")        else:            return value```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 全局钩子　　　　我们在Fom类中定义 clean() 方法，就能够实现对字段进行全局校验。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    ...    password = forms.CharField(        min_length=6,        label="密码",        widget=forms.widgets.PasswordInput(attrs={'class': 'form-control'}, render_value=True)    )    re_password = forms.CharField(        min_length=6,        label="确认密码",        widget=forms.widgets.PasswordInput(attrs={'class': 'form-control'}, render_value=True)    )    ...    # 定义全局的钩子，用来校验密码和确认密码字段是否相同    def clean(self):        password_value = self.cleaned_data.get('password')        re_password_value = self.cleaned_data.get('re_password')        if password_value == re_password_value:            return self.cleaned_data        else:            self.add_error('re_password', '两次密码不一致')            raise ValidationError('两次密码不一致')```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 六 进阶补充### 应用Bootstrap样式　　　　Django form应用Bootstrap样式简单示例：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>x-ua-compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/bootstrap/css/bootstrap.min.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>login<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>row<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login2/<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">novalidate</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-horizontal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      {% csrf_token %}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ form_obj.username.id_for_label }}<span class="token punctuation">"</span></span>               <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-md-2 control-label<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{ form_obj.username.label }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-md-10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          {{ form_obj.username }}          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>help-block<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{ form_obj.username.errors.0 }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ form_obj.pwd.id_for_label }}<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-md-2 control-label<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{ form_obj.pwd.label }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-md-10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          {{ form_obj.pwd }}          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>help-block<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{ form_obj.pwd.errors.0 }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-md-2 control-label<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{ form_obj.gender.label }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-md-10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            {% for radio in form_obj.gender %}              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ radio.id_for_label }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                {{ radio.tag }}{{ radio.choice_label }}              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>            {% endfor %}          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-md-offset-2 col-md-10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn btn-default<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>注册<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/jquery-3.2.1.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/bootstrap/js/bootstrap.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 批量添加样式　　　　可通过重写form类的init方法来实现。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class LoginForm(forms.Form):    username = forms.CharField(        min_length=8,        label="用户名",        initial="张三",        error_messages={            "required": "不能为空",            "invalid": "格式错误",            "min_length": "用户名最短8位"        }    ...    def __init__(self, *args, **kwargs):        super(LoginForm, self).__init__(*args, **kwargs)        for field in iter(self.fields):            self.fields[field].widget.attrs.update({                'class': 'form-control'            })```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 七 ModelForm　　通常在Django项目中，我们编写的大部分都是与Django 的模型紧密映射的表单。 举个例子，你也许会有个Book 模型，并且你还想创建一个form表单用来添加和编辑书籍信息到这个模型中。 在这种情况下，在form表单中定义字段将是冗余的，因为我们已经在模型中定义了那些字段。　　基于这个原因，Django 提供一个辅助类来让我们可以从Django 的模型创建Form，这就是ModelForm。### modelForm定义　　　　form与model的终极结合。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```class BookForm(forms.ModelForm):    class Meta:        model = models.Book        fields = "__all__"        labels = {            "title": "书名",            "price": "价格"        }        widgets = {            "password": forms.widgets.PasswordInput(attrs={"class": "c1"}),        }```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### class Meta下常用参数：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```model = models.Book  # 对应的Model中的类fields = "__all__"  # 字段，如果是__all__,就是表示列出所有的字段exclude = None  # 排除的字段labels = None  # 提示信息help_texts = None  # 帮助提示信息widgets = None  # 自定义插件error_messages = None  # 自定义错误信息```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### ModelForm的验证　　　　与普通的Form表单验证类型类似，ModelForm表单的验证在调用is_valid() 或访问errors 属性时隐式调用。　　　　我们可以像使用Form类一样自定义局部钩子方法和全局钩子方法来实现自定义的校验规则。　　　　如果我们不重写具体字段并设置validators属性的化，ModelForm是按照模型中字段的validators来校验的。### save()方法　　　　每个ModelForm还具有一个save()方法。 这个方法根据表单绑定的数据创建并保存数据库对象。 ModelForm的子类可以接受现有的模型实例作为关键字参数instance；如果提供此功能，则save()将更新该实例。 如果没有提供，save() 将创建模型的一个新实例：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```>>> from myapp.models import Book>>> from myapp.forms import BookForm# 根据POST数据创建一个新的form对象>>> form_obj = BookForm(request.POST)# 创建书籍对象>>> new_ book = form_obj.save()# 基于一个书籍对象创建form对象>>> edit_obj = Book.objects.get(id=1)# 使用POST提交的数据更新书籍对象>>> form_obj = BookForm(request.POST, instance=edit_obj)>>> form_obj.save()```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础三之视图函数</title>
      <link href="2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%B8%89%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0/"/>
      <url>2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%B8%89%E4%B9%8B%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10409764.html#part_1">一 Django的视图函数view</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10409764.html#part_2">二 CBV和FBV</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10409764.html#part_3">三 使用Mixin</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10409764.html#part_4">四 给视图加装饰器</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10409764.html#part_5">五 Request对象</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10409764.html#part_6">六 Response对象</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10409764.html#part_7"> </a></li></ul><h3 id="一-Django的视图函数view"><a href="#一-Django的视图函数view" class="headerlink" title="一 Django的视图函数view"></a>一 Django的视图函数view</h3><p>　　</p><p>　　一个视图函数（类），简称视图，是一个简单的Python 函数（类），它接受Web请求并且返回Web响应。</p><p>　　响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片。</p><p>　　无论视图本身包含什么逻辑，都要返回响应。代码写在哪里也无所谓，只要它在你当前项目目录下面。除此之外没有更多的要求了——可以说“没有什么神奇的地方”。为了将代码放在某处，大家约定成俗将视图放置在项目（project）或应用程序（app）目录中的名为<code>views.py</code>的文件中。</p><h3 id="一个简单的视图"><a href="#一个简单的视图" class="headerlink" title="　　一个简单的视图"></a>　　一个简单的视图</h3><p>　　下面是一个以HTML文档的形式返回当前日期和时间的视图：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.http import HttpResponseimport datetimedef current_datetime(request):    now = datetime.datetime.now()    html = "&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;" % now    return HttpResponse(html)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　让我们来逐行解释下上面的代码：</p><ul><li><p>首先，我们从 <code>django.http</code>模块导入了<code>HttpResponse</code>类，以及Python的<code>datetime</code>库。</p></li><li><p>接着，我们定义了<code>current_datetime</code>函数。它就是视图函数。每个视图函数都使用<code>HttpRequest</code>对象作为第一个参数，并且通常称之为<code>request</code>。</p><p>注意，视图函数的名称并不重要；不需要用一个统一的命名方式来命名，以便让Django识别它。我们将其命名为<code>current_datetime</code>，是因为这个名称能够比较准确地反映出它实现的功能。</p></li><li><p>这个视图会返回一个<code>HttpResponse</code>对象，其中包含生成的响应。每个视图函数都负责返回一个<code>HttpResponse</code>对象。</p></li></ul><p>　　Django使用请求和响应对象来通过系统传递状态。</p><p>　　当浏览器向服务端请求一个页面时，Django创建一个HttpRequest对象，该对象包含关于请求的元数据。然后，Django加载相应的视图，将这个HttpRequest对象作为第一个参数传递给视图函数。</p><p>　　每个视图负责返回一个HttpResponse对象。</p><p>　　</p><h4 id=""><a href="#" class="headerlink" title="　　　　"></a>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20160725101445044-1768854009.jpg" alt="img"></h4><p>　　视图层，熟练掌握两个对象即可：请求对象(request)和响应对象(HttpResponse)</p><p>　　</p><h3 id="二-CBV和FBV"><a href="#二-CBV和FBV" class="headerlink" title="二 CBV和FBV"></a>二 CBV和FBV</h3><p>　　<strong>FBV（function base views）</strong> 就是在视图里使用函数处理请求。</p><p>　　　　之前都是FBV模式写的代码，所以就不写例子了。</p><p>　　<strong>CBV（class base views）</strong> 就是在视图里使用类处理请求。</p><p>　　Python是一个面向对象的编程语言，如果只用函数来开发，有很多面向对象的优点就错失了（继承、封装、多态）。所以Django在后来加入了Class-Based-View。可以让我们用类写View。这样做的优点主要下面两种：</p><ol><li>提高了代码的复用性，可以使用面向对象的技术，比如Mixin（多继承）</li><li>可以用不同的函数针对不同的HTTP方法处理，而不是通过很多if判断，提高代码可读性</li></ol><p>　　</p><p>　　　　如果我们要写一个处理GET方法的view，用函数写的话是下面这样。</p><pre><code>from django.http import HttpResponsedef my_view(request):     if request.method == 'GET':            return HttpResponse('OK')</code></pre><p>　　　　如果用class-based view写的话，就是下面这样</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.http import HttpResponsefrom django.views import Viewclass MyView(View):      def get(self, request):            return HttpResponse('OK')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　Django的url是将一个请求分配给可调用的函数的，而不是一个class。针对这个问题，class-based view提供了一个<code>as_view()</code>静态方法（也就是类方法），调用这个方法，会创建一个类的实例，然后通过实例调用<code>dispatch()</code>方法，<code>dispatch()</code>方法会根据request的method的不同调用相应的方法来处理request（如<code>get() </code>,<code> post()</code>等）。到这里，这些方法和function-based view差不多了，要接收request，得到一个response返回。如果方法没有定义，会抛出HttpResponseNotAllowed异常。</p><p>　　　　注意：使用CBV时，urls.py中也做对应的修改：：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code># urls.pyfrom django.conf.urls import urlfrom myapp.views import MyView #引入我们在views.py里面创建的类urlpatterns = [     url(r'^index/$', MyView.as_view()),]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　CBV传参，和FBV类似，有名分组，无名分组</p><p>　　　　url写法：无名分组的</p><pre><code> url(r'^cv/(\d{2})/', views.Myd.as_view(),name='cv'), url(r'^cv/(?P&lt;n&gt;\d{2})/', views.Myd.as_view(name='xxx'),name='cv'),#如果想给类的name属性赋值，前提你的Myd类里面必须有name属性（类属性，定义init方法来接受属性行不通，但是可以自行研究一下，看看如何行通，意义不大），并且之前类里面的name属性的值会被覆盖掉</code></pre><p>　　　　类写法：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>class Myd(View):    name = 'sb'    def get(self,request,n):        print('get方法执行了')        print('&gt;&gt;&gt;',n)        return render(request,'cvpost.html',{'name':self.name})    def post(self,request,n):        print('post方法被执行了')        return HttpResponse('post')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　添加类的属性可以通过两种方法设置，第一种是常见的Python的方法，可以被子类覆盖。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.http import HttpResponsefrom django.views import Viewclass GreetingView(View):    name = "yuan"    def get(self, request):         return HttpResponse(self.name)# You can override that in a subclassclass MorningGreetingView(GreetingView):    name= "alex"</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　第二种方法，你也可以在url中指定类的属性：</p><p>　　　　在url中设置类的属性Python</p><pre><code>urlpatterns = [   url(r'^index/$', GreetingView.as_view(name="egon")), #类里面必须有name属性，并且会被传进来的这个属性值给覆盖掉]</code></pre><p>　　</p><h3 id="三-使用Mixin（了解）"><a href="#三-使用Mixin（了解）" class="headerlink" title="三 使用Mixin（了解）"></a>三 使用Mixin（了解）</h3><p>　　我觉得要理解django的class-based-view（以下简称cbv），首先要明白django引入cbv的目的是什么。在django1.3之前，generic view也就是所谓的通用视图，使用的是function-based-view（fbv），亦即基于函数的视图。有人认为fbv比cbv更pythonic，窃以为不然。python的一大重要的特性就是面向对象。而cbv更能体现python的面向对象。cbv是通过class的方式来实现视图方法的。class相对于function，更能利用多态的特定，因此更容易从宏观层面上将项目内的比较通用的功能抽象出来。关于多态，不多解释，有兴趣的同学自己Google。总之可以理解为一个东西具有多种形态（的特性）。cbv的实现原理通过看django的源码就很容易明白，大体就是由url路由到这个cbv之后，通过cbv内部的dispatch方法进行分发，将get请求分发给cbv.get方法处理，将post请求分发给cbv.post方法处理，其他方法类似。怎么利用多态呢？cbv里引入了mixin的概念。Mixin就是写好了的一些基础类，然后通过不同的Mixin组合成为最终想要的类。</p><p>　　所以，理解cbv的基础是，理解Mixin。Django中使用Mixin来重用代码，一个View Class可以继承多个Mixin，但是只能继承一个View（包括View的子类），推荐把View写在最右边，多个Mixin写在左边。</p><h3 id="四-给视图加装饰器"><a href="#四-给视图加装饰器" class="headerlink" title="四 给视图加装饰器"></a>四 给视图加装饰器</h3><h3 id="使用装饰器装饰FBV"><a href="#使用装饰器装饰FBV" class="headerlink" title="　　使用装饰器装饰FBV"></a>　　使用装饰器装饰FBV</h3><p>　　　　FBV本身就是一个函数，所以和给普通的函数加装饰器无差：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>def wrapper(func):    def inner(*args, **kwargs):        start_time = time.time()        ret = func(*args, **kwargs)        end_time = time.time()        print("used:", end_time-start_time)        return ret    return inner# FBV版添加班级@wrapperdef add_class(request):    if request.method == "POST":        class_name = request.POST.get("class_name")        models.Classes.objects.create(name=class_name)        return redirect("/class_list/")    return render(request, "add_class.html")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>使用装饰器装饰CBV</strong></p><p>　　　　类中的方法与独立函数不完全相同，因此不能直接将函数装饰器应用于类中的方法 ，我们需要先将其转换为方法装饰器。</p><p>　　　　Django中提供了method_decorator装饰器用于将函数装饰器转换为方法装饰器。</p><p>　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.views import Viewfrom django.utils.decorators import method_decoratorclass AddClass(View):    @method_decorator(wrapper)    def get(self, request):        return render(request, "add_class.html")    def post(self, request):        class_name = request.POST.get("class_name")        models.Classes.objects.create(name=class_name)        return redirect("/class_list/")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　下面是扩展内容，大家看看就可以了：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code># 使用CBV时要注意，请求过来后会先执行dispatch()这个方法，如果需要批量对具体的请求处理方法，如get，post等做一些操作的时候，这里我们可以手动改写dispatch方法，这个dispatch方法就和在FBV上加装饰器的效果一样。class Login(View):    def dispatch(self, request, *args, **kwargs):        print('before')        obj = super(Login,self).dispatch(request, *args, **kwargs)        print('after')        return obj    def get(self,request):        return render(request,'login.html')    def post(self,request):        print(request.POST.get('user'))        return HttpResponse('Login.post')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>另外给cbv添加装饰器的时候（先作为了解）：</p><ul><li><p>直接添加在dispatch里面，这样每个函数都会执行</p><p>from django.utils.decorators import method_decorator</p><p>@method_decorator(login_test)<br>def dispatch(self, request, <em>args, **kwargs):<br>res = super(IndexView, self).dispatch(request, *args, *</em>kwargs)<br>return res</p></li><li><p>添加在每一个函数中</p><p>from django.utils.decorators import method_decorator</p><p>@method_decorator(login_test)<br>def get(self, request, *args, **kwargs):<br>return render(request, ‘index.html’)</p></li><li><p>直接添加在类上，后面的name表示只给get添加装饰器</p><p>from django.utils.decorators import method_decorator</p><p>@method_decorator(login_test, name=’get’)  get是给get方法加<br>class IndexView(View):</p></li></ul><p>　　　　def get(self,request)：</p><p>　　　　　　pass</p><ul><li>添加装饰器前必须导入from django.utils.decorators import method_decorator</li><li>添加装饰器的格式必须为@method_decorator()，括号里面为装饰器的函数名</li><li>给类添加是必须声明name</li><li>注意csrf-token装饰器的特殊性，它只能加在dispatch上面</li></ul><h3 id="五-request对象"><a href="#五-request对象" class="headerlink" title="五 request对象"></a>五 request对象</h3><p>当一个页面被请求时，Django就会创建一个包含本次请求原信息（请求报文中的请求行、首部信息、内容主体等）的HttpRequest对象。<br>　　Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。</p><p>　　当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。<br>　　Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。</p><p>　　<a href="https://docs.djangoproject.com/en/1.11/ref/request-response/">官方文档</a></p><h3 id="请求相关的常用值"><a href="#请求相关的常用值" class="headerlink" title="　　请求相关的常用值"></a>　　请求相关的常用值</h3><ul><li><p><strong>path_info</strong>     返回用户访问url，不包括域名</p></li><li><p><strong>method</strong>        请求中使用的HTTP方法的字符串表示，全大写表示。</p></li><li><p><strong>GET</strong>              包含所有HTTP  GET参数的类字典对象</p></li><li><p><strong>POST</strong>           包含所有HTTP POST参数的类字典对象</p></li><li><p><strong>body</strong>            请求体，byte类型 request.POST的数据就是从body里面提取到的</p></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="　　属性"></a>　　属性</h3><p>　　所有的属性应该被认为是只读的，除非另有说明。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>属性：　　django将请求报文中的请求行、头部信息、内容主体封装成 HttpRequest 类中的属性。   除了特殊说明的之外，其他均为只读的。0.HttpRequest.scheme（后面再学）   表示请求方案的字符串（通常为http或https）1.HttpRequest.body(后面再学)　　一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML,Json等。　　但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。　　另外，我们还可以用 python 的类文件方法去操作它，详情参考 HttpRequest.read() 。2.HttpRequest.path　　一个字符串，表示请求的路径组件（不含域名）。　　例如："/music/bands/the_beatles/"3.HttpRequest.method　　一个字符串，表示请求使用的HTTP 方法。必须使用大写。　　例如："GET"、"POST"4.HttpRequest.encoding　　一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 'utf-8'）。   这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。   接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。   如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。5.HttpRequest.GET 　　一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。6.HttpRequest.POST　　一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。　　POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是表单中没有任何的数据，QueryDict 对象依然会被创建。   因此，不应该使用 if request.POST  来检查使用的是否是POST 方法；应该使用 if request.method == "POST" 　　另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。 7.HttpRequest.COOKIES　　一个标准的Python 字典，包含所有的cookie。键和值都为字符串。8.HttpRequest.FILES　　一个类似于字典的对象，包含所有的上传文件信息。   FILES 中的每个键为&lt;input type="file" name="" /&gt; 中的name，值则为对应的数据。　　注意，FILES 只有在请求的方法为POST 且提交的&lt;form&gt; 带有enctype="multipart/form-data" 的情况下才会   包含数据。否则，FILES 将为一个空的类似于字典的对象。9.HttpRequest.META 　　一个标准的Python 字典，包含所有的HTTP 首部（请求头信息）。具体的头部信息取决于客户端和服务器，下面是一些示例：    CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。    CONTENT_TYPE —— 请求的正文的MIME 类型。    HTTP_ACCEPT —— 响应可接收的Content-Type。    HTTP_ACCEPT_ENCODING —— 响应可接收的编码。    HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。    HTTP_HOST —— 客服端发送的HTTP Host 头部。    HTTP_REFERER —— Referring 页面。    HTTP_USER_AGENT —— 客户端的user-agent 字符串。    QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。    REMOTE_ADDR —— 客户端的IP 地址。    REMOTE_HOST —— 客户端的主机名。    REMOTE_USER —— 服务器认证后的用户。    REQUEST_METHOD —— 一个字符串，例如"GET" 或"POST"。    SERVER_NAME —— 服务器的主机名。    SERVER_PORT —— 服务器的端口（是一个字符串）。 　　从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，请求中的任何 HTTP 首部转换为 META 的键时，    都会将所有字母大写并将连接符替换为下划线最后加上 HTTP_  前缀。    所以，一个叫做 X-Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。10.HttpRequest.user　　一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。　　如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。你可以通过 is_authenticated() 区分它们。    例如：    if request.user.is_authenticated():        # Do something for logged-in users.    else:        # Do something for anonymous users.     　　user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。     -------------------------------------------------------------------------------------    匿名用户    class models.AnonymousUser    django.contrib.auth.models.AnonymousUser 类实现了django.contrib.auth.models.User 接口，但具有下面几个不同点：    id 永远为None。    username 永远为空字符串。    get_username() 永远返回空字符串。    is_staff 和 is_superuser 永远为False。    is_active 永远为 False。    groups 和 user_permissions 永远为空。    is_anonymous() 返回True 而不是False。    is_authenticated() 返回False 而不是True。    set_password()、check_password()、save() 和delete() 引发 NotImplementedError。    New in Django 1.8:    新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。11.HttpRequest.session 　　一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。    完整的细节参见会话的文档。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　上传文件示例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>def upload(request):    """    保存上传文件前，数据需要存放在某个位置。默认当上传文件小于2.5M时，django会将上传文件的全部内容读进内存。从内存读取一次，写磁盘一次。    但当上传文件很大时，django会把上传文件写到临时文件中，然后存放到系统临时文件夹中。    :param request:     :return:     """    if request.method == "POST":        # 从请求的FILES中获取上传文件的文件名，file为页面上type=files类型input的name属性值        filename = request.FILES["file"].name        # 在项目目录下新建一个文件        with open(filename, "wb") as f:            # 从上传的文件对象中一点一点读            for chunk in request.FILES["file"].chunks():                # 写入本地文件                f.write(chunk)        return HttpResponse("上传OK")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>方法</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>1.HttpRequest.get_host()　　根据从HTTP_X_FORWARDED_HOST（如果打开 USE_X_FORWARDED_HOST，默认为False）和 HTTP_HOST 头部信息返回请求的原始主机。   如果这两个头部没有提供相应的值，则使用SERVER_NAME 和SERVER_PORT，在PEP 3333 中有详细描述。　　USE_X_FORWARDED_HOST：一个布尔值，用于指定是否优先使用 X-Forwarded-Host 首部，仅在代理设置了该首部的情况下，才可以被使用。　　例如："127.0.0.1:8000"　　注意：当主机位于多个代理后面时，get_host() 方法将会失败。除非使用中间件重写代理的首部。2.HttpRequest.get_full_path()　　返回 path，如果可以将加上查询字符串。　　例如："/music/bands/the_beatles/?print=true"3.HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)　　返回签名过的Cookie 对应的值，如果签名不再合法则返回django.core.signing.BadSignature。　　如果提供 default 参数，将不会引发异常并返回 default 的值。　　可选参数salt 可以用来对安全密钥强力攻击提供额外的保护。max_age 参数用于检查Cookie 对应的时间戳以确保Cookie 的时间不会超过max_age 秒。        复制代码        &gt;&gt;&gt; request.get_signed_cookie('name')        'Tony'        &gt;&gt;&gt; request.get_signed_cookie('name', salt='name-salt')        'Tony' # 假设在设置cookie的时候使用的是相同的salt        &gt;&gt;&gt; request.get_signed_cookie('non-existing-cookie')        ...        KeyError: 'non-existing-cookie'    # 没有相应的键时触发异常        &gt;&gt;&gt; request.get_signed_cookie('non-existing-cookie', False)        False        &gt;&gt;&gt; request.get_signed_cookie('cookie-that-was-tampered-with')        ...        BadSignature: ...            &gt;&gt;&gt; request.get_signed_cookie('name', max_age=60)        ...        SignatureExpired: Signature age 1677.3839159 &gt; 60 seconds        &gt;&gt;&gt; request.get_signed_cookie('name', False, max_age=60)        False        复制代码4.HttpRequest.is_secure()　　如果请求时是安全的，则返回True；即请求通是过 HTTPS 发起的。5.HttpRequest.is_ajax()　　如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest'。　　大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。　　如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware，    你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图以让响应能够正确地缓存。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　</p><p>　　按照下面的方式打印一下看看：</p><p>　　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.shortcuts import render,HttpResponse,redirect# Create your views here.def index(request):    print(request.method) #请求方式    print(request.path)   #请求路径，不带参数的    print(request.POST)   #post请求数据  字典格式    print(request.GET)    #get的请求数据  字典格式    print(request.META)   #请求头信息,将来用到哪个咱们再说哪个    print(request.get_full_path())   #获取请求路径带参数的，/index/?a=1    print(request.is_ajax())   #判断是不是ajax发送的请求，True和False    '''        Django一定最后会响应一个HttpResponse的示例对象        三种形式：            1 HttpResponse('字符串') 最简单            2 render(页面)   最重要                2.1 两个功能                    -- 读取文件字符串                    -- 嵌入变量(模板渲染) html里面：{{ name }} ， {'name':'chao'}作为render的第三个参数，想写多个变量{'name':'chao','hobby':['篮球','羽毛球']....}            3 redirect() 重定向  最难理解,某个网站搬家了，网址变了，访问原来的网址就重定向到一个新网址，就叫做重定向，网站自己做的重定向，你访问还是访问的你之前的，你自己啥也不用做，浏览器发送请求，然后服务端响应，然后服务端告诉浏览器，你直接跳转到另外一个网址上，那么浏览器又自动发送了另外一个请求，发送到服务端，服务端返回一个页面，包含两次请求，登陆成功后跳转到网站的首页，网站首页的网址和你login登陆页面的网址是不用的。    '''    return render(request,'index.html',{'name':'chao'})    # return HttpResponse('ok')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用：</p><pre><code>request.POST.getlist("hobby")</code></pre><h3 id="六-response对象"><a href="#六-response对象" class="headerlink" title="六 response对象"></a>六 response对象</h3><p>　　与由Django自动创建的HttpRequest对象相比，HttpResponse对象是我们的职责范围了。我们写的每个视图都需要实例化，填充和返回一个HttpResponse。</p><p>　　HttpResponse类位于django.http模块中。</p><h3 id="使用"><a href="#使用" class="headerlink" title="　　使用"></a>　　使用</h3><p>　　　　传递字符串</p><pre><code>from django.http import HttpResponseresponse = HttpResponse("Here's the text of the Web page.")response = HttpResponse("Text only, please.", content_type="text/plain")</code></pre><p>　　　　设置或删除响应头信息</p><pre><code>response = HttpResponse()response['Content-Type'] = 'text/html; charset=UTF-8'del response['Content-Type']</code></pre><p>　　<strong>属性</strong></p><p>　　　　HttpResponse.content：响应内容</p><p>　　　　HttpResponse.charset：响应内容的编码</p><p>　　　　HttpResponse.status_code：响应的状态码</p><h3 id="JsonResponse对象（后面再学）"><a href="#JsonResponse对象（后面再学）" class="headerlink" title="　　JsonResponse对象（后面再学）"></a>　　JsonResponse对象（后面再学）</h3><p>　　　　JsonResponse是HttpResponse的子类，专门用来生成JSON编码的响应。</p><pre><code>from django.http import JsonResponseresponse = JsonResponse({'foo': 'bar'})print(response.content)b'{"foo": "bar"}'</code></pre><p>　　　　默认只能传递字典类型，如果要传递非字典类型需要设置一下safe关键字参数。</p><pre><code>response = JsonResponse([1, 2, 3], safe=False)</code></pre><p>　　响应对象主要有三种形式：</p><ul><li>HttpResponse()</li><li>render()</li><li>redirect() </li></ul><p>　　HttpResponse()括号内直接跟一个具体的字符串作为响应体，比较直接很简单，所以这里主要介绍后面两种形式。</p><h3 id="Django-shortcut-functions"><a href="#Django-shortcut-functions" class="headerlink" title="　　Django shortcut functions"></a>　　Django shortcut functions</h3><h3 id="render"><a href="#render" class="headerlink" title="　　　　render()"></a>　　　　render()</h3><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180329215116152-275073384.png" alt="img"></p><p>　　　　　　结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。</p><pre><code>　　　　　　参数：　　　　　　　　request： 用于生成响应的请求对象。　　　　　　　　template_name：要使用的模板的完整名称，可选的参数　　　　　　　　context：添加到模板上下文的一个字典。默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。　　　　　　　　content_type：生成的文档要使用的MIME类型。默认为 DEFAULT_CONTENT_TYPE 设置的值。默认为'text/html'　　　　　　　　status：响应的状态码。默认为200。　　　　　　　　useing: 用于加载模板的模板引擎的名称。　　　　　　一个简单的例子：from django.shortcuts import renderdef my_view(request):    # 视图的代码写在这里    return render(request, 'myapp/index.html', {'foo': 'bar'})</code></pre><pre><code>　　　　　　上面的代码等于（了解）：</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.http import HttpResponsefrom django.template import loaderdef my_view(request):    # 视图代码写在这里    t = loader.get_template('myapp/index.html')    c = {'foo': 'bar'}    return HttpResponse(t.render(c, request))</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="redirect-：给浏览器了一个30x的状态码"><a href="#redirect-：给浏览器了一个30x的状态码" class="headerlink" title="　　　　redirect() ：给浏览器了一个30x的状态码"></a>　　　　redirect() ：给浏览器了一个30x的状态码</h3><p>　　　　　　参数可以是：</p><p>　　　　　　　　1. 一个模型：将调用模型的<code>get_absolute_url()</code> 函数</p><p>　　　　　　　　2.一个视图，可以带有参数：将使用<code>urlresolvers.reverse</code> 来反向解析名称</p><p>　　　　　　　　3.一个绝对的或相对的URL，将原封不动的作为重定向的位置。</p><p>　　　　　　默认返回一个临时的重定向；传递<code>permanent=True</code> 可以返回一个永久的重定向。</p><p>　　　　　　示例:<a href="http://python.usyiyi.cn/documents/django_182/topics/http/shortcuts.html#examples"></a></p><p>　　　　　　你可以用多种方式使用<code>redirect()</code> 函数。</p><p>　　　　　　<strong>传递一个具体的ORM对象（了解即可）</strong></p><p>　　　　　　将调用具体ORM对象的<code>get_absolute_url()</code> 方法来获取重定向的URL：</p><pre><code>from django.shortcuts import redirectdef my_view(request):    ...    object = MyModel.objects.get(...)    return redirect(object)</code></pre><p>　　　　　　<strong>传递一个视图的名称</strong></p><pre><code>def my_view(request):    ...    return redirect('some-view-name', foo='bar')</code></pre><p>　　　　　　<strong>传递要重定向到的一个具体的网址</strong></p><pre><code>def my_view(request):    ...    return redirect('/some/url/')</code></pre><p>　　　　　　<strong>看一个例子</strong></p><p>　　　　　　　　index.html文件，内容如下　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;这是index页面&lt;/div&gt;&lt;h1&gt;{{ name }}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　　　login.html文件，内容如下</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;form action="{% url 'xxx' %}" method="post"&gt;        用户名：&lt;input type="text" name="username"&gt;        密码：&lt;input type="password" name="password"&gt;        &lt;input type="submit"&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　　　urls.py里面的内容：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [    # url(r'^admin/', admin.site.urls),    url(r'^index/', views.index),    url(r'^login/', views.login,name='xxx'),]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　　　views.py视图函数里面的内容</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.shortcuts import render,HttpResponse,redirect# Create your views here.def index(request):    return render(request,'index.html',{'name':'chao'})def login(request):    method = request.method    if method == 'GET':        return render(request,'login.html')    else:        username = request.POST.get('username')        password = request.POST.get('password')        if username == 'chao' and password == '123':            return redirect('/index/') #重定向到/index/路径，这也是发送了一个请求，别忘了在上面引入这个redirect类，和render、Httpresponse在一个地方引入            # return HttpResponse('success')        else:            return HttpResponse('失败')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　上面几个文件搞好之后，我们重启Django项目，然后登陆页面的输入网址，注意，你输入的网址端口要和你启动的django项目的端口一样。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190221173559887-69250352.png" alt="img"></p><p>　　　　　　一点击提交按钮，你看一下network里面发送了几个请求：两个请求，一个是login请求，一个index请求。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190221174234614-633318670.png" alt="img"></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190221174136644-1725338276.png" alt="img"></p><p>　　　　　　如果没有做重定向，那么你登陆完之后，还需要自己去输入首页的地址去访问网站首页，你说对不对。</p><p>　　　　　　但是如果我们在函数里面写的render来返回内容，两者有什么不同呢？</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.shortcuts import render,HttpResponse,redirect# Create your views here.def index(request):    return render(request,'index.html',{'name':'chao'})def login(request):    method = request.method    if method == 'GET':        return render(request,'login.html')    else:        username = request.POST.get('username')        password = request.POST.get('password')        if username == 'chao' and password == '123':            return redirect('/index/') #重定向到/index/路径，这也是发送了一个请求，别忘了在上面引入这个redirect类，和render、Httpresponse在一个地方引入            # return render(request,'index.html')#如果直接用render来返回页面，是一次响应就返回了页面，两者是有区别的，并且如果你用render返回index.html页面，那么这个页面里面的模板渲染语言里面需要的数据你怎么搞，如果这些数据就是人家index那个函数里面独有的呢，你怎么搞，有人可能就响了，我把所有的数据都拿过来不就行了吗，首先如果数据量很大的话，是不是都重复了，并且你想想如果用户登陆完成之后，你们有进行跳转，那么如果网速不太好，卡一下，你想刷新一下你的页面，你是不是相当于又发送了一个login请求，你刷新完之后，是不是还要让你输入用户名和密码，你想想是不是，所有咱们一般在登陆之后都做跳转。            # 并且大家注意一个问题昂：redirect('/login/')如果你重定向到你当前这个函数对应的路径下，你想想是什么想过，一直重定向自己的这个网址，浏览器会报错，当然这个注册登陆页面不会出现这个报错的情况，因为需要你用户点击提交才发送请求。你可以试试那个index函数，里面返回一个redirect('/index/')            #redirect本质上也是一个HttpResponse的操作，看看源码就知道了            # return HttpResponse('success')        else:            return HttpResponse('失败')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　</p><p>　　　　<strong>当然也可以是一个完整的网址</strong></p><pre><code>def my_view(request):    ...    return redirect('http://example.com/')</code></pre><p>　　　　　　默认情况下，<code>redirect()</code> 返回一个临时重定向。以上所有的形式都接收一个<code>permanent</code> 参数；如果设置为<code>True</code>，将返回一个永久的重定向：</p><pre><code>def my_view(request):    ...    object = MyModel.objects.get(...) #学了orm之后再看吧    return redirect(object, permanent=True)　　</code></pre><p>　　　　　　<strong>扩展阅读：</strong> </p><p>　　　　　　　　key两次请求，关于301和302：　　　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>1）301和302的区别。　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取  （用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于3012）重定向原因：（1）网站调整（如改变网页目录结构）；（2）网页被移到一个新地址；（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的    网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　　　临时重定向（响应状态码：302）和永久重定向（响应状态码：301）对普通用户来说是没什么区别的，它主要面向的是搜索引擎的机器人。</p><p>　　　　　　　　A页面临时重定向到B页面，那搜索引擎收录的就是A页面。</p><p>　　　　　　　　A页面永久重定向到B页面，那搜索引擎收录的就是B页面。</p><p> 　　　　用redirect可以解释APPEND_SLASH的用法！这个不讲~~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础七之Ajax</title>
      <link href="2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%B8%83%E4%B9%8BAjax/"/>
      <url>2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%B8%83%E4%B9%8BAjax/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-html"><code class="language-html">**本节目录**- [一 Ajax简介](https://www.cnblogs.com/clschao/articles/10468335.html#part_1)- [二 Ajax使用](https://www.cnblogs.com/clschao/articles/10468335.html#part_2)- [三 Ajax请求设置csrf_token](https://www.cnblogs.com/clschao/articles/10468335.html#part_3)- [四 关于json](https://www.cnblogs.com/clschao/articles/10468335.html#part_4)- [五 补充一个SweetAlert插件(了解)](https://www.cnblogs.com/clschao/articles/10468335.html#part_5)- [六 xxx](https://www.cnblogs.com/clschao/articles/10468335.html#part_6)- [七 xxx](https://www.cnblogs.com/clschao/articles/10468335.html#part_7)- [八 xxx](https://www.cnblogs.com/clschao/articles/10468335.html#part_8)- ### 一 Ajax简介### **1.简介**　　　　AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML,现在更多使用json数据）。　　　　AJAX 不是新的编程语言，而是一种使用现有标准的新方法。　　　　AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。（这一特点给用户的感受是在不知不觉中完成请求和响应过程）　　　　AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。　　　　　　a.同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求；　　　　　　b.异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。 　　AJAX除了**异步**的特点外，还有一个就是：浏览器页面**局部刷新**；（这一特点给用户的感受是在不知不觉中完成请求和响应过程### 2.示例　　　　**页面输入两个整数，通过AJAX传输到后端计算出结果并返回。**　　　　html文件名称为ajax_demo1.html，内容如下[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>x-ua-compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>AJAX局部刷新实例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>=<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>AJAX提交<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>b1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/jquery-3.2.1.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#b1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      url<span class="token punctuation">:</span><span class="token string">"/ajax_add/"</span><span class="token punctuation">,</span>      type<span class="token punctuation">:</span><span class="token string">"GET"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token string">"i1"</span><span class="token punctuation">:</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#i1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"i2"</span><span class="token punctuation">:</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#i2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>      success<span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#i3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　views.py里面的内容：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```def ajax_demo1(request):    return render(request, "ajax_demo1.html")def ajax_add(request):    i1 = int(request.GET.get("i1"))    i2 = int(request.GET.get("i2"))    ret = i1 + i2    return JsonResponse(ret, safe=False)```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　urls.py里面的内容```urlpatterns = [    ...    url(r'^ajax_add/', views.ajax_add),    url(r'^ajax_demo1/', views.ajax_demo1),    ...   ]```　　　启动django项目，然后运行看看效果，页面不刷新### **3.AJAX****常见应用情景**　　　　搜索引擎根据用户输入的关键字，自动提示检索关键字。　　　　还有一个很重要的应用场景就是注册时候的用户名的查重。　　　　其实这里就使用了AJAX技术！当文件框发生了输入变化时，使用AJAX技术向服务器发送一个请求，然后服务器会把查询到的结果响应给浏览器，最后再把后端返回的结果展示出来。　　　　　　a.整个过程中页面没有刷新，只是刷新页面中的局部位置而已！　　　　　　b.当请求发出后，浏览器还可以进行其他操作，无需等待服务器的响应！​       　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20161025165534625-1155566124.png)　　　　当输入用户名后，把光标移动到其他表单项上时，浏览器会使用AJAX技术向服务器发出请求，服务器会查询名为lemontree7777777的用户是否存在，最终服务器返回true表示名为lemontree7777777的用户已经存在了，浏览器在得到结果后显示“用户名已被注册！”。　　　　a.整个过程中页面没有刷新，只是局部刷新了；　　　　b.在请求发出后，浏览器不用等待服务器响应结果就可以进行其他操作；### **4.AJAX****的优缺点**#### 优点：　　　　　　1.AJAX使用JavaScript技术向服务器发送异步请求；　　　　　　2.AJAX请求无须刷新整个页面；　　　　　　3.因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以AJAX性能高；### 二 Ajax的使用### 1.基于jQuery的实现　　　　看代码：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>send_Ajax<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>send_Ajax<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">       <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".send_Ajax"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>               url<span class="token punctuation">:</span><span class="token string">"/handle_Ajax/"</span><span class="token punctuation">,</span>               type<span class="token punctuation">:</span><span class="token string">"POST"</span><span class="token punctuation">,</span>               data<span class="token punctuation">:</span><span class="token punctuation">{</span>username<span class="token punctuation">:</span><span class="token string">"chao"</span><span class="token punctuation">,</span>password<span class="token punctuation">:</span><span class="token number">123</span><span class="token punctuation">}</span><span class="token punctuation">,</span>               success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>                   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>               <span class="token punctuation">}</span><span class="token punctuation">,</span>         　　　　　　               error<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>jqXHR<span class="token punctuation">,</span> textStatus<span class="token punctuation">,</span> err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>               complete<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>jqXHR<span class="token punctuation">,</span> textStatus<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>textStatus<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>               statusCode<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    <span class="token string">'403'</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>jqXHR<span class="token punctuation">,</span> textStatus<span class="token punctuation">,</span> err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token string">'400'</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>jqXHR<span class="token punctuation">,</span> textStatus<span class="token punctuation">,</span> err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>           <span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 2.基于原生js实现　　　　看代码[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```var b2 = document.getElementById("b2");  b2.onclick = function () {    // 原生JS    var xmlHttp = new XMLHttpRequest();    xmlHttp.open("POST", "/ajax_test/", true);    xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");    xmlHttp.send("username=chao&amp;password=123456");    xmlHttp.onreadystatechange = function () {      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {        alert(xmlHttp.responseText);      }    };  };```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 3.Ajax－服务器－Ajax流程图　　 　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190303224133636-733848807.png)### 三 Ajax请求设置csrf_token### 方式1　　　　通过获取隐藏的input标签中的csrfmiddlewaretoken值，放置在data中发送。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```$.ajax({  url: "/cookie_ajax/",  type: "POST",  data: {    "username": "chao",    "password": 123456,    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val()  // 使用jQuery取出csrfmiddlewaretoken的值，拼接到data中  },  success: function (data) {    console.log(data);  }})```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 方式2（后面再说）　　　　通过获取返回的cookie中的字符串 放置在请求头中发送。　　　　注意：需要引入一个jquery.cookie.js插件。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```$.ajax({  url: "/cookie_ajax/",  type: "POST",  headers: {"X-CSRFToken": $.cookie('csrftoken')},  // 从Cookie取csrftoken，并设置到请求头中  data: {"username": "chao", "password": 123456},  success: function (data) {    console.log(data);  }})```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　或者用自己写一个getCookie方法：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```function getCookie(name) {    var cookieValue = null;    if (document.cookie &amp;&amp; document.cookie !== '') {        var cookies = document.cookie.split(';');        for (var i = 0; i &lt; cookies.length; i++) {            var cookie = jQuery.trim(cookies[i]);            // Does this cookie string begin with the name we want?            if (cookie.substring(0, name.length + 1) === (name + '=')) {                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));                break;            }        }    }    return cookieValue;}var csrftoken = getCookie('csrftoken');```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　每一次都这么写太麻烦了，可以使用$.ajaxSetup()方法为ajax请求统一设置。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```function csrfSafeMethod(method) {  // these HTTP methods do not require CSRF protection  return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));}$.ajaxSetup({  beforeSend: function (xhr, settings) {    if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) {      xhr.setRequestHeader("X-CSRFToken", csrftoken);    }  }});```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　注意：　　　　　　如果使用从cookie中取csrftoken的方式，需要确保cookie存在csrftoken值。　　　　　　如果你的视图渲染的HTML文件中没有包含 {% csrf_token %}，Django可能不会设置CSRFtoken的cookie。　　　　　　这个时候需要使用ensure_csrf_cookie()装饰器强制设置Cookie。```django.views.decorators.csrf import ensure_csrf_cookie@ensure_csrf_cookiedef login(request):    pass```　　　　更多细节详见：[Djagno官方文档中关于CSRF的内容](https://docs.djangoproject.com/en/1.11/ref/csrf/)### 四 Ajax文件上传## 请求头ContentType　　　　ContentType指的是请求体的编码类型，常见的类型共有3种：### 1 application/x-www-form-urlencoded　　　　　　这应该是最常见的 POST 提交数据的方式了。浏览器的原生 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span> 表单，如果不设置 `enctype` 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：```POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8user=yuan&amp;age=22```### 2 multipart/form-data　　　　　　这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span> 表单的 `enctype` 等于 multipart/form-data。直接来看一个请求示例：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)```POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name="user"yuan------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name="file"; filename="chrome.png"Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA--```![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　　　这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 `--boundary` 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 `--boundary--` 标示结束。关于 multipart/form-data 的详细定义，请前往 [rfc1867](http://www.ietf.org/rfc/rfc1867.txt) 查看。　　　　　　这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。　　　　　　上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span> 表单也[只支持这两种方式](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4)（通过 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span> 元素的 `enctype` 属性指定，默认为 `application/x-www-form-urlencoded`。其实 `enctype` 还支持 `text/plain`，不过用得非常少）。　　　　　　随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。### 3 application/json　　　　　　application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。　　　　　　JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。## 基于form表单的文件上传 ### 模板部分```<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      用户名 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      头像 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>avatar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>```### 视图部分[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)```def index(request):    print(request.body)   # 原始的请求体数据    print(request.GET)    # GET请求数据    print(request.POST)   # POST请求数据    print(request.FILES)  # 上传的文件数据    return render(request,"index.html")```![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)## 基于Ajax的文件上传### 模板[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)```<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>      用户名 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      头像 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>avatar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ajax-submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ajax-submit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#ajax-submit"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> formdata<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        formdata<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#user"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　 formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"csrfmiddlewaretoken"</span><span class="token punctuation">,</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"[name='csrfmiddlewaretoken']"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> #别忘了csrf_token        formdata<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"avatar_img"</span><span class="token punctuation">,</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#avatar"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            url<span class="token punctuation">:</span><span class="token string">""</span><span class="token punctuation">,</span>            type<span class="token punctuation">:</span><span class="token string">"post"</span><span class="token punctuation">,</span>            data<span class="token punctuation">:</span>formdata<span class="token punctuation">,</span>            processData<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 不处理数据</span>            contentType<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 不设置内容类型</span>            success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>```![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　　　或者使用```var form = document.getElementById("form1");var fd = new FormData(form);```　　　　　　这样也可以直接通过ajax 的 send() 方法将 fd 发送到后台。　　　　　　注意：由于 FormData 是 XMLHttpRequest Level 2 新增的接口，现在 低于IE10 的IE浏览器不支持 FormData。### 视图[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)```def index(request):    if request.is_ajax():        print(request.body)   # 原始的请求体数据        print(request.GET)    # GET请求数据        print(request.POST)   # POST请求数据        print(request.FILES)  # 上传的文件数据        return HttpResponse("ok")    return render(request,"index.html")```![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　检查浏览器的请求头：```Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryaWl9k5ZMiTAzx3FT```## 练习（用户名是否已被注册）### 功能介绍　　　　　　在注册表单中，当用户填写了用户名后，把光标移开后，会自动向服务器发送异步请求。服务器返回这个用户名是否已经被注册过。### 案例分析- 页面中给出注册表单；- 在username input标签中绑定onblur事件处理函数。- 当input标签失去焦点后获取 username表单字段的值，向服务端发送AJAX请求；- django的视图函数中处理该请求，获取username值，判断该用户在数据库中是否被注册，如果被注册了就返回“该用户已被注册”，否则响应“该用户名可以注册”。### 五 关于json### 1.什么是json- JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）- JSON 是轻量级的文本数据交换格式- JSON 独立于语言 *- JSON 具有自我描述性，更易理解- JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 　　　　啥都别多说了，上图吧！ ![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180407213606833-782897022.jpg)　　　　合格的json对象：```["one", "two", "three"]{ "one": 1, "two": 2, "three": 3 }{"names": ["张三", "李四"] }[ { "name": "张三"}, {"name": "李四"} ]　```　　　　不合格的json对象：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)```{ name: "张三", 'age': 32 }  // 属性名必须使用双引号[32, 64, 128, 0xFFF] // 不能使用十六进制值{ "name": "张三", "age": undefined }  // 不能使用undefined{ "name": "张三",  "birthday": new Date('Fri, 26 Aug 2011 07:13:10 GMT'),  "getName":  function() {return this.name;}  // 不能使用函数和日期对象}```![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　看一下普通字符串和json字符串，在进行序列化的时候的区别```import json# s = "{'name':'chao','age':18}" #普通字符串s = '{"name":"chao","age":18}'   #json字符串，里面必须是双引号ret = json.loads(s)print(ret)print(ret['name'])```### 2.js的stringify与parse方法　　　　JavaScript中关于JSON对象和字符串转换的两个方法：　　　　JSON.parse(): 用于将一个 JSON 字符串转换为 JavaScript 对象　```JSON.parse('{"name":"chao"}');JSON.parse('{name:"chao"}') ;   // 错误JSON.parse('[18,undefined]') ;   // 错误```　　　　JSON.stringify(): 用于将 JavaScript 值转换为 JSON 字符串。　```JSON.stringify({"name":"chao"})```### 3.和XML的比较　　　　JSON 格式于2001年由 Douglas Crockford 提出，目的就是取代繁琐笨重的 XML 格式。　　　　JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON迅速被接受，已经成为各大网站交换数据的标准格式，并被写入ECMAScript 5，成为标准的一部分。　　　　XML和JSON都使用结构化方法来标记数据，下面来做一个简单的比较。　　　　用XML表示中国部分省市数据如下：![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/ContractedBlock.gif) xml数据　　　　用JSON表示如下：![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/ContractedBlock.gif) json数据　　　　由上面的两端代码可以看出，JSON 简单的语法格式和清晰的层次结构明显要比 XML 容易阅读，并且在数据交换方面，由于 JSON 所使用的字符要比 XML 少得多，可以大大得节约传输数据所占用得带宽。  4.ajax和服务端的数据交互时的序列化问题　　当我们给ajax回复的不是一个字符串，而是其他数据类型的时候，需要我们将数据转换为json字符串进行发送，这样好配合js进行json字符串的处理，不然发送或者接受的是普通字符串的话，没办法处理成原来的数据类型。　　这就用到了我们前面的视图函数中那个JsonResponse了，[看博客](https://www.cnblogs.com/clschao/articles/10409764.html)，里面response的部分　　还要注意ajax中的data参数：　　　　data参数中的键值对，如果值值不为字符串，需要将其转换成字符串类型。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```$("#b1").on("click", function () {    $.ajax({      url:"/ajax_add/",      type:"GET",      data:{"i1":$("#i1").val(),"i2":$("#i2").val(),"hehe": JSON.stringify([1, 2, 3])},      success:function (data) {        $("#i3").val(data);      }    })  })```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 5.Django内置的serializers做序列化　　　　看代码：```def books_json(request):    book_list = models.Book.objects.all()[0:10]    from django.core import serializers    ret = serializers.serialize("json", book_list)    return HttpResponse(ret)```### 六 补充一个SweetAlert插件示例 看效果：　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180407235320541-386911677.gif)　　点击下载[Bootstrap-sweetalert项目](https://github.com/lipis/bootstrap-sweetalert)。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```$(".btn-danger").on("click", function () {  swal({    title: "你确定要删除吗？",    text: "删除可就找不回来了哦！",    type: "warning",    showCancelButton: true,    confirmButtonClass: "btn-danger",    confirmButtonText: "删除",    cancelButtonText: "取消",    closeOnConfirm: false    },    function () {      var deleteId = $(this).parent().parent().attr("data_id");      $.ajax({        url: "/delete_book/",        type: "post",        data: {"id": deleteId},        success: function (data) {          if (data.status === 1) {            swal("删除成功!", "你可以准备跑路了！", "success");          } else {            swal("删除失败", "你可以再尝试一下！", "error")          }        }      })    });})```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础五之django模型层(一)单表操作</title>
      <link href="2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%B8%80)%E5%8D%95%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
      <url>2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%B8%80)%E5%8D%95%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-html"><code class="language-html">**本节目录**- [一 语法](https://www.cnblogs.com/clschao/articles/10414811.html#part_1)- [二 变量](https://www.cnblogs.com/clschao/articles/10414811.html#part_2)- [三 过滤器](https://www.cnblogs.com/clschao/articles/10414811.html#part_3)- [四 标签Tags](https://www.cnblogs.com/clschao/articles/10414811.html#part_4)- [五 模板继承](https://www.cnblogs.com/clschao/articles/10414811.html#part_5)- [六 组件](https://www.cnblogs.com/clschao/articles/10414811.html#part_6)- [七 自定义标签和过滤器](https://www.cnblogs.com/clschao/articles/10414811.html#part_7)- [八 静态文件相关](https://www.cnblogs.com/clschao/articles/10414811.html#part_8)- ### 一 语法　　模板渲染的[官方文档](https://docs.djangoproject.com/en/1.11/ref/templates/builtins/#std:templatetag-for)　　　　关于模板渲染你只需要记两种特殊符号（语法）：　　{{  }}和 {% %}　　变量相关的用{{}}，逻辑相关的用{%%}。  ### 二 变量　　　　在Django的模板语言中按此语法使用：{{ 变量名 }}。　　当模版引擎遇到一个变量，它将计算这个变量，然后用结果替换掉它本身。 变量的命名包括任何字母数字以及下划线 ("_")的组合。 变量名称中不能有空格或标点符号。　　深度查询据点符（.）在模板语言中有特殊的含义。当模版系统遇到点(".")，它将以这样的顺序查询：　　　　字典查询（Dictionary lookup）　　　　属性或方法查询（Attribute or method lookup）　　　　数字索引查询（Numeric index lookup）　　注意事项：1. 如果计算结果的值是可调用的，它将被无参数的调用。 调用的结果将成为模版的值。2. 如果使用的变量不存在， 模版系统将插入 string_if_invalid 选项的值， 它被默认设置为'' (空字符串) 。　　几个例子：　　view中代码：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```def index(request):    import datetime    s = "hello"    l = [111, 222, 333]  # 列表    dic = {"name": "yuan", "age": 18}  # 字典    date = datetime.date(1993, 5, 2)  # 日期对象    class Person(object):        def __init__(self, name):            self.name = name        def dream(self):            return 'dreamer'    person_yuan = Person("chao")  # 自定义类对象    person_egon = Person("yantao")    person_alex = Person("jinxin")    person_list = [person_yuan, person_egon, person_alex]    return render(request, "index.html", {"l": l, "dic": dic, "date": date, "person_list": person_list})    # return render(request,'index.html',locals())    #locals()获取函数内容所有的变量，然后通过render方法给了index.html文件进行模板渲染，如果你图省事，你可以用它，但是很多多余的变量也被传进去了，效率低```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　模板中支持的写法：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>{{s}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>列表:{{ l.0 }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>列表:{{ l.2 }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>字典:{{ dic.name }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>日期:{{ date.year }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--取列表的第1个对象的name属性的值--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>类对象列表:{{ person_list.0.name }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--取列表的第1个对象的dream方法的返回值，如果没有返回值，拿到的是none--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>类对象列表:{{ person_list.0.dream }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>注意：    调用对象里面的方法的时候，不需要写括号来执行，并且只能执行不需要传参数的方法，如果你的这个方法需要传参数，那么模板语言不支持，不能帮你渲染```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 三 过滤器　　在Django的模板语言中，通过使用 过滤器 来改变变量的显示。　　过滤器的语法： {{ value|filter_name:参数 }}　　使用管道符"|"来应用过滤器。　　例如：{{ name|lower }}会将name变量应用lower过滤器之后再显示它的值。lower在这里的作用是将文本全都变成小写。　　注意事项：1. 过滤器支持“链式”操作。即一个过滤器的输出作为另一个过滤器的输入。2. 过滤器可以接受参数，例如：{{ sss|truncatewords:30 }}，这将显示sss的前30个词。3. 过滤器参数包含空格的话，必须用引号包裹起来。比如使用逗号和空格去连接一个列表中的元素，如：{{ list|join:', ' }}4. '|'左右没有空格没有空格没有空格　　Django的模板语言中提供了大约六十个内置过滤器。### **default**　　　　**如果一个变量是false或者为空，使用给定的默认值。 否则，使用变量的值。**```{{ value|default:"nothing"}}```　　　　如果value没有传值或者值为空的话就显示nothing### **length**　　　　**返回值的长度，作用于字符串和列表。**　　　　{{ value|length }}　　　　返回value的长度，如 value=['a', 'b', 'c', 'd']的话，就显示4.### **filesizeformat**　　　　将值格式化为一个 “人类可读的” 文件尺寸 （例如 `'13 KB'`, `'4.1 MB'`, `'102 bytes'`, 等等）。例如：```{{ value|filesizeformat }}```　　　　如果 value 是 123456789，输出将会是 117.7 MB。### **slice**　　　　切片,如果 value="hello world",还有其他可切片的数据类型```{{value|slice:"2:-1"}}```### **date**　　　　格式化,如果 value=datetime.datetime.now()```{{ value|date:"Y-m-d H:i:s"}}``` 　　关于时间日期的可用的参数(除了Y,m,d等等)还有很多，有兴趣的可以去查查看看。　　### **safe**　　　　Django的模板中在进行模板渲染的时候会对HTML标签和JS等语法标签进行自动转义，原因显而易见，这样是为了安全，django担心这是用户添加的数据，比如如果有人给你评论的时候写了一段js代码，这个评论一提交，js代码就执行啦，这样你是不是可以搞一些坏事儿了，写个弹窗的死循环，那浏览器还能用吗，是不是会一直弹窗啊，这叫做xss攻击，所以浏览器不让你这么搞，给你转义了。但是有的时候我们可能不希望这些HTML元素被转义，比如我们做一个内容管理系统，后台添加的文章中是经过修饰的，这些修饰可能是通过一个类似于FCKeditor编辑加注了HTML修饰符的文本，如果自动转义的话显示的就是保护HTML标签的源文件。为了在Django中关闭HTML的自动转义有两种方式，如果是一个单独的变量我们可以通过过滤器“|safe”的方式告诉Django这段代码是安全的不必转义。　　　　我们去network那个地方看看，浏览器看到的都是渲染之后的结果，通过network的response的那个部分可以看到，这个a标签全部是特殊符号包裹起来的，并不是一个标签，这都是django搞得事情。　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190221213947521-676002174.png)　　　　比如：　　　　　　value = "<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>#<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>点我<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>"   和   value="<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>"```{{ value|safe}}```　　　　很多网站，都会对你提交的内容进行过滤，一些敏感词汇、特殊字符、标签、黄赌毒词汇等等，你一提交内容，人家就会检测你提交的内容，如果包含这些词汇，就不让你提交，其实这也是解决xss攻击的根本途径，例如博客园：　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190221215119657-1878467407.png)### **truncatechars**　　　　如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“...”）结尾。　　　　参数：截断的字符数```{{ value|truncatechars:9}} #注意：最后那三个省略号也是9个字符里面的，也就是这个9截断出来的是6个字符+3个省略号，有人会说，怎么展开啊，配合前端的点击事件就行啦```### truncatewords　　　　在一定数量的字后截断字符串，是截多少个单词。　　　　例如：‘hello girl hi baby yue ma’,```{{ value|truncatewords:3}}  #上面例子得到的结果是 'hello girl h1...'```### **cut**　　　　**移除value中所有的与给出的变量相同的字符串**```{{ value|cut:' ' }}```　　　　如果value为'i love you'，那么将输出'iloveyou'.### **join**　　　　**使用字符串连接列表，{{ list|join:', ' }}，就像Python的str.join(list)**### **timesince（了解）**　　　　将日期格式设为自该日期起的时间（例如，“4天，6小时”）。　　　　采用一个可选参数，它是一个包含用作比较点的日期的变量（不带参数，比较点为现在）。 例如，如果blog_date是表示2006年6月1日午夜的日期实例，并且comment_date是2006年6月1日08:00的日期实例，则以下将返回“8小时”：```{{ blog_date|timesince:comment_date }}```　　　　分钟是所使用的最小单位，对于相对于比较点的未来的任何日期，将返回“0分钟”。### timeuntil（了解）　　　　似于timesince，除了它测量从现在开始直到给定日期或日期时间的时间。 例如，如果今天是2006年6月1日，而conference_date是保留2006年6月29日的日期实例，则{{ conference_date | timeuntil }}将返回“4周”。　　　　使用可选参数，它是一个包含用作比较点的日期（而不是现在）的变量。 如果from_date包含2006年6月22日，则以下内容将返回“1周”：```{{ conference_date|timeuntil:from_date }}```　　这里简单介绍一些常用的模板的过滤器，[更多详见](http://python.usyiyi.cn/translate/django_182/ref/templates/builtins.html#ref-templates-builtins-tags)### 四 标签Tags　　标签看起来像是这样的： `{% tag %}`。标签比变量更加复杂：一些在输出中创建文本，一些通过循环或逻辑来控制流程，一些加载其后的变量将使用到的额外信息到模版中。一些标签需要开始和结束标签 （例如`{% tag %} ...`标签 内容 ... {% endtag %}）。### **for标签**　　　　遍历每一个元素：  写个for，然后 tab键自动生成for循环的结构，循环很基础，就这么简单的用，没有什么break之类的，复杂一些的功能，你要通过js```{% for person in person_list %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ person.name }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--凡是变量都要用两个大括号括起来--></span>{% endfor %}```　　　　可以利用`{% for obj in list reversed %}`反向完成循环。　　　　遍历一个字典：```{% for key,val in dic.items %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ key }}:{{ val }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% endfor %}```　　　　注：循环序号可以通过｛｛forloop｝｝显示，必须在循环内部用　　[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```forloop.counter            当前循环的索引值(从1开始)，forloop是循环器，通过点来使用功能forloop.counter0           当前循环的索引值（从0开始）forloop.revcounter         当前循环的倒序索引值（从1开始）forloop.revcounter0        当前循环的倒序索引值（从0开始）forloop.first              当前循环是不是第一次循环（布尔值）forloop.last               当前循环是不是最后一次循环（布尔值）forloop.parentloop         本层循环的外层循环的对象，再通过上面的几个属性来显示外层循环的计数等```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);) 　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190224165606594-1247415849.png)　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190224165700767-229830460.png)　　　　#### for ... empty`　　　　for` 标签带有一个可选的`{% empty %}` 从句，以便在给出的组是空的或者没有被找到时，可以有所操作。```{% for person in person_list %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ person.name }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% empty %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>sorry,no person here<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% endfor %}```### if 标签`　　　　{% if %}`会对一个变量求值，如果它的值是“True”（存在、不为空、且不是boolean类型的false值），对应的内容块会输出。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```{% if num > 100 or num &lt; 0 %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>无效<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--不满足条件，不会生成这个标签--></span>{% elif num > 80 and num &lt; 100 %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>优秀<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% else %}  <span class="token comment" spellcheck="true">&lt;!--也是在if标签结构里面的--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>凑活吧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% endif %}```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　当然也可以只有if和else```{% if user_list|length > 5 %}  <span class="token comment" spellcheck="true">&lt;!--结合过滤器来使用--></span>  七座豪华SUV{% else %}    黄包车{% endif %}```　　　　if语句支持 and 、or、==、>、&lt;、!=、&lt;=、>=、in、not in、is、is not判断，注意条件两边都有空格。#### with　　　　使用一个简单地名字缓存一个复杂的变量，多用于给一个复杂的变量起别名，当你需要使用一个“昂贵的”方法（比如访问数据库）很多次的时候是非常有用的　　　　例如：　　　　注意等号左右不要加空格。```{% with total=business.employees.count %}    {{ total }} <span class="token comment" spellcheck="true">&lt;!--只能在with语句体内用--></span>{% endwith %}```　　　　或```{% with business.employees.count as total %}    {{ total }}{% endwith %}```### csrf_token　　　　我们以post方式提交表单的时候，会报错，还记得我们在settings里面的中间件配置里面把一个csrf的防御机制给注销了啊，本身不应该注销的，而是应该学会怎么使用它，并且不让自己的操作被forbiden，通过这个东西就能搞定。　　　　这个标签用于跨站请求伪造保护，　　　　在页面的form表单里面（注意是在form表单里面）任何位置写上{% csrf_token %}，这个东西模板渲染的时候替换成了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>csrfmiddlewaretoken<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8J4z1wiUEXt0gJSN59dLMnktrXFW0hv7m4d40Mtl37D7vJZfrxLir9L3jSTDjtG8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>，隐藏的，这个标签的值是个随机字符串，提交的时候，这个东西也被提交了，首先这个东西是我们后端渲染的时候给页面加上的，那么当你通过我给你的form表单提交数据的时候，你带着这个内容我就认识你，不带着，我就禁止你，因为后台我们django也存着这个东西，和你这个值相同的一个值，可以做对应验证是不是我给你的token，存储这个值的东西我们后面再学，你先知道一下就行了，就像一个我们后台给这个用户的一个通行证，如果你用户没有按照我给你的这个正常的页面来post提交表单数据，或者说你没有先去请求我这个登陆页面，而是直接模拟请求来提交数据，那么我就能知道，你这个请求是非法的，反爬虫或者恶意攻击我的网站，以后将中间件的时候我们在细说这个东西，但是现在你要明白怎么回事，明白为什么django会加这一套防御。　　　　爬虫发送post请求简单模拟：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```import requestsres = requests.post('http://127.0.0.1:8000/login/',data={    'username':'chao',    'password':'123'})print(res.text)```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　### 注释```{# ... #}```### 注意事项1. Django的模板语言不支持连续判断，即不支持以下写法：```{% if a > b > c %}...{% endif %}```2. Django的模板语言中属性的优先级大于方法（了解）```def xx(request):    d = {"a": 1, "b": 2, "c": 3, "items": "100"}    return render(request, "xx.html", {"data": d})```　　　　　　如上，我们在使用render方法渲染一个页面的时候，传的字典d有一个key是items并且还有默认的 d.items() 方法，此时在模板语言中:```{{ data.items }}```　　　　　　默认会取d的items key的值。### 五 模板继承　　Django模版引擎中最强大也是最复杂的部分就是模版继承了。模版继承可以让您创建一个基本的“骨架”模版，它包含您站点中的全部元素，并且可以定义能够被子模版覆盖的 blocks 。　　通过从下面这个例子开始，可以容易的理解模版继承：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>style.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>{% block title %}My amazing site{%/span> endblock %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sidebar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        {% block sidebar %}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/blog/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Blog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>        {% endblock %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        {% block content %}{% endblock %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);) 　　这个模版，我们把它叫作 `base.html`， 它定义了一个可以用于两列排版页面的简单HTML骨架。“子模版”的工作是用它们的内容填充空的blocks。　　在这个例子中， `block` 标签定义了三个可以被子模版内容填充的block。 `block` 告诉模版引擎： 子模版可能会覆盖掉模版中的这些位置。　　子模版可能看起来是这样的：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```{% extends "base.html" %} {% block title %}My amazing blog{% endblock %}{% block content %}{% for entry in blog_entries %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>{{ entry.title }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ entry.body }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>{% endfor %}{% endblock %}```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)`　　extends` 标签是这里的关键。它告诉模版引擎，这个模版“继承”了另一个模版。当模版系统处理这个模版时，首先，它将定位父模版——在此例中，就是“base.html”。　　那时，模版引擎将注意到 `base.html` 中的三个 `block` 标签，并用子模版中的内容来替换这些block。根据 `blog_entries` 的值，输出可能看起来是这样的：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>style.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>My amazing blog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sidebar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/blog/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Blog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>Entry one<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is my first entry.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>Entry two<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is my second entry.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　请注意，子模版并没有定义 `sidebar` block，所以系统使用了父模版中的值。父模版的 `{% block %}` 标签中的内容总是被用作备选内容（fallback）。　　这种方式使代码得到最大程度的复用，并且使得添加内容到共享的内容区域更加简单，例如，部分范围内的导航。　　这里是使用继承的一些提示：- 如果你在模版中使用 `{% extends %}` 标签，它必须是模版中的第一个标签。其他的任何情况下，模版继承都将无法工作，模板渲染的时候django都不知道你在干啥。- 在base模版中设置越多的 `{% block %}` 标签越好。请记住，子模版不必定义全部父模版中的blocks，所以，你可以在大多数blocks中填充合理的默认内容，然后，只定义你需要的那一个。多一点钩子总比少一点好。- 如果你发现你自己在大量的模版中复制内容，那可能意味着你应该把内容移动到父模版中的一个 `{% block %}` 中。- If you need to get the content of the block from the parent template, the `{{ block.super }}` variable will do the trick. This is useful if you want to add to the contents of a parent block instead of completely overriding it. Data inserted using `{{ block.super }}` will not be automatically escaped (see the next section), since it was already escaped, if necessary, in the parent template.  将子页面的内容和继承的母版中block里面的内容同时保留　　　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190224185156295-1566217485.png) - 为了更好的可读性，你也可以给你的 `{% endblock %}` 标签一个 *名字* 。例如：```{% block content %}...{% endblock content %}　　``` 　　在大型模版中，这个方法帮你清楚的看到哪一个　 `{% block %}` 标签被关闭了。- 不能在一个模版中定义多个相同名字的 `block` 标签。 　　### 六 组件　　　　可以将常用的页面内容如导航条，页尾信息等组件保存在单独的文件中，然后在需要使用的地方，文件的任意位置按如下语法导入即可。```{% include 'navbar.html' %}``` 例如：有个如下的导航栏,nav.html　[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token selector"><span class="token class">.c1</span></span><span class="token punctuation">{</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>xx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>dd<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);) 嵌入导航栏的页面，test.html[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>{% include 'nav.html' %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>xxxxxxxxxx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 七 自定义标签和过滤器　　这些我们后面用到的时候再讲：　　1、**在settings中的INSTALLED_APPS配置当前app，不然django无法找到自定义的simple_tag.**　　2、**在app中创建templatetags模块(模块名只能是templatetags)**　　**3、创建任意 .py 文件，如：my_tags.py**[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```from django import templatefrom django.utils.safestring import mark_saferegister = template.Library()   #register的名字是固定的,不可改变@register.filterdef filter_multi(v1,v2):    return  v1 * v2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>@register.simple_tag  #和自定义filter类似，只不过接收更灵活的参数，没有个数限制。def simple_tag_multi(v1,v2):    return  v1 * v2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>@register.simple_tagdef my_input(id,arg):    result = "<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>text<span class="token punctuation">'</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>%s<span class="token punctuation">'</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>%s<span class="token punctuation">'</span></span> <span class="token punctuation">/></span></span>" %(id,arg,)    return mark_safe(result)```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);) **4、在使用自定义simple_tag和filter的html文件中导入之前创建的 my_tags.py**```{% load my_tags %}　```　　**5、使用simple_tag和filter（如何调用）**[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```-------------------------------.html{% load xxx %}  # num=12{{ num|filter_multi:2 }} #24{{ num|filter_multi:"[22,333,4444]" }}{% simple_tag_multi 2 5 %}  参数不限,但不能放在if for语句中{% simple_tag_multi num 5 %}```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　注意：filter可以用在if等语句后，simple_tag不可以```{% if num|filter_multi:30 > 100 %}    {{ num|filter_multi:30 }}{% endif %}```## inclusion_tag　　　　多用于返回html代码片段　　　　示例：　　　　　　templatetags/my_inclusion.py[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```from django import templateregister = template.Library()@register.inclusion_tag('result.html')def show_results(n):    n = 1 if n &lt; 1 else int(n)    data = ["第{}项".format(i) for i in range(1, n+1)]    return {"data": data}```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　　　templates/snippets/result.html```<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  {% for choice in data %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{ choice }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  {% endfor %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>```　　　　　　templates/index.html[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>x-ua-compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>inclusion_tag test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>{% load inclusion_tag_test %}{% show_results 10 %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 八 静态文件相关　　### {% static %}```{% load static %}&lt;img src="{% static "images/hi.jpg" %}" alt="Hi!" />```　　　　引用JS文件时使用：```{% load static %}&lt;script src="{% static "mytest.js" %}"><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>```　　　　某个文件多处被用到可以存为一个变量```{% load static %}{% static "images/hi.jpg" as myphoto %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ myphoto }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>img</span><span class="token punctuation">></span></span>```### {% get_static_prefix %}```{% load static %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{% get_static_prefix %}images/hi.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Hi!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>```　　　　或者```{% load static %}{% get_static_prefix as STATIC_PREFIX %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ STATIC_PREFIX }}images/hi.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Hi!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ STATIC_PREFIX }}images/hi2.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Hello!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础五之django模型层(二)多表操作</title>
      <link href="2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C)%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
      <url>2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C)%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10439958.html#part_1">一 创建模型</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10439958.html#part_2">二 添加表记录</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10439958.html#part_3">三 基于对象的跨表查询</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10439958.html#part_4">四 基于双下划线的跨表查询</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10439958.html#part_5">五 聚合查询和分组查询</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10439958.html#part_6">六 xxx</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10439958.html#part_7">七 xxx</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10439958.html#part_8">八 xxx</a></li><li></li></ul><h3 id="一-创建模型"><a href="#一-创建模型" class="headerlink" title="一 创建模型"></a>一 创建模型</h3><p>　　<strong>表和表之间的关系</strong></p><p>　　　　一对一、多对一、多对多　</p><p>　　实例：我们来假定下面这些概念，字段和关系</p><p>　　作者模型：一个作者有姓名和年龄。</p><p>　　作者详细模型：把作者的详情放到详情表，包含生日，手机号，家庭住址等信息。作者详情模型和作者模型之间是一对一的关系（one-to-one）</p><p>　　出版商模型：出版商有名称，所在城市以及email。</p><p>　　书籍模型： 书籍有书名和出版日期，一本书可能会有多个作者，一个作者也可以写多本书，所以作者和书籍的关系就是多对多的关联关系(many-to-many);一本书只应该由一个出版商出版，所以出版商和书籍是一对多关联关系(one-to-many)。</p><p>　　模型建立如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.db import models# Create your models here.class Author(models.Model):    nid = models.AutoField(primary_key=True)    name=models.CharField( max_length=32)    age=models.IntegerField()    # 与AuthorDetail建立一对一的关系    authorDetail=models.OneToOneField(to="AuthorDetail",on_delete=models.CASCADE)class AuthorDetail(models.Model):    nid = models.AutoField(primary_key=True)    birthday=models.DateField()    telephone=models.BigIntegerField()    addr=models.CharField( max_length=64)class Publish(models.Model):    nid = models.AutoField(primary_key=True)    name=models.CharField( max_length=32)    city=models.CharField( max_length=32)    email=models.EmailField()class Book(models.Model):    nid = models.AutoField(primary_key=True)    title = models.CharField( max_length=32)    publishDate=models.DateField()    price=models.DecimalField(max_digits=5,decimal_places=2)    # 与Publish建立一对多的关系,外键字段建立在多的一方    publish=models.ForeignKey(to="Publish",to_field="nid",on_delete=models.CASCADE)    # 与Author表建立多对多的关系,ManyToManyField可以建在两个模型中的任意一个，自动创建第三张表    authors=models.ManyToManyField(to='Author',)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　生成表如下：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501223306119-1804705285.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501223412676-377958198.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501223511240-492522724.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501223620025-185160553.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501223701796-763894415.png" alt="img"></p><p> 　　</p><p>　　注意事项：</p><ul><li>表的名称<code>myapp_modelName</code>，是根据 模型中的元数据自动生成的，也可以覆写为别的名称　　</li><li><code> id</code> 字段是自动添加的</li><li>对于外键字段，Django 会在字段名上添加<code>"_id"</code> 来创建数据库中的列名</li><li>这个例子中的<code>CREATE TABLE</code> SQL 语句使用PostgreSQL 语法格式，要注意的是Django 会根据settings 中指定的数据库类型来使用相应的SQL 语句。</li><li>定义好模型之后，你需要告诉Django _使用_这些模型。你要做的就是修改配置文件中的INSTALL_APPSZ中设置，在其中添加<code>models.py</code>所在应用的名称。</li><li>外键字段 ForeignKey 有一个 null=True 的设置(它允许外键接受空值 NULL)，你可以赋给它空值 None 。</li></ul><h3 id="二-添加表记录"><a href="#二-添加表记录" class="headerlink" title="二 添加表记录"></a>二 添加表记录</h3><p>　　</p><p>　　操作前先简单的录入一些数据：</p><p>　　publish表：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501231939514-1159349232.png" alt="img"></p><p>　　author表：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501232010534-1683544746.png" alt="img"></p><p>　　authordetail表:</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501232217201-492441826.png" alt="img"></p><p>　　</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="　　一对多"></a>　　一对多</h3><pre><code>方式1:   publish_obj=Publish.objects.get(nid=1)   book_obj=Book.objects.create(title="金瓶眉",publishDate="2012-12-12",price=100,publish=publish_obj)方式2:   book_obj=Book.objects.create(title="金瓶眉",publishDate="2012-12-12",price=100,publish_id=1)　　</code></pre><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501231012070-1410608284.png" alt="img"></p><p>　　核心：book_obj.publish与book_obj.publish_id是什么？ </p><h3 id="多对多"><a href="#多对多" class="headerlink" title="　　多对多"></a>　　多对多</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>    # 当前生成的书籍对象    book_obj=Book.objects.create(title="追风筝的人",price=200,publishDate="2012-11-12",publish_id=1)    # 为书籍绑定的做作者对象    yuan=Author.objects.filter(name="yuan").first() # 在Author表中主键为2的纪录    egon=Author.objects.filter(name="alex").first() # 在Author表中主键为1的纪录    # 绑定多对多关系,即向关系表book_authors中添加纪录    book_obj.authors.add(yuan,egon)    #  将某些特定的 model 对象添加到被关联对象集合中。   =======    book_obj.authors.add(*[])</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><p>　　数据库表纪录生成如下：</p><p>　　book表 </p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501233728425-1500453543.png" alt="img"></p><p>　　book_authors表</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180501233939850-1362764638.png" alt="img"></p><p>　　核心:book_obj.authors.all()是什么？</p><p>　　多对多关系其它常用API：</p><pre><code>book_obj.authors.remove()      # 将某个特定的对象从被关联对象集合中去除。    ======   book_obj.authors.remove(*[])book_obj.authors.clear()       #清空被关联对象集合book_obj.authors.set()         #先清空再设置　　</code></pre><p> 　　</p><h3 id="三-基于对象的跨表查询"><a href="#三-基于对象的跨表查询" class="headerlink" title="三 基于对象的跨表查询"></a>三 基于对象的跨表查询</h3><h3 id="一对多查询（Publish-与-Book）"><a href="#一对多查询（Publish-与-Book）" class="headerlink" title="　　一对多查询（Publish 与 Book）"></a>　　一对多查询（Publish 与 Book）</h3><p>　　　　正向查询(按字段：publish)：</p><pre><code># 查询主键为1的书籍的出版社所在的城市book_obj=Book.objects.filter(pk=1).first()# book_obj.publish 是主键为1的书籍对象关联的出版社对象print(book_obj.publish.city) 　</code></pre><p>　　　　反向查询(按表名：book_set)：</p><pre><code>publish=Publish.objects.get(name="苹果出版社")#publish.book_set.all() : 与苹果出版社关联的所有书籍对象集合book_list=publish.book_set.all()    for book_obj in book_list:       print(book_obj.title)</code></pre><h3 id="一对一查询-Author与AuthorDetail"><a href="#一对一查询-Author与AuthorDetail" class="headerlink" title="一对一查询(Author与AuthorDetail)"></a>一对一查询(Author与AuthorDetail)</h3><p>　　正向查询(按字段：authorDetail)：</p><pre><code>egon=Author.objects.filter(name="egon").first()print(egon.authorDetail.telephone)</code></pre><p>　　　　反向查询(按表名：author)：</p><pre><code># 查询所有住址在北京的作者的姓名authorDetail_list=AuthorDetail.objects.filter(addr="beijing")for obj in authorDetail_list:     print(obj.author.name)</code></pre><h3 id="多对多查询-Author与Book"><a href="#多对多查询-Author与Book" class="headerlink" title="多对多查询(Author与Book)"></a>多对多查询(Author与Book)</h3><p>　　正向查询(按字段：authors)：</p><pre><code>`# 金瓶眉所有作者的名字以及手机号` `book_obj``=``Book.objects.``filter``(title``=``"金瓶眉"``).first()``authors``=``book_obj.authors.``all``()``for` `author_obj ``in` `authors:``     ``print``(author_obj.name,author_obj.authorDetail.telephone)`</code></pre><p>　　　　反向查询(按表名：book_set)：</p><pre><code>`# 查询egon出过的所有书籍的名字` `    ``author_obj``=``Author.objects.get(name``=``"egon"``)``    ``book_list``=``author_obj.book_set.``all``()        ``#与egon作者相关的所有书籍``    ``for` `book_obj ``in` `book_list:``        ``print``(book_obj.title)`</code></pre><p>　　　　<strong>注意：</strong></p><p>　　　　　　你可以通过在 ForeignKey() 和ManyToManyField的定义中设置 related_name 的值来覆写 FOO_set 的名称。例如，如果 Article model 中做一下更改：</p><pre><code>`publish ``=` `ForeignKey(Book, related_name``=``'bookList'``)`</code></pre><p>　　　　那么接下来就会如我们看到这般：</p><pre><code>`# 查询 人民出版社出版过的所有书籍` `publish``=``Publish.objects.get(name``=``"人民出版社"``)``book_list``=``publish.bookList.``all``()  ``# 与人民出版社关联的所有书籍对象集合`</code></pre><h3 id="四-基于双下划线的跨表查询"><a href="#四-基于双下划线的跨表查询" class="headerlink" title="四 基于双下划线的跨表查询"></a>四 基于双下划线的跨表查询</h3><p> Django 还提供了一种直观而高效的方式在查询(lookups)中表示关联关系，它能自动确认 SQL JOIN 联系。要做跨关系查询，就使用两个下划线来链接模型(model)间关联字段的名称，直到最终链接到你想要的model 为止。</p><pre><code>'''    正向查询按字段,反向查询按表名小写用来告诉ORM引擎join哪张表'''</code></pre><h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><pre><code># 练习:  查询苹果出版社出版过的所有书籍的名字与价格(一对多)    # 正向查询 按字段:publish    queryResult=Book.objects　　　　　　　　　　　　.filter(publish__name="苹果出版社")　　　　　　　　　　　　.values_list("title","price")    # 反向查询 按表名:book    queryResult=Publish.objects　　　　　　　　　　　　　　.filter(name="苹果出版社")　　　　　　　　　　　　　　.values_list("book__title","book__price")</code></pre><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询　　"></a>多对多查询　　</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><pre><code># 练习: 查询alex出过的所有书籍的名字(多对多)    # 正向查询 按字段:authors:    queryResult=Book.objects　　　　　　　　　　　　.filter(authors__name="yuan")　　　　　　　　　　　　.values_list("title")    # 反向查询 按表名:book    queryResult=Author.objects　　　　　　　　　　　　　　.filter(name="yuan")　　　　　　　　　　　　　　.values_list("book__title","book__price")</code></pre><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><pre><code>    # 查询alex的手机号    # 正向查询    ret=Author.objects.filter(name="alex").values("authordetail__telephone")    # 反向查询    ret=AuthorDetail.objects.filter(author__name="alex").values("telephone")</code></pre><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="进阶练习-连续跨表"><a href="#进阶练习-连续跨表" class="headerlink" title="进阶练习(连续跨表)"></a>进阶练习(连续跨表)</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><pre><code># 练习: 查询人民出版社出版过的所有书籍的名字以及作者的姓名    # 正向查询    queryResult=Book.objects　　　　　　　　　　　　.filter(publish__name="人民出版社")　　　　　　　　　　　　.values_list("title","authors__name")    # 反向查询    queryResult=Publish.objects　　　　　　　　　　　　　　.filter(name="人民出版社")　　　　　　　　　　　　　　.values_list("book__title","book__authors__age","book__authors__name")# 练习: 手机号以151开头的作者出版过的所有书籍名称以及出版社名称    # 方式1:    queryResult=Book.objects　　　　　　　　　　　　.filter(authors__authorDetail__telephone__regex="151")　　　　　　　　　　　　.values_list("title","publish__name")    # 方式2:        ret=Author.objects              .filter(authordetail__telephone__startswith="151")              .values("book__title","book__publish__name")</code></pre><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="related-name"><a href="#related-name" class="headerlink" title="related_name"></a>related_name</h3><p>反向查询时，如果定义了related_name ，则用related_name替换表名，例如：</p><pre><code>`publish ``=` `ForeignKey(Blog, related_name``=``'bookList'``)`</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><pre><code># 练习: 查询人民出版社出版过的所有书籍的名字与价格(一对多)# 反向查询 不再按表名:book,而是related_name:bookList    queryResult=Publish.objects　　　　　　　　　　　　　　.filter(name="人民出版社")　　　　　　　　　　　　　　.values_list("bookList__title","bookList__price") </code></pre><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="五-聚合查询和分组查询"><a href="#五-聚合查询和分组查询" class="headerlink" title="五 聚合查询和分组查询"></a>五 聚合查询和分组查询</h3><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a><code>聚合</code></h3><p><code>aggregate</code>(*args, **kwargs)</p><pre><code>`# 计算所有图书的平均价格``    ``&gt;&gt;&gt; ``from` `django.db.models ``import` `Avg``    ``&gt;&gt;&gt; Book.objects.``all``().aggregate(Avg(``'price'``))``    ``{``'price__avg'``: ``34.35``}`</code></pre><p><code>aggregate()</code>是<code>QuerySet</code> 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。如果你想要为聚合值指定一个名称，可以向聚合子句提供它。</p><pre><code>`&gt;&gt;&gt; Book.objects.aggregate(average_price``=``Avg(``'price'``))``{``'average_price'``: ``34.35``}`</code></pre><p>如果你希望生成不止一个聚合，你可以向<code>aggregate()</code>子句中添加另一个参数。所以，如果你也想知道所有图书价格的最大值和最小值，可以这样查询：</p><pre><code>`&gt;&gt;&gt; ``from` `django.db.models ``import` `Avg, ``Max``, ``Min``&gt;&gt;&gt; Book.objects.aggregate(Avg(``'price'``), ``Max``(``'price'``), ``Min``(``'price'``))``{``'price__avg'``: ``34.35``, ``'price__max'``: Decimal(``'81.20'``), ``'price__min'``: Decimal(``'12.99'``)}`</code></pre><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><pre><code>###################################－－单表分组查询－－#######################################################查询每一个部门名称以及对应的员工数emp:id  name age   salary    dep1   alex  12   2000     销售部2   egon  22   3000     人事部3   wen   22   5000     人事部sql语句:select dep,Count(*) from emp group by dep;ORM:emp.objects.values("dep").annotate(c=Count("id")###################################－－多表分组查询－－###########################多表分组查询：查询每一个部门名称以及对应的员工数emp:id  name age   salary   dep_id1   alex  12   2000       12   egon  22   3000       23   wen   22   5000       2depid   name 1    销售部2    人事部emp－dep:id  name age   salary   dep_id   id   name 1   alex  12   2000       1      1    销售部2   egon  22   3000       2      2    人事部3   wen   22   5000       2      2    人事部sql语句:select dep.name,Count(*) from emp left join dep on emp.dep_id=dep.id group by dep.idORM:dep.objetcs.values("id").annotate(c=Count("emp")).values("name","c")</code></pre><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="img">多表操作 - cls超 - 博客园_files/ExpandedBlockStart.gif)</p><pre><code>class Emp(models.Model):    name=models.CharField(max_length=32)    age=models.IntegerField()    salary=models.DecimalField(max_digits=8,decimal_places=2)    dep=models.CharField(max_length=32)    province=models.CharField(max_length=32)</code></pre><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>annotate()为调用的<code>QuerySet</code>中每一个对象都生成一个独立的统计值（统计方法用聚合函数）。</p><p>总结 ：跨表分组查询本质就是将关联表join成一张表，再按单表的思路进行分组查询。　</p><h3 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h3><p>(1) 练习：统计每一个出版社的最便宜的书</p><pre><code>`publishList``=``Publish.objects.annotate(MinPrice``=``Min``(``"book__price"``))``for` `publish_obj ``in` `publishList:``    ``print``(publish_obj.name,publish_obj.MinPrice)`</code></pre><p>annotate的返回值是querySet，如果不想遍历对象，可以用上valuelist：</p><pre><code>queryResult= Publish.objects　　　　　　　　　　　　.annotate(MinPrice=Min("book__price"))　　　　　　　　　　　　.values_list("name","MinPrice")print(queryResult)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="img">多表操作 - cls超 - 博客园_files/ExpandedBlockStart.gif)</p><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><pre><code>'''SELECT "app01_publish"."name", MIN("app01_book"."price")  AS "MinPrice" FROM "app01_publish" LEFT  JOIN "app01_book" ON ("app01_publish"."nid" = "app01_book"."publish_id") GROUP BY "app01_publish"."nid", "app01_publish"."name", "app01_publish"."city", "app01_publish"."email" '''</code></pre><p><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</p><p><a href="javascript:void(0);"><img src="./Django%E5%9F%BA%E7%A1%80%E4%BA%94%E4%B9%8Bdjango%E6%A8%A1%E5%9E%8B%E5%B1%82(%E4%BA%8C" alt="复制代码">多表操作 - cls超 - 博客园_files/copycode.gif)</a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>(2) 练习：统计每一本书的作者个数</p><pre><code>ret=Book.objects.annotate(authorsNum=Count('authors__name'))</code></pre><p>(3) 统计每一本以py开头的书籍的作者个数：</p><pre><code> queryResult=Book.objects　　　　　　　　　　 .filter(title__startswith="Py")　　　　　　　　　 　.annotate(num_authors=Count('authors'))</code></pre><p>(4) 统计不止一个作者的图书：</p><pre><code>queryResult=Book.objects　　　　　　　　　　.annotate(num_authors=Count('authors'))　　　　　　　　　　.filter(num_authors__gt=1)</code></pre><p>(5) 根据一本图书作者数量的多少对查询集 <code>QuerySet</code>进行排序:</p><pre><code>`Book.objects.annotate(num_authors``=``Count(``'authors'``)).order_by(``'num_authors'``)`</code></pre><p>(6) 查询各个作者出的书的总价格:</p><pre><code>#   按author表的所有字段 group by    queryResult=Author.objects　　　　　　　　　　　　　　.annotate(SumPrice=Sum("book__price"))　　　　　　　　　　　　　　.values_list("name","SumPrice")    print(queryResult)</code></pre><h2 id="F查询与Q查询"><a href="#F查询与Q查询" class="headerlink" title="F查询与Q查询"></a>F查询与Q查询</h2><h3 id="F查询"><a href="#F查询" class="headerlink" title="F查询"></a>F查询</h3><p>在上面所有的例子中，我们构造的过滤器都只是将字段值与某个常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？</p><p>Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。</p><pre><code>`# 查询评论数大于收藏数的书籍` `   ``from` `django.db.models ``import` `F``   ``Book.objects.``filter``(commnetNum__lt``=``F(``'keepNum'``))`</code></pre><p>Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。</p><pre><code>`# 查询评论数大于收藏数2倍的书籍``    ``Book.objects.``filter``(commnetNum__lt``=``F(``'keepNum'``)``*``2``)`</code></pre><p>修改操作也可以使用F函数,比如将每一本书的价格提高30元：</p><pre><code>`Book.objects.``all``().update(price``=``F(``"price"``)``+``30``)　`</code></pre><h3 id="Q查询"><a href="#Q查询" class="headerlink" title="Q查询"></a>Q查询</h3><p><code>filter()</code> 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如<code>OR</code> 语句），你可以使用<code>Q 对象</code>。</p><pre><code>`from` `django.db.models ``import` `Q``Q(title__startswith``=``'Py'``)`</code></pre><p><code>Q</code> 对象可以使用<code>&amp;</code> 和<code>|</code> 操作符组合起来。当一个操作符在两个<code>Q</code> 对象上使用时，它产生一个新的<code>Q</code> 对象。</p><pre><code>`bookList``=``Book.objects.``filter``(Q(authors__name``=``"yuan"``)|Q(authors__name``=``"egon"``))`</code></pre><p>等同于下面的SQL <code>WHERE</code> 子句：</p><pre><code>`WHERE name ``=``"yuan"` `OR name ``=``"egon"`</code></pre><p>你可以组合<code>&amp;</code> 和<code>|</code>  操作符以及使用括号进行分组来编写任意复杂的<code>Q</code> 对象。同时，<code>Q</code> 对象可以使用<code>~</code> 操作符取反，这允许组合正常的查询和取反(<code>NOT</code>) 查询：</p><pre><code>`bookList``=``Book.objects.``filter``(Q(authors__name``=``"yuan"``) &amp; ~Q(publishDate__year``=``2017``)).values_list(``"title"``)`</code></pre><p>查询函数可以混合使用<code>Q 对象</code>和关键字参数。所有提供给查询函数的参数（关键字参数或<code>Q</code> 对象）都将”AND”在一起。但是，如果出现<code>Q</code> 对象，它必须位于所有关键字参数的前面。例如：</p><pre><code>`bookList``=``Book.objects.``filter``(Q(publishDate__year``=``2016``) | Q(publishDate__year``=``2017``),``                              ``title__icontains``=``"python"``                             ``)`</code></pre><p>　　</p><h3 id="六-xxx"><a href="#六-xxx" class="headerlink" title="六 xxx"></a>六 xxx</h3><h3 id="七-xxx"><a href="#七-xxx" class="headerlink" title="七 xxx"></a>七 xxx</h3><h3 id="八-xxx"><a href="#八-xxx" class="headerlink" title="八 xxx"></a>八 xxx</h3><p>　　</p><p><a href="https://www.cnblogs.com/clschao/articles/10439958.html#top">回到顶部</a></p><h3 id="一对一查询-Author-与-AuthorDetail"><a href="#一对一查询-Author-与-AuthorDetail" class="headerlink" title="一对一查询(Author 与 AuthorDetail)"></a>一对一查询(Author 与 AuthorDetail)</h3><p>正向查询(按字段：authorDetail)：</p><pre><code>`egon``=``Author.objects.``filter``(name``=``"egon"``).first()``print``(egon.authorDetail.telephone)`</code></pre><p>反向查询(按表名：author)：</p><pre><code>`# 查询所有住址在北京的作者的姓名` `authorDetail_list``=``AuthorDetail.objects.``filter``(addr``=``"beijing"``)``for` `obj ``in` `authorDetail_list:``     ``print``(obj.author.name)`</code></pre><h3 id="多对多查询-Author-与-Book"><a href="#多对多查询-Author-与-Book" class="headerlink" title="多对多查询 (Author 与 Book)"></a>多对多查询 (Author 与 Book)</h3><p>正向查询(按字段：authors)：</p><pre><code>`# 金瓶眉所有作者的名字以及手机号` `book_obj``=``Book.objects.``filter``(title``=``"金瓶眉"``).first()``authors``=``book_obj.authors.``all``()``for` `author_obj ``in` `authors:``     ``print``(author_obj.name,author_obj.authorDetail.telephone)`</code></pre><p>反向查询(按表名：book_set)：</p><pre><code>`# 查询egon出过的所有书籍的名字` `    ``author_obj``=``Author.objects.get(name``=``"egon"``)``    ``book_list``=``author_obj.book_set.``all``()        ``#与egon作者相关的所有书籍``    ``for` `book_obj ``in` `book_list:``        ``print``(book_obj.title)`</code></pre><p><strong>注意：</strong></p><p>你可以通过在 ForeignKey() 和ManyToManyField的定义中设置 related_name 的值来覆写 FOO_set 的名称。例如，如果 Article model 中做一下更改：</p><pre><code>`publish ``=` `ForeignKey(Book, related_name``=``'bookList'``)`</code></pre><p>那么接下来就会如我们看到这般：</p><pre><code>`# 查询 人民出版社出版过的所有书籍` `publish``=``Publish.objects.get(name``=``"人民出版社"``)``book_list``=``publish.bookList.``all``()  ``# 与人民出版社关联的所有书籍对象集合`</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础九之中间件</title>
      <link href="2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%B9%9D%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%B9%9D%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10480419.html#part_1">一 前戏</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480419.html#part_2">二 中间件介绍</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480419.html#part_3">三 自定义中间件</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480419.html#part_4">四 中间件的执行流程</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480419.html#part_5">五 中间件版登陆认证</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480419.html#part_6">六 xxx</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480419.html#part_7">七 xxx</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480419.html#part_8">八 xxx</a></li><li></li></ul><h3 id="一-前戏"><a href="#一-前戏" class="headerlink" title="一 前戏"></a>一 前戏</h3><p>　　</p><p>　　我们在前面的课程中已经学会了给视图函数加装饰器来判断是用户是否登录，把没有登录的用户请求跳转到登录页面。我们通过给几个特定视图函数加装饰器实现了这个需求。但是以后添加的视图函数可能也需要加上装饰器，这样是不是稍微有点繁琐。</p><p>　　学完今天的内容之后呢，我们就可以用更适宜的方式来实现类似给所有请求都做相同操作的功能了</p><p>　　</p><h3 id="二-中间件介绍"><a href="#二-中间件介绍" class="headerlink" title="二 中间件介绍"></a>二 中间件介绍</h3><p>　　</p><p>　　中间件顾名思义，是介于request与response处理之间的一道处理过程，相对比较轻量级，并且在全局上改变django的输入与输出。因为改变的是全局，所以需要谨慎实用，用不好会影响到性能。</p><p>　　Django的中间件的定义：</p><pre><code>Middleware is a framework of hooks into Django’s request/response processing. &lt;br&gt;It’s a light, low-level “plugin” system for globally altering Django’s input or output.</code></pre><p>　　如果你想修改请求，例如被传送到view中的<strong>HttpRequest</strong>对象。 或者你想修改view返回的<strong>HttpResponse</strong>对象，这些都可以通过中间件来实现。</p><p>　　可能你还想在view执行之前做一些操作，这种情况就可以用 middleware来实现。</p><p>　　说的直白一点中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个方法，Django框架会在请求的特定的时间去执行这些方法。</p><p>　　我们一直都在使用中间件，只是没有注意到而已，打开Django项目的Settings.py文件，看到下面的MIDDLEWARE配置项，django默认自带的一些中间件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'django.middleware.clickjacking.XFrameOptionsMiddleware',]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　MIDDLEWARE配置项是一个列表，列表中是一个个字符串，这些字符串其实是一个个类，也就是一个个中间件。</p><p>　　我们之前已经接触过一个csrf相关的中间件了？我们一开始让大家把他注释掉，再提交post请求的时候，就不会被forbidden了，后来学会使用csrf_token之后就不再注释这个中间件了。</p><p>　　那接下来就学习中间件中的方法以及这些方法什么时候被执行。</p><h3 id="三-自定义中间件"><a href="#三-自定义中间件" class="headerlink" title="三 自定义中间件"></a>三 自定义中间件</h3><p>　　中间件可以定义五个方法，分别是：（主要的是process_request和process_response）</p><ul><li>process_request(self,request)</li><li>process_view(self, request, view_func, view_args, view_kwargs)</li><li>process_template_response(self,request,response)</li><li>process_exception(self, request, exception)</li><li>process_response(self, request, response)</li></ul><p>　　以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象，则直接将该对象返回给用户。</p><p>　　当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20171012212952512-1143032176.png" alt="img"></p><p>　　上述截图中的中间件都是django中的，我们也可以自己定义一个中间件，我们可以自己写一个类，但是必须继承MiddlewareMixin</p><h3 id="自定义一个中间件示例"><a href="#自定义一个中间件示例" class="headerlink" title="　　自定义一个中间件示例"></a>　　自定义一个中间件示例</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　　　</p><h3 id="process-request"><a href="#process-request" class="headerlink" title="　　　　process_request"></a>　　　　process_request</h3><p>　　　　　　process_request有一个参数，就是request，这个request和视图函数中的request是一样的。</p><p>　　　　　　它的返回值可以是None也可以是HttpResponse对象。返回值是None的话，按正常流程继续走，交给下一个中间件处理，如果是HttpResponse对象，Django将不执行视图函数，而将相应对象返回给浏览器。</p><p>　　　　　　我们来看看多个中间件时，Django是如何执行其中的process_request方法的。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")class MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")        pass</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　在settings.py的MIDDLEWARE配置项中注册上述两个自定义中间件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'django.middleware.clickjacking.XFrameOptionsMiddleware',    'middlewares.MD1',  # 自定义中间件MD1    'middlewares.MD2'  # 自定义中间件MD2]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　此时，我们访问一个视图，会发现终端中打印如下内容：</p><pre><code>MD1里面的 process_requestMD2里面的 process_requestapp01 中的 index视图</code></pre><p>　　　　　　把MD1和MD2的位置调换一下，再访问一个视图，会发现终端中打印的内容如下：</p><pre><code>MD2里面的 process_requestMD1里面的 process_requestapp01 中的 index视图</code></pre><p>　　　　　　看结果我们知道：视图函数还是最后执行的，MD2比MD1先执行自己的process_request方法。</p><p>　　　　　　在打印一下两个自定义中间件中process_request方法中的request参数，会发现它们是同一个对象。</p><p>　　　　　　由此总结一下：</p><p>　　　　　　　　中间件的process_request方法是在执行视图函数之前执行的。</p><p>　　　　　　　　当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。</p><p>　　　　　　　　不同中间件之间传递的request都是同一个对象</p><p>　　　　　　多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序<strong>倒序</strong>执行的，也就是说第一个中间件的process_request方法首先执行，而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。</p><h3 id="process-response"><a href="#process-response" class="headerlink" title="　　　　process_response"></a>　　　　process_response</h3><p>　　　　　　它有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。该方法的返回值也必须是HttpResponse对象。</p><p>　　　　　　给上述的M1和M2加上process_response方法：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return responseclass MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")        pass    def process_response(self, request, response):        print("MD2里面的 process_response")        return response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　访问一个视图，看一下终端的输出：</p><pre><code>MD2里面的 process_requestMD1里面的 process_requestapp01 中的 index视图MD1里面的 process_responseMD2里面的 process_response</code></pre><p>　　　　　　看结果可知：</p><p>　　　　　　process_response方法是在视图函数之后执行的，并且顺序是MD1比MD2先执行。(此时settings.py中 MD2比MD1先注册)</p><p>　　　　　　多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序<strong>倒序</strong>执行的，也就是说第一个中间件的process_request方法首先执行，而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。</p><p>　　　　　　再看一个例子：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinfrom django.shortcuts import HttpResponseclass Md1(MiddlewareMixin):    def process_request(self,request):        print("Md1请求")    def process_response(self,request,response):        print("Md1返回")        return responseclass Md2(MiddlewareMixin):    def process_request(self,request):        print("Md2请求")        #return HttpResponse("Md2中断")    def process_response(self,request,response):        print("Md2返回")        return response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong>结果：</strong></p><pre><code>Md1请求Md2请求view函数...Md2返回Md1返回</code></pre><p>　　　　<strong>注意：</strong>如果当请求到达请求2的时候直接不符合条件返回，即**return HttpResponse(“Md2中断”)**，程序将把请求直接发给中间件2返回，然后依次返回到请求者，结果如下：</p><p>　　　　返回Md2中断的页面，后台打印如下：</p><pre><code>Md1请求Md2请求Md2返回Md1返回</code></pre><p>　　　　<strong>流程图如下：</strong></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180523153139864-2049371026.png" alt="img"></p><h3 id="process-view"><a href="#process-view" class="headerlink" title="　　　　process_view"></a>　　　　process_view</h3><p>　　　　　　process_view(self, request, view_func, view_args, view_kwargs)</p><p>　　　　　　该方法有四个参数</p><p>　　　　　　request是HttpRequest对象。</p><p>　　　　　　view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）</p><p>　　　　　　view_args是将传递给视图的位置参数的列表.</p><p>　　　　　　view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。</p><p>　　　　　　Django会在调用视图函数之前调用process_view方法。</p><p>　　　　　　它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。</p><p> 　　　　　　给MD1和MD2添加process_view方法:</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD1 中的process_view")        print(view_func, view_func.__name__)class MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")        pass    def process_response(self, request, response):        print("MD2里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD2 中的process_view")        print(view_func, view_func.__name__)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　访问index视图函数，看一下输出结果：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>MD2里面的 process_requestMD1里面的 process_request--------------------------------------------------------------------------------MD2 中的process_view&lt;function index at 0x000001DE68317488&gt; index--------------------------------------------------------------------------------MD1 中的process_view&lt;function index at 0x000001DE68317488&gt; indexapp01 中的 index视图MD1里面的 process_responseMD2里面的 process_response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　process_view方法是在process_request之后，视图函数之前执行的，执行顺序按照MIDDLEWARE中的注册顺序<strong>从前到后顺序</strong>执行的</p><p> 　　　　　　</p><h3 id="process-exception"><a href="#process-exception" class="headerlink" title="　　　　process_exception"></a>　　　　process_exception</h3><p>　　　　　　process_exception(self, request, exception)</p><p>　　　　　　该方法两个参数:</p><p>　　　　　　一个HttpRequest对象</p><p>　　　　　　一个exception是视图函数异常产生的Exception对象。</p><p>　　　　　　这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的倒序执行。</p><p> 　　　　　　给MD1和MD2添加上这个方法：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD1 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD1 中的process_exception")class MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")        pass    def process_response(self, request, response):        print("MD2里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD2 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD2 中的process_exception")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　如果视图函数中无异常，process_exception方法不执行。</p><p>　　　　　　想办法，在视图函数中抛出一个异常：</p><pre><code>def index(request):    print("app01 中的 index视图")    raise ValueError("呵呵")    return HttpResponse("O98K")</code></pre><p>　　　　　　在MD1的process_exception中返回一个响应对象：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>class MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD1 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD1 中的process_exception")        return HttpResponse(str(exception))  # 返回一个响应对象</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　看输出结果：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>MD2里面的 process_requestMD1里面的 process_request--------------------------------------------------------------------------------MD2 中的process_view&lt;function index at 0x0000022C09727488&gt; index--------------------------------------------------------------------------------MD1 中的process_view&lt;function index at 0x0000022C09727488&gt; indexapp01 中的 index视图呵呵MD1 中的process_exceptionMD1里面的 process_responseMD2里面的 process_response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　注意，这里并没有执行MD2的process_exception方法，因为MD1中的process_exception方法直接返回了一个响应对象。</p><h3 id="process-template-response（用的比较少）"><a href="#process-template-response（用的比较少）" class="headerlink" title="　　　　process_template_response（用的比较少）"></a>　　　　<strong>process_template_response（用的比较少）</strong></h3><p>　　　　　　process_template_response(self, request, response)</p><p>　　　　　　它的参数，一个HttpRequest对象，response是TemplateResponse对象（由视图函数或者中间件产生）。</p><p>　　　　　　process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法（或者表明该对象是一个TemplateResponse对象或等价方法）。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>class MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD1 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD1 中的process_exception")        return HttpResponse(str(exception))    def process_template_response(self, request, response):        print("MD1 中的process_template_response")        return responseclass MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")        pass    def process_response(self, request, response):        print("MD2里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD2 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD2 中的process_exception")    def process_template_response(self, request, response):        print("MD2 中的process_template_response")        return response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　views.py中：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>def index(request):    print("app01 中的 index视图")    def render():        print("in index/render")        return HttpResponse("O98K")    rep = HttpResponse("OK")    rep.render = render    return rep</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　访问index视图，终端输出的结果：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>MD2里面的 process_requestMD1里面的 process_request--------------------------------------------------------------------------------MD2 中的process_view&lt;function index at 0x000001C111B97488&gt; index--------------------------------------------------------------------------------MD1 中的process_view&lt;function index at 0x000001C111B97488&gt; indexapp01 中的 index视图MD1 中的process_template_responseMD2 中的process_template_responsein index/renderMD1里面的 process_responseMD2里面的 process_response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　从结果看出：</p><p>　　　　　　视图函数执行完之后，立即执行了中间件的process_template_response方法，顺序是倒序，先执行MD1的，在执行MD2的，接着执行了视图函数返回的HttpResponse对象的render方法，返回了一个新的HttpResponse对象，接着执行中间件的process_response方法。</p><h3 id="四-中间件执行流程"><a href="#四-中间件执行流程" class="headerlink" title="四 中间件执行流程"></a>四 中间件执行流程</h3><p>　　上一部分，我们了解了中间件中的5个方法，它们的参数、返回值以及什么时候执行，现在总结一下中间件的执行流程。</p><p>　　请求到达中间件之后，先按照正序执行每个注册中间件的process_reques方法，process_request方法返回的值是None，就依次执行，如果返回的值是HttpResponse对象，不再执行后面的process_request方法，而是执行当前对应中间件的process_response方法，将HttpResponse对象返回给浏览器。也就是说：如果MIDDLEWARE中注册了6个中间件，执行过程中，第3个中间件返回了一个HttpResponse对象，那么第4,5,6中间件的process_request和process_response方法都不执行，顺序执行3,2,1中间件的process_response方法。</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180409214209079-1725524152.png" alt="img"></p><p>　　process_request方法都执行完后，匹配路由，找到要执行的视图函数，先不执行视图函数，先执行中间件中的process_view方法，process_view方法返回None，继续按顺序执行，所有process_view方法执行完后执行视图函数。加入中间件3 的process_view方法返回了HttpResponse对象，则4,5,6的process_view以及视图函数都不执行，直接从最后一个中间件，也就是中间件6的process_response方法开始倒序执行。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180409214307195-1684061444.png" alt="img"></p><p>　　process_template_response和process_exception两个方法的触发是有条件的，执行顺序也是倒序。总结所有的执行流程如下：</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180409214356226-286908304.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180409214433968-2137571775.png" alt="img"></p><h3 id="五-中间件版登陆认证"><a href="#五-中间件版登陆认证" class="headerlink" title="五 中间件版登陆认证"></a>五 中间件版登陆认证</h3><p>中间件版的登录验证需要依靠session，所以数据库中要有django_session表。</p><p>　　　　urls.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom app01 import viewsurlpatterns = [    url(r'^index/$', views.index),    url(r'^login/$', views.login, name='login'),]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　views.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.shortcuts import render, HttpResponse, redirectdef index(request):    return HttpResponse('this is index')def home(request):    return HttpResponse('this is home')def login(request):    if request.method == "POST":        user = request.POST.get("user")        pwd = request.POST.get("pwd")        if user == "Q1mi" and pwd == "123456":            # 设置session            request.session["user"] = user            # 获取跳到登陆页面之前的URL            next_url = request.GET.get("next")            # 如果有，就跳转回登陆之前的URL            if next_url:                return redirect(next_url)            # 否则默认跳转到index页面            else:                return redirect("/index/")    return render(request, "login.html")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　login.html</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;    &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="{% url 'login' %}"&gt;    &lt;p&gt;        &lt;label for="user"&gt;用户名：&lt;/label&gt;        &lt;input type="text" name="user" id="user"&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label for="pwd"&gt;密 码：&lt;/label&gt;        &lt;input type="text" name="pwd" id="pwd"&gt;    &lt;/p&gt;    &lt;input type="submit" value="登录"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　middlewares.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>class AuthMD(MiddlewareMixin):    white_list = ['/login/', ]  # 白名单    balck_list = ['/black/', ]  # 黑名单    def process_request(self, request):        from django.shortcuts import redirect, HttpResponse        next_url = request.path_info        print(request.path_info, request.get_full_path())        if next_url in self.white_list or request.session.get("user"):            return        elif next_url in self.balck_list:            return HttpResponse('This is an illegal URL')        else:            return redirect("/login/?next={}".format(next_url))</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　在settings.py中注册</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'middlewares.AuthMD',]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　AuthMD中间件注册后，所有的请求都要走AuthMD的process_request方法。</p><p>　　　　访问的URL在白名单内或者session中有user用户名，则不做阻拦走正常流程；</p><p>　　　　如果URL在黑名单中，则返回This is an illegal URL的字符串；</p><p>　　　　正常的URL但是需要登录后访问，让浏览器跳转到登录页面。</p><p>　　　　注：AuthMD中间件中需要session，所以AuthMD注册的位置要在session中间的下方。</p><p>　　　　附：Django请求流程图</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180409234112982-196913305.png" alt="img"></p><h3 id="六-xxx"><a href="#六-xxx" class="headerlink" title="六 xxx"></a>六 xxx</h3><h3 id="七-xxx"><a href="#七-xxx" class="headerlink" title="七 xxx"></a>七 xxx</h3><h3 id="八-xxx"><a href="#八-xxx" class="headerlink" title="八 xxx"></a>八 xxx</h3><p>　　</p><p><a href="https://www.cnblogs.com/clschao/articles/10480419.html#top">回到顶部</a></p><p>中间件版的登录验证需要依靠session，所以数据库中要有django_session表。</p><p>urls.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><pre><code>from django.conf.urls import urlfrom app01 import viewsurlpatterns = [    url(r'^index/$', views.index),    url(r'^login/$', views.login, name='login'),]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>views.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><pre><code>from django.shortcuts import render, HttpResponse, redirectdef index(request):    return HttpResponse('this is index')def home(request):    return HttpResponse('this is home')def login(request):    if request.method == "POST":        user = request.POST.get("user")        pwd = request.POST.get("pwd")        if user == "Q1mi" and pwd == "123456":            # 设置session            request.session["user"] = user            # 获取跳到登陆页面之前的URL            next_url = request.GET.get("next")            # 如果有，就跳转回登陆之前的URL            if next_url:                return redirect(next_url)            # 否则默认跳转到index页面            else:                return redirect("/index/")    return render(request, "login.html")</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>login.html</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;    &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="{% url 'login' %}"&gt;    &lt;p&gt;        &lt;label for="user"&gt;用户名：&lt;/label&gt;        &lt;input type="text" name="user" id="user"&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label for="pwd"&gt;密 码：&lt;/label&gt;        &lt;input type="text" name="pwd" id="pwd"&gt;    &lt;/p&gt;    &lt;input type="submit" value="登录"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>middlewares.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><pre><code>class AuthMD(MiddlewareMixin):    white_list = ['/login/', ]  # 白名单    balck_list = ['/black/', ]  # 黑名单    def process_request(self, request):        from django.shortcuts import redirect, HttpResponse        next_url = request.path_info        print(request.path_info, request.get_full_path())        if next_url in self.white_list or request.session.get("user"):            return        elif next_url in self.balck_list:            return HttpResponse('This is an illegal URL')        else:            return redirect("/login/?next={}".format(next_url))</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>在settings.py中注册</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><pre><code>MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'middlewares.AuthMD',]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>AuthMD中间件注册后，所有的请求都要走AuthMD的process_request方法。</p><p>访问的URL在白名单内或者session中有user用户名，则不做阻拦走正常流程；</p><p>如果URL在黑名单中，则返回This is an illegal URL的字符串；</p><p>正常的URL但是需要登录后访问，让浏览器跳转到登录页面。</p><p>注：AuthMD中间件中需要session，所以AuthMD注册的位置要在session中间的下方。</p><p>附：Django请求流程图</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180409234112982-196913305.png" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础二之URL路由系统</title>
      <link href="2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%BA%8C%E4%B9%8BURL%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F/"/>
      <url>2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E4%BA%8C%E4%B9%8BURL%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10403619.html#part_1">一 URL配置</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10403619.html#part_2">二 正则表达式详解</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10403619.html#part_3">三 分组命名匹配</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10403619.html#part_4">四 命名URL（别名）和URL反向解析</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10403619.html#part_5">五 命名空间模式</a></li><li></li></ul><h3 id="一-URL配置"><a href="#一-URL配置" class="headerlink" title="一 URL配置"></a>一 URL配置</h3><p>　　</p><p><a href="https://docs.djangoproject.com/en/1.11/topics/http/urls/">Django 1.11版本 URLConf官方文档</a></p><p>　　URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL与要为该URL调用的视图函数之间的映射表。你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。</p><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="　　基本格式 　"></a>　　基本格式 　</h3><pre><code>from django.conf.urls import url#循环urlpatterns，找到对应的函数执行,匹配上一个路径就找到对应的函数执行，就不再往下循环了，并给函数传一个参数request，和wsgiref的environ类似，就是请求信息的所有内容urlpatterns = [     url(正则表达式, views视图函数，参数，别名),]</code></pre><p>　　注意：</p><p>　　Django 2.0版本中的路由系统已经替换成下面的写法，但是django2.0是向下兼容1.x版本的语法的（<a href="https://docs.djangoproject.com/en/2.0/topics/http/urls/">官方文档</a>）：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.urls import pathurlpatterns = [    path('articles/2003/', views.special_case_2003),    path('articles/&lt;int:year&gt;/', views.year_archive),    path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive),    path('articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/', views.article_detail),]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="　　参数说明　"></a>　　参数说明　</h3><ul><li>正则表达式：一个正则表达式字符串</li><li>views视图函数：一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串</li><li>参数：可选的要传递给视图函数的默认参数（字典形式）</li><li>别名：一个可选的name参数</li></ul><h3 id="二-正则表达式详解"><a href="#二-正则表达式详解" class="headerlink" title="二 正则表达式详解"></a>二 正则表达式详解</h3><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="　　基本配置"></a>　　基本配置</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^articles/2003/$', views.special_case_2003), #思考：如果用户想看2004、2005、2006....等，你要写一堆的url吗，是不是在articles后面写一个正则表达式/d{4}/就行啦，网址里面输入127.0.0.1:8000/articles/1999/试一下看看    url(r'^articles/([0-9]{4})/$', views.year_archive),     url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive), #思考，如果你想拿到用户输入的什么年份，并通过这个年份去数据库里面匹配对应年份的文章，你怎么办？怎么获取用户输入的年份啊，分组/(\d{4})/，一个小括号搞定    url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail),]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="　　注意事项"></a>　　注意事项</h3><ol><li>urlpatterns中的元素按照书写顺序从上往下逐一匹配正则表达式，一旦匹配成功则不再继续。</li><li>若要从URL中捕获一个值，只需要在它周围放置一对圆括号（分组匹配）。</li><li>不需要添加一个前导的反斜杠（也就是写在正则最前面的那个/），因为每个URL 都有。例如，应该是^articles 而不是 ^/articles。</li><li>每个正则表达式前面的’r’ 是可选的但是建议加上。</li><li>^articles&amp;  以什么结尾，以什么开头，严格限制路径</li></ol><p>　　</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="　　补充说明"></a>　　补充说明</h3><pre><code># 是否开启URL访问地址后面不为/跳转至带有/的路径的配置项APPEND_SLASH=True</code></pre><p>　　Django settings.py配置文件中默认没有 APPEND_SLASH 这个参数，但 Django 默认这个参数为 APPEND_SLASH = True。 其作用就是自动在网址结尾加’/‘。其效果就是：我们定义了urls.py：</p><pre><code>from django.conf.urls import urlfrom app01 import viewsurlpatterns = [        url(r'^blog/$', views.blog),]</code></pre><p>　　访问 <a href="http://www.example.com/blog">http://www.example.com/blog</a> 时，默认将网址自动转换为 <a href="http://www.example/com/blog/">http://www.example/com/blog/</a> 。</p><p>　　如果在settings.py中设置了 <strong>APPEND_SLASH=False</strong>，此时我们再请求 <a href="http://www.example.com/blog">http://www.example.com/blog</a> 时就会提示找不到页面。</p><h3 id="三-分组命名匹配"><a href="#三-分组命名匹配" class="headerlink" title="三 分组命名匹配"></a>三 分组命名匹配</h3><p>　　上面的示例使用简单的正则表达式分组匹配（通过圆括号）来捕获URL中的值并以位置参数形式传递给视图。</p><p>　　在更高级的用法中，可以使用分组命名匹配的正则表达式组来捕获URL中的值并以关键字参数形式传递给视图。</p><p>　　在Python的正则表达式中，分组命名正则表达式组的语法是<code>(?P&lt;name&gt;pattern)</code>，其中<code>name</code>是组的名称，<code>pattern</code>是要匹配的模式。</p><p>　　下面是以上URLconf 使用命名组的重写： </p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^articles/2003/$', views.special_case_2003), #注意正则匹配出来的内容是字符串，即便是你在url里面写的是2003数字，匹配出来之后也是字符串　　 url(r'^articles/(\d{4})/$', views.year_archive),#year_archive(request,2003),小括号为分组，有分组，那么这个分组得到的用户输入的内容，就会作为对应函数的位置参数传进去,别忘了形参要写两个了，明白了吗？    url(r'^articles/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive),#某年的，(?P&lt;year&gt;[0-9]{4})这是命名参数（正则命名匹配还记得吗？），那么函数year_archive(request,year)，形参名称必须是year这个名字。而且注意如果你这个正则后面没有写$符号，即便是输入了月份路径，也会被它拦截下拉，因为它的正则也能匹配上    url(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$', views.month_archive),#某年某月的    url(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/(?P&lt;day&gt;[0-9]{2})/$', views.article_detail), #某年某月某日的]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　这个实现与前面的示例完全相同，只有一个细微的差别：捕获的值作为关键字参数而不是位置参数传递给视图函数。</p><p>　　例如，针对url /articles/2017/12/相当于按以下方式调用视图函数：</p><pre><code>views.month_archive(request, year="2017", month="12")，year和month的位置可以换，没所谓了，因为是按照名字来取数据的，还记得关键字参数吗？</code></pre><p>　　在实际应用中，使用分组命名匹配的方式可以让你的URLconf 更加明晰且不容易产生参数顺序问题的错误，但是有些开发人员则认为分组命名组语法太丑陋、繁琐。</p><p>　　至于究竟应该使用哪一种，你可以根据自己的喜好来决定。</p><p>　　</p><h3 id="URLconf匹配的位置"><a href="#URLconf匹配的位置" class="headerlink" title="　　URLconf匹配的位置"></a>　　URLconf匹配的位置</h3><p>　　　　URLconf 在请求的URL 上查找，将它当做一个普通的Python 字符串。不包括GET和POST参数以及域名。</p><p>　　　　例如，<a href="http://www.example.com/myapp/">http://www.example.com/myapp/</a> 请求中，URLconf 将查找myapp/。</p><p>　　　　在<a href="http://www.example.com/myapp/?page=3">http://www.example.com/myapp/?page=3</a> 请求中，URLconf 仍将查找<code>myapp/</code>。</p><p>　　　　URLconf 不检查请求的方法。换句话讲，所有的请求方法 —— 同一个URL的<code>POST</code>、<code>GET</code>、<code>HEAD</code>等等 —— 都将路由到相同的函数。</p><h3 id="捕获的参数永远都是字符串"><a href="#捕获的参数永远都是字符串" class="headerlink" title="　　捕获的参数永远都是字符串"></a>　　捕获的参数永远都是字符串</h3><p> 　　每个在URLconf中捕获的参数都作为一个普通的Python字符串传递给视图，无论正则表达式使用的是什么匹配方式。例如，下面这行URLconf 中：</p><pre><code>url(r'^articles/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive),</code></pre><p> 　　传递到视图函数<code>views.year_archive()</code> 中的<code>year</code> 参数永远是一个字符串类型。</p><h3 id="视图函数中指定默认值"><a href="#视图函数中指定默认值" class="headerlink" title="　　视图函数中指定默认值"></a>　　视图函数中指定默认值</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code># urls.py中from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^blog/$', views.page),    url(r'^blog/page(?P&lt;num&gt;[0-9]+)/$', views.page),]# views.py中，可以为num指定默认值def page(request, num="1"):    pass</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　在上面的例子中，两个URL模式指向相同的view - views.page - 但是第一个模式并没有从URL中捕获任何东西。</p><p>　　如果第一个模式匹配上了，page()函数将使用其默认参数num=“1”,如果第二个模式匹配，page()将使用正则表达式捕获到的num值。</p><h3 id="include其他的URLconfs（也叫URL分发）"><a href="#include其他的URLconfs（也叫URL分发）" class="headerlink" title="　　include其他的URLconfs（也叫URL分发）"></a>　　include其他的URLconfs（也叫URL分发）</h3><p>　　问大家一个问题，views和models文件是不是都放在每一个app应用里面了啊，而urls.py这个文件放在哪了，是不是放在项目文件夹里面了，说明什么，说明是不是所有的app都在使用它，如果你一个项目有10个应用，没有应用有100个url，那意味着你要在urls文件里面要写多少条url对应关系，并且所有的app的url都写在了这一个urls文件里面啊，这样好吗，当然也没有问题，但是耦合程度太高了，所以django在url这里给你提供了一个分发接口，叫做include</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>#At any point, your urlpatterns can “include” other URLconf modules. This#essentially “roots” a set of URLs below other ones.#For example, here’s an excerpt of the URLconf for the Django website itself.#It includes a number of other URLconfs:from django.conf.urls import include, urlurlpatterns = [   url(r'^admin/', admin.site.urls),   url(r'^blog/', include('blog.urls')),  # 可以包含其他的URLconfs文件   url(r'^app01/',include('app01.urls')),  #别忘了要去app01这个应用下创建一个urls.py的文件，现在的意思是凡是以app01开头的路径请求，都让它去找app01下的urls文件中去找对应的视图函数，还要注意一点，此时这个文件里面的那个app01路径不能用$结尾，因为如果写了$，就没办法比配上app01/后面的路径了]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>app01的urls.py的内容：（其实就是将全局的urls.py里面的内容copy一下，放到你在app01文件夹下创建的那个urls.py文件中，把不是这个app01应用的url给删掉就行了）</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import url#from django.contrib import adminfrom app01 import viewsurlpatterns = [    # url(r'^admin/', admin.site.urls),    url(r'^articles/2003/', views.special_case_2003,{'foo':'xxxxx'}),    url(r'^articles/(\d{4})/(\d{2})/', views.year_archive),]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>此时的目录结构：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220174902848-639065171.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220175239520-934873728.png" alt="img"></p><p>　　　　此时我们再访问之前的articles相关的网址路径的时候，就需要写上app01开头的了</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220175503974-1926196930.png" alt="img"></p><p>　　　　正确输入方式：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220175542951-658101021.png" alt="img"></p><p>　　　　其实相当于做了什么呢，将网址<a href="http://127.0.0.1:8000/app01/articles/2003/%EF%BC%8C%E9%87%8C%E9%9D%A2%E7%9A%84%E8%B7%AF%E5%BE%84%E9%83%A8%E5%88%86app01/articles/2003/%EF%BC%8C%E5%88%B0%E9%A1%B9%E7%9B%AE%E7%9A%84urls.py%E9%87%8C%E9%9D%A2%E5%8C%B9%E9%85%8D%EF%BC%8C%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86app01/%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8B%BF%E7%9D%80%E8%B7%AF%E5%BE%84%E5%89%A9%E4%BD%99%E7%9A%84%E9%83%A8%E5%88%86articles/2003/%E5%8E%BBapp01%E9%87%8C%E9%9D%A2%E7%9A%84urls.py%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E3%80%82">http://127.0.0.1:8000/app01/articles/2003/，里面的路径部分app01/articles/2003/，到项目的urls.py里面匹配，匹配到了app01/，然后拿着路径剩余的部分articles/2003/去app01里面的urls.py文件里面进行匹配，找到对应的函数执行。</a></p><p>　　　　还要注意一点，看下面的$符号：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220180024964-1754694287.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220180055451-225179252.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220180112333-1721944268.png" alt="img"></p><p>　　　　</p><p>　　　　再来看：如果我们想通过输入<a href="http://127.0.0.1:8000/app01/%EF%BC%8C%E7%9C%8B%E5%88%B0app01%E8%BF%99%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84%E9%A6%96%E9%A1%B5%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E5%B0%B1%E5%83%8F%E6%88%91%E7%8E%B0%E5%9C%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAhttp://127.0.0.1:8000%E6%9D%A5%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%AB%99%E7%9A%84%E9%A6%96%E9%A1%B5%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%88%91%E5%90%8E%E9%9D%A2%E4%B8%8D%E5%8A%A0%E4%BB%BB%E4%BD%95%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%B0%B1%E7%9C%8B%E4%BD%A0%E7%BD%91%E5%9D%80%E7%9A%84%E9%A6%96%E9%A1%B5%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%8C%E4%B8%80%E8%88%AC%E7%BD%91%E7%AB%99%E7%9A%84%E6%A0%B9%E8%B7%AF%E5%BE%84%E9%83%BD%E6%98%AF%E7%BD%91%E7%AB%99%E7%9A%84%E9%A6%96%E9%A1%B5%EF%BC%8C%E5%AF%B9%E4%B8%8D%E5%AF%B9">http://127.0.0.1:8000/app01/，看到app01这个应用的首页，怎么办？就像我现在输入一个http://127.0.0.1:8000来查看网站的首页，怎么办，也就是说我后面不加任何路径，就看你网址的首页，怎么办，一般网站的根路径都是网站的首页，对不对</a></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220180543160-1425967.png" alt="img"></p><p>　　　　看下面这种写法可不可以：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220181735816-386159751.png" alt="img"></p><p>　　　　</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220181856526-775984446.png" alt="img"></p><p>　　　　views.py里面写了这么个函数</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220181157993-167542386.png" alt="img"></p><p>　　　　输入网址：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220181228065-320985053.png" alt="img"></p><p>　　　　发现都跑到index这个函数里面去执行了，也就是说，全部被这个没有匹配规则的url获取到了，对不对</p><p>　　　　所以，正确的写法，匹配根路径的写法：</p><pre><code>url(r'^$', views.index),#以空开头，还要以空结尾，写在项目的urls.py文件里面就是项目的首页，写在应用文件夹里面的urls.py文件中，那就是app01的首页</code></pre><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220182224457-1944564466.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220182238916-236289910.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220182347001-1869285547.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220182425827-1106255978.png" alt="img"></p><p>　　　　app01函数的内容：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220182505324-10639988.png" alt="img"></p><p>　　　　</p><p> 　　还有注意一点，就是加app的时候，需要进行配置：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190220184103575-1921038232.png" alt="img"></p><h2 id="传递额外的参数给视图函数（了解）"><a href="#传递额外的参数给视图函数（了解）" class="headerlink" title="　　传递额外的参数给视图函数（了解）"></a>　　传递额外的参数给视图函数（了解）</h2><p> 　　</p><p>　　　　URLconfs 具有一个钩子，让你传递一个Python 字典作为额外的参数传递给视图函数。</p><p><code>　　　　django.conf.urls.url()</code> 函数可以接收一个可选的第三个参数，它是一个字典，表示想要传递给视图函数的额外关键字参数。</p><p>　　　　例如：　</p><pre><code>from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^blog/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive, {'foo': 'bar'}),#注意，这就像一个命名分组一样，你的函数里面的必须有一个形参，形参必须叫做foo才行。]</code></pre><p>　　在这个例子中，对于/blog/2005/请求，Django 将调用views.year_archive(request, year=’2005’, foo=’bar’)。<br>　　　　这个技术在Syndication 框架中使用，来传递元数据和选项给视图。</p><h3 id="四-命名URL（别名）和URL的反向解析"><a href="#四-命名URL（别名）和URL的反向解析" class="headerlink" title="四 命名URL（别名）和URL的反向解析"></a>四 命名URL（别名）和URL的反向解析</h3><p> 你想，我们自己写的url里面的路径有没有可能会更改，如果路径更改了，那么我们前端访问这个路径的标签（a标签，form表单等等）里面的属性值是不是也要自己手动去改啊，这样我们拓展起来就不方便了，你想是不是？尤其是前端可能不是你写的，那你是不是要进行部门沟通啊，想一想怎么办？</p><p>　　在使用Django 项目时，一个常见的需求是获得URL的最终形式，以用于嵌入到生成的内容中（视图中和显示给用户的URL等）或者用于处理服务器端的导航（重定向等）。<br>　　人们强烈希望不要硬编码（其实就是在标签里面写死了路径，凡是写死了的代码就是硬编码）这些URL（费力、不可扩展且容易产生错误）或者设计一种与URLconf 毫不相关的专门的URL 生成机制，因为这样容易导致一定程度上产生过期的URL。<br>　　换句话讲，需要的是一个DRY 机制。除了其它有点，它还允许设计的URL 可以自动更新而不用遍历项目的源代码来搜索并替换过期的URL。<br>　　获取一个URL 最开始想到的信息是处理它视图的标识（例如名字），查找正确的URL 的其它必要的信息有视图参数的类型（位置参数、关键字参数）和值。<br>　　Django 提供一个办法是让URL 映射是URL 设计唯一的地方。你填充你的URLconf，然后可以双向使用它：</p><ul><li>根据用户/浏览器发起的URL 请求，它调用正确的Django 视图，并从URL 中提取它的参数需要的值。</li><li>根据Django 视图的标识和将要传递给它的参数的值，获取与之关联的URL。</li></ul><p>　　第一种方式是我们在前面的章节中一直讨论的用法。第二种方式叫做反向解析URL、反向URL 匹配、反向URL 查询或者简单的URL 反查。<br>　　在需要URL 的地方，对于不同层级，Django 提供不同的工具用于URL 反查：</p><ul><li>在模板中：使用url模板标签。</li><li>在Python 代码中：使用django.core.urlresolvers.reverse() 函数。</li><li>在更高层的与处理Django 模型实例相关的代码中：使用get_absolute_url() 方法。</li></ul><p>　　上面说了一大堆，你可能并没有看懂。（那是官方文档的生硬翻译）。</p><p>　　咱们简单来说就是可以给我们的URL匹配规则起个名字，一个URL匹配模式起一个名字。</p><p>　　这样我们以后就不需要写死URL代码了，只需要通过名字来调用当前的URL。</p><p>　　举个简单的例子：</p><pre><code>url(r'^home', views.home, name='home'),  # 给我的url匹配模式起名（别名）为 home，别名不需要改，路径你就可以随便改了，别的地方使用这个路径，就用别名来搞url(r'^index/(\d*)', views.index, name='index'),  # 给我的url匹配模式起名为index</code></pre><p>　　这样：</p><p>　　在模板里面可以这样引用：</p><pre><code>{% url 'home' %}  #模板渲染的时候，被django解析成了这个名字对应的那个url，这个过程叫做反向解析</code></pre><p> 在views函数中可以这样引用：(后面再讲这个视图函数应用反向解析的内容，上面的是模板应用反向解析的过程)</p><pre><code>from django.urls import reversereverse("index", args=("2018", ))</code></pre><p>　　例子：<br>　　考虑下面的URLconf：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom . import viewsurlpatterns = [    # ...    url(r'^articles/([0-9]{4})/$', views.year_archive, name='news-year-archive'),    # ...]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　根据这里的设计，某一年nnnn对应的归档的URL是<code>/articles/nnnn/</code>。</p><p>　　你可以在模板的代码中使用下面的方法获得它们：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;a href="{% url 'news-year-archive' 2012 %}"&gt;2012 Archive&lt;/a&gt;&lt;ul&gt;{% for yearvar in year_list %}<li><a href="{% url 'news-year-archive' yearvar %}">{{ yearvar }} Archive</a></li>{% endfor %}&lt;/ul&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 在Python 代码中，这样使用：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.urls import reversefrom django.shortcuts import redirectdef redirect_to_year(request):    # ...    year = 2006    # ...    return redirect(reverse('news-year-archive', args=(year,)))</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　如果出于某种原因决定按年归档文章发布的URL应该调整一下，那么你将只需要修改URLconf 中的内容。</p><p>　　在某些场景中，一个视图是通用的，所以在URL 和视图之间存在多对一的关系。对于这些情况，当反查URL 时，只有视图的名字还不够。</p><p>　　<strong>注意：</strong></p><p>　　为了完成上面例子中的URL 反查，你将需要使用命名的URL 模式。URL 的名称使用的字符串可以包含任何你喜欢的字符。不只限制在合法的Python 名称。</p><p>　　当命名你的URL 模式时，请确保使用的名称不会与其它应用中名称冲突。如果你的URL 模式叫做<code>comment</code>，而另外一个应用中也有一个同样的名称，当你在模板中使用这个名称的时候不能保证将插入哪个URL。</p><p>　　在URL 名称中加上一个前缀，比如应用的名称，将减少冲突的可能。我们建议使用<code>myapp-comment</code> 而不是<code>comment</code>。</p><p>　　 </p><h3 id="五-命名空间模式"><a href="#五-命名空间模式" class="headerlink" title="五 命名空间模式"></a>五 命名空间模式</h3><p>　　这个内容，我们后面用到的时候再过来学吧，比较靠后的一个内容<del>~</del></p><p>　　即使不同的APP使用相同的URL名称，URL的命名空间模式也可以让你唯一反转命名的URL。</p><p>　　举个例子：</p><p>　　project中的urls.py</p><pre><code>from django.conf.urls import url, includeurlpatterns = [    url(r'^app01/', include('app01.urls', namespace='app01')),    url(r'^app02/', include('app02.urls', namespace='app02')),]</code></pre><p>　　app01中的urls.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom app01 import viewsapp_name = 'app01'urlpatterns = [    url(r'^(?P&lt;pk&gt;\d+)/$', views.detail, name='detail')]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　app02中的urls.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom app02 import viewsapp_name = 'app02'urlpatterns = [    url(r'^(?P&lt;pk&gt;\d+)/$', views.detail, name='detail')]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　现在，我的两个app中 url名称重复了，我反转URL的时候就可以通过命名空间的名称得到我当前的URL。</p><p>　　<strong>语法：</strong></p><p>　　‘命名空间名称:URL名称’</p><p>　　模板中使用：</p><pre><code>{% url 'app01:detail' pk=12 pp=99 %}</code></pre><p>　　views中的函数中使用</p><pre><code>v = reverse('app01:detail', kwargs={'pk':11})</code></pre><p> 　　这样即使app中URL的命名相同，我也可以反转得到正确的URL了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础四之模板系统</title>
      <link href="2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E5%9B%9B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F/"/>
      <url>2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E5%9B%9B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-html"><code class="language-html">**本节目录**- [一 ORM简介](https://www.cnblogs.com/clschao/articles/10427807.html#part_1)- [二 单表操作](https://www.cnblogs.com/clschao/articles/10427807.html#part_2)- [三 章节作业](https://www.cnblogs.com/clschao/articles/10427807.html#part_3)- [四 xxx](https://www.cnblogs.com/clschao/articles/10427807.html#part_4)- [五 xxx](https://www.cnblogs.com/clschao/articles/10427807.html#part_5)- [六 xxx](https://www.cnblogs.com/clschao/articles/10427807.html#part_6)- [七 xxx](https://www.cnblogs.com/clschao/articles/10427807.html#part_7)- [八 xxx](https://www.cnblogs.com/clschao/articles/10427807.html#part_8)- ### 一 ORM简介　　- MVC或者MVC框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库，这极大的减轻了开发人员的工作量，不需要面对因数据库变更而导致的无效劳动- ORM是“对象-关系-映射”的简称。（Object Relational Mapping，简称ORM）(将来会学一个sqlalchemy，是和他很像的，但是django的orm没有独立出来让别人去使用，虽然功能比sqlalchemy更强大，但是别人用不了)- 类对象--->sql--->pymysql--->mysql服务端--->磁盘，orm其实就是将类对象的语法翻译成sql语句的一个引擎，明白orm是什么了，剩下的就是怎么使用orm，怎么来写类对象关系语句。　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180425153356710-1116321211.png)　　**原生sql和python的orm代码对比**[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```#sql中的表                                                       #创建表:     CREATE TABLE employee(                                                     id INT PRIMARY KEY auto_increment ,                                    name VARCHAR (20),                                                      gender BIT default 1,                                                  birthday DATA ,                                                         department VARCHAR (20),                                                salary DECIMAL (8,2) unsigned,                                        );  #sql中的表纪录                                                    #添加一条表纪录:                                                                INSERT employee (name,gender,birthday,salary,department)                         VALUES   ("alex",1,"1985-12-12",8000,"保洁部");                 #查询一条表纪录:                                                                 SELECT * FROM employee WHERE age=24;                                 #更新一条表纪录:                                                                 UPDATE employee SET birthday="1989-10-24" WHERE id=1;                #删除一条表纪录:                                                                DELETE FROM employee WHERE name="alex"                             #python的类class Employee(models.Model):     id=models.AutoField(primary_key=True)     name=models.CharField(max_length=32)     gender=models.BooleanField()     birthday=models.DateField()     department=models.CharField(max_length=32)     salary=models.DecimalField(max_digits=8,decimal_places=2) #python的类对象      #添加一条表纪录:          emp=Employee(name="alex",gender=True,birthday="1985-12-12",epartment="保洁部")          emp.save()      #查询一条表纪录:          Employee.objects.filter(age=24)      #更新一条表纪录:          Employee.objects.filter(id=1).update(birthday="1989-10-24")      #删除一条表纪录:          Employee.objects.filter(name="alex").delete()```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 二 单表操作　　## 一、创建表### 创建模型　　　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180426141311697-594587712.png)　　　　　　创建名为book的app，在book下的models.py中创建模型：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```from django.db import models# Create your models here.class Book(models.Model):     id=models.AutoField(primary_key=True) #如果表里面没有写主键，表里面会自动生成一个自增主键字段，叫做id字段，orm要求每个表里面必须要写一个主键     title=models.CharField(max_length=32)  #和varchar(32)是一样的，32个字符     state=models.BooleanField()     pub_date=models.DateField() #必须存这种格式"2018-12-12"     price=models.DecimalField(max_digits=8,decimal_places=2) #max_digits最大位数，decimal_places小数部分占多少位     publish=models.CharField(max_length=32)```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　　　接下来要创建对应的数据，连接上对应的数据库，然后执行创建表的命令，翻译成相应的sql，然后到数据库里面执行，从而创建对应的表。多了一步orm翻译成sql的过程，效率低了，但是没有太大的损伤，还能忍受，当你不能忍的时候，你可以自己写原生sql语句，一般的场景orm都够用了，开发起来速度更快，写法更贴近应用程序开发，还有一点就是数据库升级或者变更，那么你之前用sql语句写的数据库操作，那么就需要将sql语句全部修改，但是如果你用orm，就不需要担心这个问题，不管是你从mysql变更到oracle还是从oracle更换到mysql，你如果用的是orm来搞的，你只需要修改一下orm的引擎（配置文件里面改一些配置就搞定）就可以了，你之前写的那些orm语句还是会自动翻译成对应数据库的sql语句。　　　　　　### 2 更多字段和参数　　　　　　每个字段有一些特有的参数，例如，CharField需要max_length参数来指定`VARCHAR`数据库字段的大小。还有一些适用于所有字段的通用参数。 这些参数在文档中有详细定义，这里我们只简单介绍一些最常用的：　　　　　　**更多字段：**[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```'''&lt;1> CharField        字符串字段, 用于较短的字符串.        CharField 要求必须有一个参数 maxlength, 用于从数据库层和Django校验层限制该字段所允许的最大字符数.&lt;2> IntegerField       #用于保存一个整数.&lt;3> FloatField        一个浮点数. 必须 提供两个参数:        参数    描述        max_digits    总位数(不包括小数点和符号)        decimal_places    小数位数                举例来说, 要保存最大值为 999 (小数点后保存2位),你要这样定义字段:                models.FloatField(..., max_digits=5, decimal_places=2)                要保存最大值一百万(小数点后保存10位)的话,你要这样定义:                models.FloatField(..., max_digits=17, decimal_places=10) #max_digits大于等于17就能存储百万以上的数了                admin 用一个文本框(<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>)表示该字段保存的数据.&lt;4> AutoField        一个 IntegerField, 添加记录时它会自动增长. 你通常不需要直接使用这个字段;        自定义一个主键：my_id=models.AutoField(primary_key=True)        如果你不指定主键的话,系统会自动添加一个主键字段到你的 model.&lt;5> BooleanField        A true/false field. admin 用 checkbox 来表示此类字段.&lt;6> TextField        一个容量很大的文本字段.        admin 用一个 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span><span class="token punctuation">></span></span> (文本区域)表示该字段数据.(一个多行编辑框).&lt;7> EmailField        一个带有检查Email合法性的 CharField,不接受 maxlength 参数.&lt;8> DateField        一个日期字段. 共有下列额外的可选参数:        Argument    描述        auto_now    当对象被保存时,自动将该字段的值设置为当前时间.通常用于表示 "last-modified" 时间戳.        auto_now_add    当对象首次被创建时,自动将该字段的值设置为当前时间.通常用于表示对象创建时间.        （仅仅在admin中有意义...)&lt;9> DateTimeField         一个日期时间字段. 类似 DateField 支持同样的附加选项.&lt;10> ImageField        类似 FileField, 不过要校验上传对象是否是一个合法图片.#它有两个可选参数:height_field和width_field,        如果提供这两个参数,则图片将按提供的高度和宽度规格保存.    &lt;11> FileField     一个文件上传字段.     要求一个必须有的参数: upload_to, 一个用于保存上载文件的本地文件系统路径. 这个路径必须包含 strftime #formatting,     该格式将被上载文件的 date/time     替换(so that uploaded files don't fill up the given directory).     admin 用一个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>部件表示该字段保存的数据(一个文件上传部件) .     注意：在一个 model 中使用 FileField 或 ImageField 需要以下步骤:            （1）在你的 settings 文件中, 定义一个完整路径给 MEDIA_ROOT 以便让 Django在此处保存上传文件.            (出于性能考虑,这些文件并不保存到数据库.) 定义MEDIA_URL 作为该目录的公共 URL. 要确保该目录对             WEB服务器用户帐号是可写的.            （2） 在你的 model 中添加 FileField 或 ImageField, 并确保定义了 upload_to 选项,以告诉 Django             使用 MEDIA_ROOT 的哪个子目录保存上传文件.你的数据库中要保存的只是文件的路径(相对于 MEDIA_ROOT).             出于习惯你一定很想使用 Django 提供的 get_<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#fieldname</span><span class="token punctuation">></span></span>_url 函数.举例来说,如果你的 ImageField             叫作 mug_shot, 你就可以在模板中以 {{ object.#get_mug_shot_url }} 这样的方式得到图像的绝对路径.&lt;12> URLField      用于保存 URL. 若 verify_exists 参数为 True (默认), 给定的 URL 会预先检查是否存在( 即URL是否被有效装入且      没有返回404响应).      admin 用一个 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 文本框表示该字段保存的数据(一个单行编辑框)&lt;13> NullBooleanField       类似 BooleanField, 不过允许 NULL 作为其中一个选项. 推荐使用这个字段而不要用 BooleanField 加 null=True 选项       admin 用一个选择框 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span> (三个可选择的值: "Unknown", "Yes" 和 "No" ) 来表示这种字段数据.&lt;14> SlugField       "Slug" 是一个报纸术语. slug 是某个东西的小小标记(短签), 只包含字母,数字,下划线和连字符.#它们通常用于URLs       若你使用 Django 开发版本,你可以指定 maxlength. 若 maxlength 未指定, Django 会使用默认长度: 50.  #在       以前的 Django 版本,没有任何办法改变50 这个长度.       这暗示了 db_index=True.       它接受一个额外的参数: prepopulate_from, which is a list of fields from which to auto-#populate       the slug, via JavaScript,in the object's admin form: models.SlugField       (prepopulate_from=("pre_name", "name"))prepopulate_from 不接受 DateTimeFields.&lt;13> XMLField        一个校验值是否为合法XML的 TextField,必须提供参数: schema_path, 它是一个用来校验文本的 RelaxNG schema #的文件系统路径.&lt;14> FilePathField        可选项目为某个特定目录下的文件名. 支持三个特殊的参数, 其中第一个是必须提供的.        参数    描述        path    必需参数. 一个目录的绝对文件系统路径. FilePathField 据此得到可选项目.        Example: "/home/images".        match    可选参数. 一个正则表达式, 作为一个字符串, FilePathField 将使用它过滤文件名.         注意这个正则表达式只会应用到 base filename 而不是        路径全名. Example: "foo.*\.txt^", 将匹配文件 foo23.txt 却不匹配 bar.txt 或 foo23.gif.        recursive可选参数.要么 True 要么 False. 默认值是 False. 是否包括 path 下面的全部子目录.        这三个参数可以同时使用.        match 仅应用于 base filename, 而不是路径全名. 那么,这个例子:        FilePathField(path="/home/images", match="foo.*", recursive=True)        ...会匹配 /home/images/foo.gif 而不匹配 /home/images/foo/bar.gif&lt;15> IPAddressField        一个字符串形式的 IP 地址, (i.e. "24.124.1.30").&lt;16> CommaSeparatedIntegerField        用于存放逗号分隔的整数值. 类似 CharField, 必须要有maxlength参数.'''　　```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);) 　　　　　　**更多参数：**[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```(1)null如果为True，Django 将用NULL 来在数据库中存储空值。 默认值是 False.(1)blank如果为True，该字段允许不填。默认为False。要注意，这与 null 不同。null纯粹是数据库范畴的，而 blank 是数据验证范畴的。如果一个字段的blank=True，表单的验证将允许该字段是空值。如果字段的blank=False，该字段就是必填的。(2)default字段的默认值。可以是一个值或者可调用对象。如果可调用 ，每有新对象被创建它都会被调用，如果你的字段没有设置可以为空，那么将来如果我们后添加一个字段，这个字段就要给一个default值(3)primary_key如果为True，那么这个字段就是模型的主键。如果你没有指定任何一个字段的primary_key=True，Django 就会自动添加一个IntegerField字段做为主键，所以除非你想覆盖默认的主键行为，否则没必要设置任何一个字段的primary_key=True。(4)unique如果该值设置为 True, 这个数据字段的值在整张表中必须是唯一的(5)choices由二元组组成的一个可迭代对象（例如，列表或元组），用来给字段提供选择项。 如果设置了choices ，默认的表单将是一个选择框而不是标准的文本框，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>而且这个选择框的选项就是choices 中的选项。```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);) 　　　　### 3 settings配置　　　　　　若想将模型转为mysql数据库中的表，需要在settings中配置：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```DATABASES = {    'default': {        'ENGINE': 'django.db.backends.mysql',        'NAME':'bms',     　　 　  # 要连接的数据库，连接前需要创建好        'USER':'root',　　　　　　  # 连接数据库的用户名        'PASSWORD':'',　　　　　　  # 连接数据库的密码        'HOST':'127.0.0.1',       # 连接主机，默认本级        'PORT'：3306    　　　     #  端口 默认3306    }}```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　　　注意1：NAME即数据库的名字，在mysql连接前该数据库必须已经创建，而上面的sqlite数据库下的db.sqlite3则是项目自动创建 USER和PASSWORD分别是数据库的用户名和密码。设置完后，再启动我们的Django项目前，我们需要激活我们的mysql。然后，启动项目，会报错：no module named MySQLdb 。这是因为django默认你导入的驱动是MySQLdb，可是MySQLdb 对于py3有很大问题，所以我们需要的驱动是PyMySQL 所以，我们只需要找到项目名文件下的__init__,在里面写入：　　```import pymysqlpymysql.install_as_MySQLdb()```　　　　　　最后通过两条数据库迁移命令即可在指定的数据库中创建表 ：```python manage.py makemigrations  #生成记录，每次修改了models里面的内容或者添加了新的app，新的app里面写了models里面的内容，都要执行这两条python manage.py migrate         #执行上面这个语句的记录来创建表，生成的表名字前面会自带应用的名字，例如：你的book表在mysql里面叫做app01_book表```　　　　　　通过pycharm提供的功能来执行manage.py相关的指令：　　　　　　![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190225185643688-1003383248.png)　　　　　　　　给之前的字段添加一些数据，然后再添加一个字段，然后执行上面两个指令，看看效果。　　　　　　注意2:确保配置文件中的INSTALLED_APPS中写入我们创建的app名称[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```INSTALLED_APPS = [    'django.contrib.admin',  #这是django给你提供的一些特殊功能的配置（应用，只是咱们看不到），也在应用这里给配置的，这些功能如果你注销了，那么我们执行同步数据库指令之后，就不会生成那些django自带的表了。因为执行数据库同步语句的时候，django会找这里面所有的应用，找到他们的models来创建表    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    "book"  #直接写app的名字也行，写'app01.apps.App01Config'也行]```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　 　　　　注意3:如果报错如下：```django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None```　　　　MySQLclient目前只支持到python3.4，因此如果使用的更高版本的python，需要修改如下：　　　　通过查找路径C:\Programs\Python\Python36-32\Lib\site-packages\Django-2.0-py3.6.egg\django\db\backends\mysql　　　　这个路径里的文件把```if version &lt; (1, 3, 3):     raise ImproperlyConfigured("mysqlclient 1.3.3 or newer is required; you have %s" % Database.__version__)```　　　　注释掉 就OK了。　　　　注意4: 如果想打印orm转换过程中的sql，需要在settings中进行如下配置：（学了增加记录的语句在过来配置吧）[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```LOGGING = {    'version': 1,    'disable_existing_loggers': False,    'handlers': {        'console':{            'level':'DEBUG',            'class':'logging.StreamHandler',        },    },    'loggers': {        'django.db.backends': {            'handlers': ['console'],            'propagate': True,            'level':'DEBUG',        },    }}　　```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);) 　　　　还有一种查看sql语句的方式[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```from app01 import modelsdef add_book(request):    '''    添加表记录    :param request: http请求信息    :return:    '''    book_obj = models.Book(title='python',price=123,pub_date='2012-12-12',publish='人民出版社')    book_obj.save()    from django.db import connection  #通过这种方式也能查看执行的sql语句    print(connection.queries)    return HttpResponse('ok')```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　　　 　　表创建完了，我们就来个增删改查，来个图书管理系统。## 二、添加表纪录　　　　　在python中orm的对应关系有三种：　　　　类        ---------->表　　　　类对象 ---------->行(记录)　　　　类属性 ---------->表的字段（重点）　　　　首先想操作表的增删改查，你需要导入这个表　　　　[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```#在逻辑代码中导入你要操作的表from app01 import modelsdef add_book(request):    '''    添加表记录    :param request: http请求信息    :return:    '''    models.Book(title='python',price=123,pub_date='2012-12-12',publish='人民出版社')```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 方式1```book_obj=Book(title="python葵花宝典",state=True,price=100,publish="苹果出版社",pub_date="2012-12-12") #实例化一个对象表示一行记录，时间日期如果只写日期的话，时间默认是00.00.00，注意日期写法必须是2012-12-12这种格式book_obj.save() #就是pymysql的那个commit提交```### 方式2（用的多）[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```# create方法的返回值book_obj就是插入book表中的python葵花宝典这本书籍纪录对象  book_obj=Book.objects.create(title="python葵花宝典",state=True,price=100,publish="苹果出版社",pub_date="2012-12-12")  #这个返回值就像是mysql里面咱们讲的那个new对象，还记得吗，他跟上面那种创建方式创建的那个对象是一样的  #这个Book.objects就像是一个Book表的管理器一样，提供了增删改查所有的方法  print(book_obj.title) #可以基于这个对象来取这个新添加的记录对象的属性值  dic1 = {'title':'linux','state'=True,'price':100,'publish'='2018-12-12'}  #这样写的时候，注意如果你用post提交过来的请求，有个csrf_token的键值对要删除，并且request.POST是不能直接在request.POST里面进行修改和删除的，data = request.POST.dict()转换成普通的字典-->Book.objects.create(**data)  book.objects.create(**dic1)```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 　## 三、查询表纪录　　　　还记得表类.objects像是一个管理器，提供了增删改查的方法，Book.objects.all()获取所有的书籍，查询这里大家就掌握谁调用的下面的方法### 查询API[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```&lt;1> all():                  查询所有结果，结果是queryset类型&lt;2> filter(**kwargs):       它包含了与所给筛选条件相匹配的对象，结果也是queryset类型 Book.objects.filter(title='linux',price=100) #里面的多个条件用逗号分开，并且这几个条件必须都成立，是and的关系，or关系的我们后面再学，直接在这里写是搞不定or的&lt;3> get(**kwargs):          返回与所给筛选条件相匹配的对象，不是queryset类型，是行记录对象，返回结果有且只有一个，                            如果符合筛选条件的对象超过一个或者没有都会抛出错误。捕获异常try。  Book.objects.get(id=1)&lt;4> exclude(**kwargs):      排除的意思，它包含了与所给筛选条件不匹配的对象，没有不等于的操作昂，用这个exclude，返回值是queryset类型&lt;5> order_by(*field):       对查询结果排序&lt;6> reverse():              对查询结果反向排序&lt;8> count():                返回数据库中匹配查询(QuerySet)的对象数量。&lt;9> first():                返回第一条记录 Book.objects.all()[0] = Book.objects.all().first()，得到的都是model对象，不是queryset&lt;10> last():                返回最后一条记录&lt;11> exists():              如果QuerySet包含数据，就返回True，否则返回False&lt;12> values(*field):        返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列                            model的实例化对象，而是一个可迭代的字典序列&lt;13> values_list(*field):   它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列&lt;14> distinct():            从返回结果中剔除重复纪录```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)　　打印一个对象，让他显示一个能够看懂的值，__str__，models.py的数据表类里面定义一个__str__方法就可以了[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```#__str__方法的使用class MyClass:    def __init__(self,name,age):        self.name = name        self.age = age    def __str__(self):        return self.name + '>>>' + str(self.age)a = MyClass('chao',18)b = MyClass('wc',20)print(a)print(b)```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);) 　　models.py的__str__的写法：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```from django.db import models# Create your models here.class Book(models.Model):    id = models.AutoField(primary_key=True)    title = models.CharField(max_length=32)    price = models.DecimalField(max_digits=8,decimal_places=2,)    pub_date = models.DateTimeField() #必须存这种格式"2012-12-12"    publish = models.CharField(max_length=32)    def __str__(self): #后添加这个str方法，也不需要重新执行同步数据库的指令        return self.title #当我们打印这个类的对象的时候，显示title值```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 基于双下划线的模糊查询　　[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```Book.objects.filter(price__in=[100,200,300])Book.objects.filter(price__gt=100)Book.objects.filter(price__lt=100)Book.objects.filter(price__range=[100,200])Book.objects.filter(title__contains="python")Book.objects.filter(title__icontains="python")Book.objects.filter(title__startswith="py")Book.objects.filter(pub_date__year=2012)```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)## 四、删除表纪录 　　　　删除方法就是 delete()。它运行时立即删除对象而不返回任何值。例如：```model_obj.delete()```　　　　你也可以一次性删除多个对象。每个 QuerySet 都有一个 delete() 方法，它一次性删除 QuerySet 中所有的对象。　　　　例如，下面的代码将删除 pub_date 是2005年的 Entry 对象：```Entry.objects.filter(pub_date__year=2005).delete()```　　　　在 Django 删除对象时，会模仿 SQL 约束 ON DELETE CASCADE 的行为，换句话说，删除一个对象时也会删除与它相关联的外键对象。例如：　```b = Blog.objects.get(pk=1)# This will delete the Blog and all of its Entry objects.b.delete()```　　　　要注意的是： delete() 方法是 QuerySet 上的方法，但并不适用于 Manager 本身。这是一种保护机制，是为了避免意外地调用 Entry.objects.delete() 方法导致 所有的 记录被误删除。如果你确认要删除所有的对象，那么你必须显式地调用：```Entry.objects.all().delete()　```　　　　如果不想级联删除，可以设置为:```pubHouse = models.ForeignKey(to='Publisher', on_delete=models.SET_NULL, blank=True, null=True)``` 　　　　## 五、修改表纪录```Book.objects.filter(title__startswith="py").update(price=120),```　　　　此外，update()方法对于任何结果集（QuerySet）均有效，这意味着你可以同时更新多条记录update()方法会返回一个整型数值，表示受影响的记录条数。　　　　注意：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>date<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>book_pub_date<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>出版日期<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>book_pub_date<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ edit_obj.pub_date|date:<span class="token punctuation">'</span>Y-m-d<span class="token punctuation">'</span> }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>，type='date'的input标签，value的值必须是'Y-m-d'的格式，这个标签才能认识并被赋值，所以，要通过date过滤给它改变格式。### 三 章节作业### 1 图书管理系统　　　　实现功能：book单表的增删改查### 2 查询操作练习[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```1 查询老男孩出版社出版过的价格大于200的书籍2 查询2017年8月出版的所有以py开头的书籍名称3 查询价格为50,100或者150的所有书籍名称及其出版社名称4 查询价格在100到200之间的所有书籍名称及其价格5 查询所有人民出版社出版的书籍的价格（从高到低排序，去重）```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)### 四 xxx 配置：（自行忽略此处）[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)```LANGUAGE_CODE = 'zh-hans'TIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础八之cookie和session</title>
      <link href="2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E5%85%AB%E4%B9%8Bcookie%E5%92%8Csession%20/"/>
      <url>2019/11/15/Django/Django%E5%9F%BA%E7%A1%80%E5%85%AB%E4%B9%8Bcookie%E5%92%8Csession%20/</url>
      
        <content type="html"><![CDATA[<p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10480206.html#part_1">一 会话跟踪</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480206.html#part_2">二 cookie</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480206.html#part_3">三 django中操作cookie</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480206.html#part_4">四 session</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480206.html#part_5">五 django中操作session</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480206.html#part_6">六 xxx</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480206.html#part_7">七 xxx</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10480206.html#part_8">八 xxx</a></li><li></li></ul><h3 id="一-会话跟踪"><a href="#一-会话跟踪" class="headerlink" title="一 会话跟踪"></a>一 会话跟踪</h3><p>　　<strong>我们需要先了解一下什么是会话！可以把会话理解为客户端与服务器之间的一次会晤，在一次会晤中可能会包含多次请求和响应。例如你给10086打个电话，你就是客户端，而10086服务人员就是服务器了。从双方接通电话那一刻起，会话就开始了，到某一方挂断电话表示会话结束。在通话过程中，你会向10086发出多个请求，那么这多个请求都在一个会话中。 客户向某一服务器发出第一个请求开始，会话就开始了，直到客户关闭了浏览器会话结束。</strong></p><p>　　</p><p>　　在一个会话的多个请求中共享数据，这就是会话跟踪技术。例如在一个会话中的请求如下： </p><ul><li>请求银行主页； </li><li>请求登录（请求参数是用户名和密码）；</li><li>请求转账（请求参数与转账相关的数据）； </li><li>请求信誉卡还款（请求参数与还款相关的数据）。  </li></ul><p>　　在这上会话中当前用户信息必须在这个会话中共享的，因为登录的是张三，那么在转账和还款时一定是相对张三的转账和还款！这就说明我们必须在一个会话过程中有共享数据的能力。而web中这种能力的实现就要依靠cookie和session</p><h3 id="二-cookie"><a href="#二-cookie" class="headerlink" title="二 cookie"></a>二 cookie</h3><h3 id="Cookie的由来"><a href="#Cookie的由来" class="headerlink" title="　　Cookie的由来"></a>　　Cookie的由来</h3><p>　　　　大家都知道HTTP协议是无状态的。</p><p>　　　　无状态的意思是每次请求都是独立的，它的执行情况和结果与前面的请求和之后的请求都无直接关系，它不会受前面的请求响应情况直接影响，也不会直接影响后面的请求响应情况。</p><p>　　　　一句有意思的话来描述就是人生只如初见，对服务器来说，每次的请求都是全新的。</p><p>　　　　状态可以理解为客户端和服务器在某次会话中产生的数据，那无状态的就以为这些数据不会被保留。会话中产生的数据又是我们需要保存的，也就是说要“保持状态”。因此Cookie就是在这样一个场景下诞生。</p><p>​              并且还有一个问题就是，你登陆我的网站的时候，我没法确定你是不是登陆了，之前我们学的django，虽然写了很多页面，但是用户不用登陆都是可以看所有网页的，只要他知道网址就行，但是我们为了自己的安全机制，我们是不是要做验证啊，访问哪一个网址，都要验证用户的身份，但是还有保证什么呢，用户登陆过之后，还要保证登陆了的用户不需要再重复登陆，就能够访问我网站的其他的网址的页面，对不对，但是http无状态啊，怎么保证这个事情呢？此时就要找cookie了。</p><h3 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="　　什么是Cookie"></a>　　什么是Cookie</h3><p>　　　　首先来讲，cookie是浏览器的技术，Cookie具体指的是一段小信息，它是服务器发送出来存储在浏 览器上的一组组键值对，可以理解为服务端给客户端的一个小甜点，下次访问服务器时浏览器会自动携带这些键值对，以便服务器提取有用信息。</p><h3 id="Cookie的原理"><a href="#Cookie的原理" class="headerlink" title="　　Cookie的原理"></a>　　Cookie的原理</h3><p>　　　　cookie的工作原理是：浏览器访问服务端，带着一个空的cookie，然后由服务器产生内容，浏览器收到相应后保存在本地；当浏览器再次访问时，浏览器会自动带上Cookie，这样服务器就能通过Cookie的内容来判断这个是“谁”了。</p><h3 id="查看-Cookie"><a href="#查看-Cookie" class="headerlink" title="　　查看**Cookie**"></a>　　<strong>查看**</strong>Cookie**</h3><p>　　　　我们使用Chrome浏览器，打开开发者工具。　　　　</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180403225926558-498750585.png" alt="img"></p><h3 id="cookie图解"><a href="#cookie图解" class="headerlink" title="　　cookie图解"></a>　　cookie图解</h3><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180516192005344-137605378.png" alt="img"></p><p>　　</p><h3 id="Cookie规范"><a href="#Cookie规范" class="headerlink" title="　　Cookie规范"></a>　　Cookie规范</h3><ul><li>Cookie大小上限为4KB； </li><li>一个服务器最多在客户端浏览器上保存20个Cookie； </li><li>一个浏览器最多保存300个Cookie，因为一个浏览器可以访问多个服务器。</li></ul><p>　　　　上面的数据只是HTTP的Cookie规范，但在浏览器大战的今天，一些浏览器为了打败对手，为了展现自己的能力起见，可能对Cookie规范“扩展”了一些，例如每个Cookie的大小为8KB，最多可保存500个Cookie等！但也不会出现把你硬盘占满的可能！<br>注意，不同浏览器之间是不共享Cookie的。也就是说在你使用IE访问服务器时，服务器会把Cookie发给IE，然后由IE保存起来，当你在使用FireFox访问服务器时，不可能把IE保存的Cookie发送给服务器。</p><h3 id="Cookie与HTTP头"><a href="#Cookie与HTTP头" class="headerlink" title="　　Cookie与HTTP头"></a>　　Cookie与HTTP头</h3><p>　　　　Cookie是通过HTTP请求和响应头在客户端和服务器端传递的： </p><ul><li>Cookie：请求头，客户端发送给服务器端； </li><li>格式：Cookie: a=A; b=B; c=C。即多个Cookie用分号离开；  Set-Cookie：响应头，服务器端发送给客户端； </li><li>一个Cookie对象一个Set-Cookie： Set-Cookie: a=A Set-Cookie: b=B Set-Cookie: c=C  </li></ul><h3 id="Cookie的覆盖"><a href="#Cookie的覆盖" class="headerlink" title="　　Cookie的覆盖"></a>　　Cookie的覆盖</h3><p>  　　　　如果服务器端发送重复的Cookie那么会覆盖原有的Cookie，例如客户端的第一个请求服务器端发送的Cookie是：Set-Cookie: a=A；第二请求服务器端发送的是：Set-Cookie: a=AA，那么客户端只留下一个Cookie，即：a=AA。 </p><h3 id="三-django中操作cookie"><a href="#三-django中操作cookie" class="headerlink" title="三 django中操作cookie"></a>三 django中操作cookie</h3><p> 　　Ctrl + Shift + del三个键来清除页面缓存和cookie，将来这个操作你会用的很多。</p><h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="　　获取Cookie"></a>　　获取Cookie</h3><pre><code>request.COOKIES['key']request.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)</code></pre><p>　　　　参数：</p><p>　　　　　　default: 默认值</p><p>　　　　　　salt: 加密盐</p><p>　　　　　　max_age: 后台控制过期时间</p><h3 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="　　设置Cookie"></a>　　设置Cookie</h3><pre><code>rep = HttpResponse(...)rep ＝ render(request, ...)rep.set_cookie(key,value,...)rep.set_signed_cookie(key,value,salt='加密盐', max_age=None, ...)</code></pre><p>　　　　参数：</p><p>　　　　　　key, 键</p><p>　　　　　　value=’’, 值</p><p>　　　　　　max_age=None, 超时时间</p><p>　　　　　　expires=None, 超时时间(IE requires expires, so set it if hasn’t been already.)</p><p>　　　　　　path=’/‘, Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问</p><p>　　　　　　domain=None, Cookie生效的域名</p><p>　　　　　　secure=False, https传输</p><p>　　　　　　httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</p><p>　　　　<strong>set_cookie方法源码</strong>：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>class HttpResponseBase:        def set_cookie(self, key,                 键        　　　　　　　　　　　　 value='',            值        　　　　　　　　　　　　 max_age=None,        超长时间 ,有效事件，max_age=20意思是这个cookie20秒后就消失了，默认时长是2周,这个是以秒为单位的　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　cookie需要延续的时间（以秒为单位）　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　如果参数是\ None`` ，这个cookie会延续到浏览器关闭为止。        　　　　　　　　　　　　 expires=None,        超长时间，值是一个datetime类型的时间日期对象，到这个日期就失效的意思，用的不多       　　　　　　　　　　　　　　　　　　　　　　　　　　expires默认None ,cookie失效的实际日期/时间。     　　　　　　　　　　　　　　　　　　　　　　　　　　　　        　　　　　　　　　　　　 path='/',           Cookie生效的路径，就是访问哪个路径可以得到cookie，'/'是所有路径都能获得cookie                                                 浏览器只会把cookie回传给带有该路径的页面，这样可以避免将                                                 cookie传给站点中的其他的应用。                                                 / 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问        　　　　　　　　　　　　                              domain=None,         Cookie生效的域名                                                  你可用这个参数来构造一个跨站cookie。                                                  如， domain=".example.com"                                                  所构造的cookie对下面这些站点都是可读的：                                                  www.example.com 、 www2.example.com         　　　　　　　　　　　　　　　　　　　　　　　　　和an.other.sub.domain.example.com 。                                                  如果该参数设置为 None ，cookie只能由设置它的站点读取。        　　　　　　　　　　　　 secure=False,        如果设置为 True ，浏览器将通过HTTPS来回传cookie。        　　　　　　　　　　　　 httponly=False       只能http协议传输，无法被JavaScript获取                                                 （不是绝对，底层抓包可以获取到也可以被覆盖）        　　　　　　　　　　): pass</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="删除Cookie"><a href="#删除Cookie" class="headerlink" title="　　删除Cookie"></a>　　删除Cookie</h3><pre><code>def logout(request):    rep = redirect("/login/")    rep.delete_cookie("user")  # 删除用户浏览器上之前设置的usercookie值    return rep</code></pre><p>　　<a href="https://www.cnblogs.com/clschao/articles/10480029.html">jQuery操作cookie</a></p><p>　　<strong>Cookie版登陆校验示例：</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>def check_login(func):    @wraps(func)    def inner(request, *args, **kwargs):        next_url = request.get_full_path()        if request.get_signed_cookie("login", salt="SSS", default=None) == "yes":            # 已经登录的用户...            return func(request, *args, **kwargs)        else:            # 没有登录的用户，跳转刚到登录页面            return redirect("/login/?next={}".format(next_url))    return innerdef login(request):    if request.method == "POST":        username = request.POST.get("username")        passwd = request.POST.get("password")        if username == "xxx" and passwd == "dashabi":            next_url = request.GET.get("next")            if next_url and next_url != "/logout/":                response = redirect(next_url)            else:                response = redirect("/class_list/")            response.set_signed_cookie("login", "yes", salt="SSS")            return response    return render(request, "login.html")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>留两个小练习吧：</p><p>　　　　案例1:显示上次访问时间。　</p><p>　　　　案例2:显示上次浏览过的商品。</p><h3 id="四-session"><a href="#四-session" class="headerlink" title="四 session"></a>四 session</h3><p> Session是服务器端技术，利用这个技术，服务器在运行时可以 为每一个用户的浏览器创建一个其独享的session对象，由于 session为用户浏览器独享，所以用户在访问服务器的web资源时 ，可以把各自的数据放在各自的session中，当用户再去访问该服务器中的其它web资源时，其它web资源再从用户各自的session中 取出数据为用户服务。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180516210726463-1449400075.png" alt="img"></p><p> 　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/0_132156434454Ee.gif" alt="img"> </p><p>　　Cookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session。</p><p>　　问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。</p><p>　　我们可以给每个客户端的Cookie分配一个唯一的id，这样用户在访问时，通过Cookie，服务器就知道来的人是“谁”。然后我们再根据不同的Cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。</p><p>　　总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在Session里保存私密的信息以及超过4096字节的文本。</p><p>　　另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。</p><h3 id="五-django中操作session"><a href="#五-django中操作session" class="headerlink" title="五 django中操作session"></a>五 django中操作session</h3><h2 id="Django中Session相关方法"><a href="#Django中Session相关方法" class="headerlink" title="　　Django中Session相关方法"></a>　　Django中Session相关方法</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><p>　　注意：这都是django提供的方法，其他的框架就需要你自己关于cookie和session的方法了。</p><pre><code># 获取、设置、删除Session中数据#取值request.session['k1'] request.session.get('k1',None) #request.session这句是帮你从cookie里面将sessionid的值取出来，将django-session表里面的对应sessionid的值的那条记录中的session-data字段的数据给你拿出来（并解密）,get方法就取出k1这个键对应的值#设置值request.session['k1'] = 123request.session.setdefault('k1',123) # 存在则不设置#帮你生成随机字符串，帮你将这个随机字符串和用户数据（加密后）和过期时间保存到了django-session表里面，帮你将这个随机字符串以sessionid：随机字符串的形式添加到cookie里面返回给浏览器,这个sessionid名字是可以改的，以后再说#但是注意一个事情，django-session这个表，你不能通过orm来直接控制，因为你的models.py里面没有这个对应关系#删除值del request.session['k1']  #django-session表里面同步删除# 所有 键、值、键值对request.session.keys()request.session.values()request.session.items()# 会话session的keysession_key = request.session.session_key  获取sessionid的值# 将所有Session失效日期小于当前日期的数据删除，将过期的删除request.session.clear_expired()# 检查会话session的key在数据库中是否存在request.session.exists("session_key") #session_key就是那个sessionid的值# 删除当前会话的所有Session数据request.session.delete()　　# 删除当前的会话数据并删除会话的Cookie。request.session.flush()  #常用，清空所有cookie---删除session表里的这个会话的记录，    这用于确保前面的会话数据不可以再次被用户的浏览器访问    例如，django.contrib.auth.logout() 函数中就会调用它。# 设置会话Session和Cookie的超时时间request.session.set_expiry(value)    * 如果value是个整数，session会在些秒数后失效。    * 如果value是个datatime或timedelta，session就会在这个时间后失效。    * 如果value是0,用户关闭浏览器session就会失效。    * 如果value是None,session会依赖全局session失效策略。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="Session详细流程解析"><a href="#Session详细流程解析" class="headerlink" title="　　Session详细流程解析"></a>　　Session详细流程解析</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/867021-20180514143525989-365124875.png" alt="img"></p><h3 id="Session版登陆验证示例"><a href="#Session版登陆验证示例" class="headerlink" title="　　Session版登陆验证示例"></a>　　Session版登陆验证示例</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from functools import wrapsdef check_login(func):    @wraps(func)    def inner(request, *args, **kwargs):        next_url = request.get_full_path()        if request.session.get("user"):            return func(request, *args, **kwargs)        else:            return redirect("/login/?next={}".format(next_url))    return innerdef login(request):    if request.method == "POST":        user = request.POST.get("user")        pwd = request.POST.get("pwd")        if user == "alex" and pwd == "alex1234":            # 设置session            request.session["user"] = user            # 获取跳到登陆页面之前的URL            next_url = request.GET.get("next")            # 如果有，就跳转回登陆之前的URL            if next_url:                return redirect(next_url)            # 否则默认跳转到index页面            else:                return redirect("/index/")    return render(request, "login.html")@check_logindef logout(request):    # 删除所有当前请求相关的session    request.session.delete()    return redirect("/login/")@check_logindef index(request):    current_user = request.session.get("user", None)    return render(request, "index.html", {"user": current_user})</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　问题：同一个浏览器上，如果一个用户已经登陆了，你如果在通过这个浏览器以另外一个用户来登陆，那么到底是第一个用户的页面还是第二个用户的页面，有同学是不是懵逼了，你想想，一个浏览器和一个网站能保持两个用户的对话吗？你登陆一下博客园试试，第一个用户登陆的时候，没有带着sessionid，第二个用户登陆的时候，带着第一个用户的sessionid，这个值在第二个用户登陆之后，session就被覆盖了，浏览器上的sessionid就是我第二个用户的了，那么你用第一个用户再点击其他内容，你会发现，看到的都是第二个用户的信息（注意：公众都能访问的a标签不算）。还有，你想想是不是你登陆一次就在django-session表里面给你添加一条session记录吗？为什么呢？因为你想，如果是每个用户每次登陆都添加一条sesson的记录，那么这个用户一年要登陆多少次啊，那你需要记录多少次啊，你想想，所以，你每次登陆的时候，都会将你之前登陆的那个session记录给你更新掉，也就是说你登陆的时候，如果你带着一个session_id，那么不是新添加一条记录，用的还是django-session表里面的前面那一次登陆的session_key随机字符串，但是session_data和expire_date都变了，也就是说那条记录的钥匙还是它，但是数据变了，有同学又要问了，那我过了好久才过来再登陆的，那个session_id都没有了啊怎么办，你放心，你浏览器上的session_id没有了的话，你django-session表里的关于你这个用户的session记录肯定被删掉了。再想，登陆之后，你把登陆之后的网址拿到另外一个浏览器上去访问，能访问吗？当然不能啦，另外一个浏览器上有你这个浏览器上的cookie吗，没有cookie能有session吗？如果你再另外一个浏览器上又输入了用户名和密码登陆了，会发生什么事情，django-session表里面会多一条记录，记着，一个网站对一个浏览器，是一个sessionid的，换一个浏览器客户端，肯定会生成另外一个sessionid，django-session表里面的session_key肯定不同，但是session_data字段的数据肯定是一样的，当然了，这个还要看人家的加密规则。</p><h3 id="Django中的Session配置"><a href="#Django中的Session配置" class="headerlink" title="　　Django中的Session配置"></a>　　Django中的Session配置</h3><p>　　　　Django中默认支持Session，其内部提供了5种类型的Session供开发者使用。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>1. 数据库SessionSESSION_ENGINE = 'django.contrib.sessions.backends.db'   # 引擎（默认）2. 缓存SessionSESSION_ENGINE = 'django.contrib.sessions.backends.cache'  # 引擎SESSION_CACHE_ALIAS = 'default'                            # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置3. 文件SessionSESSION_ENGINE = 'django.contrib.sessions.backends.file'    # 引擎SESSION_FILE_PATH = None                                    # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 4. 缓存+数据库SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'        # 引擎5. 加密Cookie SessionSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies'   # 引擎其他公用设置项：SESSION_COOKIE_NAME ＝ "sessionid"                       # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH ＝ "/"                               # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None                             # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False                            # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True                           # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 1209600                             # Session的cookie失效日期（2周）（默认）SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False                       # 是否每次请求都保存Session，默认修改之后才保存（默认）</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="CBV中加装饰器相关"><a href="#CBV中加装饰器相关" class="headerlink" title="　　CBV中加装饰器相关"></a>　　CBV中加装饰器相关</h3><p>　　　　CBV实现的登录视图</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>class LoginView(View):    def get(self, request):        """        处理GET请求        """        return render(request, 'login.html')    def post(self, request):        """        处理POST请求         """        user = request.POST.get('user')        pwd = request.POST.get('pwd')        if user == 'alex' and pwd == "alex1234":            next_url = request.GET.get("next")            # 生成随机字符串            # 写浏览器cookie -&gt; session_id: 随机字符串            # 写到服务端session：            # {            #     "随机字符串": {'user':'alex'}            # }            request.session['user'] = user            if next_url:                return redirect(next_url)            else:                return redirect('/index/')        return render(request, 'login.html')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　要在CBV视图中使用我们上面的check_login装饰器，有以下三种方式：</p><p>　　　　from django.utils.decorators import method_decorator</p><p>　　　　　　<strong>1. 加在CBV视图的get或post方法上</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.decorators import method_decoratorclass HomeView(View):    def dispatch(self, request, *args, **kwargs):        return super(HomeView, self).dispatch(request, *args, **kwargs)    def get(self, request):        return render(request, "home.html")    @method_decorator(check_login)    def post(self, request):        print("Home View POST method...")        return redirect("/index/")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　<strong>2. 加在dispatch方法上</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.decorators import method_decoratorclass HomeView(View):    @method_decorator(check_login)    def dispatch(self, request, *args, **kwargs):        return super(HomeView, self).dispatch(request, *args, **kwargs)    def get(self, request):        return render(request, "home.html")    def post(self, request):        print("Home View POST method...")        return redirect("/index/")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　因为CBV中首先执行的就是dispatch方法，所以这么写相当于给get和post方法都加上了登录校验。</p><p>　　　　　　<strong>3. 直接加在视图类上，但method_decorator必须传 name 关键字参数</strong></p><p>　　　　　　　　如果get方法和post方法都需要登录校验的话就写两个装饰器。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><pre><code>from django.utils.decorators import method_decorator@method_decorator(check_login, name="get")@method_decorator(check_login, name="post")class HomeView(View):    def dispatch(self, request, *args, **kwargs):        return super(HomeView, self).dispatch(request, *args, **kwargs)    def get(self, request):        return render(request, "home.html")    def post(self, request):        print("Home View POST method...")        return redirect("/index/")</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="补充"><a href="#补充" class="headerlink" title="　　　　补充"></a>　　　　补充</h3><p>　　　　　　CSRF Token相关装饰器在CBV只能加到dispatch方法上，或者加在视图类上然后name参数指定为dispatch方法。</p><p>　　　　　　备注：</p><p>　　　　　　　　csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。</p><p>　　　　　　　　csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.views.decorators.csrf import csrf_exempt, csrf_protectfrom django.utils.decorators import method_decoratorclass HomeView(View):    @method_decorator(csrf_exempt)    def dispatch(self, request, *args, **kwargs):        return super(HomeView, self).dispatch(request, *args, **kwargs)    def get(self, request):        return render(request, "home.html")    def post(self, request):        print("Home View POST method...")        return redirect("/index/")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　或者</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.views.decorators.csrf import csrf_exempt, csrf_protectfrom django.utils.decorators import method_decorator@method_decorator(csrf_exempt, name='dispatch')class HomeView(View):    def dispatch(self, request, *args, **kwargs):        return super(HomeView, self).dispatch(request, *args, **kwargs)    def get(self, request):        return render(request, "home.html")    def post(self, request):        print("Home View POST method...")        return redirect("/index/")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django基础一之web框架的本质</title>
      <link href="2019/11/15/Django/django%E5%9F%BA%E7%A1%80%E4%B8%80%E4%B9%8Bweb%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
      <url>2019/11/15/Django/django%E5%9F%BA%E7%A1%80%E4%B8%80%E4%B9%8Bweb%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>django第一天</p><p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10391859.html#part_1">一 web框架的本质及自定义web框架</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10391859.html#part_2">二 模板渲染JinJa2</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10391859.html#part_3">三 MVC和MTV框架</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10391859.html#part_4">四 Django的下载安装</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10391859.html#part_5">五 基于Django实现的一个简单示例</a></li><li></li></ul><h3 id="一-web框架的本质及自定义web框架"><a href="#一-web框架的本质及自定义web框架" class="headerlink" title="一 web框架的本质及自定义web框架"></a>一 web框架的本质及自定义web框架</h3><p>　　<strong>我们可以这样理解：所有的Web应用本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端，基于请求做出响应，客户都先请求，服务端做出对应的响应，按照http协议的请求协议发送请求，服务端按照http协议的响应协议来响应请求，这样的网络通信，我们就可以自己实现Web框架了。</strong></p><p>　　<strong>通过对socket的学习，我们知道网络通信，我们完全可以自己写了，因为socket就是做网络通信用的，下面我们就基于socket来自己实现一个web框架，写一个web服务端，让浏览器来请求，并通过自己的服务端把页面返回给浏览器，浏览器渲染出我们想要的效果。在后面的学习中，**</strong>大家提前准备一些文件：**</p><p>　　　　<strong>html文件内容如下，名称为test.html：</strong>　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel="stylesheet" href="test.css"&gt;    &lt;link rel="icon" href="wechat.ico"&gt;     &lt;!--直接写在html页面里面的css样式是直接可以在浏览器上显示的--&gt;    &lt;!--&lt;style&gt;--&gt;        &lt;!--h1{--&gt;            &lt;!--background-color: green;--&gt;            &lt;!--color: white;--&gt;        &lt;!--}--&gt;    &lt;!--&lt;/style&gt;--&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;姑娘，你好，我是Jaden，请问约吗？嘻嘻~~&lt;/h1&gt;&lt;!--直接写在html页面里面的img标签的src属性值如果是别人网站的地址（网络地址）是直接可以在浏览器上显示的--&gt;&lt;!--&lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1550395461724&amp;di=c2b971db12eef5d85aba410d1e2e8568&amp;imgtype=0&amp;src=http%3A%2F%2Fy0.ifengimg.com%2Fifengimcp%2Fpic%2F20140822%2Fd69e0188b714ee789e97_size87_w800_h1227.jpg" alt=""&gt;--&gt; &lt;!--如果都是网络地址，那么只要你的电脑有网，就可以看到，不需要自己在后端写对应的读取文件，返回图片文件信息的代码，因为别人的网站就做了这个事情了--&gt;&lt;img src="meinv.png" alt="" width="100" height="100"&gt; &lt;!--如果你是本地的图片想要返回给页面，你需要对页面上的关于这个图片的请求要自己做出响应，这个src就是来你本地请求这个图片，你只要将图片信息读取出来，返回给页面，页面拿到这个图片的数据，就能够渲染出来了，是不是很简单--&gt;&lt;!--直接写在html页面里面的js操作是直接可以在浏览器上显示的--&gt;&lt;!--&lt;script&gt;--&gt;    &lt;!--alert('这是我们第一个网页')--&gt;&lt;!--&lt;/script&gt;--&gt;&lt;script src="test.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　css文件内容如下，名称为test.css：　</p><pre><code>h1{    background-color: green;    color: white;}</code></pre><p>　　　　js文件内容如下，名称为test.js：</p><pre><code>alert('这是我们第一个网页');</code></pre><p>　　　　<strong>再准备一个图片，名称为meinv.jpg，再准备一个ico文件，名称为wechat.ico，其实就是个图片文件，微信官网打开之后，在浏览器最上面能够看到<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217161553642-1455488905.png" alt="img">，把它保存下来</strong></p><p>　　　　</p><p>　　上面的文件都准备好之后，你用pycharm新建一个项目，把文件都放到一个文件夹里面去，留着备用，像下面这个样子：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217161740583-1253868814.png" alt="img"></p><p>　　然后开始写我们的web框架，<strong>我们分这么几步来写：</strong></p><p>　　<strong>一、简单的web框架</strong></p><p>　　　　<strong>创建一个python文件，内容如下，名称为test.py：</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>import socketsk = socket.socket()sk.bind(('127.0.0.1',8001))sk.listen()conn,addr = sk.accept()from_b_msg = conn.recv(1024)str_msg = from_b_msg.decode('utf-8')#socket是应用层和传输层之间的抽象层，每次都有协议，协议就是消息格式，那么传输层的消息格式我们不用管，因为socket帮我们搞定了，但是应用层的协议还是需要咱们自己遵守的，所以再给浏览器发送消息的时候，如果没有按照应用层的消息格式来写，那么你返回给浏览器的信息，浏览器是没法识别的。而应用层的协议就是我们的HTTP协议，所以我们按照HTTP协议规定的消息格式来给浏览器返回消息就没有问题了，关于HTTP我们会细说，首先看一下直接写conn.send(b'hello')的效果，然后运行代码，通过浏览器来访问一下，然后再看这一句conn.send(b'HTTP/1.1 200 ok \r\n\r\nhello')的效果#下面这句就是按照http协议来写的# conn.send(b'HTTP/1.1 200 ok \r\n\r\nhello')#上面这句还可以分成下面两句来写conn.send(b'HTTP/1.1 200 ok \r\n\r\n')conn.send(b'hello')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　我们来浏览器上看一下浏览器发送的请求：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217165555288-1404955543.png" alt="img"></p><p>　　　　目前我们还没有写如何返回一个html文件给浏览器，所以这里暂时不用管它，那么我们点开这个127.0.0.1看看：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217165848448-2082569292.png" alt="img"></p><p>　　　　我们在python文件中打印一下浏览器发送过来的请求信息是啥：</p><p>　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217171401085-1669271307.png" alt="img"></p><p>　　　　重启我们的代码，然后在网址中输入这个：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217171827604-1319061425.png" alt="img"></p><p>　　　　再重启我们的代码，然后在网址中输入这个：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217180502464-365178390.png" alt="img"></p><p>　　 </p><p> 　　　　浏览器发过来一堆的消息，我们给浏览器回复(响应)信息的时候，也要按照一个消息格式来写，这些都是http协议规定的，那么我们就来学习一下http协议，然后继续完善我们的web框架：</p><p>　　　　　　HTTP协议：<a href="https://www.cnblogs.com/clschao/articles/9230431.html">https://www.cnblogs.com/clschao/articles/9230431.html</a></p><p> 　　</p><p> 　　<strong>二、返回HTML文件的web框架</strong></p><p>　　　　首先写一个html文件，内容如下，名称为test.html：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;link rel="stylesheet" href="test.css"&gt;    &lt;!--直接写在html页面里面的css样式是直接可以在浏览器上显示的--&gt;    &lt;style&gt;        h1{            background-color: green;            color: white;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;姑娘，你好，我是Jaden，请问约吗？嘻嘻~~&lt;/h1&gt;&lt;!--直接写在html页面里面的img标签的src属性值如果是别人网站的地址（网络地址）是直接可以在浏览器上显示的--&gt;&lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1550395461724&amp;di=c2b971db12eef5d85aba410d1e2e8568&amp;imgtype=0&amp;src=http%3A%2F%2Fy0.ifengimg.com%2Fifengimcp%2Fpic%2F20140822%2Fd69e0188b714ee789e97_size87_w800_h1227.jpg" alt=""&gt; &lt;!--如果都是网络地址，那么只要你的电脑有网，就可以看到，不需要自己在后端写对应的读取文件，返回图片文件信息的代码，因为别人的网站就做了这个事情了--&gt;&lt;!--直接写在html页面里面的js操作是直接可以在浏览器上显示的--&gt;&lt;script&gt;    alert('这是我们第一个网页')&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　准备我们的python代码，服务端程序，文件内容如下，文件名称为test.py：　　　　　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>import socketsk = socket.socket()sk.bind(('127.0.0.1',8001))sk.listen()conn,addr = sk.accept()from_b_msg = conn.recv(1024)str_msg = from_b_msg.decode('utf-8')print('浏览器请求信息：',str_msg)# conn.send(b'HTTP/1.1 200 ok \r\ncontent-type:text/html;charset=utf-8;\r\n') conn.send(b'HTTP/1.1 200 ok \r\n\r\n')with open('test1.html','rb') as f:    f_data = f.read()conn.send(f_data)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　页面上输入网址看效果，css和js代码的效果也有，very good：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217205314200-934222566.png" alt="img"></p><p>　　　　</p><p> 　　但是我们知道，我们的css和js基本都是写在本地的文件里面的啊，而且我们的图片基本也是我们自己本地的啊，怎么办，我们将上面我们提前准备好的js和css还有那个.ico结尾的图片文件都准备好，来我们在来一个升级版的web框架，其实css、js、图片等文件都叫做网站的静态文件。</p><p>　　首先我们先看一个效果，如果我们直接将我们写好的css和js还有.ico和图片文件插入到我们的html页面里面，就是下面这个html文件</p><p>　　　　名称为test.html，内容如下：　　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel="stylesheet" href="test.css"&gt;    &lt;!--加上下面这句，那么我们看浏览器调试窗口中的那个network里面就没有那个favicon.ico的请求了，其实这就是页面title标签文字左边的那个页面图标,但是这个文件是我们自己本地的，所以我们需要在后端代码里面将这个文件数据读取出来返回给前端--&gt;    &lt;link rel="icon" href="wechat.ico"&gt;    &lt;!--直接写在html页面里面的css样式是直接可以在浏览器上显示的--&gt;    &lt;!--&lt;style&gt;--&gt;        &lt;!--h1{--&gt;            &lt;!--background-color: green;--&gt;            &lt;!--color: white;--&gt;        &lt;!--}--&gt;    &lt;!--&lt;/style&gt;--&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;姑娘，你好，我是Jaden，请问约吗？嘻嘻~~&lt;/h1&gt;&lt;!--直接写在html页面里面的img标签的src属性值如果是别人网站的地址（网络地址）是直接可以在浏览器上显示的--&gt;&lt;!--&lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1550395461724&amp;di=c2b971db12eef5d85aba410d1e2e8568&amp;imgtype=0&amp;src=http%3A%2F%2Fy0.ifengimg.com%2Fifengimcp%2Fpic%2F20140822%2Fd69e0188b714ee789e97_size87_w800_h1227.jpg" alt=""&gt;--&gt; &lt;!--如果都是网络地址，那么只要你的电脑有网，就可以看到，不需要自己在后端写对应的读取文件，返回图片文件信息的代码，因为别人的网站就做了这个事情了--&gt;&lt;img src="meinv.png" alt="" width="100" height="100"&gt; &lt;!--如果你是本地的图片想要返回给页面，你需要对页面上的关于这个图片的请求要自己做出响应，这个src就是来你本地请求这个图片，你只要将图片信息读取出来，返回给页面，页面拿到这个图片的数据，就能够渲染出来了，是不是很简单--&gt;&lt;!--直接写在html页面里面的js操作是直接可以在浏览器上显示的--&gt;&lt;!--&lt;script&gt;--&gt;    &lt;!--alert('这是我们第一个网页')--&gt;&lt;!--&lt;/script&gt;--&gt;&lt;script src="test.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　同样使用我们之前的python程序，来看效果：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217210153254-1291193522.png" alt="img"></p><p>　　　　发现js和css的效果都没有出来，并且我们看一下浏览器调试窗口的那个network</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217210402034-1514551154.png" alt="img"></p><p>　　　　在下来我们在network里面点击那个test.css文件，看看请求是什么：</p><p>　　　　　  <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217210751685-1433657612.png" alt="img"></p><p>　　　　还有就是当我们直接在浏览器上保存某个页面的时候，随便一个页面，我们到页面上点击右键另存为，然后存到本地的一个目录下，你会发现这个页面的html、css、js、图片等文件都跟着保存下来了，我保存了一下博客园首页的页面，看，是一个文件夹和一个html文件：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217211604118-1129260335.png" alt="img"></p><p>　　　　　　我们点开博客园那个文件夹看看里面都有什么：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217211533384-439814169.png" alt="img"></p><p> 　　　　　　发现js、css还有图片什么的都被保存了下来，说明什么，说明这些文件本身就存在浏览器上了，哦，原来就是将html页面需要的css、js、图片等文件也发送给浏览器就可以了，并且这些静态文件都是浏览器单独过来请求的，其实和标签的属性有有关系，css文件是link标签的href属性：<link rel="stylesheet" href="test.css">，js文件是script标签的src属性：<script src="test.js"></script>，图片文件是img标签的src属性：<img src="meinv.png" alt="" width="100" height="100"> ，那个.ico文件是link标签的属性：<link rel="icon" href="wechat.ico">，其实这些属性都会在页面加载的时候，单独到自己对应的属性值里面取请求对应的文件数据，而且我们如果在值里面写的都是自己本地的路径，那么都会来自己的本地路径来找，如果我们写的是相对路径，就会到我们自己的网址+文件名称，这个路径来找它需要的文件，所以我们只需要将这些请求做一些响应，将对应的文件数据相应给浏览器就可以了！并且我们通过前面的查看，能够发现，浏览器url的请求路径我们知道是什么，静态文件不是也这样请求的吗，好，我们针对不同的路径给它返回不同的文件，<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217212514109-1556720401.png" alt="img">非常好！我们来尝试一下！</p><p>　　 <strong>三、返回静态文件的高级web框架</strong></p><p>　　　　　还是用第二个web框架里面的那个html文件，我们只需要写一些我们的服务端程序就可以了，同样是test.py文件，内容如下：　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>import socketsk = socket.socket()sk.bind(('127.0.0.1',8001))sk.listen()#首先浏览器相当于给我们发送了多个请求，一个是请求我们的html文件，而我们的html文件里面的引入文件的标签又给我们这个网站发送了请求静态文件的请求，所以我们要将建立连接的过程循环起来，才能接受多个请求，没毛病while 1:    conn,addr = sk.accept()    # while 1:    from_b_msg = conn.recv(1024)    str_msg = from_b_msg.decode('utf-8')    #通过http协议我们知道，浏览器请求的时候，有一个请求内容的路径，通过对请求信息的分析，这个路径我们在请求的所有请求信息中可以提炼出来，下面的path就是我们提炼出来的路径    path = str_msg.split('\r\n')[0].split(' ')[1]    print('path&gt;&gt;&gt;',path)    conn.send(b'HTTP/1.1 200 ok \r\n\r\n')    #由于整个页面需要html、css、js、图片等一系列的文件，所以我们都需要给人家浏览器发送过去，浏览器才能有这些文件，才能很好的渲染你的页面    #根据不同的路径来返回响应的内容    if path == '/': #返回html文件        print(from_b_msg)        with open('test.html','rb') as f:        # with open('Python开发.html','rb') as f:            data = f.read()        conn.send(data)        conn.close()    elif path == '/meinv.png': #返回图片        with open('meinv.png','rb') as f:            pic_data = f.read()        # conn.send(b'HTTP/1.1 200 ok \r\n\r\n')        conn.send(pic_data)        conn.close()    elif path == '/test.css': #返回css文件        with open('test.css','rb') as f:            css_data = f.read()        conn.send(css_data)        conn.close()    elif path == '/wechat.ico':#返回页面的ico图标        with open('wechat.ico','rb') as f:            ico_data = f.read()        conn.send(ico_data)        conn.close()    elif path == '/test.js': #返回js文件        with open('test.js','rb') as f:            js_data = f.read()        conn.send(js_data)        conn.close()    #注意：上面每一个请求处理完之后，都有一个conn.close()是因为，HTTP协议是短链接的，一次请求对应一次响应，这个请求就结束了，所以我们需要写上close，不然浏览器自己断了，你自己写的服务端没有断，就会出问题。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　运行起来我们的py文件，然后在浏览器访问一下我们的服务端，看效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190217213105264-177729435.png" alt="img"></p><p>　　　　666666，完全搞定了，自己通过socket已经完全搞定了web项目，激动不，哈哈，我们再来完善一下</p><p>　　</p><p> 　　<strong>四：函数版高级web框架</strong></p><p>　　　　html文件和其他的静态文件还是我们上面使用的。</p><p>　　　　python代码如下：　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time    : 2019/2/17 14:06# @Author  : wuchao# @Site    :# @File    : test.py# @Software: PyCharmimport socketsk = socket.socket()sk.bind(('127.0.0.1',8001))sk.listen()#处理页面请求的函数def func1(conn):    with open('test.html', 'rb') as f:        # with open('Python开发.html','rb') as f:        data = f.read()    conn.send(data)    conn.close()#处理页面img标签src属性值是本地路径的时候的请求def func2(conn):    with open('meinv.png', 'rb') as f:        pic_data = f.read()    # conn.send(b'HTTP/1.1 200 ok \r\n\r\n')    conn.send(pic_data)    conn.close()#处理页面link（ &lt;link rel="stylesheet" href="test.css"&gt;）标签href属性值是本地路径的时候的请求def func3(conn):    with open('test.css', 'rb') as f:        css_data = f.read()    conn.send(css_data)    conn.close()#处理页面link（&lt;link rel="icon" href="wechat.ico"&gt;）标签href属性值是本地路径的时候的请求def func4(conn):    with open('wechat.ico', 'rb') as f:        ico_data = f.read()    conn.send(ico_data)    conn.close()#处理页面script（&lt;script src="test.js"&gt;&lt;/script&gt;）标签src属性值是本地路径的时候的请求def func5(conn):    with open('test.js', 'rb') as f:        js_data = f.read()    conn.send(js_data)    conn.close()while 1:    conn,addr = sk.accept()    # while 1:    from_b_msg = conn.recv(1024)    str_msg = from_b_msg.decode('utf-8')    path = str_msg.split('\r\n')[0].split(' ')[1]    print('path&gt;&gt;&gt;',path)    conn.send(b'HTTP/1.1 200 ok \r\n\r\n')    print(from_b_msg)    if path == '/':        func1(conn)    elif path == '/meinv.png':        func2(conn)    elif path == '/test.css':        func3(conn)    elif path == '/wechat.ico':        func4(conn)    elif path == '/test.js':        func5(conn)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　</p><p>　　<strong>五 更高级版(多线程版)web框架</strong></p><p>　　　　应用上我们并发编程的内容，反正html文件和静态文件都直接给浏览器，那大家就一块并发处理，html文件和静态文件还是上面的。</p><p>　　　　python代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time    : 2019/2/17 14:06# @Author  : wuchao# @Site    : # @File    : test.py# @Software: PyCharmimport socketfrom threading import Thread#注意一点，不开多线程完全是可以搞定的，在这里只是教大家要有并发编程的思想，所以我使用了多线程sk = socket.socket()sk.bind(('127.0.0.1',8001))sk.listen()def func1(conn):    with open('test.html', 'rb') as f:        # with open('Python开发.html','rb') as f:        data = f.read()    conn.send(data)    conn.close()def func2(conn):    with open('meinv.png', 'rb') as f:        pic_data = f.read()    # conn.send(b'HTTP/1.1 200 ok \r\n\r\n')    conn.send(pic_data)    conn.close()def func3(conn):    with open('test.css', 'rb') as f:        css_data = f.read()    conn.send(css_data)    conn.close()def func4(conn):    with open('wechat.ico', 'rb') as f:        ico_data = f.read()    conn.send(ico_data)    conn.close()def func5(conn):    with open('test.js', 'rb') as f:        js_data = f.read()    conn.send(js_data)    conn.close()while 1:    conn,addr = sk.accept()    # while 1:    from_b_msg = conn.recv(1024)    str_msg = from_b_msg.decode('utf-8')    path = str_msg.split('\r\n')[0].split(' ')[1]    print('path&gt;&gt;&gt;',path)    conn.send(b'HTTP/1.1 200 ok \r\n\r\n')    print(from_b_msg)    if path == '/':        # func1(conn)        t = Thread(target=func1,args=(conn,))        t.start()    elif path == '/meinv.png':        # func2(conn)        t = Thread(target=func2, args=(conn,))        t.start()    elif path == '/test.css':        # func3(conn)        t = Thread(target=func3, args=(conn,))        t.start()    elif path == '/wechat.ico':        # func4(conn)        t = Thread(target=func4, args=(conn,))        t.start()    elif path == '/test.js':        # func5(conn)        t = Thread(target=func5, args=(conn,))        t.start()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>六  更更高级版web框架</strong></p><p>　　　　if判断太多了，开线程的方式也比较恶心，有多少个if判断，就写多少次创建线程，简化一下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>import socketfrom threading import Threadsk = socket.socket()sk.bind(('127.0.0.1',8001))sk.listen()def func1(conn):    conn.send(b'HTTP/1.1 200 ok\r\ncontent-type:text/html\r\ncharset:utf-8\r\n\r\n')    with open('test.html', 'rb') as f:        # with open('Python开发.html','rb') as f:        data = f.read()    conn.send(data)    conn.close()def func2(conn):    conn.send(b'HTTP/1.1 200 ok\r\n\r\n')    with open('meinv.png', 'rb') as f:        pic_data = f.read()    # conn.send(b'HTTP/1.1 200 ok \r\n\r\n')    conn.send(pic_data)    conn.close()def func3(conn):    conn.send(b'HTTP/1.1 200 ok\r\n\r\n')    with open('test.css', 'rb') as f:        css_data = f.read()    conn.send(css_data)    conn.close()def func4(conn):    conn.send(b'HTTP/1.1 200 ok\r\n\r\n')    with open('wechat.ico', 'rb') as f:        ico_data = f.read()    conn.send(ico_data)    conn.close()def func5(conn):    conn.send(b'HTTP/1.1 200 ok\r\n\r\n')    with open('test.js', 'rb') as f:        js_data = f.read()    conn.send(js_data)    conn.close()#定义一个路径和执行函数的对应关系，不再写一堆的if判断了l1 = [    ('/',func1),    ('/meinv.png',func2),    ('/test.css',func3),    ('/wechat.ico',func4),    ('/test.js',func5),]#遍历路径和函数的对应关系列表，并开多线程高效的去执行路径对应的函数，def fun(path,conn):    for i in l1:        if i[0] == path:            t = Thread(target=i[1],args=(conn,))            t.start()    # else:    #     conn.send(b'sorry')while 1:    conn,addr = sk.accept()    #看完这里面的代码之后，你就可以思考一个问题了，很多人要同时访问你的网站，你在请求这里是不是可以开起并发编程的思想了，多进程+多线程+协程，妥妥的支持高并发，再配合服务器集群，这个网页就支持大量的高并发了，有没有很激动，哈哈，但是咱们写的太low了，而且功能很差，容错能力也很差，当然了，如果你有能力，你现在完全可以自己写web框架了，写一个nb的，如果现在没有这个能力，那么我们就来好好学学别人写好的框架把，首先第一个就是咱们的django框架了，其实就是将这些功能封装起来，并且容错能力强，抗压能力强，总之一个字：吊。    # while 1:    from_b_msg = conn.recv(1024)    str_msg = from_b_msg.decode('utf-8')    path = str_msg.split('\r\n')[0].split(' ')[1]    print('path&gt;&gt;&gt;',path)    # 注意：因为开启的线程很快，可能导致你的文件还没有发送过去，其他文件的请求已经来了，导致你文件信息没有被浏览器正确的认识，所以需要将发送请求行和请求头的部分写道前面的每一个函数里面去，并且防止出现浏览器可能不能识别你的html文件的情况，需要在发送html文件的那个函数里面的发送请求行和请求头的部分加上两个请求头content-type:text/html\r\ncharset:utf-8\r\n    # conn.send(b'HTTP/1.1 200 ok\r\n\r\n')  不这样写了    # conn.send(b'HTTP/1.1 200 ok\r\ncontent-type:text/html\r\ncharset:utf-8\r\n\r\n')  不这样写了    print(from_b_msg)    #执行这个fun函数并将路径和conn管道都作为参数传给他    fun(path,conn)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>七 根据不同路径返回不同页面的web框架</strong></p><p>　　　　既然知道了我们可以根据不同的请求路径来返回不同的内容，那么我们可不可以根据用户访问的不同路径，返回不同的页面啊，嗯，应该是可以的</p><p>　　　　自己创建两个html文件，写几个标签在里面，名为index.html和home.html，然后根据不同的路径返回不同的页面，我就给大家写上python代码吧：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>"""根据URL中不同的路径返回不同的内容返回独立的HTML页面"""import socketsk = socket.socket()sk.bind(("127.0.0.1", 8080))  # 绑定IP和端口sk.listen()  # 监听# 将返回不同的内容部分封装成函数def index(url):    # 读取index.html页面的内容    with open("index.html", "r", encoding="utf8") as f:        s = f.read()    # 返回字节数据    return bytes(s, encoding="utf8")def home(url):    with open("home.html", "r", encoding="utf8") as f:        s = f.read()    return bytes(s, encoding="utf8")# 定义一个url和实际要执行的函数的对应关系list1 = [    ("/index/", index),    ("/home/", home),]while 1:    # 等待连接    conn, add = sk.accept()    data = conn.recv(8096)  # 接收客户端发来的消息    # 从data中取到路径    data = str(data, encoding="utf8")  # 把收到的字节类型的数据转换成字符串    # 按\r\n分割    data1 = data.split("\r\n")[0]    url = data1.split()[1]  # url是我们从浏览器发过来的消息中分离出的访问路径    conn.send(b'HTTP/1.1 200 OK\r\n\r\n')  # 因为要遵循HTTP协议，所以回复的消息也要加状态行    # 根据不同的路径返回不同内容    func = None  # 定义一个保存将要执行的函数名的变量    for i in list1:        if i[0] == url:            func = i[1]            break    if func:        response = func(url)    else:        response = b"404 not found!"    # 返回具体的响应消息    conn.send(response)    conn.close()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>八、返回动态页面的web框架</strong></p><p>　　　　这网页能够显示出来了，但是都是静态的啊。页面的内容都不会变化的，我想要的是动态网站，动态网站的意思是里面有动态变化的数据，而不是页面里面有动态效果，这个大家要注意啊。</p><p>　　　　没问题，我也有办法解决。我选择使用字符串替换来实现这个需求。（这里使用时间戳来模拟动态的数据，还是只给大家python代码吧）</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>"""根据URL中不同的路径返回不同的内容返回HTML页面让网页动态起来"""import socketimport timesk = socket.socket()sk.bind(("127.0.0.1", 8080))  # 绑定IP和端口sk.listen()  # 监听# 将返回不同的内容部分封装成函数def index(url):    with open("index.html", "r", encoding="utf8") as f:        s = f.read()        now = str(time.time())        s = s.replace("@@oo@@", now)  # 在网页中定义好特殊符号，用动态的数据去替换提前定义好的特殊符号    return bytes(s, encoding="utf8")def home(url):    with open("home.html", "r", encoding="utf8") as f:        s = f.read()    return bytes(s, encoding="utf8")# 定义一个url和实际要执行的函数的对应关系list1 = [    ("/index/", index),    ("/home/", home),]while 1:    # 等待连接    conn, add = sk.accept()    data = conn.recv(8096)  # 接收客户端发来的消息    # 从data中取到路径    data = str(data, encoding="utf8")  # 把收到的字节类型的数据转换成字符串    # 按\r\n分割    data1 = data.split("\r\n")[0]    url = data1.split()[1]  # url是我们从浏览器发过来的消息中分离出的访问路径    conn.send(b'HTTP/1.1 200 OK\r\n\r\n')  # 因为要遵循HTTP协议，所以回复的消息也要加状态行    # 根据不同的路径返回不同内容    func = None  # 定义一个保存将要执行的函数名的变量    for i in list1:        if i[0] == url:            func = i[1]            break    if func:        response = func(url)    else:        response = b"404 not found!"    # 返回具体的响应消息    conn.send(response)    conn.close()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　这八个框架让大家满意了吧，这下子明白整个web框架的原理了吧，哈哈，但是我们写的框架还是太low了，不够强壮，那别人已经开发好了很多nb的框架了，如：Django、Flask、Tornado等等，我们学学怎么用就可以啦，但是注意一个问题，我们在里面获取路径的时候，我们是按照\r\n来分割然后再通过空格来分割获取到的路径，但是如果不是http协议的话，你自己要注意消息格式了。</p><p>　　接下来我们看一个别人写好的模块来搞的web框架，这个模块叫做wsgiref</p><p>　　<strong>九、wsgiref模块版web框架</strong></p><p>　　　　wsgiref模块其实就是将整个请求信息给封装了起来，就不需要你自己处理了，假如它将所有请求信息封装成了一个叫做request的对象，那么你直接request.path就能获取到用户这次请求的路径，request.method就能获取到本次用户请求的请求方式(get还是post)等，那这个模块用起来，我们再写web框架是不是就简单了好多啊。</p><p>　　　　对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。</p><p>　　　　服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。</p><p>　　　　应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：Django、Flask、web.py 等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。</p><p>　　　　这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。</p><p>正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口协议来实现这样的服务器软件，让我们专心用Python编写Web业务。</p><p>　　　　这时候，标准化就变得尤为重要。我们可以设立一个标准，只要服务器程序支持这个标准，框架也支持这个标准，那么他们就可以配合使用。一旦标准确定，双方各自实现。这样，服务器可以支持更多支持标准的框架，框架也可以使用更多支持标准的服务器。</p><p>　　　　WSGI（Web Server Gateway Interface）就是一种规范，它定义了使用Python编写的web应用程序与web服务器程序之间的接口格式，实现web应用程序与web服务器程序间的解耦。</p><p>　　　　常用的WSGI服务器有uwsgi、Gunicorn。而Python标准库提供的独立WSGI服务器叫wsgiref，Django开发环境用的就是这个模块来做服务器。</p><p>　　　　</p><p>　　　　好，接下来我们就看一下（能理解就行，了解就可以了）：先看看wsfiref怎么使用</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from wsgiref.simple_server import make_server# wsgiref本身就是个web框架，提供了一些固定的功能（请求和响应信息的封装，不需要我们自己写原生的socket了也不需要咱们自己来完成请求信息的提取了，提取起来很方便）#函数名字随便起def application(environ, start_response):    '''    :param environ: 是全部加工好的请求信息，加工成了一个字典，通过字典取值的方式就能拿到很多你想要拿到的信息    :param start_response: 帮你封装响应信息的（响应行和响应头），注意下面的参数    :return:    '''    start_response('200 OK', [('Content-Type', 'text/html'),('k1','v1')])    print(environ)    print(environ['PATH_INFO'])  #输入地址127.0.0.1:8000，这个打印的是'/',输入的是127.0.0.1:8000/index，打印结果是'/index'    return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;']#和咱们学的socketserver那个模块很像啊httpd = make_server('127.0.0.1', 8080, application)print('Serving HTTP on port 8080...')# 开始监听HTTP请求:httpd.serve_forever()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><p>　　　　来一个完整的web项目，用户登录认证的项目，我们需要连接数据库了，所以先到mysql数据库里面准备一些表和数据</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; create database db1;Query OK, 1 row affected (0.00 sec)mysql&gt; use db1;Database changedmysql&gt; create table userinfo(id int primary key auto_increment,username char(20) not null unique,password char(20) not null);Query OK, 0 rows affected (0.23 sec)mysql&gt; insert into userinfo(username,password) values('chao','666'),('sb1','222');Query OK, 2 rows affected (0.03 sec)Records: 2  Duplicates: 0  Warnings: 0mysql&gt; select * from userinfo;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | chao     | 666      ||  2 | sb1      | 222      |+----+----------+----------+2 rows in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　然后再创建这么几个文件：</p><p>　　　　python文件名称webmodel.py，内容如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>#创建表，插入数据def createtable():    import pymysql    conn = pymysql.connect(        host='127.0.0.1',        port=3306,        user='root',        password='666',        database='db1',        charset='utf8'    )    cursor = conn.cursor(pymysql.cursors.DictCursor)    sql = '''        -- 创建表        create table userinfo(id int primary key auto_increment,username char(20) not null unique,password char(20) not null);        -- 插入数据        insert into userinfo(username,password) values('chao','666'),('sb1','222');    '''    cursor.execute(sql)    conn.commit()    cursor.close()    conn.close()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　python的名为webauth文件，内容如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>#对用户名和密码进行验证def auth(username,password):    import pymysql    conn = pymysql.connect(        host='127.0.0.1',        port=3306,        user='root',        password='123',        database='db1',        charset='utf8'    )    print('userinfo',username,password)    cursor = conn.cursor(pymysql.cursors.DictCursor)    sql = 'select * from userinfo where username=%s and password=%s;'    res = cursor.execute(sql, [username, password])    if res:        return True    else:        return False</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　用户输入用户名和密码的文件，名为we.html，内容如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--如果form表单里面的action什么值也没给，默认是往当前页面的url上提交你的数据，所以我们可以自己指定数据的提交路径--&gt;&lt;!--&lt;form action="http://127.0.0.1:8080/auth/" method="post"&gt;--&gt;&lt;form action="http://127.0.0.1:8080/auth/" method="get"&gt;    用户名&lt;input type="text" name="username"&gt;    密码 &lt;input type="password" name="password"&gt;    &lt;input type="submit"&gt;&lt;/form&gt;&lt;script&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　用户验证成功后跳转的页面，显示成功，名为websuccess.html，内容如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        h1{            color:red;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;宝贝儿，恭喜你登陆成功啦&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　python服务端代码(主逻辑代码)，名为web_python.py：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from urllib.parse import parse_qsfrom wsgiref.simple_server import make_serverimport webauthdef application(environ, start_response):    # start_response('200 OK', [('Content-Type', 'text/html'),('k1','v1')])    # start_response('200 OK', [('Content-Type', 'text/html'),('charset','utf-8')])    start_response('200 OK', [('Content-Type', 'text/html')])    print(environ)    print(environ['PATH_INFO'])    path = environ['PATH_INFO']    #用户获取login页面的请求路径    if path == '/login':        with open('web.html','rb') as f:            data = f.read()    #针对form表单提交的auth路径，进行对应的逻辑处理    elif path == '/auth/':        #登陆认证        #1.获取用户输入的用户名和密码        #2.去数据库做数据的校验，查看用户提交的是否合法        # user_information = environ['']        if environ.get("REQUEST_METHOD") == "POST":            #获取请求体数据的长度,因为提交过来的数据需要用它来提取,注意POST请求和GET请求的获取数据的方式不同            try:                request_body_size = int(environ.get('CONTENT_LENGTH', 0))            except (ValueError):                request_body_size = 0            #POST请求获取数据的方式            request_data = environ['wsgi.input'].read(request_body_size)            print('&gt;&gt;&gt;&gt;&gt;',request_data) # &gt;&gt;&gt;&gt;&gt; b'username=chao&amp;password=123'，是个bytes类型数据            print('?????',environ['QUERY_STRING']) #????? 空的，因为post请求只能按照上面这种方式取数据            #parse_qs可以帮我们解析数据            re_data = parse_qs(request_data)            print('拆解后的数据',re_data) #拆解后的数据 {b'password': [b'123'], b'username': [b'chao']}            #post请求的返回数据我就不写啦　　　　　　  pass        if environ.get("REQUEST_METHOD") == "GET":            #GET请求获取数据的方式，只能按照这种方式取            print('?????',environ['QUERY_STRING']) #????? username=chao&amp;password=123,是个字符串类型数据            request_data = environ['QUERY_STRING']            # parse_qs可以帮我们解析数据            re_data = parse_qs(request_data)            print('拆解后的数据', re_data) #拆解后的数据 {'password': ['123'], 'username': ['chao']}            username = re_data['username'][0]            password = re_data['password'][0]            print(username,password)            #进行验证：            status = webauth.auth(username,password)            if status:            # 3.将相应内容返回                with open('websuccess.html','rb') as f:                    data = f.read()            else:                data = b'auth error'        # 但是不管是post还是get请求都不能直接拿到数据，拿到的数据还需要我们来进行分解提取，所以我们引入urllib模块来帮我们分解        #注意昂，我们如果直接返回中文，没有给浏览器指定编码格式，默认是gbk，所以我们需要gbk来编码一下，浏览器才能识别        # data='登陆成功！'.encode('gbk')    else:        data = b'sorry 404!,not found the page'    return [data]#和咱们学的socketserver那个模块很像啊httpd = make_server('127.0.0.1', 8080, application)print('Serving HTTP on port 8080...')# 开始监听HTTP请求:httpd.serve_forever()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　把代码拷走，创建文件，放到同一个目录下，运行一下we_python.py文件的代码就能看到效果，注意先输入的网址是127.0.0.1:8080/login ，还要注意你的mysql数据库没有问题。</p><p>　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218175649497-215686790.png" alt="img"></p><p> 　　十、起飞版web框架</p><p>　　　　我们上一个web框架把所有的代码都写在了一个py文件中，我们拆到其他文件里面去，并且针对不用的路径来进行分发请求的时候都用的if判断，很多值得优化的地方，好，结合我们前面几个版本的优势我们来优化一下，分几个文件和文件夹</p><p>　　　　代码就不在博客上都列出来了，我打包放到百度云上了，大家去下载看看把：<a href="https://pan.baidu.com/s/1Ns5QHFpZGusGHuHzrCto3A">https://pan.baidu.com/s/1Ns5QHFpZGusGHuHzrCto3A</a></p><p> 　　　</p><p>　　将来要说的MVC框架是什么呢：</p><p>　　　　M：model.py  就是和数据库打交道用的，创建表等操作</p><p>　　　　V：View  视图（视图函数，html文件）</p><p>　　　　C：controller  控制器（其实就是我百度云代码里面那个urls文件里面的内容，url（路径）分发与视图函数的逻辑处理）</p><p> 　　Django叫做MTV框架</p><p>　　　　M：model.py  就是和数据库打交道用的，创建表等操作（和上面一样）</p><p>　　　　T：templates  存放HTML文件的</p><p>　　　　V：View 视图函数（逻辑处理）</p><p>　　　　其实你会发现MTV比MVC少一个url分发的部分</p><p>　　　　所以我们学的django还要学一个叫做url控制器（路径分发）的东西，MTV+url控制器就是我们django要学的内容。 　　　　</p><p>　　捋一下框架的整个流程吧<del>~</del></p><h3 id="二-模板渲染JinJa2"><a href="#二-模板渲染JinJa2" class="headerlink" title="二 模板渲染JinJa2"></a>二 模板渲染JinJa2</h3><p>　　上面的代码实现了一个简单的动态页面(字符串替换)，我完全可以从数据库中查询数据，然后去替换我html中的对应内容（专业名词叫做模板渲染，你先渲染一下，再给浏览器进行渲染），然后再发送给浏览器完成渲染。 这个过程就相当于HTML模板渲染数据。 本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。 我这里用的特殊符号是我定义的，其实模板渲染有个现成的工具： <code>jinja2</code>　　</p><p>　　下载：</p><pre><code>pip install jinja2</code></pre><p>　　来一个html文件，index2,html，内容如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;姓名：{{name}}&lt;/h1&gt;    &lt;h1&gt;爱好：&lt;/h1&gt;    &lt;ul&gt;        {% for hobby in hobby_list %}        <li>{{hobby}}</li>        {% endfor %}    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　使用jinja2渲染index2.html文件，创建一个python文件，代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from wsgiref.simple_server import make_serverfrom jinja2 import Templatedef index():    with open("index2.html", "r",encoding='utf-8') as f:        data = f.read()    template = Template(data)  # 生成模板文件    ret = template.render({"name": "于谦", "hobby_list": ["烫头", "泡吧"]})  # 把数据填充到模板里面    return [bytes(ret, encoding="utf8"), ]# 定义一个url和函数的对应关系URL_LIST = [    ("/index/", index),]def run_server(environ, start_response):    start_response('200 OK', [('Content-Type', 'text/html;charset=utf8'), ])  # 设置HTTP响应的状态码和头信息    url = environ['PATH_INFO']  # 取到用户输入的url    func = None  # 将要执行的函数    for i in URL_LIST:        if i[0] == url:            func = i[1]  # 去之前定义好的url列表里找url应该执行的函数            break    if func:  # 如果能找到要执行的函数        return func()  # 返回函数的执行结果    else:        return [bytes("404没有该页面", encoding="utf8"), ]if __name__ == '__main__':    httpd = make_server('', 8000, run_server)    print("Serving HTTP on port 8000...")    httpd.serve_forever()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　现在的数据是我们自己手写的，那可不可以从数据库中查询数据，来填充页面呢？</p><p>　　使用pymysql连接数据库：</p><pre><code>conn = pymysql.connect(host="127.0.0.1", port=3306, user="root", passwd="xxx", db="xxx", charset="utf8")cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)cursor.execute("select name, age, department_id from userinfo")user_list = cursor.fetchall()cursor.close()conn.close()</code></pre><p>　　创建一个测试的user表：</p><pre><code>CREATE TABLE user(  id int auto_increment PRIMARY KEY,  name CHAR(10) NOT NULL,  hobby CHAR(20) NOT NULL)engine=innodb DEFAULT charset=UTF8;</code></pre><p> 　　模板的原理就是字符串替换，我们只要在HTML页面中遵循jinja2的语法规则写上，其内部就会按照指定的语法进行相应的替换，从而达到动态的返回内容。</p><p>　　</p><h3 id="三-MVC和MTV框架"><a href="#三-MVC和MTV框架" class="headerlink" title="三 MVC和MTV框架"></a>三 MVC和MTV框架</h3><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>　　Web服务器开发领域里著名的MVC模式，所谓MVC就是把Web应用分为模型(M)，控制器(C)和视图(V)三层，他们之间以一种插件式的、松耦合的方式连接在一起，模型负责业务对象与数据库的映射(ORM)，视图负责与用户的交互(页面)，控制器接受用户的输入调用模型和视图完成用户的请求，其示意图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180418162558974-92667466.png" alt="img"></p><h2 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h2><p>　　Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是值：</p><ul><li>M 代表模型（Model）： 负责业务对象和数据库的关系映射(ORM)。</li><li>T 代表模板 (Template)：负责如何把页面展示给用户(html)。</li><li>V 代表视图（View）：   负责业务逻辑，并在适当时候调用Model和Template。</li></ul><p>　　除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20180418162350672-193671507.png" alt="img"></p><p>　　一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。</p><h3 id="四-Django下载安装"><a href="#四-Django下载安装" class="headerlink" title="四 Django下载安装"></a>四 Django下载安装</h3><p> <a href="https://www.djangoproject.com/download/">Django官网下载页面</a></p><h3 id="1、下载Django："><a href="#1、下载Django：" class="headerlink" title="1、下载Django："></a>1、下载Django：</h3><h3 id="2、创建一个django-project"><a href="#2、创建一个django-project" class="headerlink" title="2、创建一个django project"></a>2、创建一个django project</h3><p> 　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218205509202-588867847.png" alt="img"></p><p>　　当前目录下会生成mysite的工程，目录结构如下：（大家注意昂，pip下载下来的django你就理解成一个模块，而不是django项目，这个模块可以帮我们创建django项目）</p><p>​        　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20160724114201404-1121087959.png" alt="img"></p><ul><li>manage.py —– Django项目里面的工具，通过它可以调用django shell和数据库，启动关闭项目与项目交互等，不管你将框架分了几个文件，必然有一个启动文件，其实他们本身就是一个文件。</li><li>settings.py —- 包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。</li><li>urls.py —– 负责把URL模式映射到应用程序。</li><li>wsgi.py —- runserver命令就使用wsgiref模块做简单的web server，后面会看到renserver命令，所有与socket相关的内容都在这个文件里面了，目前不需要关注它。</li></ul><p>　　</p><pre><code> python manage.py runserver 127.0.0.1:8080  #此时已经可以启动django项目了，只不过什么逻辑也没有呢</code></pre><p>　　你会发现，上面没有什么view视图函数的文件啊，这里我们说一个应用与项目的关系，上面我们只是创建了一个项目，并没有创建应用，以微信来举例，微信是不是一个大的项目，但是微信里面是不是有很多个应用，支付应用、聊天应用、朋友圈、小程序等这些在一定程度上都是相互独立的应用，也就是说一个大的项目里面可以有多个应用，也就是说项目是包含应用的，它没有将view放到这个项目目录里面是因为它觉得，一个项目里面可以有多个应用，而每个应用都有自己这个应用的逻辑内容，所以他觉得这个view应该放到应用里面，比如说我们的微信，刚才说了几个应用，这几个应用的逻辑能放到一起吗，放到一起是不是就乱套啦，也不好管理和维护，所以这些应用的逻辑都分开来放，它就帮我们提炼出来了，提炼出来一个叫做应用的东西，所以我们需要来创建这个应用。</p><p>　　　　</p><h3 id="3、在mysite目录下创建应用"><a href="#3、在mysite目录下创建应用" class="headerlink" title="3、在mysite目录下创建应用"></a>3、在mysite目录下创建应用</h3><p>​     　　   <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20160724114930826-472002646.png" alt="img"></p><p>　　我们现在只需要看其中两个文件</p><p>　　　　models.py ：之前我们写的那个名为model的文件就是创建表用的，这个文件就是存放与该app(应用)相关的表结构的</p><p>　　　　views.py    ：存放与该app相关的视图函数的</p><h3 id="4、启动django项目"><a href="#4、启动django项目" class="headerlink" title="4、启动django项目"></a>4、启动django项目</h3><p>​       这样我们的django就启动起来了！当我们访问：<a href="http://127.0.0.1:8080/%E6%97%B6%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%9A">http://127.0.0.1:8080/时就可以看到：</a></p><p>​       <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/877318-20160724120547497-22629173.png" alt="img"></p><p>学习Django，我们就学上面的这些文件，怎么在MTV+url分发的功能下来使用。</p><p>最后我们说一下，其实我们将来创建django项目，很少用命令行了，就用pycharm来创建，怎么创建呢？看图：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218212732820-700635300.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218212647295-533476159.png" alt="img"></p><p> 　　　　看项目目录：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218212923366-780961303.png" alt="img"></p><h3 id="五-基于Django实现一个简单的示例"><a href="#五-基于Django实现一个简单的示例" class="headerlink" title="五 基于Django实现一个简单的示例"></a>五 基于Django实现一个简单的示例</h3><p> 现在实现一个用户输入一个timer路径，返回一个含有当前时间的页面，想想怎么做？用户输入网址–&gt;路径–&gt;函数–&gt;返回数据(文件)</p><h3 id="url控制器（第一步就找它）"><a href="#url控制器（第一步就找它）" class="headerlink" title="　　url控制器（第一步就找它）"></a>　　url控制器（第一步就找它）</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.contrib import adminfrom django.urls import path#找对应的函数，是哪个app里面的函数from app01 import viewsurlpatterns = [    path('admin/', admin.site.urls), #这个先不用管，后面会学    path('index/',views.index),]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　视图</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>from django.shortcuts import render,HttpResponse# Create your views here.#逻辑和返回数据def index(request):    import datetime    now=datetime.datetime.now()    ctime=now.strftime("%Y-%m-%d %X")　　 #return HttpResponse('哈哈，好玩吗？')    return render(request,"index.html",{"ctime":ctime}) #render，渲染html页面文件并返回给浏览器</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　模板</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;当前时间:{{ ctime }}&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　通过pycharm来运行项目：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218214227231-153650928.png" alt="img"></p><p>　　　　看控制台：</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218214438381-1425402212.png" alt="img"></p><p>　　执行效果如下：</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218213237723-1108613034.png" alt="img"></p><p> 有同学说：我想自己配置启动的端口怎么搞啊：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218214319870-1182270859.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218214345440-48001565.png" alt="img"></p><p>　　 　　</p><p>　　还有一点说一下昂，在settings配置文件里面有关于templates(放html文件的配置)：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>TEMPLATES = [    {        'BACKEND': 'django.template.backends.django.DjangoTemplates',        'DIRS': [os.path.join(BASE_DIR, 'templates')] #有些版本的django没有写这个，自己写一下，就是配置一个django找html文件的路径，render方法就来这里找html文件        ,        'APP_DIRS': True,        'OPTIONS': {            'context_processors': [                'django.template.context_processors.debug',                'django.template.context_processors.request',                'django.contrib.auth.context_processors.auth',                'django.contrib.messages.context_processors.messages',            ],        },    },]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　关于请求和响应的请求信息和相应信息的设置还需要你自己写吗？之前我们用wsgiref是不是还写来着，现在都不需要写了，简单不。</p><p>　　还有一点：post请求的时候你会发现一个 Forbidden的错误：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218220535726-1977412154.png" alt="img"></p><p>　　现在只需要做一步，在settings配置文件里面将这一行注释掉，这是django给你加的一个csrf的认证，现在不需要，我们会讲的</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    # 'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'django.middleware.clickjacking.XFrameOptionsMiddleware',]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　还记得django写视图函数的时候，有一个参数是必须要给的吗，叫做request，如果你是post请求，那么就用request.POST，就能拿到post请求提交过来的所有数据（一个字典，然后再通过字典取值request.POST.get(‘username’)，取出来的就是个字符串，你在那个字典里面看到的是{‘username’:[‘chao’]}，虽然看着是列表，但是request.POST.get(‘username’)取出来的就是个字符串），通过request.GET就能拿到提交过来的所有数据，而且记着，每一个视图函数都要给人家返回一些内容，用render或者HttpResponse等，其实render里面也是通过HttpResponse来返回内容，不然会报错，错误是告诉你没有返回任何内容：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/988061-20190218220501334-1922192819.png" alt="img"></p><p>　　django认识了，以后我们就按照下面的步骤来学：</p><p>　　　　1.django的url控制器</p><p>　　　　2.django的视图</p><p>　　　　3.django的模板(template)</p><p>　　　　4.ORM（花的时间比较久）</p><p>　　作业好了，我们之前写的那个登陆认证示例，加到django里面来吧！</p><p> 　　</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 Django之路由系统</title>
      <link href="2019/11/15/CRM/01%20Django%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F/"/>
      <url>2019/11/15/CRM/01%20Django%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Django之路由系统"><a href="#Django之路由系统" class="headerlink" title="Django之路由系统"></a><a href="https://www.cnblogs.com/maple-shaw/articles/9282718.html">Django之路由系统</a></h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h1 id="Django的路由系统"><a href="#Django的路由系统" class="headerlink" title="Django的路由系统"></a>Django的路由系统</h1><p><a href="https://docs.djangoproject.com/en/1.11/topics/http/urls/">Django 1.11版本 URLConf官方文档</a></p><p>URL配置(URLconf)就像Django所支撑网站的目录。它的本质是URL与要为该URL调用的视图函数之间的映射表。</p><p>我们就是以这种方式告诉Django，遇到哪个URL的时候，要对应执行哪个函数。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9282718.html#_labelTop">回到顶部</a></p><h2 id="URLconf配置"><a href="#URLconf配置" class="headerlink" title="URLconf配置"></a>URLconf配置</h2><h3 id="基本格式："><a href="#基本格式：" class="headerlink" title="基本格式："></a>基本格式：</h3><pre><code>from django.conf.urls import urlurlpatterns = [     url(正则表达式, views视图，参数，别名),]</code></pre><p>示例：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^articles/2003/$', views.special_case_2003),    url(r'^articles/([0-9]{4})/$', views.year_archive),    url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive),    url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail),]</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><ul><li>正则表达式：一个正则表达式字符串</li><li>views视图：一个可调用对象，通常为一个视图函数</li><li>参数：可选的要传递给视图函数的默认参数（字典形式）</li><li>别名：一个可选的name参数</li></ul><p>注意：</p><p>Django 2.0版本中的路由系统是下面的写法（<a href="https://docs.djangoproject.com/en/1.11/topics/http/urls/">官方文档</a>）：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from django.urls import path，re_pathurlpatterns = [    path('articles/2003/', views.special_case_2003),    path('articles/&lt;int:year&gt;/', views.year_archive),    path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive),    path('articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/', views.article_detail),]</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2.0版本中re_path和1.11版本的url是一样的用法。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9282718.html#_labelTop">回到顶部</a></p><h2 id="正则表达式详解"><a href="#正则表达式详解" class="headerlink" title="正则表达式详解"></a>正则表达式详解</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^articles/2003/$', views.special_case_2003),    url(r'^articles/([0-9]{4})/$', views.year_archive),    url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive),    url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail),]</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>urlpatterns中的元素按照书写顺序从上往下逐一匹配正则表达式，一旦匹配成功则不再继续。</li><li>若要从URL中捕获一个值，只需要在它周围放置一对圆括号（分组匹配）。</li><li>不需要添加一个前导的反斜杠，因为每个URL 都有。例如，应该是^articles 而不是 ^/articles。</li><li>每个正则表达式前面的’r’ 是可选的但是建议加上。</li></ol><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><pre><code># 是否开启URL访问地址后面不为/跳转至带有/的路径的配置项APPEND_SLASH=True</code></pre><p>Django settings.py配置文件中默认没有 APPEND_SLASH 这个参数，但 Django 默认这个参数为 APPEND_SLASH = True。 其作用就是自动在网址结尾加’/‘。</p><p>其效果就是：</p><p>我们定义了urls.py：</p><pre><code>from django.conf.urls import urlfrom app01 import viewsurlpatterns = [    url(r'^blog/$', views.blog),]</code></pre><p>访问 <a href="http://www.example.com/blog">http://www.example.com/blog</a> 时，默认将网址自动转换为 <a href="http://www.example/com/blog/">http://www.example/com/blog/</a> 。</p><p>如果在settings.py中设置了 <strong>APPEND_SLASH=False</strong>，此时我们再请求 <a href="http://www.example.com/blog">http://www.example.com/blog</a> 时就会提示找不到页面。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9282718.html#_labelTop">回到顶部</a></p><h2 id="分组命名匹配"><a href="#分组命名匹配" class="headerlink" title="分组命名匹配"></a>分组命名匹配</h2><p>上面的示例使用简单的正则表达式分组匹配（通过圆括号）来捕获URL中的值并以位置参数形式传递给视图。</p><p>在更高级的用法中，可以使用分组命名匹配的正则表达式组来捕获URL中的值并以关键字参数形式传递给视图。</p><p>在Python的正则表达式中，分组命名正则表达式组的语法是<code>(?P&lt;name&gt;pattern)</code>，其中<code>name</code>是组的名称，<code>pattern</code>是要匹配的模式。</p><p>下面是以上URLconf 使用命名组的重写：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^articles/2003/$', views.special_case_2003),    url(r'^articles/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive),    url(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$', views.month_archive),    url(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/(?P&lt;day&gt;[0-9]{2})/$', views.article_detail),]</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>这个实现与前面的示例完全相同，只有一个细微的差别：捕获的值作为关键字参数而不是位置参数传递给视图函数。</p><p>例如，针对URL /articles/2017/12/相当于按以下方式调用视图函数：</p><pre><code>views.month_archive(request, year="2017", month="12")</code></pre><p>在实际应用中，使用分组命名匹配的方式可以让你的URLconf 更加明晰且不容易产生参数顺序问题的错误，但是有些开发人员则认为分组命名组语法太丑陋、繁琐。</p><p>至于究竟应该使用哪一种，你可以根据自己的喜好来决定。</p><h3 id="URLconf匹配的位置"><a href="#URLconf匹配的位置" class="headerlink" title="URLconf匹配的位置"></a>URLconf匹配的位置</h3><p>URLconf 在请求的URL 上查找，将它当做一个普通的Python 字符串。不包括GET和POST参数以及域名。</p><p>例如，<a href="http://www.example.com/myapp/">http://www.example.com/myapp/</a> 请求中，URLconf 将查找 /myapp/ 。</p><p>在<a href="http://www.example.com/myapp/?page=3">http://www.example.com/myapp/?page=3</a> 请求中，URLconf 仍将查找 /myapp/ 。</p><p>URLconf 不检查请求的方法。换句话讲，所有的请求方法 —— 同一个URL的<code>POST</code>、<code>GET</code>、<code>HEAD</code>等等 —— 都将路由到相同的函数。</p><h3 id="捕获的参数永远都是字符串"><a href="#捕获的参数永远都是字符串" class="headerlink" title="捕获的参数永远都是字符串"></a>捕获的参数永远都是字符串</h3><p>每个在URLconf中捕获的参数都作为一个普通的Python字符串传递给视图，无论正则表达式使用的是什么匹配方式。例如，下面这行URLconf 中：</p><pre><code>url(r'^articles/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive),</code></pre><p>传递到视图函数<code>views.year_archive()</code> 中的<code>year</code>参数永远是一个字符串类型。</p><h3 id="视图函数中指定默认值"><a href="#视图函数中指定默认值" class="headerlink" title="视图函数中指定默认值"></a>视图函数中指定默认值</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code># urls.py中from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^blog/$', views.page),    url(r'^blog/page(?P&lt;num&gt;[0-9]+)/$', views.page),]# views.py中，可以为num指定默认值def page(request, num="1"):    pass</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>在上面的例子中，两个URL模式指向相同的view - views.page - 但是第一个模式并没有从URL中捕获任何东西。</p><p>如果第一个模式匹配上了，page()函数将使用其默认参数num=“1”,如果第二个模式匹配，page()将使用正则表达式捕获到的num值。</p><h3 id="include其他的URLconfs"><a href="#include其他的URLconfs" class="headerlink" title="include其他的URLconfs"></a>include其他的URLconfs</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#At any point, your urlpatterns can “include” other URLconf modules. This#essentially “roots” a set of URLs below other ones.#For example, here’s an excerpt of the URLconf for the Django website itself.#It includes a number of other URLconfs:from django.conf.urls import include, urlurlpatterns = [   url(r'^admin/', admin.site.urls),   url(r'^blog/', include('blog.urls')),  # 可以包含其他的URLconfs文件]</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9282718.html#_labelTop">回到顶部</a></p><h2 id="传递额外的参数给视图函数（了解）"><a href="#传递额外的参数给视图函数（了解）" class="headerlink" title="传递额外的参数给视图函数（了解）"></a>传递额外的参数给视图函数（了解）</h2><p>URLconfs 具有一个钩子，让你传递一个Python 字典作为额外的参数传递给视图函数。</p><p><code>django.conf.urls.url()</code> 可以接收一个可选的第三个参数，它是一个字典，表示想要传递给视图函数的额外关键字参数。</p><p>例如：</p><pre><code>from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^blog/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive, {'foo': 'bar'}),]</code></pre><p>在这个例子中，对于/blog/2005/请求，Django 将调用views.year_archive(request, year=’2005’, foo=’bar’)。<br>当传递额外参数的字典中的参数和URL中捕获值的命名关键字参数同名时，函数调用时将使用的是字典中的参数，而不是URL中捕获的参数。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9282718.html#_labelTop">回到顶部</a></p><h2 id="命名URL和URL反向解析"><a href="#命名URL和URL反向解析" class="headerlink" title="命名URL和URL反向解析"></a>命名URL和URL反向解析</h2><p>在使用Django 项目时，一个常见的需求是获得URL的最终形式，以用于嵌入到生成的内容中（视图中和显示给用户的URL等）或者用于处理服务器端的导航（重定向等）。<br>人们强烈希望不要硬编码这些URL（费力、不可扩展且容易产生错误）或者设计一种与URLconf 毫不相关的专门的URL 生成机制，因为这样容易导致一定程度上产生过期的URL。<br>换句话讲，需要的是一个DRY 机制。除了其它有点，它还允许设计的URL 可以自动更新而不用遍历项目的源代码来搜索并替换过期的URL。<br>获取一个URL 最开始想到的信息是处理它视图的标识（例如名字），查找正确的URL 的其它必要的信息有视图参数的类型（位置参数、关键字参数）和值。<br>Django 提供一个办法是让URL 映射是URL 设计唯一的地方。你填充你的URLconf，然后可以双向使用它：</p><ul><li>根据用户/浏览器发起的URL 请求，它调用正确的Django 视图，并从URL 中提取它的参数需要的值。</li><li>根据Django 视图的标识和将要传递给它的参数的值，获取与之关联的URL。</li></ul><p>第一种方式是我们在前面的章节中一直讨论的用法。第二种方式叫做反向解析URL、反向URL 匹配、反向URL 查询或者简单的URL 反查。<br>在需要URL 的地方，对于不同层级，Django 提供不同的工具用于URL 反查：</p><ul><li>在模板中：使用url模板标签。</li><li>在Python 代码中：使用django.core.urlresolvers.reverse() 函数。</li><li>在更高层的与处理Django 模型实例相关的代码中：使用get_absolute_url() 方法。</li></ul><p>上面说了一大堆，你可能并没有看懂。（那是官方文档的生硬翻译）。</p><p>咱们简单来说就是可以给我们的URL匹配规则起个名字，一个URL匹配模式起一个名字。</p><p>这样我们以后就不需要写死URL代码了，只需要通过名字来调用当前的URL。</p><p>举个简单的例子：</p><pre><code>url(r'^home', views.home, name='home'),  # 给我的url匹配模式起名为 homeurl(r'^index/(\d*)', views.index, name='index'),  # 给我的url匹配模式起名为index</code></pre><p>这样：</p><p>在模板里面可以这样引用：</p><pre><code>{% url 'home' %}</code></pre><p>在views函数中可以这样引用：</p><pre><code>from django.urls import reversereverse("index", args=("2018", ))</code></pre><p>例子：<br>考虑下面的URLconf：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom . import viewsurlpatterns = [    # ...    url(r'^articles/([0-9]{4})/$', views.year_archive, name='news-year-archive'),    # ...]</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>根据这里的设计，某一年nnnn对应的归档的URL是<code>/articles/nnnn/</code>。</p><p>你可以在模板的代码中使用下面的方法获得它们：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;a href="{% url 'news-year-archive' 2012 %}"&gt;2012 Archive&lt;/a&gt;&lt;ul&gt;{% for yearvar in year_list %}<li><a href="{% url 'news-year-archive' yearvar %}">{{ yearvar }} Archive</a></li>{% endfor %}&lt;/ul&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>在Python 代码中，这样使用：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from django.urls import reversefrom django.shortcuts import redirectdef redirect_to_year(request):    # ...    year = 2006    # ...    return redirect(reverse('news-year-archive', args=(year,)))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如果出于某种原因决定按年归档文章发布的URL应该调整一下，那么你将只需要修改URLconf 中的内容。</p><p>在某些场景中，一个视图是通用的，所以在URL 和视图之间存在多对一的关系。对于这些情况，当反查URL 时，只有视图的名字还不够。</p><p><strong>注意：</strong></p><p>为了完成上面例子中的URL 反查，你将需要使用命名的URL 模式。URL 的名称使用的字符串可以包含任何你喜欢的字符。不只限制在合法的Python 名称。</p><p>当命名你的URL 模式时，请确保使用的名称不会与其它应用中名称冲突。如果你的URL 模式叫做<code>comment</code>，而另外一个应用中也有一个同样的名称，当你在模板中使用这个名称的时候不能保证将插入哪个URL。</p><p>在URL 名称中加上一个前缀，比如应用的名称，将减少冲突的可能。我们建议使用<code>myapp-comment</code> 而不是<code>comment</code>。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9282718.html#_labelTop">回到顶部</a></p><h2 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h2><p>即使不同的APP使用相同的URL名称，URL的命名空间模式也可以让你唯一反转命名的URL。</p><p>举个例子：</p><p>project中的urls.py</p><pre><code>from django.conf.urls import url, includeurlpatterns = [    url(r'^app01/', include('app01.urls', namespace='app01')),    url(r'^app02/', include('app02.urls', namespace='app02')),]</code></pre><p>app01中的urls.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom app01 import viewsapp_name = 'app01'urlpatterns = [    url(r'^(?P&lt;pk&gt;\d+)/$', views.detail, name='detail')]</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>app02中的urls.py</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from django.conf.urls import urlfrom app02 import viewsapp_name = 'app02'urlpatterns = [    url(r'^(?P&lt;pk&gt;\d+)/$', views.detail, name='detail')]</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>现在，我的两个app中 url名称重复了，我反转URL的时候就可以通过命名空间的名称得到我当前的URL。</p><p><strong>语法：</strong></p><p>‘命名空间名称:URL名称’</p><p>模板中使用：</p><pre><code>{% url 'app01:detail' pk=12 pp=99 %}</code></pre><p>views中的函数中使用</p><pre><code>v = reverse('app01:detail', kwargs={'pk':11})</code></pre><p> 这样即使app中URL的命名相同，我也可以反转得到正确的URL了。　　</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 Cookie和Session</title>
      <link href="2019/11/15/CRM/05%20Cookie%E5%92%8CSession/"/>
      <url>2019/11/15/CRM/05%20Cookie%E5%92%8CSession/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#_label0">目录</a></li><li>Cookie<ul><li><a href="#_label1_0">Cookie的由来</a></li><li><a href="#_label1_1">什么是Cookie</a></li><li><a href="#_label1_2">Cookie的原理</a></li><li><a href="#_label1_3">查看Cookie</a></li></ul></li><li>Django中操作Cookie<ul><li><a href="#_label2_0">获取Cookie</a></li><li><a href="#_label2_1">设置Cookie</a></li><li><a href="#_label2_2">删除Cookie</a></li></ul></li><li>Session<ul><li><a href="#_label3_0">Session的由来</a></li></ul></li><li>Django中Session相关方法<ul><li><a href="#_label4_0">Session流程解析</a></li><li><a href="#_label4_1">Session版登陆验证</a></li><li><a href="#_label4_2">Django中的Session配置</a></li></ul></li></ul><p><a href="#_labelTop">回到顶部</a></p><h2 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h2><p><a href="https://www.cnblogs.com/maple-shaw/articles/9502602.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>大家都知道HTTP协议是无状态的。</p><p>无状态的意思是每次请求都是独立的，它的执行情况和结果与前面的请求和之后的请求都无直接关系，它不会受前面的请求响应情况直接影响，也不会直接影响后面的请求响应情况。</p><p>一句有意思的话来描述就是人生只如初见，对服务器来说，每次的请求都是全新的。</p><p>状态可以理解为客户端和服务器在某次会话中产生的数据，那无状态的就以为这些数据不会被保留。会话中产生的数据又是我们需要保存的，也就是说要“保持状态”。因此Cookie就是在这样一个场景下诞生。</p><p>Cookie具体指的是一段小信息，它是服务器发送出来存储在浏览器上的一组组键值对，下次访问服务器时浏览器会自动携带这些键值对，以便服务器提取有用信息。</p><p>cookie的工作原理是：由服务器产生内容，浏览器收到请求后保存在本地；当浏览器再次访问时，浏览器会自动带上Cookie，这样服务器就能通过Cookie的内容来判断这个是“谁”了。</p><p>我们使用Chrome浏览器，打开开发者工具。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180403225926558-498750585.png" alt="img"></p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9502602.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Django中操作Cookie"><a href="#Django中操作Cookie" class="headerlink" title="Django中操作Cookie"></a>Django中操作Cookie</h2><pre><code>request.COOKIES['key']request.get_signed_cookie('key', default=RAISE_ERROR, salt='', max_age=None)</code></pre><p>get_signed_cookie方法的参数：</p><ul><li>default: 默认值</li><li>salt: 加密盐</li><li>max_age: 后台控制过期时间</li></ul><pre><code>rep = HttpResponse(...)rep ＝ render(request, ...)rep.set_cookie(key,value,...)rep.set_signed_cookie(key,value,salt='加密盐',...)</code></pre><p>参数：</p><ul><li>key, 键</li><li>value=’’, 值</li><li>max_age=None, 超时时间</li><li>expires=None, 超时时间(IE requires expires, so set it if hasn’t been already.)</li><li>path=’/‘, Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问</li><li>domain=None, Cookie生效的域名</li><li>secure=False, https传输</li><li>httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</li></ul><pre><code>def logout(request):    rep = redirect("/login/")    rep.delete_cookie("user")  # 删除用户浏览器上之前设置的user的cookie值    return rep</code></pre><p>Cookie版登陆校验</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> cookie版登录</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9502602.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Cookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session。</p><p>问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。</p><p>我们可以给每个客户端的Cookie分配一个唯一的id，这样用户在访问时，通过Cookie，服务器就知道来的人是“谁”。然后我们再根据不同的Cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。</p><p>总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在Session里保存私密的信息以及超过4096字节的文本。</p><p>另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9502602.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Django中Session相关方法"><a href="#Django中Session相关方法" class="headerlink" title="Django中Session相关方法"></a>Django中Session相关方法</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code># 获取、设置、删除Session中数据request.session['k1']request.session.get('k1',None)request.session['k1'] = 123request.session.setdefault('k1',123) # 存在则不设置del request.session['k1']# 所有 键、值、键值对request.session.keys()request.session.values()request.session.items()request.session.iterkeys()request.session.itervalues()request.session.iteritems()# 会话session的keyrequest.session.session_key# 将所有Session失效日期小于当前日期的数据删除request.session.clear_expired()# 检查会话session的key在数据库中是否存在request.session.exists("session_key")# 删除当前会话的所有Session数据request.session.delete()　　# 删除当前的会话数据并删除会话的Cookie。request.session.flush()     这用于确保前面的会话数据不可以再次被用户的浏览器访问    例如，django.contrib.auth.logout() 函数中就会调用它。# 设置会话Session和Cookie的超时时间request.session.set_expiry(value)    * 如果value是个整数，session会在些秒数后失效。    * 如果value是个datatime或timedelta，session就会在这个时间后失效。    * 如果value是0,用户关闭浏览器session就会失效。    * 如果value是None,session会依赖全局session失效策略。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/1168194-20180821121836014-326120237.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> Session版登录验证</p><p>Django中默认支持Session，其内部提供了5种类型的Session供开发者使用。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> Django中Session相关设置</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06 Django的中间件</title>
      <link href="2019/11/15/CRM/06%20Django%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>2019/11/15/CRM/06%20Django%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#_label0">目录</a></li><li>中间件介绍<ul><li><a href="#_label1_0">什么是中间件？</a></li></ul></li><li>自定义中间件<ul><li><a href="#_label2_0">自定义一个中间件示例</a></li><li><a href="#_label2_1">process_request</a></li><li><a href="#_label2_2">process_response</a></li><li><a href="#_label2_3">process_view</a></li><li><a href="#_label2_4">process_exception</a></li><li><a href="#_label2_5">process_template_response（用的比较少）</a></li></ul></li><li><a href="#_label3">中间件的执行流程</a></li><li><a href="#_label4">中间件版登录验证 </a></li><li><a href="#_label5">附：Django请求流程图</a></li></ul><p><a href="#_labelTop">回到顶部</a></p><h2 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h2><h1 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a><strong>前戏</strong></h1><p>我们在前面的课程中已经学会了给视图函数加装饰器来判断是用户是否登录，把没有登录的用户请求跳转到登录页面。我们通过给几个特定视图函数加装饰器实现了这个需求。但是以后添加的视图函数可能也需要加上装饰器，这样是不是稍微有点繁琐。</p><p>学完今天的内容之后呢，我们就可以用更适宜的方式来实现类似给所有请求都做相同操作的功能了。</p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p><a href="https://www.cnblogs.com/maple-shaw/articles/9333824.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="中间件介绍"><a href="#中间件介绍" class="headerlink" title="中间件介绍"></a><strong>中间件介绍</strong></h2><p>官方的说法：中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。每个中间件组件都负责做一些特定的功能。</p><p>但是由于其影响的是全局，所以需要谨慎使用，使用不当会影响性能。</p><p>说的直白一点中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个方法，Django框架会在处理请求的特定的时间去执行这些方法。</p><p>我们一直都在使用中间件，只是没有注意到而已，打开Django项目的Settings.py文件，看到下图的MIDDLEWARE配置项。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'django.middleware.clickjacking.XFrameOptionsMiddleware',]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>MIDDLEWARE配置项是一个列表，列表中是一个个字符串，这些字符串其实是一个个类，也就是一个个中间件。</p><p>我们之前已经接触过一个csrf相关的中间件了？我们一开始让大家把他注释掉，再提交post请求的时候，就不会被forbidden了，后来学会使用csrf_token之后就不再注释这个中间件了。</p><p>那接下来就学习中间件中的方法以及这些方法什么时候被执行。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9333824.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h2><p>中间件可以定义五个方法，分别是：（主要的是process_request和process_response）</p><ul><li>process_request(self,request)</li><li>process_view(self, request, view_func, view_args, view_kwargs)</li><li>process_template_response(self,request,response)</li><li>process_exception(self, request, exception)</li><li>process_response(self, request, response)</li></ul><p>以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象，则直接将该对象返回给用户。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>process_request有一个参数，就是request，这个request和视图函数中的request是一样的。</p><p>它的返回值可以是None也可以是HttpResponse对象。返回值是None的话，按正常流程继续走，交给下一个中间件处理，如果是HttpResponse对象，Django将不执行视图函数，而将响应对象返回给浏览器。</p><p>我们来看看多个中间件时，Django是如何执行其中的process_request方法的。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")class MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>在settings.py的MIDDLEWARE配置项中注册上述两个自定义中间件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'django.middleware.clickjacking.XFrameOptionsMiddleware',    'middlewares.MD1',  # 自定义中间件MD1    'middlewares.MD2'  # 自定义中间件MD2]</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>此时，我们访问一个视图，会发现终端中打印如下内容：</p><pre><code>MD1里面的 process_requestMD2里面的 process_requestapp01 中的 index视图</code></pre><p>把MD1和MD2的位置调换一下，再访问一个视图，会发现终端中打印的内容如下：</p><pre><code>MD2里面的 process_requestMD1里面的 process_requestapp01 中的 index视图</code></pre><p>看结果我们知道：视图函数还是最后执行的，MD2比MD1先执行自己的process_request方法。</p><p>在打印一下两个自定义中间件中process_request方法中的request参数，会发现它们是同一个对象。</p><p>由此总结一下：</p><ol><li>中间件的process_request方法是在执行视图函数之前执行的。</li><li>当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。</li><li>不同中间件之间传递的request都是同一个对象</li></ol><p>它有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。该方法的返回值也必须是HttpResponse对象。</p><p>给上述的M1和M2加上process_response方法：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return responseclass MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")    def process_response(self, request, response):        print("MD2里面的 process_response")        return response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>访问一个视图，看一下终端的输出：</p><pre><code>MD2里面的 process_requestMD1里面的 process_requestapp01 中的 index视图MD1里面的 process_responseMD2里面的 process_response</code></pre><p>看结果可知：</p><p>process_response方法是在视图函数之后执行的，并且顺序是MD1比MD2先执行。(此时settings.py中 MD2比MD1先注册)</p><p>多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序<strong>倒序</strong>执行的，也就是说第一个中间件的process_request方法首先执行，而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。</p><p>process_view(self, request, view_func, view_args, view_kwargs)</p><p>该方法有四个参数</p><p>request是HttpRequest对象。</p><p>view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）</p><p>view_args是将传递给视图的位置参数的列表.</p><p>view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。</p><p>Django会在调用视图函数之前调用process_view方法。</p><p>它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。</p><p> 给MD1和MD2添加process_view方法:</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD1 中的process_view")        print(view_func, view_func.__name__)class MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")    def process_response(self, request, response):        print("MD2里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD2 中的process_view")        print(view_func, view_func.__name__)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>访问index视图函数，看一下输出结果：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>MD2里面的 process_requestMD1里面的 process_request--------------------------------------------------------------------------------MD2 中的process_view&lt;function index at 0x000001DE68317488&gt; index--------------------------------------------------------------------------------MD1 中的process_view&lt;function index at 0x000001DE68317488&gt; indexapp01 中的 index视图MD1里面的 process_responseMD2里面的 process_response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>process_view方法是在process_request之后，视图函数之前执行的，执行顺序按照MIDDLEWARE中的注册顺序<strong>从前到后顺序</strong>执行的</p><p>process_exception(self, request, exception)</p><p>该方法两个参数:</p><p>一个HttpRequest对象</p><p>一个exception是视图函数异常产生的Exception对象。</p><p>这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的倒序执行。</p><p> 给MD1和MD2添加上这个方法：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.utils.deprecation import MiddlewareMixinclass MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD1 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD1 中的process_exception")class MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")    def process_response(self, request, response):        print("MD2里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD2 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD2 中的process_exception")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如果视图函数中无异常，process_exception方法不执行。</p><p>想办法，在视图函数中抛出一个异常：</p><pre><code>def index(request):    print("app01 中的 index视图")    raise ValueError("呵呵")    return HttpResponse("O98K")</code></pre><p>在MD1的process_exception中返回一个响应对象：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD1 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD1 中的process_exception")        return HttpResponse(str(exception))  # 返回一个响应对象</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>看输出结果：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>MD2里面的 process_requestMD1里面的 process_request--------------------------------------------------------------------------------MD2 中的process_view&lt;function index at 0x0000022C09727488&gt; index--------------------------------------------------------------------------------MD1 中的process_view&lt;function index at 0x0000022C09727488&gt; indexapp01 中的 index视图呵呵MD1 中的process_exceptionMD1里面的 process_responseMD2里面的 process_response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>注意，这里并没有执行MD2的process_exception方法，因为MD1中的process_exception方法直接返回了一个响应对象。</p><p>process_template_response(self, request, response)</p><p>它的参数，一个HttpRequest对象，response是TemplateResponse对象（由视图函数或者中间件产生）。</p><p>process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法（或者表明该对象是一个TemplateResponse对象或等价方法）。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class MD1(MiddlewareMixin):    def process_request(self, request):        print("MD1里面的 process_request")    def process_response(self, request, response):        print("MD1里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD1 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD1 中的process_exception")        return HttpResponse(str(exception))    def process_template_response(self, request, response):        print("MD1 中的process_template_response")        return responseclass MD2(MiddlewareMixin):    def process_request(self, request):        print("MD2里面的 process_request")    def process_response(self, request, response):        print("MD2里面的 process_response")        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print("-" * 80)        print("MD2 中的process_view")        print(view_func, view_func.__name__)    def process_exception(self, request, exception):        print(exception)        print("MD2 中的process_exception")    def process_template_response(self, request, response):        print("MD2 中的process_template_response")        return response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>views.py中：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>def index(request):    print("app01 中的 index视图")    def render():        print("in index/render")        return HttpResponse("O98K")    rep = HttpResponse("OK")    rep.render = render    return rep</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>访问index视图，终端输出的结果：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>MD2里面的 process_requestMD1里面的 process_request--------------------------------------------------------------------------------MD2 中的process_view&lt;function index at 0x000001C111B97488&gt; index--------------------------------------------------------------------------------MD1 中的process_view&lt;function index at 0x000001C111B97488&gt; indexapp01 中的 index视图MD1 中的process_template_responseMD2 中的process_template_responsein index/renderMD1里面的 process_responseMD2里面的 process_response</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>从结果看出：</p><p>视图函数执行完之后，立即执行了中间件的process_template_response方法，顺序是倒序，先执行MD1的，在执行MD2的，接着执行了视图函数返回的HttpResponse对象的render方法，返回了一个新的HttpResponse对象，接着执行中间件的process_response方法。</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9333824.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="中间件的执行流程"><a href="#中间件的执行流程" class="headerlink" title="中间件的执行流程"></a><strong>中间件的执行流程</strong></h2><p>上一部分，我们了解了中间件中的5个方法，它们的参数、返回值以及什么时候执行，现在总结一下中间件的执行流程。</p><p>请求到达中间件之后，先按照正序执行每个注册中间件的process_reques方法，process_request方法返回的值是None，就依次执行，如果返回的值是HttpResponse对象，不再执行后面的process_request方法，而是执行当前对应中间件的process_response方法，将HttpResponse对象返回给浏览器。也就是说：如果MIDDLEWARE中注册了6个中间件，执行过程中，第3个中间件返回了一个HttpResponse对象，那么第4,5,6中间件的process_request和process_response方法都不执行，顺序执行3,2,1中间件的process_response方法。</p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180409214209079-1725524152.png" alt="img"></p><p>process_request方法都执行完后，匹配路由，找到要执行的视图函数，先不执行视图函数，先执行中间件中的process_view方法，process_view方法返回None，继续按顺序执行，所有process_view方法执行完后执行视图函数。假如中间件3 的process_view方法返回了HttpResponse对象，则4,5,6的process_view以及视图函数都不执行，直接从最后一个中间件，也就是中间件6的process_response方法开始倒序执行。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180409214307195-1684061444.png" alt="img"></p><p>process_template_response和process_exception两个方法的触发是有条件的，执行顺序也是倒序。总结所有的执行流程如下：</p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180409214356226-286908304.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180409214433968-2137571775.png" alt="img"></p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9333824.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="中间件版登录验证"><a href="#中间件版登录验证" class="headerlink" title="中间件版登录验证"></a>中间件版登录验证</h2><p>中间件版的登录验证需要依靠session，所以数据库中要有django_session表。</p><p>urls.py</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> urls.py</p><p>views.py</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> views.py</p><p>login.html</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> login.html</p><p>middlewares.py</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> 中间件</p><p>在settings.py中注册</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> 注册中间件</p><p>AuthMD中间件注册后，所有的请求都要走AuthMD的process_request方法。</p><p>如果URL在黑名单中，则返回This is an illegal URL的字符串；</p><p>访问的URL在白名单内或者session中有user用户名，则不做阻拦走正常流程；</p><p>正常的URL但是需要登录后访问，让浏览器跳转到登录页面。</p><p>注：AuthMD中间件中需要session，所以AuthMD注册的位置要在session中间的下方。 </p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9333824.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="附：Django请求流程图"><a href="#附：Django请求流程图" class="headerlink" title="附：Django请求流程图"></a>附：Django请求流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/1168194-20180719084357413-1778333372.png" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07 AJAX</title>
      <link href="2019/11/15/CRM/07%20AJAX%20/"/>
      <url>2019/11/15/CRM/07%20AJAX%20/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-html"><code class="language-html">## 目录- [目录](#_label0)- AJAX准备知识：JSON  - [stringify与parse方法](#_label1_0)  - [和XML的比较](#_label1_1)- AJAX简介  - [AJAX常见应用情景](#_label2_0)  - [AJAX的优缺点](#_label2_1)- jQuery实现的AJAX  - [$.ajax参数](#_label3_0)- [JS实现AJAX](#_label4)- AJAX请求如何设置csrf_token  - [方式1](#_label5_0)  - [方式2](#_label5_1)- [AJAX上传文件](#_label6)- 练习（用户名是否已被注册）  - [功能介绍](#_label7_0)  - [案例分析](#_label7_1)- 序列化  - [Django内置的serializers](#_label8_0)- [SweetAlert插件](#_label9)[回到顶部](#_labelTop)## 目录[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9524153.html#_labelTop)[回到顶部](#_labelTop)## AJAX准备知识：JSON什么是 JSON ？- JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）- JSON 是轻量级的文本数据交换格式- JSON 独立于语言 *- JSON 具有自我描述性，更易理解\* JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 啥都别多说了，上图吧！![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180407213606833-782897022.jpg)合格的json对象：```["one", "two", "three"]{ "one": 1, "two": 2, "three": 3 }{"names": ["张三", "李四"] }[ { "name": "张三"}, {"name": "李四"} ]　``` 不合格的json对象：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)```{ name: "张三", 'age': 32 }  　　　　　　 // 属性名必须使用双引号[32, 64, 128, 0xFFF] 　　　　　　　　　　  // 不能使用十六进制值{ "name": "张三", "age": undefined }    // 不能使用undefined{ "name": "张三",  "birthday": new Date('Fri, 26 Aug 2011 07:13:10 GMT'),  "getName":  function() {return this.name;}  // 不能使用函数和日期对象}```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)JavaScript中关于JSON对象和字符串转换的两个方法：JSON.parse(): 用于将一个 JSON 字符串转换为 JavaScript 对象　```JSON.parse('{"name":"alex"}');JSON.parse('{name:"alex"}') ;      // 错误JSON.parse('[18,undefined]') ;     // 错误```JSON.stringify(): 用于将 JavaScript 值转换为 JSON 字符串。　```JSON.stringify({"name":"alex"})```JSON 格式于2001年由 Douglas Crockford 提出，目的就是取代繁琐笨重的 XML 格式。JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON迅速被接受，已经成为各大网站交换数据的标准格式，并被写入ECMAScript 5，成为标准的一部分。XML和JSON都使用结构化方法来标记数据，下面来做一个简单的比较。用XML表示中国部分省市数据如下：![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif) XML格式数据用JSON表示如下：![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif) JSON格式数据由上面的两端代码可以看出，JSON 简单的语法格式和清晰的层次结构明显要比 XML 容易阅读，并且在数据交换方面，由于 JSON 所使用的字符要比 XML 少得多，可以大大得节约传输数据所占用得带宽。 [回到顶部](https://www.cnblogs.com/maple-shaw/articles/9524153.html#_labelTop)[回到顶部](#_labelTop)## AJAX简介AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML）。AJAX 不是新的编程语言，而是一种使用现有标准的新方法。AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。（这一特点给用户的感受是在不知不觉中完成请求和响应过程）AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。- 同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求；- 异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。#### **示例****页面输入两个整数，通过AJAX传输到后端计算出结果并返回。**![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif) HTML部分代码![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif) views.py![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif) urls.py搜索引擎根据用户输入的关键字，自动提示检索关键字。还有一个很重要的应用场景就是注册时候的用户名的查重。其实这里就使用了AJAX技术！当文件框发生了输入变化时，使用AJAX技术向服务器发送一个请求，然后服务器会把查询到的结果响应给浏览器，最后再把后端返回的结果展示出来。- 整个过程中页面没有刷新，只是刷新页面中的局部位置而已！- 当请求发出后，浏览器还可以进行其他操作，无需等待服务器的响应！​       ![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/877318-20161025165534625-1155566124.png)当输入用户名后，把光标移动到其他表单项上时，浏览器会使用AJAX技术向服务器发出请求，服务器会查询名为lemontree7777777的用户是否存在，最终服务器返回true表示名为lemontree7777777的用户已经存在了，浏览器在得到结果后显示“用户名已被注册！”。- 整个过程中页面没有刷新，只是局部刷新了；- 在请求发出后，浏览器不用等待服务器响应结果就可以进行其他操作；#### 优点：- AJAX使用JavaScript技术向服务器发送异步请求；- AJAX请求无须刷新整个页面；- 因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以AJAX性能高； [回到顶部](https://www.cnblogs.com/maple-shaw/articles/9524153.html#_labelTop)[回到顶部](#_labelTop)## jQuery实现的AJAX最基本的jQuery发送AJAX请求示例：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)```<span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zh-CN<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>x-ua-compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>ajax test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ajaxTest<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>AJAX 测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#ajaxTest"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      url<span class="token punctuation">:</span> <span class="token string">"/ajax_test/"</span><span class="token punctuation">,</span>      type<span class="token punctuation">:</span> <span class="token string">"POST"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span> <span class="token punctuation">{</span>username<span class="token punctuation">:</span> <span class="token string">"Q1mi"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token number">123456</span><span class="token punctuation">}</span><span class="token punctuation">,</span>      success<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)#### views.py：```def ajax_test(request):    user_name = request.POST.get("username")    password = request.POST.get("password")    print(user_name, password)    return HttpResponse("OK")```data参数中的键值对，如果值值不为字符串，需要将其转换成字符串类型。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)```  $("#b1").on("click", function () {    $.ajax({      url:"/ajax_add/",      type:"GET",      data:{"i1":$("#i1").val(),"i2":$("#i2").val(),"hehe": JSON.stringify([1, 2, 3])},      success:function (data) {        $("#i3").val(data);      }    })  })```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9524153.html#_labelTop)[回到顶部](#_labelTop)## JS实现AJAX[+ View Code](https://www.cnblogs.com/maple-shaw/articles/9524153.html#)[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9524153.html#_labelTop)[回到顶部](#_labelTop)## AJAX请求如何设置csrf_token通过获取隐藏的input标签中的csrfmiddlewaretoken值，放置在data中发送。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)```$.ajax({  url: "/cookie_ajax/",  type: "POST",  data: {    "username": "Q1mi",    "password": 123456,    "csrfmiddlewaretoken": $("[name = 'csrfmiddlewaretoken']").val()  // 使用jQuery取出csrfmiddlewaretoken的值，拼接到data中  },  success: function (data) {    console.log(data);  }})```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)通过获取返回的cookie中的字符串 放置在请求头中发送。注意：需要引入一个jquery.cookie.js插件。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)```$.ajax({  url: "/cookie_ajax/",  type: "POST",  headers: {"X-CSRFToken": $.cookie('csrftoken')},  // 从Cookie取csrftoken，并设置到请求头中  data: {"username": "Q1mi", "password": 123456},  success: function (data) {    console.log(data);  }})```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)或者用自己写一个getCookie方法：[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)```function getCookie(name) {    var cookieValue = null;    if (document.cookie &amp;&amp; document.cookie !== '') {        var cookies = document.cookie.split(';');        for (var i = 0; i &lt; cookies.length; i++) {            var cookie = jQuery.trim(cookies[i]);            // Does this cookie string begin with the name we want?            if (cookie.substring(0, name.length + 1) === (name + '=')) {                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));                break;            }        }    }    return cookieValue;}var csrftoken = getCookie('csrftoken');```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)每一次都这么写太麻烦了，可以使用$.ajaxSetup()方法为ajax请求统一设置。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)```function csrfSafeMethod(method) {  // these HTTP methods do not require CSRF protection  return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));}$.ajaxSetup({  beforeSend: function (xhr, settings) {    if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) {      xhr.setRequestHeader("X-CSRFToken", csrftoken);    }  }});```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)注意：如果使用从cookie中取csrftoken的方式，需要确保cookie存在csrftoken值。如果你的视图渲染的HTML文件中没有包含 {% csrf_token %}，Django可能不会设置CSRFtoken的cookie。这个时候需要使用ensure_csrf_cookie()装饰器强制设置Cookie。```django.views.decorators.csrf import ensure_csrf_cookie@ensure_csrf_cookiedef login(request):    pass```更多细节详见：[Djagno官方文档中关于CSRF的内容](https://docs.djangoproject.com/en/1.11/ref/csrf/)[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9524153.html#_labelTop)[回到顶部](#_labelTop)## AJAX上传文件[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)```// 上传文件示例$("#b3").click(function () {  var formData = new FormData();  formData.append("csrfmiddlewaretoken", $("[name='csrfmiddlewaretoken']").val());  formData.append("f1", $("#f1")[0].files[0]);  $.ajax({    url: "/upload/",    type: "POST",    processData: false,  // 告诉jQuery不要去处理发送的数据    contentType: false,  // 告诉jQuery不要去设置Content-Type请求头    data: formData,    success:function (data) {      console.log(data)    }  })})```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9524153.html#_labelTop)[回到顶部](#_labelTop)## 练习（用户名是否已被注册）在注册表单中，当用户填写了用户名后，把光标移开后，会自动向服务器发送异步请求。服务器返回这个用户名是否已经被注册过。- 页面中给出注册表单；- 在username input标签中绑定onblur事件处理函数。- 当input标签失去焦点后获取 username表单字段的值，向服务端发送AJAX请求；- django的视图函数中处理该请求，获取username值，判断该用户在数据库中是否被注册，如果被注册了就返回“该用户已被注册”，否则响应“该用户名可以注册”。[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9524153.html#_labelTop)[回到顶部](#_labelTop)## 序列化```def books_json(request):    book_list = models.Book.objects.all()[0:10]    from django.core import serializers    ret = serializers.serialize("json", book_list)    return HttpResponse(ret)```[回到顶部](https://www.cnblogs.com/maple-shaw/articles/9524153.html#_labelTop)[回到顶部](#_labelTop)## SweetAlert插件![img](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/867021-20180407235320541-386911677.gif)点击下载[Bootstrap-sweetalert项目](https://github.com/lipis/bootstrap-sweetalert)。[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)```$(".btn-danger").on("click", function () {  swal({    title: "你确定要删除吗？",    text: "删除可就找不回来了哦！",    type: "warning",    showCancelButton: true,    confirmButtonClass: "btn-danger",    confirmButtonText: "删除",    cancelButtonText: "取消",    closeOnConfirm: false    },    function () {      var deleteId = $(this).parent().parent().attr("data_id");      $.ajax({        url: "/delete_book/",        type: "post",        data: {"id": deleteId},        success: function (data) {          if (data.status === 1) {            swal("删除成功!", "你可以准备跑路了！", "success");          } else {            swal("删除失败", "你可以再尝试一下！", "error")          }        }      })    });})```[![复制代码](https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif)](javascript:void(0);)[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08 Django form表单</title>
      <link href="2019/11/15/CRM/08%20Django%20form%E8%A1%A8%E5%8D%95/"/>
      <url>2019/11/15/CRM/08%20Django%20form%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#_label0">目录</a></li><li>普通方式手写注册功能<ul><li><a href="#_label1_0">views.py</a></li><li><a href="#_label1_1">login.html</a></li></ul></li><li>使用form组件实现注册功能<ul><li><a href="#_label2_0">views.py</a></li><li><a href="#_label2_1">login2.html</a></li></ul></li><li>常用字段与插件<ul><li><a href="#_label3_0">initial</a></li><li><a href="#_label3_1">error_messages</a></li><li><a href="#_label3_2">password</a></li><li><a href="#_label3_3">radioSelect</a></li><li><a href="#_label3_4">单选Select</a></li><li><a href="#_label3_5">多选Select</a></li><li><a href="#_label3_6">单选checkbox</a></li><li><a href="#_label3_7">多选checkbox</a></li></ul></li><li><a href="#_label4">Django Form所有内置字段</a></li><li><a href="#_label5">校验</a></li><li>补充进阶<ul><li><a href="#_label6_0">应用Bootstrap样式</a></li><li><a href="#_label6_1">批量添加样式</a></li></ul></li></ul><p><a href="#_labelTop">回到顶部</a></p><h2 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h2><h1 id="Form介绍"><a href="#Form介绍" class="headerlink" title="Form介绍"></a>Form介绍</h1><p>我们之前在HTML页面中利用form表单向后端提交数据时，都会写一些获取用户输入的标签并且用form标签把它们包起来。</p><p>与此同时我们在好多场景下都需要对用户的输入做校验，比如校验用户是否输入，输入的长度和格式等正不正确。如果用户输入的内容有错误就需要在页面上相应的位置显示对应的错误信息.。</p><p>Django form组件就实现了上面所述的功能。</p><p>总结一下，其实form组件的主要功能如下:</p><ul><li>生成页面可用的HTML标签</li><li>对用户提交的数据进行校验</li><li>保留上次输入内容</li></ul><p><a href="https://www.cnblogs.com/maple-shaw/articles/9537309.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="普通方式手写注册功能"><a href="#普通方式手写注册功能" class="headerlink" title="普通方式手写注册功能"></a>普通方式手写注册功能</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code># 注册def register(request):    error_msg = ""    if request.method == "POST":        username = request.POST.get("name")        pwd = request.POST.get("pwd")        # 对注册信息做校验        if len(username) &lt; 6:            # 用户长度小于6位            error_msg = "用户名长度不能小于6位"        else:            # 将用户名和密码存到数据库            return HttpResponse("注册成功")    return render(request, "register.html", {"error_msg": error_msg})</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/reg/" method="post"&gt;    {% csrf_token %}    &lt;p&gt;        用户名:        &lt;input type="text" name="name"&gt;    &lt;/p&gt;    &lt;p&gt;        密码：        &lt;input type="password" name="pwd"&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type="submit" value="注册"&gt;        &lt;p style="color: red"&gt;{{ error_msg }}&lt;/p&gt;    &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9537309.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="使用form组件实现注册功能"><a href="#使用form组件实现注册功能" class="headerlink" title="使用form组件实现注册功能"></a>使用form组件实现注册功能</h2><p>先定义好一个RegForm类：</p><pre><code>from django import forms# 按照Django form组件的要求自己写一个类class RegForm(forms.Form):    name = forms.CharField(label="用户名")    pwd = forms.CharField(label="密码")</code></pre><p>再写一个视图函数：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code># 使用form组件实现注册方式def register2(request):    form_obj = RegForm()    if request.method == "POST":        # 实例化form对象的时候，把post提交过来的数据直接传进去        form_obj = RegForm(request.POST)        # 调用form_obj校验数据的方法        if form_obj.is_valid():            return HttpResponse("注册成功")    return render(request, "register2.html", {"form_obj": form_obj})</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;注册2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action="/reg2/" method="post" novalidate autocomplete="off"&gt;        {% csrf_token %}        &lt;div&gt;            &lt;label for="{{ form_obj.name.id_for_label }}"&gt;{{ form_obj.name.label }}&lt;/label&gt;            {{ form_obj.name }} {{ form_obj.name.errors.0 }}        &lt;/div&gt;        &lt;div&gt;            &lt;label for="{{ form_obj.pwd.id_for_label }}"&gt;{{ form_obj.pwd.label }}&lt;/label&gt;            {{ form_obj.pwd }} {{ form_obj.pwd.errors.0 }}        &lt;/div&gt;        &lt;div&gt;            &lt;input type="submit" class="btn btn-success" value="注册"&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>看网页效果发现 也验证了form的功能：<br>•    前端页面是form类的对象生成的                                      –&gt;生成HTML标签功能<br>•    当用户名和密码输入为空或输错之后 页面都会提示        –&gt;用户提交校验功能<br>•    当用户输错之后 再次输入 上次的内容还保留在input框   –&gt;保留上次输入内容</p><h1 id="Form那些事儿"><a href="#Form那些事儿" class="headerlink" title="Form那些事儿"></a>Form那些事儿</h1><p><a href="https://www.cnblogs.com/maple-shaw/articles/9537309.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="常用字段与插件"><a href="#常用字段与插件" class="headerlink" title="常用字段与插件"></a>常用字段与插件</h2><p>创建Form类时，主要涉及到 【字段】 和 【插件】，字段用于对用户请求数据的验证，插件用于自动生成HTML;</p><p>初始值，input框里面的初始值。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class LoginForm(forms.Form):    username = forms.CharField(        min_length=8,        label="用户名",        initial="张三"  # 设置默认值    )    pwd = forms.CharField(min_length=6, label="密码")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>重写错误信息。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class LoginForm(forms.Form):    username = forms.CharField(        min_length=8,        label="用户名",        initial="张三",        error_messages={            "required": "不能为空",            "invalid": "格式错误",            "min_length": "用户名最短8位"        }    )    pwd = forms.CharField(min_length=6, label="密码")</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class LoginForm(forms.Form):    ...    pwd = forms.CharField(        min_length=6,        label="密码",        widget=forms.widgets.PasswordInput(attrs={'class': 'c1'}, render_value=True)    )</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>单radio值为字符串</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class LoginForm(forms.Form):    username = forms.CharField(        min_length=8,        label="用户名",        initial="张三",        error_messages={            "required": "不能为空",            "invalid": "格式错误",            "min_length": "用户名最短8位"        }    )    pwd = forms.CharField(min_length=6, label="密码")    gender = forms.fields.ChoiceField(        choices=((1, "男"), (2, "女"), (3, "保密")),        label="性别",        initial=3,        widget=forms.widgets.RadioSelect()    )</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class LoginForm(forms.Form):    ...    hobby = forms.fields.ChoiceField(        choices=((1, "篮球"), (2, "足球"), (3, "双色球"), ),        label="爱好",        initial=3,        widget=forms.widgets.Select()    )</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class LoginForm(forms.Form):    ...    hobby = forms.fields.MultipleChoiceField(        choices=((1, "篮球"), (2, "足球"), (3, "双色球"), ),        label="爱好",        initial=[1, 3],        widget=forms.widgets.SelectMultiple()    )</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class LoginForm(forms.Form):    ...    keep = forms.fields.ChoiceField(        label="是否记住密码",        initial="checked",        widget=forms.widgets.CheckboxInput()    )</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class LoginForm(forms.Form):    ...    hobby = forms.fields.MultipleChoiceField(        choices=((1, "篮球"), (2, "足球"), (3, "双色球"),),        label="爱好",        initial=[1, 3],        widget=forms.widgets.CheckboxSelectMultiple()    )</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>关于choice的注意事项：</p><p>在使用选择标签时，需要注意choices的选项可以从数据库中获取，但是由于是静态字段 <strong><em>获取的值无法实时更新</em></strong>，那么需要自定义构造方法从而达到此目的。</p><p>方式一：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsclass MyForm(Form):    user = fields.ChoiceField(        # choices=((1, '上海'), (2, '北京'),),        initial=2,        widget=widgets.Select    )    def __init__(self, *args, **kwargs):        super(MyForm,self).__init__(*args, **kwargs)        # self.fields['user'].choices = ((1, '上海'), (2, '北京'),)        # 或        self.fields['user'].choices = models.Classes.objects.all().values_list('id','caption')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>方式二：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django import formsfrom django.forms import fieldsfrom django.forms import models as form_modelclass FInfo(forms.Form):    authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())  # 多选    # authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all())  # 单选</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9537309.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="Django-Form所有内置字段"><a href="#Django-Form所有内置字段" class="headerlink" title="Django Form所有内置字段"></a>Django Form所有内置字段</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> Django Form内置字段</p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9537309.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>方式一：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>from django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsfrom django.core.validators import RegexValidatorclass MyForm(Form):    user = fields.CharField(        validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')],    )</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>方式二：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>import refrom django.forms import Formfrom django.forms import widgetsfrom django.forms import fieldsfrom django.core.exceptions import ValidationError# 自定义验证规则def mobile_validate(value):    mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$')    if not mobile_re.match(value):        raise ValidationError('手机号码格式错误')class PublishForm(Form):    title = fields.CharField(max_length=20,                            min_length=5,                            error_messages={'required': '标题不能为空',                                            'min_length': '标题最少为5个字符',                                            'max_length': '标题最多为20个字符'},                            widget=widgets.TextInput(attrs={'class': "form-control",                                                          'placeholder': '标题5-20个字符'}))    # 使用自定义验证规则    phone = fields.CharField(validators=[mobile_validate, ],                            error_messages={'required': '手机不能为空'},                            widget=widgets.TextInput(attrs={'class': "form-control",                                                          'placeholder': u'手机号码'}))    email = fields.EmailField(required=False,                            error_messages={'required': u'邮箱不能为空','invalid': u'邮箱格式错误'},                            widget=widgets.TextInput(attrs={'class': "form-control", 'placeholder': u'邮箱'}))</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="https://www.cnblogs.com/maple-shaw/articles/9537309.html#_labelTop">回到顶部</a></p><p><a href="#_labelTop">回到顶部</a></p><h2 id="补充进阶"><a href="#补充进阶" class="headerlink" title="补充进阶"></a>补充进阶</h2><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> Django form应用Bootstrap样式简单示例</p><p>可通过重写form类的init方法来实现。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/ContractedBlock.gif" alt="img"> 批量添加样式</p><h1 id="ModelForm"><a href="#ModelForm" class="headerlink" title="ModelForm"></a>ModelForm</h1><p>form与model的终极结合。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>class BookForm(forms.ModelForm):    class Meta:        model = models.Book        fields = "__all__"        labels = {            "title": "书名",            "price": "价格"        }        widgets = {            "password": forms.widgets.PasswordInput(attrs={"class": "c1"}),        }</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> class Meta:下常用参数：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><pre><code>model = models.Student  # 对应的Model中的类fields = "__all__"  # 字段，如果是__all__,就是表示列出所有的字段exclude = None  # 排除的字段labels = None  # 提示信息help_texts = None  # 帮助提示信息widgets = None  # 自定义插件error_messages = None  # 自定义错误信息</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/crm/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之锁、事务、优化、OLAP、OLTP</title>
      <link href="2019/11/15/Django/MySQL%E4%B9%8B%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E4%BC%98%E5%8C%96%E3%80%81OLAP%E3%80%81OLTP%20/"/>
      <url>2019/11/15/Django/MySQL%E4%B9%8B%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E4%BC%98%E5%8C%96%E3%80%81OLAP%E3%80%81OLTP%20/</url>
      
        <content type="html"><![CDATA[<p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10463743.html#part_1">一 锁的分类及特性</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10463743.html#part_2">二 表级锁定(MyISAM举例)</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10463743.html#part_3">三 行级锁定</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10463743.html#part_4">四 查看死锁、解除锁</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10463743.html#part_5">五 事务</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10463743.html#part_6">六 慢日志、执行计划、sql优化</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10463743.html#part_7">七 OLTP与OLAP的介绍和对比</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10463743.html#part_8">八 关于autocommit的测试</a></li><li></li></ul><h3 id="一-锁的分类及特性"><a href="#一-锁的分类及特性" class="headerlink" title="一 锁的分类及特性"></a>一 锁的分类及特性</h3><p>　　数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。对于任何一种数据库来说都需要有相应的锁定机制，所以MySQL自然也不能例外。MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。MySQL各存储引擎使用了三种类型（级别）的锁定机制：表级锁定，行级锁定和页级锁定。<br>　　<strong>1.表级锁定（table-level）</strong></p><p>　　　　表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。<br>　　　　当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。<br>　　　　使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。　　</p><h4 id="2-行级锁定（row-level）"><a href="#2-行级锁定（row-level）" class="headerlink" title="　　2.行级锁定（row-level）　　　　"></a>　　2.行级锁定（row-level）　　　　</h4><p>　　　　行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>　　　　虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。<br>　　　　使用行级锁定的主要是InnoDB存储引擎。　　</p><h4 id="3-页级锁定（page-level）"><a href="#3-页级锁定（page-level）" class="headerlink" title="　　3.页级锁定（page-level）　　　　"></a>　　3.页级锁定（page-level）　　　　</h4><p>　　　　页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。<br>　　　　在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。<br>　　　　使用页级锁定的主要是BerkeleyDB存储引擎。<br>　　　　总的来说，MySQL这3种锁的特性可大致归纳如下：<br>　　　　　　表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；<br>　　　　　　行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；<br>　　　　　　页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<br>　　　　适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。　　</p><h3 id="二-表级锁定-MyISAM举例"><a href="#二-表级锁定-MyISAM举例" class="headerlink" title="二 表级锁定(MyISAM举例)"></a>二 表级锁定(MyISAM举例)</h3><p>　　</p><p>　　由于MyISAM存储引擎使用的锁定机制完全是由MySQL提供的表级锁定实现，所以下面我们将以MyISAM存储引擎作为示例存储引擎。<br>　　<strong>1.MySQL表级锁的锁模式</strong><br>　　　　MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。锁模式的兼容性：<br>　　　　对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；<br>　　　　对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；<br>　　　　MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p><p>　　　　总结：<strong>表锁，读锁会阻塞写，不会阻塞读。而写锁则会把读写都阻塞</strong>。<br>　　<strong>2.如何加表锁</strong><br>　　　　MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p><p>　　　　显示加锁：<br>　　　　　　共享读锁：lock table tableName read;<br>　　　　　　独占写锁：lock table tableName write;</p><p>​                      同时加多锁：lock table t1 write,t2 read;<br>　　　　　　批量解锁：unlock tables;<br>　　<strong>3.MyISAM表锁优化建议</strong><br>　　　　对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。<br>　　　　（1）查询表级锁争用情况<br>　　　　　　MySQL内部有两组专门的状态变量记录系统内部锁资源争用情况：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; show status like 'table%';+----------------------------+---------+| Variable_name              | Value   |+----------------------------+---------+| Table_locks_immediate      | 100     || Table_locks_waited         | 11      |+----------------------------+---------+</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p><p>　　　　　　Table_locks_immediate：产生表级锁定的次数；<br>　　　　　　Table_locks_waited：出现表级锁定争用而发生等待的次数；此值越高则说明存在着越严重的表级锁争用情况。此外，MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的存储引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永久阻塞。</p><p>　　　　　　两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了。<br>　　　　（2）缩短锁定时间<br>　　　　　　如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。<br>　　　　　　a)尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；<br>　　　　　　b)尽可能的建立足够高效的索引，让数据检索更迅速；<br>　　　　　　c)尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；<br>　　　　　　d)利用合适的机会优化MyISAM表数据文件。<br>　　　　（3）分离能并行的操作<br>　　说到MyISAM的表锁，而且是读写互相阻塞的表锁，可能有些人会认为在MyISAM存储引擎的表上就只能是完全的串行化，没办法再并行了。大家不要忘记了，MyISAM的存储引擎还有一个非常有用的特性，那就是ConcurrentInsert（并发插入）的特性。<br>　　MyISAM存储引擎有一个控制是否打开Concurrent Insert功能的参数选项：concurrent_insert，可以设置为0，1或者2。三个值的具体说明如下：<br>　　　　concurrent_insert=2，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录；<br>　　　　concurrent_insert=1，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置；<br>　　　　concurrent_insert=0，不允许并发插入。<br>　　可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入的锁争用。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。<br>　　　　（4）合理利用读写优先级<br>　　　　　　MyISAM存储引擎的是读写互相阻塞的，那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？<br>　　　　　　答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前。<br>　　　　　　这是因为MySQL的表级锁定对于读和写是有不同优先级设定的，默认情况下是写优先级要大于读优先级。<br>　　　　　　所以，如果我们可以根据各自系统环境的差异决定读与写的优先级：<br>　　　　　　通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接读比写的优先级高。如果我们的系统是一个以读为主，可以设置此参数，如果以写为主，则不用设置；<br>　　　　　　通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。<br>　　　　　　虽然上面方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。<br>　　　　　　另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。<br>　　　　　　这里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”，因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语句来解决问题，因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。</p><p> 　　　　</p><p>　　　　InnoDB默认采用行锁，在未使用索引字段查询时升级为表锁。MySQL这样设计并不是给你挖坑。它有自己的设计目的。<br>　　　　即便你在条件中使用了索引字段，MySQL会根据自身的执行计划，考虑是否使用索引(所以explain命令中会有possible_key 和 key)。如果MySQL认为全表扫描效率更高，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。<strong>关于执行计划</strong></p><p>　　　　第一种情况：<strong>全表更新</strong>。事务需要更新大部分或全部数据，且表又比较大。若使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突。</p><p>　　　　第二种情况：<strong>多表级联</strong>。事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚。这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。</p><h3 id="三-行级锁定"><a href="#三-行级锁定" class="headerlink" title="三 行级锁定"></a>三 行级锁定</h3><p>　　行级锁定不是MySQL自己实现的锁定方式，而是由其他存储引擎自己所实现的，如广为大家所知的InnoDB存储引擎，以及MySQL的分布式存储引擎NDBCluster等都是实现了行级锁定。考虑到行级锁定君由各个存储引擎自行实现，而且具体实现也各有差别，而InnoDB是目前事务型存储引擎中使用最为广泛的存储引擎，所以这里我们就主要分析一下InnoDB的锁定特性。<br>　　<strong>1.InnoDB锁定模式及实现机制</strong><br>　　　　考虑到行级锁定君由各个存储引擎自行实现，而且具体实现也各有差别，而InnoDB是目前事务型存储引擎中使用最为广泛的存储引擎，所以这里我们就主要分析一下InnoDB的锁定特性。<br>　　　　总的来说，InnoDB的锁定机制和Oracle数据库有不少相似之处。InnoDB的行级锁定同样分为两种类型，共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存，InnoDB也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。<br>　　　　当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。所以，可以说InnoDB的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX），我们可以通过以下表格来总结上面这四种所的共存逻辑关系：<br>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1033231-20170118181153984-1417117507.png" alt="img"></p><p>　　　　如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。<br>　　　　意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><pre><code>共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE</code></pre><p>　　　　用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。<br>　　　　但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。<br>　　<strong>2.InnoDB行锁实现方式</strong><br>　　　　InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁<br>　　　　在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。<br>　　　　（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。<br>　　　　（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。<br>　　　　（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。<br>　　　　（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。<br>　　<strong>3.间隙锁（Next-Key锁）</strong><br>　　　　当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；<br>　　　　对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。<br>　　　　例：<br>　　　　假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p><pre><code>mysql&gt; select * from emp where empid &gt; 100 for update;</code></pre><p>　　　　是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。<br>　　　　InnoDB使用间隙锁的目的：<br>　　　　（1）防止幻读，以满足相关隔离级别的要求（关于事务的隔离级别）。对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；<br>　　　　（2）为了满足其恢复和复制的需要。<br>　　　　很显然，在使用范围条件检索并锁定记录时，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。<br>除了间隙锁给InnoDB带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：<br>　　　　（1）当Query无法利用索引的时候，InnoDB会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；<br>　　　　（2）当Query使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所只想的数据可能有部分并不属于该Query的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；<br>　　　　（3）当Query在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同的时候（索引只是过滤条件的一部分），一样会被锁定。<br>　　　　因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。<br>　　　　还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁。<br>　　<strong>4.死锁</strong><br>　　　　上文讲过，MyISAM表锁是deadlock free的，这是因为MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。<br>　　　　在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当InnoDB检测到系统中产生了死锁之后，InnoDB会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚，而让另外一个较大的事务成功完成。<br>　　　　那InnoDB是以什么来为标准判定事务的大小的呢？MySQL官方手册中也提到了这个问题，实际上在InnoDB发现死锁之后，会计算出两个事务各自插入、更新或者删除的数据量来判定两个事务的大小。也就是说哪个事务所改变的记录条数越多，在死锁中就越不会被回滚掉。<br>　　　　但是有一点需要注意的就是，当产生死锁的场景中涉及到不止InnoDB存储引擎的时候，InnoDB是没办法检测到该死锁的，这时候就只能通过锁定超时限制参数InnoDB_lock_wait_timeout来解决。<br>　　　　需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。<br>　　　　通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的SQL语句，绝大部分死锁都可以避免。下面就通过实例来介绍几种避免死锁的常用方法：<br>　　　　　　（1）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。<br>　　　　　　（2）在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。<br>　　　　　　（3）在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。<br>　　　　　　（4）在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…FOR UPDATE加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。<br>　　　　　　（5）当隔离级别为READ COMMITTED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁。这时如果有第3个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。<br>　　<strong>5.什么时候使用表锁</strong><br>　　　　对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁：<br>　　　　（1）事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。<br>　　　　（2）事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。<br>当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。<br>　　　　在InnoDB下，使用表锁要注意以下两点。<br>　　　　（1）使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0（不自动提交，默认是自动提交的）、InnoDB_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁，否则，InnoDB将无法自动检测并处理这种死锁。<br>　　　　（2）在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。正确的方式见如下语句：<br>　　　　例如，如果需要写表t1并从表t读，可以按如下做：</p><pre><code>SET AUTOCOMMIT=0;LOCK TABLES t1 WRITE, t2 READ, ...;[do something with tables t1 and t2 here];COMMIT;UNLOCK TABLES;</code></pre><p>　　<strong>6.InnoDB行锁优化建议</strong><br>　　　　InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。但是，InnoDB的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。<br>　　　　（1）要想合理利用InnoDB的行级锁定，做到扬长避短，我们必须做好以下工作：<br>　　　　　　a)尽可能让所有的数据检索都通过索引来完成，从而避免InnoDB因为无法通过索引键加锁而升级为表级锁定；<br>　　　　　　b)合理设计索引，让InnoDB在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行；<br>　　　　　　c)尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录；<br>　　　　　　d)尽量控制事务的大小，减少锁定的资源量和锁定时间长度；<br>　　　　　　e)在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本。<br>　　　　（2）由于InnoDB的行级锁定和事务性，所以肯定会产生死锁，下面是一些比较常用的减少死锁产生概率的小建议：<br>　　　　　　a)类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；<br>　　　　　　b)在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；<br>　　　　　　c)对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。<br>　　　　（3）可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; show status like 'InnoDB_row_lock%';+-------------------------------+-------+| Variable_name                 | Value |+-------------------------------+-------+| InnoDB_row_lock_current_waits | 0     || InnoDB_row_lock_time          | 0     || InnoDB_row_lock_time_avg      | 0     || InnoDB_row_lock_time_max      | 0     || InnoDB_row_lock_waits         | 0     |+-------------------------------+-------+</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　InnoDB 的行级锁定状态变量不仅记录了锁定等待次数，还记录了锁定总时长，每次平均时长，以及最大时长，此外还有一个非累积状态量显示了当前正在等待锁定的等待数量。对各个状态量的说明如下：</p><p>　　InnoDB_row_lock_current_waits：当前正在等待锁定的数量；<br>　　InnoDB_row_lock_time：从系统启动到现在锁定总时间长度；<br>　　InnoDB_row_lock_time_avg：每次等待所花平均时间；<br>　　InnoDB_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；<br>　　InnoDB_row_lock_waits：系统启动后到现在总共等待的次数；<br>　　对于这5个状态变量，比较重要的主要是InnoDB_row_lock_time_avg（等待平均时长），InnoDB_row_lock_waits（等待总次数）以及InnoDB_row_lock_time（等待总时长）这三项。尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。<br>　　如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors 来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。<br>　　锁冲突的表、数据行等，并分析锁争用的原因。具体方法如下：</p><pre><code>mysql&gt; create table InnoDB_monitor(a INT) engine=InnoDB;</code></pre><p>　　然后就可以用下面的语句来进行查看：</p><pre><code>mysql&gt; show engine InnoDB status;</code></pre><p>　　监视器可以通过发出下列语句来停止查看：</p><pre><code>mysql&gt; drop table InnoDB_monitor;</code></pre><p>　　设置监视器后，会有详细的当前锁等待的信息，包括表名、锁类型、锁定记录的情况等，便于进行进一步的分析和问题的确定。可能会有读者朋友问为什么要先创建一个叫InnoDB_monitor的表呢？因为创建该表实际上就是告诉InnoDB我们开始要监控他的细节状态了，然后InnoDB就会将比较详细的事务以及锁定信息记录进入MySQL的errorlog中，以便我们后面做进一步分析使用。打开监视器以后，默认情况下每15秒会向日志中记录监控的内容，如果长时间打开会导致.err文件变得非常的巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器，或者通过使用“–console”选项来启动服务器以关闭写日志文件。</p><h3 id="四-查看死锁、解除锁"><a href="#四-查看死锁、解除锁" class="headerlink" title="四 查看死锁、解除锁"></a>四 查看死锁、解除锁</h3><p>　　结合上面对表锁和行锁的分析情况，解除正在死锁的状态有两种方法：</p><p>　　　　<strong>第一种：</strong></p><p>　　　　　　1.查询是否锁表</p><p>　　　　　　　　show OPEN TABLES where In_use &gt; 0;</p><p>　　　　　　2.查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）</p><p>　　　　　　　　show processlist</p><p>　　　　　　3.杀死进程id（就是上面命令的id列）</p><p>　　　　　　　　kill id</p><p>　　　　<strong>第二种：</strong></p><p>　　　　　　1.查看下在锁的事务 </p><p>　　　　　　　　SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</p><p>　　　　　　2.杀死进程id（就是上面命令的trx_mysql_thread_id列）</p><p>　　　　　　　　kill 线程ID</p><p>　　例子：</p><p>　　　　查出死锁进程：SHOW PROCESSLIST<br>　　　　杀掉进程          KILL 420821;</p><p>　　其它关于查看死锁的命令：</p><p>　　　　1：查看当前的事务<br>　　　　　　SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</p><p>　　　　2：查看当前锁定的事务</p><p>　　　　　　SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</p><p>　　3：查看当前等锁的事务<br>　　　　　　SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</p><h3 id="五-事务"><a href="#五-事务" class="headerlink" title="五 事务"></a>五 事务</h3><h4 id="1-MySQL-事务属性"><a href="#1-MySQL-事务属性" class="headerlink" title="　　1.MySQL 事务属性"></a>　　1.MySQL 事务属性</h4><p>　　　　事务是由一组SQL语句组成的逻辑处理单元，事务具有ACID属性。<br>　　　　<strong>原子性</strong>（Atomicity）：事务是一个原子操作单元。在当时原子是不可分割的最小元素，其对数据的修改，要么全部成功，要么全部都不成功。<br>　　　　<strong>一致性</strong>（Consistent）：事务开始到结束的时间段内，数据都必须保持一致状态。<br>　　　　<strong>隔离性</strong>（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的”独立”环境执行。<br>　　　　<strong>持久性</strong>（Durable）：事务完成后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</p><h4 id="2-事务常见问题"><a href="#2-事务常见问题" class="headerlink" title="　　2.事务常见问题"></a>　　2.事务常见问题</h4><p>　　　　<strong>更新丢失</strong>（Lost Update）<br>　　　　　　原因：当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比github提交冲突。</p><p>　　　　<strong>脏读</strong>（Dirty Reads）<br>　　　　　　原因：事务A读取了事务B已经修改但尚未提交的数据。若事务B回滚数据，事务A的数据存在不一致性的问题。</p><p>　　　　<strong>不可重复读</strong>（Non-Repeatable Reads）<br>　　　　　　原因：事务A第一次读取最初数据，第二次读取事务B已经提交的修改或删除数据。导致两次读取数据不一致。不符合事务的隔离性。</p><p>　　　　<strong>幻读</strong>（Phantom Reads）<br>　　　　　　原因：事务A根据相同条件第二次查询到事务B提交的新增数据，两次数据结果集不一致。不符合事务的隔离性。</p><p>　　　　幻读和脏读有点类似<br>　　　　脏读是事务B里面修改了数据，<br>　　　　幻读是事务B里面新增了数据。</p><h4 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="　　3.事务的隔离级别"></a>　　3.事务的隔离级别</h4><p>　　　　数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大。这是因为事务隔离实质上是将事务在一定程度上”串行”进行，这显然与”并发”是矛盾的。根据自己的业务逻辑，权衡能接受的最大副作用。从而平衡了”隔离” 和 “并发”的问题。MySQL默认隔离级别是可重复读。<br>　　　　脏读，不可重复读，幻读，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>+------------------------------+---------------------+--------------+--------------+--------------+| 隔离级别                      | 读数据一致性         | 脏读         | 不可重复 读   | 幻读         |+------------------------------+---------------------+--------------+--------------+--------------+| 未提交读(Read uncommitted)    | 最低级别            | 是            | 是           | 是           | +------------------------------+---------------------+--------------+--------------+--------------+| 已提交读(Read committed)      | 语句级              | 否           | 是           | 是           |+------------------------------+---------------------+--------------+--------------+--------------+| 可重复读(Repeatable read)     | 事务级              | 否           | 否           | 是           |+------------------------------+---------------------+--------------+--------------+--------------+| 可序列化(Serializable)        | 最高级别，事务级     | 否           | 否           | 否           |+------------------------------+---------------------+--------------+--------------+--------------+</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　查看当前数据库的事务隔离级别：show variables like ‘tx_isolation’;</p><pre><code>mysql&gt; show variables like 'tx_isolation';+---------------+-----------------+| Variable_name | Value           |+---------------+-----------------+| tx_isolation  | REPEATABLE-READ |+---------------+-----------------+</code></pre><h4 id="4-事务级别的设置"><a href="#4-事务级别的设置" class="headerlink" title="　　4.事务级别的设置"></a>　　4.事务级别的设置</h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>1.未提交读（READ UNCOMMITED） 解决的障碍：无； 引入的问题：脏读    set SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;2.已提交读 （READ COMMITED） 解决的障碍：脏读； 引入的问题：不可重复读    set SESSION TRANSACTION ISOLATION LEVEL read committed;3.可重复读（REPEATABLE READ）解决的障碍：不可重复读； 引入的问题：    set SESSION TRANSACTION ISOLATION LEVEL repeatable read;4.可串行化（SERIALIZABLE）解决的障碍：可重复读； 引入的问题：锁全表，性能低下    set SESSION TRANSACTION ISOLATION LEVEL repeatable read;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>总结：</strong></p><p>　　　　<strong>事务隔离级别为可重复读时，如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间、行锁、页锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表</strong></p><p>　　　　<strong>事务隔离级别为串行化时，读写数据都会锁住整张表</strong></p><p>　　　　<strong>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，对于多数应用程序，可以**</strong>优先考虑把数据库系统的隔离级别设为Read Committed**<strong>，它能够避免脏读取，而且具有较好的并发性能。</strong></p><h4 id="5-事务保存点，实现部分回滚"><a href="#5-事务保存点，实现部分回滚" class="headerlink" title="5.事务保存点，实现部分回滚"></a>5.事务保存点，实现部分回滚</h4><p>　　　　我们可以在<a href="http://uphtm.com/database/183.html">mysql事务处理</a>过程中定义保存点(SAVEPOINT)，然后回滚到指定的保存点前的状态。</p><p>　　　　定义保存点，以及回滚到指定保存点前状态的语法如下。</p><p>　　　　1.定义保存点—SAVEPOINT 保存点名;</p><p>　　　　2.回滚到指定保存点—ROLLBACK TO SAVEPOINT 保存点名:</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>1、查看user表中的数据mysql&gt; select * from user;+-----+----------+-----+------+| mid | name | scx | word |+-----+----------+-----+------+| 1 | zhangsan | 0 | NULL || 2 | wangwu    | 1 | NULL |+-----+----------+-----+------+2 rows in set (0.05 sec)2、mysql事务开始mysql&gt; BEGIN; -- 或者start transaction；Query OK, 0 rows affected (0.00 sec)3、向表user中插入2条数据mysql&gt; INSERT INTO user VALUES ('3','one','0','');Query OK, 1 row affected (0.08 sec)mysql&gt; INSERT INTO user VALUES ('4,'two','0','');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from user;+-----+----------+-----+------+| mid | name | scx | word |+-----+----------+-----+------+| 1 | zhangsan | 0 | NULL || 2 | wangwu    | 1 | NULL || 3 | one            | 0 | || 4 | two             | 0 | |+-----+----------+-----+------+4 rows in set (0.00 sec)4、指定保存点，保存点名为testmysql&gt; SAVEPOINT test;Query OK, 0 rows affected (0.00 sec)5、向表user中插入第3条数据mysql&gt; INSERT INTO user VALUES ('5','three','0','');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from user;+-----+----------+-----+------+| mid | name | scx | word |+-----+----------+-----+------+| 1 | zhangsan | 0 | NULL || 2 | wangwu | 1 | NULL || 3 | one | 0 | || 4 | two | 0 | || 5 | three | 0 | |+-----+----------+-----+------+5 rows in set (0.02 sec)6、回滚到保存点testmysql&gt; ROLLBACK TO SAVEPOINT test;Query OK, 0 rows affected (0.31 sec)mysql&gt; select * from user;+-----+----------+-----+------+| mid | name | scx | word |+-----+----------+-----+------+| 1 | zhangsan | 0 | NULL || 2 | wangwu    | 1 | NULL || 3 | one            | 0 | || 4 | two            | 0 | |+-----+----------+-----+------+4 rows in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　我们可以看到保存点test以后插入的记录没有显示了，即成功团滚到了定义保存点test前的状态。利用保存点可以实现只提交事务中部分处理的功能。</p><h4 id="6-事务控制语句"><a href="#6-事务控制语句" class="headerlink" title="　　6 事务控制语句"></a>　　6 事务控制语句</h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>BEGIN或START TRANSACTION；显式地开启一个事务；COMMIT；                  也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的；ROLLBACK；                有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；SAVEPOINT identifier；    SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；RELEASE SAVEPOINT identifier；    删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；ROLLBACK TO identifier；   把事务回滚到标记点；SET TRANSACTION；   用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。</code></pre><p>  用 BEGIN, ROLLBACK, COMMIT来实现<br>  BEGIN 开始一个事务<br>  ROLLBACK 事务回滚<br>  COMMIT 事务确认<br>  直接用 SET 来改变 MySQL 的自动提交模式:<br>  SET AUTOCOMMIT=0或者off 禁止自动提交<br>  SET AUTOCOMMIT=1或者on 开启自动提交</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="六-慢查询、执行计划、sql优化"><a href="#六-慢查询、执行计划、sql优化" class="headerlink" title="六 慢查询、执行计划、sql优化"></a>六 慢查询、执行计划、sql优化</h3><p>　　<strong>什么是慢查询</strong></p><p>　　　　慢查询日志，顾名思义，就是查询慢的日志，是指mysql记录所有执行超过long_query_time参数设定的时间阈值的SQL语句的日志。该日志能为SQL语句的优化带来很好的帮助。默认情况下，慢查询日志是关闭的，要使用慢查询日志功能，首先要开启慢查询日志功能。</p><h3 id="慢查询基本配置"><a href="#慢查询基本配置" class="headerlink" title="　　慢查询基本配置"></a>　　<strong>慢查询基本配置</strong></h3><p> 　　　　slow_query_log 启动停止技术慢查询日志</p><p> 　　　　slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起）</p><p> 　　　　long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒）</p><p> 　　　　log_queries_not_using_indexes  是否记录未使用索引的SQL</p><p> 　　　　log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】</p><p>　　　　配置了慢查询后，它会记录符合条件的SQL</p><p>　　　　包括：</p><p>　　　　　　查询语句</p><p>　　　　　　数据修改语句</p><p>　　　　　　已经回滚得SQL</p><p>　　<strong>实操：</strong></p><p>　　　　<strong>通过下面命令查看下上面的配置：</strong></p><p>　　　　　　show VARIABLES like ‘%slow_query_log%’</p><p>　　　　　　show VARIABLES like ‘%slow_query_log_file%’</p><p>　　　　　　show VARIABLES like ‘%long_query_time%’</p><p>　　　　　　show VARIABLES like ‘%log_queries_not_using_indexes%’</p><p>　　　　　　show VARIABLES like ‘log_output’</p><p>　　　　　　set global long_query_time=0;   —默认10秒，这里为了演示方便设置为0</p><p>　　　　　　set GLOBAL  slow_query_log = 1; –开启慢查询日志</p><p>　　　　　　set global log_output=’FILE,TABLE’  –项目开发中日志只能记录在日志文件中，不能记表中</p><p>　　　　　　设置完成后，查询一些列表可以发现慢查询的日志文件里面有数据了。</p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219234903533-1423036194.png" alt="img"></p><h3 id="慢查询解读"><a href="#慢查询解读" class="headerlink" title="　　　　慢查询解读"></a>　　　　<strong>慢查询解读</strong></h3><p>　　　　　　从慢查询日志里面摘选一条慢查询日志，数据组成如下</p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219234943423-516489335.png" alt="img"></p><p>　　　　　　第一行：用户名 、用户的IP信息、线程ID号</p><p>　　　　　　第二行：执行花费的时间【单位：毫秒】</p><p>　　　　　　第三行：执行获得锁的时间</p><p>　　　　　　第四行：获得的结果行数</p><p>　　　　　　第五行：扫描的数据行数</p><p>　　　　　　第六行：这SQL执行的具体时间</p><p>　　　　　　第七行：具体的SQL语句</p><h2 id="执行计划（explain-select…、explain-extended-select…）"><a href="#执行计划（explain-select…、explain-extended-select…）" class="headerlink" title="　　执行计划（explain select…、explain extended select…）"></a>　　<strong>执行计划（explain select…、explain extended select…）</strong></h2><p>  　　　　使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p><h3 id="执行计划作用"><a href="#执行计划作用" class="headerlink" title="　　　　执行计划作用"></a>　　　　执行计划作用</h3><p> 　　　　　　表的读取顺序</p><p>　　　　　　 数据读取操作的操作类型</p><p> 　　　　　　哪些索引可以使用</p><p> 　　　　　　哪些索引被实际使用</p><p>　　　　　　 表之间的引用</p><p>　　　　　　 每张表有多少行被优化器查询</p><h3 id="执行计划的语法"><a href="#执行计划的语法" class="headerlink" title="　　　　执行计划的语法"></a>　　　　<strong>执行计划的语法</strong></h3><p>　　　　　　执行计划的语法其实非常简单： 在SQL查询的前面加上EXPLAIN关键字就行。</p><p>　　　　　　比如：EXPLAIN select * from table1</p><p>　　　　　　重点的就是EXPLAIN后面你要分析的SQL语句 </p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235423257-1487252623.png" alt="img"></p><h3 id="ID列"><a href="#ID列" class="headerlink" title="　　　　ID列"></a>　　　　<strong>ID列</strong></h3><p>　　　　　　ID列：描述select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序</p><p>　　　　　　根据ID的数值结果可以分成一下三种情况</p><p>　　　　　　id相同：执行顺序由上至下</p><p>　　　　　　id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><p>　　　　　　id相同不同：同时存在</p><p>　　　　　　分别举例来看</p><p> 　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235453667-1329263176.png" alt="img"></p><p>　　　　　　如上图所示，ID列的值全为1，代表执行的允许从t1开始加载，依次为t3与t2</p><p>　　　　　　EXPLAIN  select t2.* from t1,t2,t3  where t1.id = t2.id and t1.id = t3.id and t1.other_column = ‘’;</p><p>　　　　　　<strong>Id不同</strong></p><p> 　　　　　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235553574-442127808.png" alt="img"></strong></p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235532996-1423358885.png" alt="img"></p><p>　　　　　　如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><p>　　　　　　EXPLAIN select t2.* from  t2 where id = (</p><p>　　　　　　　　select id from t1 where id =  (select t3.id from t3 where t3.other_column=’’)</p><p>　　　　　　);</p><p> 　　　　　　<strong>Id相同又不同</strong></p><p> 　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235612559-428043347.png" alt="img"></p><p>　　　　　　id如果相同，可以认为是一组，从上往下顺序执行；</p><p>　　　　　　在所有组中，id值越大，优先级越高，越先执行</p><p>　　　　　　EXPLAIN select t2.* from (select t3.id from t3 where t3.other_column = ‘’) s1 ,t2 where s1.id = t2.id;</p><h3 id="select-type列"><a href="#select-type列" class="headerlink" title="　　　　select_type列"></a>　　　　<strong>select_type列</strong></h3><p>　　　　　　Select_type:查询的类型，要是用于区别:普通查询、联合查询、子查询等的复杂查询</p><p>　　　　　　类型如下</p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235704828-1423464641.png" alt="img"></p><p>　　　　　　<strong>SIMPLE</strong></p><p>　　　　　　　　EXPLAIN select * from t1</p><p>　　　　　　　　简单的 select 查询,查询中不包含子查询或者UNION</p><p> 　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235756832-32620301.png" alt="img"></p><p>　　　　　　　　<strong>PRIMARY与SUBQUERY</strong></p><p>　　　　　　　　PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为</p><p>　　　　　　　　SUBQUERY：在SELECT或WHERE列表中包含了子查询</p><p>　　　　　　　　EXPLAIN select t1.*,(select t2.id from t2 where t2.id = 1 ) from t1 </p><p> 　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235849555-1405897889.png" alt="img"></p><p> 　　　　　　<strong>DERIVED</strong></p><p>　　　　　　　　在FROM列表中包含的子查询被标记为DERIVED(衍生)</p><p>　　　　　　　　MySQL会递归执行这些子查询, 把结果放在临时表里。</p><p> 　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235916544-290087960.png" alt="img"></p><p>　　　　　　.<strong>UNION RESULT 与UNION</strong></p><p>　　　　　　　　UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；</p><p>　　　　　　　　UNION RESULT：从UNION表获取结果的SELECT</p><p>　　　　　　　　#UNION RESULT ,UNION</p><p>　　　　　　　　EXPLAIN select * from t1 UNION select * from t2</p><p>　　　　　　　　　　 <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181219235946669-246517613.png" alt="img"></p><h3 id="table列"><a href="#table列" class="headerlink" title="　　　　table列"></a>　　　　<strong>table列</strong></h3><p>　　　　　　显示这一行的数据是关于哪张表的</p><p> 　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000006443-482227186.png" alt="img"></p><h3 id="Type列"><a href="#Type列" class="headerlink" title="　　　　Type列"></a>　　　　<strong>Type列</strong></h3><p>　　　　　　　　type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：</p><p>　　　　　　　　system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>　　　　　　　　需要记忆的</p><p>　　　　　　　　　　<strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong></p><p>　　　　　　　　一般来说，得保证查询至少达到range级别，最好能达到ref。</p><p> 　　　　　　　　<strong>System与const</strong></p><p>　　　　　　　　　　System：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</p><p>　　　　　　　　　　Const：表示通过索引一次就找到了</p><p>　　　　　　　　　　const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快</p><p>　　　　　　　　如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p><p> 　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000150547-998583887.png" alt="img"></p><p>　　　　　　　　<strong>eq_ref</strong></p><p> 　　　　　　　　　　唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</p><p> 　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000243583-1670946265.png" alt="img"></p><p>　　　　　　　　<strong>Ref</strong></p><p>　　　　　　　　　　 非唯一性索引扫描，返回匹配某个单独值的所有行.</p><p>　　　　　　　　　　本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</p><p> 　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000316081-1595389685.png" alt="img"></p><p>　　　　　　　　<strong>Range</strong></p><p>　　　　　　　　只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引</p><p>　　　　　　　　一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询</p><p>　　　　　　　　这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p><p> 　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000338119-88802728.png" alt="img"></p><p>　　　　　　　　<strong>Index</strong></p><p>　　　　　　　　当查询的结果全为索引列的时候，虽然也是全部扫描，但是只查询的索引库，而没有去查询数据。</p><p> 　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000353517-1493317165.png" alt="img"></p><p>　　　　　　　　<strong>All</strong></p><p>　　　　　　　　　　Full Table Scan，将遍历全表以找到匹配的行</p><p> 　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000414029-793232718.png" alt="img"></p><p>　　　　　　　　<strong>possible_keys 与Key</strong> </p><p>　　　　　　　　　　possible_keys:可能使用的key</p><p>　　　　　　　　　　Key:实际使用的索引。如果为NULL，则没有使用索引</p><p>　　　　　　　　　　查询中若使用了<strong>覆盖索引</strong>，则该索引和查询的select字段重叠</p><p> 　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000715933-1633509308.png" alt="img"></p><h3 id="key-len列"><a href="#key-len列" class="headerlink" title="　　　　key_len列"></a>　　　　<strong>key_len列</strong></h3><p>　　　　　　Key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p>　　　　　　key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000908803-1267379495.png" alt="img"></p><p> 　　　　　　key_len表示索引使用的字节数，</p><p> 　　　　　　根据这个值，就可以判断索引使用情况，特别是在组合索引的时候，判断所有的索引字段是否都被查询用到。</p><p> 　　　　　　char和varchar跟字符编码也有密切的联系,</p><p> 　　　　　　<strong>latin1占用1个字节，gbk占用2个字节，utf8占用3个字节。（不同字符编码占用的存储空间不同）</strong></p><p> 　　　　　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220000940655-733679707.png" alt="img"></strong></p><p>　　　　　　<strong>字符类型</strong></p><p> 　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220001201149-497874571.png" alt="img"></p><p>　　　　　　<strong>字符类型-索引字段为char类型+不可为Null时</strong></p><p> 　　　　　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220001301740-625568695.png" alt="img"></strong></p><p>　　　　　　　　name这一列为char(10),字符集为utf-8占用3个字节Keylen=10*3</p><p>　　　　　　<strong>字符类型-索引字段为char类型+允许为Null时</strong></p><p>　　　　　　　　 <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220001357029-928484031.png" alt="img"></p><p>　　　　　　　　name这一列为char(10),字符集为utf-8占用3个字节,外加需要存入一个null值</p><p>　　　　　　　　Keylen=10*3+1(null) 结果为31</p><p>　　　　　　<strong>索引字段为varchar类型+不可为Null时</strong></p><p> 　　　　　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220001511264-2122569802.png" alt="img"></strong></p><p>　　　　　　　　Keylen=varchar(n)变长字段+不允许Null=n*(utf8=3,gbk=2,latin1=1)+2</p><p> 　　　　　　<strong>索引字段为varchar类型+允许为Null时</strong></p><p> 　　　　　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220001543161-1861860851.png" alt="img"></strong></p><p>　　　　　　Keylen=varchar(n)变长字段+允许Null=n*(utf8=3,gbk=2,latin1=1)+1(NULL)+2</p><p>　　　　<strong>总结</strong></p><p>　　　　　　<strong>字符类型</strong></p><p>　　　　　　　　变长字段需要额外的2个字节（VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)，所以VARCAHR索引长度计算时候要加2），固定长度字段不需要额外的字节。</p><p>　　　　　　　　而NULL都需要1个字节的额外空间,所以索引字段最好不要为NULL，因为NULL让统计更加复杂并且需要额外的存储空间。</p><p>　　　　　　　　复合索引有最左前缀的特性，如果复合索引能全部使用上，则是复合索引字段的索引长度之和，这也可以用来判定复合索引是否部分使用，还是全部使用。</p><p>　　　　　　<strong>整数/浮点数/时间类型的索引长度</strong></p><p>　　　　　　　　NOT NULL=字段本身的字段长度</p><p>​        　　　　　　NULL=字段本身的字段长度+1(因为需要有是否为空的标记，这个标记需要占用1个字节)</p><p>　　　　　　datetime类型在5.6中字段长度是5个字节，datetime类型在5.5中字段长度是8个字节</p><h3 id="Ref列"><a href="#Ref列" class="headerlink" title="　　　　Ref列"></a>　　　　<strong>Ref列</strong></h3><p>　　　　　　显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220001850088-1945535225.png" alt="img"></p><p>　　　　　　由key_len可知t1表的idx_col1_col2被充分使用，col1匹配t2表的col1，col2匹配了一个常量，即 ‘ac’</p><p>　　　　　　其中 【shared.t2.col1】 为 【数据库.表.列】</p><h3 id="Rows列"><a href="#Rows列" class="headerlink" title="　　　　Rows列"></a>　　　　<strong>Rows列</strong></h3><p>　　　　　　根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002029423-119770225.png" alt="img"></p><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="　　　　Extra列"></a>　　　　<strong>Extra列</strong></h3><p>　　　　　　包含不适合在其他列中显示但十分重要的额外信息。</p><p> 　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002127517-1330629789.png" alt="img"></p><p>　　　　　　<strong>Using filesort</strong></p><p>　　　　　　　　说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”</p><p>　　　　　　　　当发现有Using filesort 后，实际上就是发现了可以优化的地方</p><p>　　 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002227367-2126093311.png" alt="img"></p><p>　　　　　　　　上图其实是一种索引失效的情况，后面会讲，可以看出查询中用到了个联合索引，索引分别为col1,col2,col3</p><p>　　　　　　　　 <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002254014-1127690041.png" alt="img"></p><p>　　　　　　　　当我排序新增了个col2，发现using filesort 就没有了。</p><p>　　　　　　<strong>Using temporary</strong></p><p>　　　　　　　　使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</p><p>　　　　　　　　 <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002339977-1027848055.png" alt="img"></p><p>　　　　　　　　 <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002412056-659308288.png" alt="img"></p><p>　　　　　　　　尤其发现在执行计划里面有using filesort而且还有Using temporary的时候，特别需要注意</p><p>　　　　　　<strong>Using index</strong></p><p>　　　　　　　　表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！</p><p>　　　　　　　　<strong>如果同时出现using where，表明索引被用来执行索引键值的查找;</strong></p><p>　　　　　　　　 <strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002503631-1194095526.png" alt="img"></strong></p><p>　　　　　　　　<strong>如果没有同时出现using where，表明索引用来读取数据而非执行查找动作</strong></p><p>　　　　　　　　 <strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002518472-1635174945.png" alt="img"></strong></p><p>　　　　　　<strong>Using where 与 using join buffer</strong></p><p>　　　　　　　　Using where</p><p>　　　　　　　　　　表明使用了where过滤</p><p>　　　　　　　　using join buffer</p><p>　　　　　　　　　　使用了连接缓存：</p><p>　　　　　　　　 <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002704065-1861990218.png" alt="img"></p><p>　　　　　　 <strong>impossible where</strong></p><p>　　　　　　　　where子句的值总是false，不能用来获取任何元组</p><p>　　　　　　　　 <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220002724312-533421361.png" alt="img"></p><h3 id="filtered列"><a href="#filtered列" class="headerlink" title="　　　　filtered列"></a>　　　　filtered列</h3><p>　　　　　　　使用explain extended时显示，显示针对表里符合某个条件（where子句或者联结条件）的记录数的百分比所做的一个悲观估算，即mysql将要过滤行数的百分比。</p><p>　　　　</p><h2 id="sql优化顺口溜"><a href="#sql优化顺口溜" class="headerlink" title="　　sql优化顺口溜"></a>　　sql优化顺口溜</h2><p> 　　　　全职匹配我最爱，最左前缀要遵守；</p><p> 　　　　带头大哥不能死，中间兄弟不能断；</p><p> 　　　　索引列上少计算，范围之后全失效；</p><p>　　 　　LIKE百分写最右，覆盖索引不写*；</p><p> 　　　　全职匹配我最爱？</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220003027251-1484532060.png" alt="img"></p><p>　　　　当建立了索引列后，能在where条件中使用索引的尽量所用。</p><p>　　　　最左前缀要遵守，带头大哥不能死，中间兄弟不能断？</p><p>　　　　 <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/1403971-20181220003128842-2077798724.png" alt="img"></p><p>　　　　如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><h3 id="七-OLTP与OLAP的介绍和对比"><a href="#七-OLTP与OLAP的介绍和对比" class="headerlink" title="七 OLTP与OLAP的介绍和对比"></a>七 OLTP与OLAP的介绍和对比</h3><p>　　<strong>OLTP与OLAP的介绍</strong></p><p>​    　　数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型<a href="http://lib.csdn.net/base/mysql">数据库</a>的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 </p><p>　　　　<strong>OLTP</strong> 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作；<br>　　　　<strong>OLAP</strong> 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。 </p><p>　　<strong>OLTP与OLAP之间的比较</strong>：   </p><p><img src="http://img.my.csdn.net/uploads/201212/08/1354896501_9646.jpg" alt="img"></p><p>　　　　<strong>OLTP，也叫联机事务处理（Online Transaction Processing）</strong>，表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。在这样的系统中，单个数据库每秒处理的Transaction往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。典型的OLTP系统有电子商务系统、银行、证券等，如美国eBay的业务数据库，就是很典型的OLTP数据库。<br>OLTP系统最容易出现瓶颈的地方就是CPU与磁盘子系统。<br>　　　　（1）CPU出现瓶颈常表现在逻辑读总量与计算性函数或者是过程上，逻辑读总量等于单个语句的逻辑读乘以执行次数，如果单个语句执行速度虽然很快，但是执行次数非常多，那么，也可能会导致很大的逻辑读总量。设计的方法与优化的方法就是减少单个语句的逻辑读，或者是减少它们的执行次数。另外，一些计算型的函数，如自定义函数、decode等的频繁使用，也会消耗大量的CPU时间，造成系统的负载升高，正确的设计方法或者是优化方法，需要尽量避免计算过程，如保存计算结果到统计表就是一个好的方法。<br>　　　　（2）磁盘子系统在OLTP环境中，它的承载能力一般取决于它的IOPS处理能力. 因为在OLTP环境中，磁盘物理读一般都是db file sequential read，也就是单块读，但是这个读的次数非常频繁。如果频繁到磁盘子系统都不能承载其IOPS的时候，就会出现大的性能问题。<br>   　　　　 OLTP比较常用的设计与优化方式为Cache技术与B-tree索引技术，Cache决定了很多语句不需要从磁盘子系统获得数据，所以，Web cache与Oracle data buffer对OLTP系统是很重要的。另外，在索引使用方面，语句越简单越好，这样执行计划也稳定，而且一定要使用绑定变量，减少语句解析，尽量减少表关联，尽量减少分布式事务，基本不使用分区技术、MV技术、并行技术及位图索引。因为并发量很高，批量更新时要分批快速提交，以避免阻塞的发生。<br>OLTP 系统是一个数据块变化非常频繁，SQL 语句提交非常频繁的系统。 对于数据块来说，应尽可能让数据块保存在内存当中，对于SQL来说，尽可能使用变量绑定技术来达到SQL重用，减少物理I/O 和重复的SQL 解析，从而极大的改善数据库的性能。<br>   　　　　 这里影响性能除了绑定变量，还有可能是热快（hot block）。 当一个块被多个用户同时读取时，Oracle 为了维护数据的一致性，需要使用Latch来串行化用户的操作。当一个用户获得了latch后，其他用户就只能等待，获取这个数据块的用户越多，等待就越明显。 这就是热快的问题。 这种热快可能是数据块，也可能是回滚端块。 对于数据块来讲，通常是数据库的数据分布不均匀导致，如果是索引的数据块，可以考虑创建反向索引来达到重新分布数据的目的，对于回滚段数据块，可以适当多增加几个回滚段来避免这种争用。<br>　　　　<strong>OLAP，也叫联机分析处理（Online Analytical Processing）</strong>系统，有的时候也叫DSS决策支持系统，就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB/s的流量。<br>    　　　　　　磁盘子系统的吞吐量则往往取决于磁盘的个数，这个时候，Cache基本是没有效果的，数据库的读写类型基本上是db file scattered read与direct path read/write。应尽量采用个数比较多的磁盘以及比较大的带宽，如4Gb的光纤接口。<br>　　　　<strong>在OLAP系统中，常使用分区技术、并行技术。</strong><br>    　　　　　　分区技术在OLAP系统中的重要性主要体现在数据库管理上，比如数据库加载，可以通过分区交换的方式实现，备份可以通过备份分区表空间实现，删除数据可以通过分区进行删除，至于分区在性能上的影响，它可以使得一些大表的扫描变得很快（只扫描单个分区）。另外，如果分区结合并行的话，也可以使得整个表的扫描会变得很快。总之，分区主要的功能是管理上的方便性，它并不能绝对保证查询性能的提高，有时候分区会带来性能上的提高，有时候会降低。<br>   　　　　　　 并行技术除了与分区技术结合外，在Oracle 10g中，与RAC结合实现多节点的同时扫描，效果也非常不错，可把一个任务，如select的全表扫描，平均地分派到多个RAC的节点上去。<br>    　　　　　　在OLAP系统中，不需要使用绑定（BIND）变量，因为整个系统的执行量很小，分析时间对于执行时间来说，可以忽略，而且可避免出现错误的执行计划。但是OLAP中可以大量使用位图索引，物化视图，对于大的事务，尽量寻求速度上的优化，没有必要像OLTP要求快速提交，甚至要刻意减慢执行的速度。<br>    　　　　　　绑定变量真正的用途是在OLTP系统中，这个系统通常有这样的特点，用户并发数很大，用户的请求十分密集，并且这些请求的SQL 大多数是可以重复使用的。<br>    　　　　　　对于OLAP系统来说，绝大多数时候数据库上运行着的是报表作业，执行基本上是聚合类的SQL 操作，比如group by，这时候，把优化器模式设置为all_rows是恰当的。 而对于一些分页操作比较多的网站类数据库，设置为first_rows会更好一些。 但有时候对于OLAP 系统，我们又有分页的情况下，我们可以考虑在每条SQL 中用hint。 如：<br>    　　　　　　Select  a.* from table a;<br>　　<strong>分开设计与优化</strong><br>　　　　在设计上要特别注意，如在高可用的OLTP环境中，不要盲目地把OLAP的技术拿过来用。<br>　　　　如分区技术，假设不是大范围地使用分区关键字，而采用其它的字段作为where条件，那么，如果是本地索引，将不得不扫描多个索引，而性能变得更为低下。如果是全局索引，又失去分区的意义。<br>　　　　并行技术也是如此，一般在完成大型任务时才使用，如在实际生活中，翻译一本书，可以先安排多个人，每个人翻译不同的章节，这样可以提高翻译速度。如果只是翻译一页书，也去分配不同的人翻译不同的行，再组合起来，就没必要了，因为在分配工作的时间里，一个人或许早就翻译完了。<br>　　　　位图索引也是一样，如果用在OLTP环境中，很容易造成阻塞与死锁。但是，在OLAP环境中，可能会因为其特有的特性，提高OLAP的查询速度。MV也是基本一样，包括触发器等，在DML频繁的OLTP系统上，很容易成为瓶颈，甚至是Library Cache等待，而在OLAP环境上，则可能会因为使用恰当而提高查询速度。<br>　　　　对于OLAP系统，在内存上可优化的余地很小，增加CPU 处理速度和磁盘I/O 速度是最直接的提高数据库性能的方法，当然这也意味着系统成本的增加。<br>　　　　比如我们要对几亿条或者几十亿条数据进行聚合处理，这种海量的数据，全部放在内存中操作是很难的，同时也没有必要，因为这些数据快很少重用，缓存起来也没有实际意义，而且还会造成物理I/O相当大。 所以这种系统的瓶颈往往是磁盘I/O上面的。<br>　　　　对于OLAP系统，SQL 的优化非常重要，因为它的数据量很大，做全表扫描和索引对性能上来说差异是非常大的。<br>　　<strong>其他</strong><br>    　　Oracle 10g以前的版本建库过程中可供选择的模板有：<br>        　　Data Warehouse （数据仓库）<br>        　　General Purpose  （通用目的、一般用途）<br>        　　New Database<br>        　　Transaction Processing  （事务处理）<br>    　　Oracle 11g的版本建库过程中可供选择的模板有：<br>       　　 一般用途或事务处理<br>        　　定制数据库</p><p>​        　　数据仓库</p><p>　　个人对这些模板的理解为：</p><p>​     　　联机分析处理（OLAP,On-line Analytical Processing），数据量大，DML少。使用数据仓库模板<br>​     　　联机事务处理（OLTP,On-line Transaction Processing），数据量少，DML频繁，并行事务处理多，但是一般都很短。使用一般用途或事务处理模板。</p><p>​     　　决策支持系统（DDS，Decision support system)，典型的操作是全表扫描，长查询，长事务，但是一般事务的个数很少，往往是一个事务独占系统。</p><h3 id="八-autocommit测试"><a href="#八-autocommit测试" class="headerlink" title="八 autocommit测试"></a>八 autocommit测试</h3><p>　　</p><p>　　MySQL是默认提交的，也就是说默认保存到磁盘上的，但是如果我们将本次回话设置了set autocommit=0;取消了默认提交的话，看一下效果：</p><p>　　可以通过查看“@@AUTOCOMMIT”变量来查看当前自动提交状态，查看此变量SELECT @@AUTOCOMMIT。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; use orm3;Database changedmysql&gt; select * from app01_publish;+----+-----------------+--------+| id | name            | addr   |+----+-----------------+--------+|  1 | 西瓜出版社      | 北京   ||  2 | 人民出版社      | 天津   ||  3 | 清华出版社      | 北京   ||  4 | 南京出版社      | 南京   ||  5 | hah             | xxxx   ||  6 | 呵呵            | ssss   |+----+-----------------+--------+6 rows in set (0.00 sec)mysql&gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into app01_publish values(7,'第七条','上海');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from app01_publish;+----+-----------------+--------+| id | name            | addr   |+----+-----------------+--------+|  1 | 西瓜出版社      | 北京   ||  2 | 人民出版社      | 天津   ||  3 | 清华出版社      | 北京   ||  4 | 南京出版社      | 南京   ||  5 | hah             | xxxx   ||  6 | 呵呵            | ssss   ||  7 | 第七条          | 上海   |+----+-----------------+--------+7 rows in set (0.00 sec)mysql&gt; quitByeC:\Users\zequan&gt;mysqlWelcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.6.21 MySQL Community Server (GPL)Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; use orm3;Database changedmysql&gt; select * from app01_publish;  #再进来发现新插入的数据没有了+----+-----------------+--------+| id | name            | addr   |+----+-----------------+--------+|  1 | 西瓜出版社      | 北京   ||  2 | 人民出版社      | 天津   ||  3 | 清华出版社      | 北京   ||  4 | 南京出版社      | 南京   ||  5 | hah             | xxxx   ||  6 | 呵呵            | ssss   |+----+-----------------+--------+6 rows in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/django/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL5.6的4个自带库详解</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL5.6%E7%9A%844%E4%B8%AA%E8%87%AA%E5%B8%A6%E5%BA%93%E8%AF%A6%E8%A7%A3%20/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL5.6%E7%9A%844%E4%B8%AA%E8%87%AA%E5%B8%A6%E5%BA%93%E8%AF%A6%E8%A7%A3%20/</url>
      
        <content type="html"><![CDATA[<p><strong>1.information_schema详细介绍：</strong></p><p>　　information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。 information_schema数据库表说明:</p><p>　　　　SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。 TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。</p><p>　　　　COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。</p><p>　　　　STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。</p><p>　　　　USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。</p><p>　　　　SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。</p><p>　　　　TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。</p><p>　　　　COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。</p><p>　　　　CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。</p><p>　　　　COLLATIONS表：提供了关于各字符集的对照信息。</p><p>　　　　COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。</p><p>　　　　TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。</p><p>　　　　KEY_COLUMN_USAGE表：描述了具有约束的键列。</p><p>　　　　ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。</p><p>　　　　VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。</p><p>　　　　TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表</p><p><strong>2. mysql作用介绍：</strong></p><p>　　mysql：这个是mysql的核心数据库，类似于sql server中的master表，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。</p><p><strong>3. performance_schema作用介绍：</strong></p><p>　　 mysql 5.5 版本 新增了一个性能优化的引擎： PERFORMANCE_SCHEMA这个功能默认是关闭的： 需要设置参数： performance_schema 才可以启动该功能，这个参数是静态参数，只能写在my.ini 中 不能动态修改。 先看看有什么东西吧：</p><p>　　　　mysql&gt; use performance_schema;</p><p>　　　　Database changed</p><p>　　　　mysql&gt; show tables ;</p><p>　　　　+———————————————-+</p><p>　　　　| Tables_in_performance_schema |</p><p>　　　　+———————————————-+</p><p>　　　　| cond_instances |</p><p>　　　　| events_waits_current |</p><p>　　　　| events_waits_history |</p><p>　　　　| events_waits_history_long |</p><p>　　　　| events_waits_summary_by_instance |</p><p>　　　　| events_waits_summary_by_thread_by_event_name |</p><p>　　　　| events_waits_summary_global_by_event_name |</p><p>　　　　| file_instances | | file_summary_by_event_name |</p><p>　　　　| file_summary_by_instance |</p><p>　　　　| mutex_instances |</p><p>　　　　| performance_timers |</p><p>　　　　| rwlock_instances |</p><p>　　　　| setup_consumers |</p><p>　　　　| setup_instruments |</p><p>　　　　| setup_timers |</p><p>　　　　| threads |</p><p>　　　　+———————————————-+</p><p>　　　　17 rows in set (0.00 sec)</p><p>　　　　这里的数据表分为几类：</p><p>　　　　　　1） setup table ： 设置表，配置监控选项。</p><p>　　　　　　2） current events table : 记录当前那些thread 正在发生什么事情。</p><p>　　　　　　3） history table 发生的各种事件的历史记录表</p><p>　　　　　　4） summary table 对各种事件的统计表</p><p>　　　　　　5） 杂项表，乱七八糟表。</p><p>　　　　setup 表：</p><p>　　　　　　mysql&gt; SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES -&gt; WHERE TABLE_SCHEMA = ‘performance_schema’ -&gt; AND TABLE_NAME LIKE ‘setup%’;</p><p>　　　　　　+——————-+</p><p>　　　　　　| TABLE_NAME |</p><p>　　　　　　+——————-+</p><p>　　　　　　| setup_consumers |</p><p>　　　　　　| setup_instruments |</p><p>　　　　　　| setup_timers |</p><p>　　　　　　+——————-+</p><p>　　　　　　setup_consumers 描述各种事件 setup_instruments 描述这个数据库下的表名以及是否开启监控。 setup_timers 描述 监控选项已经采样频率的时间间隔</p><p><strong>4. test作用介绍：</strong></p><p>　　这个是安装时候创建的一个测试数据库，和它的名字一样，是一个完全的空数据库，没有任何表，可以删除。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端HTML</title>
      <link href="2019/11/15/%E5%89%8D%E7%AB%AF/1%20-%20%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80--HTML%20/"/>
      <url>2019/11/15/%E5%89%8D%E7%AB%AF/1%20-%20%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80--HTML%20/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前端基础–HTML"><a href="#1-前端基础–HTML" class="headerlink" title="1 - 前端基础–HTML"></a><a href="https://www.cnblogs.com/hansha/p/9680115.html">1 - 前端基础–HTML</a></h1><h2 id="本文主要内容："><a href="#本文主要内容：" class="headerlink" title="本文主要内容："></a>本文主要内容：</h2><ol><li>HTML文档格式及标签格式介绍</li><li>head中的标签</li><li>body中的标签<ol><li>h1~h6、p、strong、b、em、i、del、u、div、span、br、hr</li><li>ol、ul、a、img、table、</li><li>form</li></ol></li></ol><h2 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h2><h3 id="HTML文档格式："><a href="#HTML文档格式：" class="headerlink" title="HTML文档格式："></a>HTML文档格式：</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol><li><p>声明为HTML5文档。</p></li><li><p><code>&lt;html&gt;、&lt;/html&gt;</code>是文档的开始标记和结束的标记。是HTML页面的根元素，在它们之间是文档的头部（head）和主体（body）。</p><p><code>&lt;html lang="en"&gt;</code>指定网页的语言</p></li><li><p><code>&lt;head&gt;、&lt;/head&gt;</code>定义了HTML文档的开头部分。它们之间的内容不会在浏览器的文档窗口显示。包含了文档的元（meta）数据。</p></li><li><p><code>&lt;body&gt;、&lt;/body&gt;</code>之间的文本是可见的网页主体内容。</p></li></ol><p><strong>注意：</strong>对于中文网页需要使用 <code>&lt;meta charset="utf-8"&gt;</code>声明编码，否则会出现乱码。有些浏览器会设置 GBK 为默认编码，则你需要设置为 <code>&lt;meta charset="gbk"&gt;</code>。</p><h3 id="HTML标签格式"><a href="#HTML标签格式" class="headerlink" title="HTML标签格式"></a>HTML标签格式</h3><ul><li>HTML标签是由尖括号包围的关键字，如<code>&lt;html&gt;, &lt;div&gt;</code>等</li><li>HTML标签通常是成对出现的，比如：<code>&lt;div&gt;</code>和<code>&lt;/div&gt;</code>，第一个标签是开始，第二个标签是结束。结束标签会有斜线。</li><li>也有一部分标签是单独呈现的，比如：<code>&lt;br/&gt;</code>、<code>&lt;hr/&gt;</code>、<code>&lt;img src="1.jpg" /&gt;</code>等。</li><li>标签里面可以有若干属性，也可以不带属性。如果带属性，必须有属性值，属性值放到引号里</li><li>标签字母全部是小写</li></ul><h4 id="标签的语法："><a href="#标签的语法：" class="headerlink" title="标签的语法："></a>标签的语法：</h4><ul><li>&lt;标签名 属性1=“属性值1” 属性2=“属性值2”……&gt;内容部分&lt;/标签名&gt;</li><li>&lt;标签名 属性1=“属性值1” 属性2=“属性值2”…… /&gt;</li><li>空白折叠</li></ul><h4 id="几个很重要的属性："><a href="#几个很重要的属性：" class="headerlink" title="几个很重要的属性："></a>几个很重要的属性：</h4><ul><li>id：定义标签的唯一ID，HTML文档树中唯一</li><li>class：为html元素定义一个或多个类名（classname）(CSS样式类名)</li><li>style：规定元素的行内样式（CSS样式）</li></ul><h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h3><pre><code>&lt;!--注释内容--&gt;</code></pre><p><strong>注释是代码之母</strong></p><h2 id="head中的标签"><a href="#head中的标签" class="headerlink" title="head中的标签"></a>head中的标签</h2><p>head标签都放在头部分之间。这里面包含了：</p><p> <code>&lt;title&gt;</code>、<code>&lt;meta&gt;</code>、<code>&lt;link&gt;</code>，<code>&lt;style&gt;</code></p><ul><li><code>&lt;title&gt;</code>：指定整个网页的标题，在浏览器最上方显示。</li><li><meta>：提供有关页面的基本信息</li><li><code>&lt;link&gt;</code>：定义文档与外部资源的关系。</li><li><style>:定义内部样式表与网页的关系</li></ul><p>头标签位于文档的头部，不包含任何内容。</p><p>提供的信息是用户不可见的。 meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</p><h3 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h3><p>主要用来告诉用户和搜索引擎这个网页的主要内容是什么，搜索引擎可以通过网页标题，迅速的判断出当前网页的主题。</p><pre><code> &lt;title&gt;路飞学城&lt;/title&gt;</code></pre><h3 id="Meta标签"><a href="#Meta标签" class="headerlink" title="Meta标签"></a>Meta标签</h3><p>元素可提供有关页面的原信息（mata-information）,针对搜索引擎和更新频度的描述和关键词。</p><p>标签位于文档的头部，不包含任何内容。</p><p>提供的信息是用户不可见的。 meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</p><p>常用的meta标签：</p><h4 id="1、http-equiv属性"><a href="#1、http-equiv属性" class="headerlink" title="1、http-equiv属性"></a>1、http-equiv属性</h4><p>它用来向浏览器传达一些有用的信息，帮助浏览器正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。</p><pre><code>&lt;!--重定向 2秒后跳转到对应的网址，注意分号--&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2;URL=http://www.luffycity.com&quot;&gt;&lt;!--指定文档的内容类型和编码类型 --&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;&lt;!--告诉IE浏览器以最高级模式渲染当前网页--&gt;&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;</code></pre><p>ps:关于mime文件类型（前端静态资源文件）：</p><p>连接：<a href="http://www.w3school.com.cn/media/media_mimeref.asp">http://www.w3school.com.cn/media/media_mimeref.asp</a></p><h4 id="2、name属性"><a href="#2、name属性" class="headerlink" title="2、name属性"></a>2、name属性</h4><p>主要用于页面的关键字和描述，是写给搜索引擎看的，关键字可以有多个用 ‘,’号隔开，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。</p><pre><code>&lt;meta name=&quot;Keywords&quot; content=&quot;网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信&quot; /&gt;</code></pre><p>这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到。</p><pre><code>&lt;meta name=&quot;Description&quot; content=&quot;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。&quot; /&gt;</code></pre><p><em>只要设置Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做<strong>SEO</strong>（search engine optimization，搜索引擎优化）。</em></p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</code></pre><p>上面这个标签，是让我们网页支持移动端，移动设备优先（了解即可）</p><h3 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h3><p>link标签定义了文档与外部资源之间的关系，通常用于链接到样式表:</p><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></pre><h3 id="style标签"><a href="#style标签" class="headerlink" title="style标签"></a>style标签</h3><p>style标签在 HTML 文档中添加样式:</p><pre><code>&lt;head&gt;    &lt;style type=&quot;text/css&quot;&gt;        body &#123;background-color:yellow&#125;        p &#123;color:blue&#125;    &lt;/style&gt;&lt;/head&gt;</code></pre><h2 id="body中的标签"><a href="#body中的标签" class="headerlink" title="body中的标签"></a>body中的标签</h2><h3 id="标题-lt-h1-gt"><a href="#标题-lt-h1-gt" class="headerlink" title="标题&lt;h1&gt;"></a>标题<code>&lt;h1&gt;</code></h3><p>标题使用<code>&lt;h1&gt;</code>至<code>&lt;h6&gt;</code>标签进行定义。<code>&lt;h1&gt;</code>定义最大的标题，<code>&lt;h6&gt;</code>定义最小的标题。</p><p>示例：</p><pre><code>&lt;h1&gt;路飞学城&lt;/h1&gt;&lt;h2&gt;路飞学城&lt;/h2&gt;&lt;h3&gt;路飞学城&lt;/h3&gt;&lt;h4&gt;路飞学城&lt;/h4&gt;&lt;h5&gt;路飞学城&lt;/h5&gt;&lt;h6&gt;路飞学城&lt;/h6&gt;</code></pre><h3 id="段落标签-lt-p-gt"><a href="#段落标签-lt-p-gt" class="headerlink" title="段落标签&lt;p&gt;"></a>段落标签<code>&lt;p&gt;</code></h3><p>段落：是英文paragraph的缩写。</p><p>属性：</p><ul><li><code>align=&#39;属性值&#39;</code>：对齐方式。属性值包括：<code>left、center、right</code></li></ul><p>示例：</p><pre><code>&lt;p&gt;这是第一个段落&lt;/p&gt;&lt;p&gt;这是第二个段落&lt;/p&gt;&lt;p&gt;这是第三个段落&lt;/p&gt;</code></pre><h3 id="粗体标签-lt-b-gt-或-lt-strong-gt"><a href="#粗体标签-lt-b-gt-或-lt-strong-gt" class="headerlink" title="粗体标签&lt;b&gt;或&lt;strong&gt;"></a>粗体标签<code>&lt;b&gt;</code>或<code>&lt;strong&gt;</code></h3><p>示例：</p><pre><code>路飞学城&lt;b&gt;路飞学城&lt;/b&gt;&lt;strong&gt;路飞学城&lt;/strong&gt;</code></pre><h3 id="斜体标记-lt-i-gt-或-lt-em-gt"><a href="#斜体标记-lt-i-gt-或-lt-em-gt" class="headerlink" title="斜体标记 &lt;i&gt;或&lt;em&gt;"></a>斜体标记 <code>&lt;i&gt;</code>或<code>&lt;em&gt;</code></h3><p>示例：</p><pre><code>路飞学城&lt;i&gt;路飞学城&lt;/i&gt;&lt;em&gt;路飞学城&lt;/em&gt;</code></pre><h3 id="标签-lt-div-gt-和标签-lt-span-gt"><a href="#标签-lt-div-gt-和标签-lt-span-gt" class="headerlink" title="标签 &lt;div&gt;和标签&lt;span&gt;"></a>标签 <code>&lt;div&gt;</code>和标签<code>&lt;span&gt;</code></h3><p>div和span是非常重要的标签。CSS课程中你将知道，这两个东西，都是最最重要的“盒子”。</p><p>div：把标签中的内容作为一个块儿来对待。必须单独占据一行。</p><p>div标签的属性：</p><ul><li><code>align=&quot;属性值&quot;</code>：设置块儿的位置。属性值可选择：left、right、 center</li></ul><p><strong><span>和<div>唯一的区别在于</strong>：<code>&lt;span&gt;</code>是不换行的，而<code>&lt;div&gt;</code>是换行的。</p><p>如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。</p><p>示例：</p><pre><code>&lt;body&gt;    &lt;div&gt;        导航栏    &lt;/div&gt;    &lt;div&gt;        中心banner    &lt;/div&gt;    &lt;span&gt;路飞&lt;/span&gt;    &lt;span&gt;alex&lt;/span&gt;    &lt;/body&gt;</code></pre><p>div在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。</p><p>div标签是一个<strong>容器级</strong>标签，里面什么都能放，当然也可以放div自己。</p><p>span也是表达“小区域、小跨度”的标签，但是是一个<strong>文本级</strong>的标签。</p><p>就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、ol、div。</p><p>span举例：</p><pre><code>&lt;p&gt;        商品简介:        &lt;span&gt;            &lt;a href=&quot;&quot;&gt;详细信息&lt;/a&gt;            &lt;a href=&quot;&quot;&gt;生产日期&lt;/a&gt;        &lt;/span&gt;&lt;/p&gt;</code></pre><p>div举例：</p><pre><code>&lt;div class=&quot;header&quot;&gt;    &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;nav&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;div class=&quot;guanggao&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;shop&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;</code></pre><p>所以，我们把这种模式叫做“<strong>div+css</strong>”。<strong>div标签负责布局，负责结构，负责分块。css负责样式</strong>。</p><p>ps:这个class属性名就与css有很大关联，讲到css模块会详细讲这块内容。</p><h3 id="超链接-lt-a-gt-："><a href="#超链接-lt-a-gt-：" class="headerlink" title="超链接&lt;a&gt;："></a>超链接<code>&lt;a&gt;</code>：</h3><h4 id="1、外部链接"><a href="#1、外部链接" class="headerlink" title="1、外部链接"></a>1、外部链接</h4><p> 链接到外部文件。举例：</p><pre><code>&lt;a href=&quot;new.html&quot;&gt;点击进入到新网页&lt;/a&gt;</code></pre><p>a是英语<code>anchor</code>“锚”的意思，就好像这个页面往另一个页面扔出了一个锚。是一个文本级的标签。</p><p>href是英语<code>hypertext reference</code>超文本地址的缩写。</p><p>我们可以点击进入一个自己写的新网页</p><pre><code> &lt;a href=&quot;new.html&quot;&gt;进入新网页&lt;/a&gt;</code></pre><p>当然，我们也可以直接点进链接，访问一个网址。举例如下；</p><pre><code> &lt;a href=&quot;http://www.baidu.com&quot;&gt;进入百度&lt;/a&gt;</code></pre><h4 id="2、锚链接"><a href="#2、锚链接" class="headerlink" title="2、锚链接"></a>2、锚链接</h4><p>指给超链接起一个名字，作用是<strong>在本页面或者其他页面的的不同位置进行跳转</strong>。比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就是利用到了锚链接。首先我们要创建一个<strong>锚点</strong>，也就是说，使用<code>name</code>属性或者<code>id</code>属性给那个特定的位置起个名字。</p><pre><code>&lt;div id=&quot;top1&quot;&gt;这是div1&lt;/div&gt;&lt;div style=&quot;height: 2000px;&quot;&gt;&lt;/div&gt;&lt;div id=&quot;top2&quot;&gt;这是div2&lt;/div&gt;&lt;div style=&quot;height: 2000px;&quot;&gt;&lt;/div&gt;&lt;a href=&quot;#top1&quot;&gt;回到div1&lt;/a&gt;&lt;a href=&quot;#top2&quot;&gt;回到div2&lt;/a&gt;</code></pre><p>上面代码中，第一个div的id是top1，第二个div的id是top2。第一个a标签，点击页面跳到第一个div的位置，第二个a标签，点击页面跳到第二个div的位置，</p><p>然后在底部设置超链接，点击时将回到顶部（此时，网页中的url的末尾也出现了<code>#top</code>）。注意<strong>href中的#号不要忘记了</strong>，表示跳到名为top的特定位置，这是规定。如果少了<code>#</code>号，点击之后，就会跳到top这个文件或者top这个文件夹中去。</p><p>我们可以写成：</p><pre><code>&lt;a href=&quot;new.hhml#top&quot;&gt;回到顶部&lt;/a&gt;</code></pre><p>就表示，点击之后，跳转到<code>new.html</code>页面的<code>top</code>锚点中去。</p><p>说明：name属性是HTML4.0以前使用的，id属性是HTML4.0后才开始使用。如果要向前兼容，name和id这两个属性都要写上，并且值是一样的。</p><h4 id="3、邮件链接、电话号码："><a href="#3、邮件链接、电话号码：" class="headerlink" title="3、邮件链接、电话号码："></a>3、邮件链接、电话号码：</h4><p>代码举例：</p><pre><code>&lt;a href=&quot;mailto:zhaoxu@tedu.cn&quot;&gt;联系我们&lt;/a&gt;&lt;a href=&quot;tel:10086&quot;&gt;联系我们&lt;/a&gt;</code></pre><p>效果：点击之后，会弹出outlook，作用不大。</p><p>前提：计算机中必须安装邮件客户端，并且配置好了邮件相关信息</p><h4 id="特殊几个链接："><a href="#特殊几个链接：" class="headerlink" title="特殊几个链接："></a>特殊几个链接：</h4><p>返回页面顶部的位置</p><pre><code> &lt;a href=&quot;#&quot;&gt;跳转到顶部&lt;/a&gt;</code></pre><p>与js有关：</p><pre><code> &lt;a href=&quot;javascript:alert(1)&quot;&gt;内容&lt;/a&gt;  &lt;a href=&quot;javascript:;&quot;&gt;内容&lt;/a&gt;</code></pre><ol><li><p>javascript:;表示什么都不执行，这样点击<code>&lt;a&gt;</code>时就没有任何反应</p><p> 例如： <code>&lt;a href=&quot;javascrip:;&quot;&gt;</code>内容<code>&lt;/a&gt;</code></p></li><li><p>javascript:是表示在触发<code>&lt;a&gt;</code>默认动作时，执行一段JavaScript代码。</p><p> 例如： <code>&lt;ahref=&quot;javascript:alert()&quot;&gt;内容&lt;/a&gt;</code></p></li></ol><h4 id="超链接的属性"><a href="#超链接的属性" class="headerlink" title="超链接的属性"></a>超链接的属性</h4><ul><li><code>href</code>：目标URL</li><li><code>title</code>：悬停文本。</li><li><code>name</code>：主要用于设置一个锚点的名称。</li><li><code>target</code>：告诉浏览器用什么方式来打开目标页面。<code>target</code>属性有以下几个值：<ul><li><code>_self</code>：在同一个网页中显示（默认值）</li><li><code>_blank</code>：<strong>在新的窗口中打开</strong>。</li><li><code>_parent</code>：在父窗口中显示</li><li><code>_top</code>：在顶级窗口中显示</li></ul></li></ul><p>blank就是“空白”的意思，就表示新建一个空白窗口。为啥有一个_ ，就是规定，没啥好解释的。 也就是说，如果不写<code>target=”_blank”</code>那么就是在相同的标签页打开，如果写了<code>target=”_blank”</code>，就是在新的空白</p><h4 id="ps-a是一个文本级的标签"><a href="#ps-a是一个文本级的标签" class="headerlink" title="ps:a是一个文本级的标签"></a>ps:a是一个文本级的标签</h4><p>比如一个段落中的所有文字都能够被点击，那么应该是p包含a；</p><pre><code>&lt;p&gt;    &lt;a href=&quot;&quot;&gt;段落段落段落段落段落段落&lt;/a&gt;&lt;/p&gt;</code></pre><p>而不是a包裹p：</p><pre><code>&lt;a href=&quot;&quot;&gt;    &lt;p&gt;        段落段落段落段落段落段落    &lt;/p&gt;&lt;/a&gt;</code></pre><p>a的语义要小于p，a就是可以当做文本来处理，所以p里面相当于放的就是纯文字。</p><h3 id="图片标签-lt-img-gt"><a href="#图片标签-lt-img-gt" class="headerlink" title="图片标签 &lt;img /&gt;"></a>图片标签 <code>&lt;img /&gt;</code></h3><p>img: 代表的就是一张图片。是单边标记。</p><p>img是自封闭标签，也称为单标签。</p><h5 id="能插入的图片类型："><a href="#能插入的图片类型：" class="headerlink" title="能插入的图片类型："></a>能插入的图片类型：</h5><ul><li>能够插入的图片类型是：jpg(jpeg)、gif、png、bmp。</li><li>不能往网页中插入的图片格式是：psd、ai</li></ul><p>HTML页面不是直接插入图片，而是插入图片的引用地址，所以也要把图片上传到服务器上。</p><h5 id="src属性：图片的相对路径和绝对路径"><a href="#src属性：图片的相对路径和绝对路径" class="headerlink" title="src属性：图片的相对路径和绝对路径"></a><code>src</code>属性：图片的相对路径和绝对路径</h5><p>这里涉及到图片的一个属性：</p><ul><li><code>src</code>属性：指图片的路径。</li></ul><p>在写<strong>图片的路径</strong>时，有两种写法：相对路径、绝对路径</p><h5 id="1、写法一：相对路径"><a href="#1、写法一：相对路径" class="headerlink" title="1、写法一：相对路径"></a>1、写法一：相对路径</h5><p>相对当前页面所在的路径。两个标记 <code>.</code> 和 <code>..</code> 分表代表当前目录和父路径。</p><p>举例1：</p><pre><code>&lt;!-- 当前目录中的图片 --&gt;&lt;img src=&quot;2.jpg&quot;&gt;&lt;img src=&quot;.\2.jpg&quot;&gt; &lt;!-- 上一级目录中的图片 --&gt;&lt;img src=&quot;..\2.jpg&quot;&gt;</code></pre><p>img 是image“图片”的简写，src 是英语source“资源”的缩写。</p><p>举例2：</p><pre><code>&lt;img src=&quot;images/1.jpg&quot;&gt;</code></pre><p>上方代码的意思是说，当前页面有一个并列的文件夹<code>images</code>，在文件夹<code>images</code>中存放了一张图片<code>1.jpg</code></p><h5 id="2、写法二：绝对路径"><a href="#2、写法二：绝对路径" class="headerlink" title="2、写法二：绝对路径"></a>2、写法二：绝对路径</h5><p><strong>（1）以盘符开始的绝对路径。举例：</strong></p><pre><code>&lt;img src=&quot;C:\Users\aaa\Desktop\html-01\images\1.jpg&quot;&gt;不要这样写，本地文件都用相对路径</code></pre><p>（2）网络路径。举例：</p><pre><code>&lt;img src=&quot;http://www.baidu.com/2016040102.jpg&quot;&gt;</code></pre><h5 id="相对路径和绝对路径的总结"><a href="#相对路径和绝对路径的总结" class="headerlink" title="相对路径和绝对路径的总结"></a>相对路径和绝对路径的总结</h5><p>相对路径的好处：站点不管拷贝到哪里，文件和图片的相对路径关系都是不变的。相对路径使用有一个前提，就是网页文件和你的图片，必须在一个服务器上。</p><pre><code>&lt;img src=&quot;file://C:\Users\Danny\Pictures\明星\1.jpg&quot; alt=&quot;&quot; /&gt;不要这样写，本地文件都用相对路径</code></pre><p>总结一下：</p><ul><li>我们现在无论是在a标签、img标签，如果要用路径。只有两种路径能用，就是相对路径和绝对路径。</li><li>相对路径，就是../ image/ 这种路径。从自己出发，找到别人；</li><li>绝对路径，就是http://开头的路径。</li><li>绝对不允许使用file://开头的东西，这个是完全错误的！</li></ul><h5 id="img标签的常用其它属性"><a href="#img标签的常用其它属性" class="headerlink" title="img标签的常用其它属性"></a>img标签的常用其它属性</h5><ul><li><code>width</code>：宽度</li><li><code>height</code>：高度</li><li><code>title</code>：<strong>提示性文本</strong>。公有属性。也就是鼠标悬停时出现的文本。</li><li><code>align</code>：指图片的水平对齐方式，属性值可以是：left、center、right</li><li><code>alt</code>：当图片显示不出来的时候，代替图片显示的内容。alt是英语 alternate “替代”的意思。（有的浏览器不支持）</li></ul><p>举例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/1364810-20180520092542606-792034884.png" alt="img"></p><p>示例：</p><pre><code>嘿嘿&lt;img src=&quot;images/bojie.jpeg&quot; alt=&quot;波姐&quot; title=&#39;波多野结衣&#39; width=&quot;400&quot; height=&quot;400&quot;&gt;幺幺</code></pre><p>文本级的标签显示在浏览器上时，不管你的图片多高，它总会底边对齐，这是一种现象，“高矮不齐，底边对齐”。</p><p>此时大家可以给图片设置align属性，来查看效果吧！</p><p><strong>注意事项：</strong>（1）如果要想保证图片等比例缩放，请只设置width和height中其中一个。（2）如果想实现图文混排的效果，请使用align属性，取值为left或right</p><p>如果想点击图片的时候跳转到某个链接，应该是：</p><pre><code>&lt;a&gt;   &lt;img src=&quot;images/bojie.jpeg&quot; alt=&quot;波姐&quot; title=&#39;波多野结衣&#39;&gt;&lt;/a&gt;</code></pre><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p>列表标签分为三种。</p><h5 id="有序列表-lt-ol-gt"><a href="#有序列表-lt-ol-gt" class="headerlink" title="有序列表&lt;ol&gt;"></a>有序列表<code>&lt;ol&gt;</code></h5><p>里面的每一项是<code>&lt;li&gt;</code>，</p><ul><li>ol:ordered list，“有序列表”的意思。</li><li>li：list item，“列表项”的意思。</li></ul><p>例如：</p><pre><code>&lt;ol&gt;    &lt;li&gt;北京&lt;/li&gt;    &lt;li&gt;上海&lt;/li&gt;    &lt;li&gt;广州&lt;/li&gt;    &lt;li&gt;深圳&lt;/li&gt;&lt;/ol&gt;</code></pre><p><strong>属性：</strong></p><ul><li><code>type=&quot;属性值&quot;</code>。属性值可以是：1(阿拉伯数字，默认)、a、A、i、I。结合<code>start</code>属性表示<code>从几开始</code>。</li></ul><p>有序列表也是可以嵌套的。</p><p>ol和ul就是语义不一样，怎么使用都是一样的。ol里面只能有li，li必须被ol包裹。li是容器级。</p><p>ol这个东西用的不多，如果想表达顺序，大家一般也用ul，在内容中加序号。</p><h5 id="无序列表-lt-ul-gt"><a href="#无序列表-lt-ul-gt" class="headerlink" title="无序列表&lt;ul&gt;"></a>无序列表<code>&lt;ul&gt;</code></h5><p>ul：unordered list，“无序列表”的意思，无序列表中的每一项是<code>&lt;li&gt;</code></p><p>示例：</p><pre><code>&lt;ul&gt;    &lt;li&gt;张三&lt;/li&gt;        &lt;li&gt;李四&lt;/li&gt;        &lt;li&gt;王五&lt;/li&gt;    &lt;/ul&gt;</code></pre><p>注意：</p><ul><li>li不能单独存在，必须包裹在ul里面；反过来说，ul的“儿子”不能是别的东西，只能有li。</li><li>我们这里再次强调，ul的作用，并不是给文字增加小圆点的，而是增加无序列表的“语义”的。</li></ul><p><strong>属性：</strong></p><ul><li><code>type=&quot;属性值&quot;</code>。属性值可以选： <code>disc</code>(实心原点，默认)，<code>square</code>(实心方点)，<code>circle</code>(空心圆)。</li></ul><p>列表之间是可以<strong>嵌套</strong>的。我们来举个例子：代码：</p><pre><code>&lt;ul&gt;  &lt;li&gt;&lt;b&gt;北京市&lt;/b&gt;      &lt;ul&gt;          &lt;li&gt;海淀区&lt;/li&gt;          &lt;li&gt;朝阳区&lt;/li&gt;          &lt;li&gt;东城区&lt;/li&gt;      &lt;/ul&gt;  &lt;/li&gt;  &lt;li&gt;&lt;b&gt;天津市&lt;/b&gt;      &lt;ul&gt;          &lt;li&gt;河东区&lt;/li&gt;          &lt;li&gt;河西区&lt;/li&gt;          &lt;li&gt;河北区&lt;/li&gt;          &lt;li&gt;南开区&lt;/li&gt;      &lt;/ul&gt;  &lt;/li&gt;&lt;/ul&gt;</code></pre><p>声明：ul的儿子，只能是li。但是li是一个容器级标签，li里面什么都能放。也可以再放一个ul。</p><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p>表格标签用<code>&lt;table&gt;</code>表示。一个表格<code>&lt;table&gt;</code>是由每行<code>&lt;tr&gt;</code>组成的，每行是由<code>&lt;td&gt;</code>组成的。所以我们要记住，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。但是现在在做页面的时候，表格作用还是有一些的。</p><p>例如，一行的单元格：</p><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><p>上面的表格中没有加文字，所以在生成的网页中什么都看不到。</p><p>例如，3行4列的单元格：</p><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;id&lt;/td&gt;        &lt;td&gt;书名&lt;/td&gt;        &lt;td&gt;作者&lt;/td&gt;        &lt;td&gt;出版社&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;1&lt;/td&gt;        &lt;td&gt;天龙八部&lt;/td&gt;        &lt;td&gt;金庸&lt;/td&gt;        &lt;td&gt;沙河出版社&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;2&lt;/td&gt;        &lt;td&gt;鹿鼎记&lt;/td&gt;        &lt;td&gt;金庸&lt;/td&gt;        &lt;td&gt;西二旗出版社&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;3&lt;/td&gt;        &lt;td&gt;侠客岛&lt;/td&gt;        &lt;td&gt;金庸&lt;/td&gt;        &lt;td&gt;上地出版社&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><p>这样的表格好像没看到边框呀，不急，接下来看看<code>&lt;table&gt;</code>标签的属性。</p><table>的属性：<ul><li><ul><li><code>border</code>：边框。像素为单位。</li><li><code>style=&quot;border-collapse:collapse;&quot;</code>：单元格的线和表格的边框线合并</li><li><code>width</code>：宽度。像素为单位。</li><li><code>height</code>：高度。像素为单位。</li><li><code>bordercolor</code>：表格的边框颜色。</li><li><code>align</code>：<strong>表格</strong>的水平对齐方式。属性值可以填：left right center。注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签<code>&lt;td&gt;</code>进行设置）</li><li><code>cellpadding</code>：单元格内容到边的距离，像素为单位。默认情况下，文字是紧挨着左边那条线的，即默认情况下的值为0。注意不是单元格内容到四条边的距离哈，而是到一条边的距离，默认是与左边那条线的距离。如果设置属性<code>dir=&quot;rtl&quot;</code>，那就指的是内容到右边那条线的距离。</li><li><code>cellspacing</code>：单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0</li><li><code>bgcolor=&quot;#99cc66&quot;</code>：表格的背景颜色。</li><li><code>background=&quot;路径src/...&quot;</code>：背景图片。背景图片的优先级大于背景颜色。</li></ul></li></ul><p>单元格带边框的效果：</p><p>备注：表格中很细表格边线的制作：CSS的写法：</p><pre><code>style=&quot;border-collapse:collapse;&quot;</code></pre><h4 id="lt-tr-gt-：行"><a href="#lt-tr-gt-：行" class="headerlink" title="&lt;tr&gt;：行"></a><code>&lt;tr&gt;</code>：行</h4><p>一个表格就是一行一行组成的嘛。<strong>属性：</strong></p><ul><li><code>dir</code>：公有属性，设置这一行单元格内容的排列方式。可以取值：<code>ltr</code>：从左到右（left to right，默认），<code>rtl</code>：从右到左（right to left）</li><li><code>bgcolor</code>：设置这一行的单元格的背景色。注：没有background属性，即：无法设置这一行的背景图片，如果非要设置，可以用css实现。</li><li><code>height</code>：一行的高度</li><li><code>align=&quot;center&quot;</code>：一行的内容水平居中显示，取值：left、center、right</li><li><code>valign=&quot;center&quot;</code>：一行的内容垂直居中，取值：top、middle、bottom</li></ul><h4 id="lt-td-gt-：单元格"><a href="#lt-td-gt-：单元格" class="headerlink" title="&lt;td&gt;：单元格"></a><code>&lt;td&gt;</code>：单元格</h4><p><strong>属性：</strong></p><ul><li><code>align</code>：内容的横向对齐方式。属性值可以填：left right center。如果想让每个单元格的内容都居中，这个属性太麻烦了，以后用css来解决。</li><li><code>valign</code>：内容的纵向对齐方式。属性值可以填：top middle bottom</li><li><code>width</code>：绝对值或者相对值(%)</li><li><code>height</code>：单元格的高度</li><li><code>bgcolor</code>：设置这个单元格的背景色。</li><li><code>background</code>：设置这个单元格的背景图片。</li></ul><h4 id="单元格的合并"><a href="#单元格的合并" class="headerlink" title="单元格的合并"></a>单元格的合并</h4><p>如果要将两个单元格合并，那肯定就要删掉一个单元格。单元格的属性：</p><ul><li><ul><li><code>colspan</code>：横向合并。例如<code>colspan=&quot;2&quot;</code>表示当前单元格在水平方向上要占据两个单元格的位置。</li><li><code>rowspan</code>：纵向合并。例如<code>rowspan=&quot;2&quot;</code>表示当前单元格在垂直方向上</li></ul></li></ul><h4 id="lt-th-gt-：加粗的单元格。相当于-lt-td-gt-lt-b-gt"><a href="#lt-th-gt-：加粗的单元格。相当于-lt-td-gt-lt-b-gt" class="headerlink" title="&lt;th&gt;：加粗的单元格。相当于&lt;td&gt; + &lt;b&gt;"></a><code>&lt;th&gt;</code>：加粗的单元格。相当于<code>&lt;td&gt;</code> + <code>&lt;b&gt;</code></h4><ul><li>属性同<code>&lt;td&gt;</code>标签</li></ul><h4 id="lt-caption-gt-：表格的标题。使用时和tr标签并列"><a href="#lt-caption-gt-：表格的标题。使用时和tr标签并列" class="headerlink" title="&lt;caption&gt;：表格的标题。使用时和tr标签并列"></a><code>&lt;caption&gt;</code>：表格的标题。使用时和<code>tr</code>标签并列</h4><h4 id="表格的-lt-thead-gt-标签、-lt-tbody-gt-标签、-lt-tfoot-gt-标签"><a href="#表格的-lt-thead-gt-标签、-lt-tbody-gt-标签、-lt-tfoot-gt-标签" class="headerlink" title="表格的&lt;thead&gt;标签、&lt;tbody&gt;标签、&lt;tfoot&gt;标签"></a>表格的<code>&lt;thead&gt;</code>标签、<code>&lt;tbody&gt;</code>标签、<code>&lt;tfoot&gt;</code>标签</h4><p>这三个标签有与没有的区别：</p><ul><li>1、如果写了，那么这三个部分的<strong>代码顺序可以任意</strong>，浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候是从按照代码的从上到下的顺序来显示。</li><li>2、当表格非常大内容非常多的时候，如果用thead、tbody、tfoot标签的话，那么<strong>数据可以边获取边显示</strong>。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。</li></ul><p>例子：</p><pre><code>&lt;table border=&quot;1&quot; style=&quot;border-collapse: collapse&quot;&gt;    &lt;tr&gt;        &lt;td&gt;id&lt;/td&gt;        &lt;td&gt;书名&lt;/td&gt;        &lt;td&gt;作者&lt;/td&gt;        &lt;td&gt;出版社&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;1&lt;/td&gt;        &lt;td&gt;天龙八部&lt;/td&gt;        &lt;td&gt;金庸&lt;/td&gt;        &lt;td&gt;沙河出版社&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;2&lt;/td&gt;        &lt;td&gt;鹿鼎记&lt;/td&gt;        &lt;td&gt;金庸&lt;/td&gt;        &lt;td&gt;西二旗出版社&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;3&lt;/td&gt;        &lt;td&gt;侠客岛&lt;/td&gt;        &lt;td&gt;金庸&lt;/td&gt;        &lt;td&gt;上地出版社&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;4&lt;/td&gt;        &lt;td&gt;倚天屠龙记&lt;/td&gt;        &lt;td&gt;金庸&lt;/td&gt;        &lt;td&gt;老男孩儿出版社&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><h3 id="表单标签：-lt-form-gt"><a href="#表单标签：-lt-form-gt" class="headerlink" title="表单标签：&lt;form&gt;****"></a>表单标签：<code>&lt;form&gt;****</code></h3><ul><li><p>form表单用于与服务器的交互，将用户填入表单的信息提交到服务器。</p></li><li><p>form表单属性</p><ul><li><p>action：指定表单数据发送的url。</p></li><li><p>method：表单数据的提交方式</p><ul><li><p>get（默认）</p></li><li><p>post</p></li><li><p>get提交和post提交的区别：GET方式：将表单数据，以”name=value”形式追加到action指定的处理程序的后面，两者间用”?”隔开，每一个表单的”name=value”间用”&amp;”号隔开。特点：只适合提交少量信息，并且不太安全(不要提交敏感数据)、提交的数据类型只限于ASCII字符。</p><p>POST方式：将表单数据直接发送(隐藏)到action指定的处理程序。POST发送的数据不可见。Action指定的处理程序可以获取到表单数据。特点：可以提交海量信息，相对来说安全一些，提交的数据格式是多样的(Word、Excel、rar、img)。</p></li></ul></li><li><p><strong>Enctype：</strong></p><p>表单数据的编码方式(加密方式)，取值可以是：application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。</p><ul><li>Application/x-www-form-urlencoded：<strong>默认</strong>加密方式，除了上传文件之外的数据都可以</li><li>Multipart/form-data：<strong>上传附件时，必须使用这种编码方式</strong>。</li></ul></li></ul></li><li><p>input（输入标签）</p><ul><li>name=”数据名” 要提交的数据的名字</li><li>type=”属性值“：标签的文本类型<ul><li>text（默认）</li><li>password 密码</li><li>radio 单选按钮，name相同的radio作为一组，组内互斥，只能选中其中的一个，（必须是name相同的一组中的内容，才会互斥）</li><li>checkbox 多选按钮，name相同的作为一组，可以选择多个</li><li>button 普通按钮</li><li>submit 提交按钮，点击该按钮，会将表单中的数据按照method的请求方式，提交到action对应的url中</li><li>reset 重置当前表单内的所有内容</li><li>image 图片按钮，和提交按钮的功能完全一致，只不过图片按钮可以显示图片。</li><li>file<ul><li>上传文件到服务器，要上传文件，form表单的method必须是post，并且在form标签中设置属性<code>enctype=&quot;multipart/form-data&quot;</code></li></ul></li></ul></li><li>value=”内容“：文本框里的默认内容（已经被填好的）</li><li>size=“50”：表示文本框可以显示50个字符。</li><li>readonly 输入框只读</li><li>disabled</li><li>checked 选择框默认选中</li></ul></li><li><p>select标签</p><ul><li><code>&lt;select&gt;</code>标签里面的每一项用<code>&lt;option&gt;</code>表示。select就是“选择”，option“选项”。select标签和ul、ol、dl一样，都是组标签。</li><li><code>&lt;select&gt;</code>标签的属性：<ul><li><code>multiple</code>：可以对下拉列表中的选项进行多选。没有属性值。</li><li><code>size=&quot;3&quot;</code>：如果属性值大于1，则列表为滚动视图。默认属性值为1，即下拉视图。</li></ul></li><li><code>&lt;option&gt;</code>标签的属性：<ul><li><code>selected</code>：预选中。没有属性值。</li></ul></li></ul></li><li><p>textarea</p><ul><li><p>text就是“文本”，area就是“区域”。</p><p><strong>属性：</strong></p><ul><li><code>value</code>：提交给服务器的值。</li><li><code>rows=&quot;4&quot;</code>：指定文本区域的行数。</li><li><code>cols=&quot;20&quot;</code>：指定文本区域的列数。</li><li><code>readonly</code>：只读。</li></ul></li></ul></li><li><p>label标签</p><ul><li>通过for属性，将lable和input标签绑定，为 input 元素定义标注（标记）。</li></ul></li><li><p>表单语义化</p><ul><li><p>比如，我们在注册一个网站的信息的时候，有一部分是必填信息，有一部分是选填信息，这个时候可以利用表单的语义化。</p></li><li><pre><code>&lt;form&gt;    &lt;fieldset&gt;        &lt;legend&gt;账号信息&lt;/legend&gt;        姓名：&lt;input value=&quot;呵呵&quot;&gt;        密码：&lt;input type=&quot;password&quot; value=&quot;pwd&quot; size=&quot;50&quot;&gt;&lt;br&gt;    &lt;/fieldset&gt;    &lt;fieldset&gt;        &lt;legend&gt;其他信息&lt;/legend&gt;        性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked=&quot;&quot;&gt;男        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt;女&lt;br&gt;        爱好：&lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;eat&quot;&gt;吃饭        &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;sleep&quot;&gt;睡觉        &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;bat&quot;&gt;打豆豆    &lt;/fieldset&gt;&lt;/form&gt;</code></pre></li></ul></li></ul><h4 id="form表单实例"><a href="#form表单实例" class="headerlink" title="form表单实例"></a>form表单实例</h4><p>1、百度搜索</p><pre><code>&lt;form action=&quot;https://www.baidu.com/s&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;wd&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;百度一下&quot;&gt;&lt;/form&gt;</code></pre><p>2、百度注册页面（HTML）</p><pre><code>&lt;form action=&quot;&quot;&gt;    &lt;p&gt;        &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt;        &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label for=&quot;tel&quot;&gt;手机号：&lt;/label&gt;        &lt;input type=&quot;text&quot; id=&quot;tel&quot; name=&quot;tel&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt;        &lt;input type=&quot;password&quot; id=&quot;password&quot;name=&quot;password&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label for=&quot;verifycode&quot;&gt;验证码：&lt;/label&gt;        &lt;input type=&quot;text&quot; id=&quot;verifycode&quot;name=&quot;verifycode&quot;&gt;        &lt;button&gt;获取验证码&lt;/button&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type=&quot;checkbox&quot; id=&quot;isagree&quot;&gt;        &lt;label for=&quot;isagree&quot;&gt;            阅读并接受 &lt;a href=&quot;#&quot;&gt;《百度用户协议》&lt;/a&gt;            及 &lt;a href=&quot;#&quot;&gt;《百度隐私权保护声明》&lt;/a&gt;        &lt;/label&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;    &lt;/p&gt;&lt;/form&gt;</code></pre></style></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础之BOM和DOM</title>
      <link href="2019/11/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BBOM%E5%92%8CDOM/"/>
      <url>2019/11/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BBOM%E5%92%8CDOM/</url>
      
        <content type="html"><![CDATA[<h1 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h1><p>　　到目前为止，我们已经学过了JavaScript的一些简单的语法。但是这些简单的语法，并没有和浏览器有任何交互。</p><p>　　也就是我们还不能制作一些我们经常看到的网页的一些交互，我们需要继续学习BOM和DOM相关知识。</p><p>　　JavaScript分为 ECMAScript，DOM，BOM。</p><p>　　BOM（Browser Object Model）是指浏览器对象模型，它使 JavaScript 有能力与浏览器进行“对话”。</p><p>　　DOM （Document Object Model）是指文档对象模型，通过它，可以访问HTML文档的所有元素。</p><p>　　Window对象是客户端JavaScript最高层对象之一，由于window对象是其它大部分对象的共同祖先，在调用window对象的方法和属性时，可以省略window对象的引用。例如：window.document.write()可以简写成：document.write()。</p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190107143727135-751871868.png" alt="img"></p><p>　　看上面的例子你会发现，name直接封装到了window对象上，了解一下就可以了。</p><p>　　所有浏览器都支持 window 对象。它表示浏览器窗口。</p><p>　　*<em>如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象（了解）。</em></p><p>　　*<em>没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象（了解）。</em></p><p>　　所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p><p>　　全局变量是 window 对象的属性。全局函数是 window 对象的方法。</p><p>　　接下来要讲的HTML DOM 的 document 也是 window 对象的属性之一。</p><p>　　一些常用的Window方法：（在浏览器调试器的console里面输入下面这些属性或者方法，就能看到对应的效果）</p><ul><li>window.innerHeight - 浏览器窗口的内部高度</li><li>window.innerWidth - 浏览器窗口的内部宽度</li><li>window.open() - 打开新窗口</li><li>window.close() - 关闭当前窗口 (只能关闭用js的window.open()打开的页面，了解一下就行了)</li></ul><h2 id="window的子对象"><a href="#window的子对象" class="headerlink" title="window的子对象"></a>window的子对象</h2><h3 id="navigator对象（了解即可）"><a href="#navigator对象（了解即可）" class="headerlink" title="　　navigator对象（了解即可）"></a>　　navigator对象（了解即可）</h3><p>　　　　浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息。</p><pre><code>navigator.appName　　// Web浏览器全称navigator.appVersion　　// Web浏览器厂商和版本的详细字符串navigator.userAgent　　// 客户端绝大部分信息navigator.platform　　　// 浏览器运行所在的操作系统</code></pre><p>　　　　看示例：</p><h3 id=""><a href="#" class="headerlink" title="　　　　"></a>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190107180301299-2021162138.png" alt="img"></h3><h3 id="screen对象（了解即可）"><a href="#screen对象（了解即可）" class="headerlink" title="　　screen对象（了解即可）"></a>　　screen对象（了解即可）</h3><p>　　　　屏幕对象，不常用。</p><p>　　　　一些属性：</p><ul><li>screen.availWidth - 可用的屏幕宽度</li><li>screen.availHeight - 可用的屏幕高度</li></ul><h3 id="history对象（了解即可）"><a href="#history对象（了解即可）" class="headerlink" title="　　history对象（了解即可）"></a>　　history对象（了解即可）</h3><p>　　　　window.history 对象包含浏览器的历史。</p><p>　　　　浏览历史对象，包含了用户对当前页面的浏览历史，但我们无法查看具体的地址，可以简单的用来前进或后退一个页面。</p><pre><code>history.forward()  // 前进一页，其实也是window的属性，window.history.forward()history.back()  // 后退一页</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190107181048061-1068527309.png" alt="img"></p><h3 id="location对象"><a href="#location对象" class="headerlink" title="　　location对象"></a>　　location对象</h3><p>　　　　window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。</p><p>　　　　常用属性和方法：</p><pre><code>location.href  获取URLlocation.href="URL" // 跳转到指定页面location.reload() 重新加载页面,就是刷新一下页面</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190107181411060-1536721355.png" alt="img"></p><p>　　</p><p>　　上面的内容需要大家记住的是：</p><p>　　　　1.window对象</p><p>　　　　2.window的子对象：location的那几个属性和方法</p><p>　　　　3.其他的作为了解</p><p>　　我们下面来学些比较有意思有用的内容：</p><h3 id="弹出框"><a href="#弹出框" class="headerlink" title="　　弹出框"></a>　　弹出框</h3><p>　　　　可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框。</p><p>　　<strong>警告框</strong></p><p>　　　　警告框经常用于确保用户可以得到某些信息。</p><p>　　　　当警告框出现后，用户需要点击确定按钮才能继续进行操作。</p><p>　　　　语法：</p><pre><code>alert("你看到了吗？");</code></pre><p>　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190108161125227-523196490.png" alt="img"></strong></p><p>　　<strong>确认框（了解即可）</strong></p><p>　　　　确认框用于使用户可以验证或者接受某些信息。</p><p>　　　　当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。</p><p>　　　　如果用户点击确认，那么返回值为 true。如果用户点击取消，那么返回值为 false。</p><p>　　　　语法：</p><pre><code>confirm("你确定吗？")</code></pre><p>　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190108161230372-1797799681.png" alt="img"></strong></p><p>　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190108161305106-1505220878.png" alt="img"></p><p>　　　　我们可以根据返回的true和false来判断一下，然后根据这个值来使用location去跳转对应的网站。</p><p>　　<strong>提示框（了解即可）</strong></p><p>　　　　提示框经常用于提示用户在进入页面前输入某个值。</p><p>　　　　当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。</p><p>　　　　如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为默认值，就是第二个参数，如果没有默认值那么返回null。</p><p>　　　　语法：</p><pre><code>prompt("请在下方输入","你的答案")</code></pre><h3 id="-1"><a href="#-1" class="headerlink" title="　　　　"></a>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190108161643066-1970894455.png" alt="img"></h3><p>　　　　可以通过用户输入的内容来判断我们怎么去进行后面的操作</p><p>　　除了那个警告框（用的也不都），其他的都很少用，比较丑陋，了解一下就行</p><h3 id="计时相关（比较重要）"><a href="#计时相关（比较重要）" class="headerlink" title="　　计时相关（比较重要）"></a>　　计时相关（比较重要）</h3><p>　　　　通过使用 JavaScript，我们可以在一定时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。</p><p>　　　　<strong>setTimeout()  一段时间后做一些事情</strong></p><p>　　　　　　语法：</p><pre><code>var t=setTimeout("JS语句",毫秒)  第一个参数js语句多数是写一个函数，不然一般的js语句到这里就直接执行了，先用函数封装一下，返回值t其实就是一个id值（浏览器给你自动分配的）</code></pre><p>　　　　　　setTimeout() 方法会返回某个值。在上面的语句中，值被储存在名为 t 的变量中。假如你希望取消这个 setTimeout()，你可以使用这个变量名来指定它。</p><p>　　　　　　setTimeout() 的第一个参数是含有 JavaScript 语句的字符串。这个语句可能诸如 “alert(‘5 seconds!’)”，或者对函数的调用，诸如 alertMsg()”。</p><p>　　　　　　第二个参数指示从当前起多少毫秒后执行第一个参数（1000 毫秒等于一秒）。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190108162921143-1654295051.png" alt="img"></p><p>　　　　<strong>clearTimeout()</strong></p><p>　　　　　　语法：</p><pre><code>clearTimeout(setTimeout_variable)</code></pre><p>　　　　举个例子<strong>：</strong></p><pre><code>// 在指定时间之后执行一次相应函数var timer = setTimeout(function(){alert(123);}, 3000)// 取消setTimeout设置clearTimeout(timer);</code></pre><p>　　　　<strong>setInterval() 每隔一段时间做一些事情</strong></p><p>　　　　　　setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。</p><p>　　　　　　setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。</p><p>　　　　　　语法：</p><pre><code>setInterval("JS语句",时间间隔)</code></pre><p>　　　　　　返回值</p><p>　　　　　　一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值。</p><p>　　　　<strong>clearInterval()</strong></p><p>　　　　　　clearInterval() 方法可取消由 setInterval() 设置的 timeout。</p><p>　　　　　　clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值。</p><p>　　　　　　语法：</p><pre><code>clearInterval(setinterval返回的ID值)</code></pre><p>　　　　　　举个例子：</p><pre><code>// 每隔一段时间就执行一次相应函数var timer = setInterval(function(){console.log(123);}, 3000)// 取消setInterval设置clearInterval(timer);</code></pre><p>　　　　　　</p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>　　DOM（Document Object Model）是一套对文档的内容进行抽象和概念化的方法。 </p><p>　　当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。</p><p>　　HTML DOM 模型被构造为对象的树。</p><h2 id="HTML-DOM-树"><a href="#HTML-DOM-树" class="headerlink" title="　　HTML DOM 树"></a>　　HTML DOM 树</h2><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/867021-20180312215352312-132101897.png" alt="img"></p><p>　　DOM标准规定HTML文档中的每个成分都是一个节点(node)：</p><ul><li>文档节点(document对象)：代表整个文档</li><li>元素节点(element 对象)：代表一个元素（标签）</li><li>文本节点(text对象)：代表元素（标签）中的文本</li><li>属性节点(attribute对象)：代表一个属性，元素（标签）才有属性</li><li>注释是注释节点(comment对象)　</li></ul><p>　　JavaScript 可以通过DOM创建动态的 HTML：</p><ul><li>JavaScript 能够改变页面中的所有 HTML 元素</li><li>JavaScript 能够改变页面中的所有 HTML 属性</li><li>JavaScript 能够改变页面中的所有 CSS 样式</li><li>JavaScript 能够对页面中的所有事件做出反应（鼠标点击事件，鼠标移动事件等）</li></ul><h2 id="查找标签（和css一样，你想操作某个标签需要先找到它）"><a href="#查找标签（和css一样，你想操作某个标签需要先找到它）" class="headerlink" title="　　查找标签（和css一样，你想操作某个标签需要先找到它）"></a>　　查找标签（和css一样，你想操作某个标签需要先找到它）</h2><h3 id="直接查找"><a href="#直接查找" class="headerlink" title="　　　　直接查找"></a>　　　　直接查找</h3><pre><code>document.getElementById           根据ID获取一个标签document.getElementsByClassName   根据class属性获取（可以获取多个元素，所以返回的是一个数组）document.getElementsByTagName     根据标签名获取标签合集</code></pre><p>　　　　例子：　</p><p>　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114143608764-554851001.png" alt="img"></p><h3 id="间接查找"><a href="#间接查找" class="headerlink" title="　　　　间接查找"></a>　　　　间接查找</h3><pre><code>parentElement            父节点标签元素children                 所有子标签firstElementChild        第一个子标签元素lastElementChild         最后一个子标签元素nextElementSibling       下一个兄弟标签元素previousElementSibling   上一个兄弟标签元素</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190108212928892-787715039.png" alt="img"></p><p>　　　如果查找出来的内容是个数组，那么就可以通过索引来取对应的标签对象</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190123164539521-1719344894.png" alt="img"></p><p>　　上面说的这些查找标签的方法，以后我们很少用，等学了JQuery，会有很好用、更全的查找标签的功能，上面这些大家简单练习一下，有个了解就行了。</p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="　　节点操作"></a>　　节点操作</h2><h3 id="创建节点（就是创建标签）"><a href="#创建节点（就是创建标签）" class="headerlink" title="　　　　创建节点（就是创建标签）"></a>　　　　创建节点（就是创建标签）</h3><p>　　　　　　语法：</p><p>　　　　　　createElement(标签名)</p><p>　　　　　　示例：</p><pre><code>var divEle = document.createElement("div");</code></pre><p>　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114144346770-1679768028.png" alt="img"></p><p>　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114144613105-1817427819.png" alt="img"></p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="　　　添加节点"></a>　　　添加节点</h3><p>　　　　　　语法：</p><p>　　　　　　追加一个子节点（作为最后的子节点）</p><p>　　　　　　somenode.appendChild(newnode)；</p><p>　　　　　　把增加的节点放到某个节点的前边。</p><p>　　　　　　somenode.insertBefore(newnode,某个节点);</p><p>　　　　　　示例：</p><pre><code>var imgEle=document.createElement("img");imgEle.setAttribute("src", "http://image11.m1905.cn/uploadfile/s2010/0205/20100205083613178.jpg");var d1Ele = document.getElementById("d1");d1Ele.appendChild(imgEle);</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114163940975-500045384.png" alt="img"></p><h3 id="删除节点："><a href="#删除节点：" class="headerlink" title="　　　    删除节点："></a>　　　    删除节点：</h3><p>　　　　　　语法：</p><p>　　　　　　获得要删除的元素，通过父元素调用该方法删除。</p><p>　　　　　　somenode.removeChild(要删除的节点)</p><h3 id="替换节点："><a href="#替换节点：" class="headerlink" title="　　　　替换节点："></a>　　　　替换节点：</h3><p>　　　　　　语法：</p><p>　　　　　　somenode.replaceChild(newnode, 某个节点);</p><p>　　　　　　somenode是父级标签，然后找到这个父标签里面的要被替换的子标签，然后用新的标签将该子标签替换掉</p><h3 id="属性节点"><a href="#属性节点" class="headerlink" title="　　　　属性节点"></a>　　　　属性节点</h3><p>　　　　　　获取文本节点的值：</p><pre><code>var divEle = document.getElementById("d1")divEle.innerText  #输入这个指令，一执行就能获取该标签和内部所有标签的文本内容divEle.innerHTML  #获取的是该标签内的所有内容，包括文本和标签</code></pre><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114165125386-23225020.png" alt="img"></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114165355096-1495510388.png" alt="img"></p><p>　　　　　　设置文本节点的值：</p><pre><code>var divEle = document.getElementById("d1")divEle.innerText="1"  divEle.innerHTML="&lt;p&gt;2&lt;/p&gt;" #能识别成一个p标签</code></pre><p>　　　　　　<strong>attribute操作</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var divEle = document.getElementById("d1");divEle.setAttribute("age","18")  #比较规范的写法divEle.getAttribute("age")divEle.removeAttribute("age")// 自带的属性还可以直接.属性名来获取和设置，如果是你自定义的属性，是不能通过.来获取属性值的imgEle.srcimgEle.src="..."</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="获取值操作"><a href="#获取值操作" class="headerlink" title="　　　　获取值操作"></a>　　　　获取值操作</h3><p>　　　　　　语法：</p><p>　　　　　　elementNode.value</p><p>　　　　　　适用于以下标签，用户输入或者选择类型的标签：</p><p>　　　　　　1.input   </p><p>　　　　　　2.select</p><p>　　　　　　3.textarea </p><pre><code>var iEle = document.getElementById("i1");console.log(iEle.value);var sEle = document.getElementById("s1");console.log(sEle.value);var tEle = document.getElementById("t1");console.log(tEle.value);</code></pre><p>　　　　　　　例如：页面上有下面三个标签</p><p>　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114172404256-68629120.png" alt="img"></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114172519468-1074650452.png" alt="img"></p><p>　　　　　　</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114172625124-2122283084.png" alt="img"></p><h3 id="class的操作"><a href="#class的操作" class="headerlink" title="　　　　class的操作"></a>　　　　class的操作</h3><pre><code>className  获取所有样式类名(字符串)classList.remove(cls)  删除指定类classList.add(cls)  添加类classList.contains(cls)  存在返回true，否则返回falseclassList.toggle(cls)  存在就删除，否则添加，toggle的意思是切换，有了就给你删除，如果没有就给你加一个</code></pre><p>　　　　　　例如：我想将c2的类加到class里面去</p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114172940839-232175846.png" alt="img"></p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114173059999-1233980566.png" alt="img"></p><p>　　　　　　</p><h3 id="指定CSS操作"><a href="#指定CSS操作" class="headerlink" title="　　　　指定CSS操作"></a>　　　　<strong>指定CSS操作</strong></h3><pre><code>obj.style.backgroundColor="red"</code></pre><p>　　　　　　JS操作CSS属性的规律：</p><p>　　　　　　1.对于没有中横线的CSS属性一般直接使用style.属性名即可。如：</p><pre><code>obj.style.marginobj.style.widthobj.style.leftobj.style.position</code></pre><p>　　　　　　　　</p><p>　　　　　　2.对含有中横线的CSS属性，将中<strong>横线后面的第一个字母换成大写</strong>即可。如：</p><pre><code>obj.style.marginTopobj.style.borderLeftWidthobj.style.zIndexobj.style.fontFamily</code></pre><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114173249330-865346984.png" alt="img"></p><p>　　我们上面所说的这些修改样式的方法，是不是应该应用在用户的某些操作上啊，如果你用户点击了某个内容，让它变变颜色之类的，给用户一些好看的效果或者指示的效果啊，所以这就要和我们下面要学的事件结合起来要做的事情，通过事件+上面的样式修改来实现。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>　　HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。</p><h3 id="常用事件-就先讲一下onfocus，onblur，onclick，onchange吧，其他的回头再说"><a href="#常用事件-就先讲一下onfocus，onblur，onclick，onchange吧，其他的回头再说" class="headerlink" title="　　常用事件(就先讲一下onfocus，onblur，onclick，onchange吧，其他的回头再说~~)"></a>　　常用事件(就先讲一下onfocus，onblur，onclick，onchange吧，其他的回头再说~~)</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>onclick        当用户点击某个对象时调用的事件句柄。ondblclick     当用户双击某个对象时调用的事件句柄。onfocus        元素获得焦点。               // 练习：输入框onblur         元素失去焦点。               应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.onchange       域的内容被改变。             应用场景：通常用于表单元素,当元素内容被改变时触发.（select联动）onkeydown      某个键盘按键被按下。          应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.onkeypress     某个键盘按键被按下并松开。onkeyup        某个键盘按键被松开。onload         一张页面或一幅图像完成加载。onmousedown    鼠标按钮被按下。onmousemove    鼠标被移动。onmouseout     鼠标从某元素移开。onmouseover    鼠标移到某元素之上。onselect      在文本框中的文本被选中时发生。onsubmit      确认按钮被点击，使用的对象是form。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="绑定方式："><a href="#绑定方式：" class="headerlink" title="　　绑定方式："></a>　　绑定方式：</h3><p>　　　　方式一：（已经不常用了，多数用方式二了）</p><pre><code>&lt;div id="d1" onclick="changeColor(this);"&gt;点我&lt;/div&gt;  &lt;script&gt;    function changeColor(ths) {      ths.style.backgroundColor="green";  }&lt;/script&gt;</code></pre><p>　　　　注意：</p><p>　　　　　　this是实参，表示触发事件的当前元素。</p><p>　　　　　　函数定义过程中的ths为形参。</p><p>　　　　方式二：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;div id="d2"&gt;点我&lt;/div&gt;&lt;script&gt;  var divEle2 = document.getElementById("d2");  divEle2.onclick=function () {　　 //console.log(this)    this.innerText="呵呵"; #哪个标签触发的这个事件，this就指向谁  }&lt;/script&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　</p><p>　　　　注意一个问题：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114200441880-1120527283.png" alt="img"></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114200343303-1328666434.png" alt="img"></p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114200505296-472950193.png" alt="img"></p><p>　　　　　　还有一种解决办法就是将script标签写到body标签最下面</p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190114200838248-496411228.png" alt="img"></p><p>　　　　　　</p><p>　　　　结合计时器的事件示例:</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;定时器&lt;/title&gt;  &lt;script&gt;  //当js代码中有找标签的操作的时候，别忘了页面加载的时候的顺序，以防出现找不到标签的情况出现，我们可以将这个script标签放到body标签最下面，或者用window.onload，这里我没有放，你们练习的时候放到下面去    var intervalId; //用来保存定时器对象，因为开始定时器是一个函数，结束定时器是一个函数，两个函数都是操作的一个定时器，让他们互相能够操作这个定时器，就需要一个全局变量来接受一下这个对象　　　　　　//把当前事件放到id为i1的input标签里面    function f() {      var timeStr = (new Date()).toLocaleString(); // 1.拿到当前事件      var inputEle = document.getElementById("i1");// 2.获取input标签对象      inputEle.value = timeStr;  //3.将事件赋值给input标签的value属性    }　　//开始定时任务    function start() {      f();      if (intervalId === undefined) { //如果不加这个判断条件，你每次点击开始按钮，就创建一个定时器，每点一次就创建一个定时器，点的次数多了就会在页面上生成好多个定时器，并且点击停止按钮的时候，只能停止最后一个定时器，这样不好，也不对，所以加一个判断        intervalId = setInterval(f, 1000);      }    }    //结束定时任务    function end() {      clearInterval(intervalId); //　清除对应的那个定时器      intervalId = undefined;    }  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="i1"&gt;&lt;input type="button" value="开始" id="start" onclick="start();"&gt;&lt;input type="button" value="结束" id="end" onclick="end();"&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　事件示例：</p><p>　　　　　　搜索框示例：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;搜索框示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id="d1" type="text" value="请输入关键字" onblur="blur()" onfocus="focus()"&gt;&lt;script&gt;function focus(){  //如果在标签中写的blur()等方法，没有传入this参数，那么我们就需要自己来获取一下这个标签，例如下面的getElementById('d1')    var inputEle=document.getElementById("d1");    if (inputEle.value==="请输入关键字"){        inputEle.value="";　　　　 //inputEle.setAttribute('value','')    }}function blur(){    var inputEle=document.getElementById("d1");    var val=inputEle.value;    if(!val.trim()){        inputEle.value="请输入关键字";    }}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　select联动：选择省份，自动列出所有的城市，例如：选择河北省就显示河北省所有的市</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;select联动&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;select id="province"&gt;  &lt;option&gt;请选择省:&lt;/option&gt;&lt;/select&gt;&lt;select id="city"&gt;  &lt;option&gt;请选择市:&lt;/option&gt;&lt;/select&gt;&lt;script&gt;  data = {"河北省": ["廊坊", "邯郸"], "北京": ["朝阳区", "海淀区"], "山东": ["威海市", "烟台市"]};  var p = document.getElementById("province");  var c = document.getElementById("city");  //页面一刷新就将所有的省份都添加到select标签中  for (var i in data) {    var optionP = document.createElement("option"); //创建option标签    optionP.innerHTML = i; //将省份的数据添加到option标签中    p.appendChild(optionP);//将option标签添加到select标签中  }  //只要select中选择的值发生变化的时候，就可以触发一个onchange事件，那么我们就可以通过这个事件来完成select标签联动  p.onchange = function () {    //1.获取省的值    var pro = (this.options[this.selectedIndex]).innerHTML;//this.selectedIndex是当前选择的option标签的索引位置，this.options是获取所有的option标签，通过索引拿到当前选择的option标签对象，然后.innerHTML获取对象中的内容，也就是省份    //还可以这样获取省：var pro = this.value;    var citys = data[pro]; //2. 通过上面获得的省份去data里面取出该省对应的所有的市    // 3. 清空option    c.innerHTML = ""; //清空显示市的那个select标签里面的内容　　    //4.循环所有的市，然后添加到显示市的那个select标签中    for (var i=0;i&lt;citys.length;i++) {      var option_city = document.createElement("option");      option_city.innerHTML = citys[i];      c.appendChild(option_city);    }  }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　window.onload</p><p>　　　　当我们给页面上的元素绑定事件的时候，必须等到文档加载完毕。因为我们无法给一个不存在的元素绑定事件。</p><p>　　　　window.onload事件在文件加载过程结束的时候触发。此时，文档中的所有对象都位于DOM中，并且所有图像，脚本，链接和子框架都已完成加载。</p><p>　　　　注意：.onload()函数存在覆盖现象。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap框架和inconfont、font-awesome使用</title>
      <link href="2019/11/15/%E5%89%8D%E7%AB%AF/Bootstrap%E6%A1%86%E6%9E%B6%E5%92%8Cinconfont%E3%80%81font-awesome%E4%BD%BF%E7%94%A8/"/>
      <url>2019/11/15/%E5%89%8D%E7%AB%AF/Bootstrap%E6%A1%86%E6%9E%B6%E5%92%8Cinconfont%E3%80%81font-awesome%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>　　iconfont的使用：<a href="https://www.cnblogs.com/clschao/articles/10387580.html">https://www.cnblogs.com/clschao/articles/10387580.html</a></p><h2 id="Bootstrap介绍"><a href="#Bootstrap介绍" class="headerlink" title="Bootstrap介绍"></a>Bootstrap介绍</h2><p>　　Bootstrap是Twitter开源的基于HTML、CSS、JavaScript的前端框架。</p><p>　　它是为实现快速开发Web应用程序而设计的一套前端工具包。</p><p>　　它支持响应式布局，并且在V3版本之后坚持移动设备优先。</p><p>​       就是复制黏贴一把梭，html\css\js代码的封装组合</p><h2 id="为什么要使用Bootstrap？"><a href="#为什么要使用Bootstrap？" class="headerlink" title="为什么要使用Bootstrap？"></a>为什么要使用Bootstrap？</h2><p>　　在Bootstrap出现之前：</p><p>　　命名：重复、复杂、无意义（想个名字费劲）</p><p>　　样式：重复、冗余、不规范、不和谐</p><p>　　页面：错乱、不规范、不和谐</p><p>　　在使用Bootstrap之后： 各种命名都统一并且规范化。 页面风格统一，画面和谐。</p><h2 id="Bootstrap下载"><a href="#Bootstrap下载" class="headerlink" title="Bootstrap下载"></a>Bootstrap下载</h2><p>　　官方地址：<a href="https://getbootstrap.com/">https://getbootstrap.com</a></p><p>　　中文地址：<a href="http://www.bootcss.com/">http://www.bootcss.com/</a></p><p>　　我们使用V3版本的Bootstrap，我们下载的是用于生产环境的Bootstrap。</p><h2 id="Bootstrap环境搭建"><a href="#Bootstrap环境搭建" class="headerlink" title="Bootstrap环境搭建"></a>Bootstrap环境搭建</h2><p>　　目录结构：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>bootstrap-3.3.7-dist/ ├── css  // CSS文件│   ├── bootstrap-theme.css  // Bootstrap主题样式文件,官方提供的，一般不用│   ├── bootstrap-theme.css.map│   ├── bootstrap-theme.min.css  // 主题相关样式压缩文件│   ├── bootstrap-theme.min.css.map│   ├── bootstrap.css  //引用的时候，引用这一个或者下面那个bootstrap.min.css文件就可以了│   ├── bootstrap.css.map│   ├── bootstrap.min.css  // 核心CSS样式压缩文件，其他的文件都是在这个核心文件的基础上加了一些其他的样式│   └── bootstrap.min.css.map├── fonts  // 字体文件│   ├── glyphicons-halflings-regular.eot│   ├── glyphicons-halflings-regular.svg│   ├── glyphicons-halflings-regular.ttf│   ├── glyphicons-halflings-regular.woff│   └── glyphicons-halflings-regular.woff2└── js  // JS文件    ├── bootstrap.js    ├── bootstrap.min.js  // 核心JS压缩文件    └── npm.js</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　处理依赖</p><p>　　由于Bootstrap的某些组件依赖于jQuery，所以请确保下载对应版本的jQuery文件，来保证Bootstrap相关组件运行正常。</p><p>　　引入：</p><p>　　　　将下载解压的那个文件夹放到我们的项目目录下就能够使用了</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212154036868-1603171112.png" alt="img"></p><p>　　　　　　可以把主题那些你用不到的css等文件删除。</p><p>　　　　然后引入一下就能用了，很简单</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212154159596-971708048.png" alt="img"></p><h2 id="Bootstrap全局样式"><a href="#Bootstrap全局样式" class="headerlink" title="Bootstrap全局样式"></a>Bootstrap全局样式</h2><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212150207724-96437654.png" alt="img"></p><p>　　排版、按钮、表格、表单、图片等我们常用的HTML元素，Bootstrap中都提供了全局样式。</p><p>　　我们只要在基本的HTML元素上通过设置class就能够应用上Bootstrap的样式，从而使我们的页面更美观和谐。</p><p>　　基础模板：简单看看结构</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;  &lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;!--页面宽度自适应设备的屏幕宽度--&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt;    &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;    &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;    &lt;!--[if lt IE 9]&gt;        &lt;script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"&gt;&lt;/script&gt;      &lt;script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"&gt;&lt;/script&gt;    &lt;![endif]--&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;你好，世界！&lt;/h1&gt;    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt;    &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　    <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212155314635-1174684386.png" alt="img"></p><p> 　　想让手机端能够显示完整的页面，就需要写上</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212160127448-140756534.png" alt="img"></p><p>　　使用栅格进行布局的时候注意人家bootstrap官网里面写的要求：写法就按照下面的来，写到布局容器里面，列是行里面的元素。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212160720357-328395774.png" alt="img"></p><p>　　　　效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212160813218-2044476748.png" alt="img"></p><p>　　　　如果里面的列元素没有占满12份，那么右边就会空出来几份的宽度。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212161105807-909503549.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212161116682-1645764212.png" alt="img"></p><p>　　　　还有：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212161304815-1598512867.png" alt="img"></p><p>　　列偏移　　</p><p>　　关于媒体查询：　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;    &lt;style&gt;        body {            margin: 0;        }        .c1 {            background-color: red;            height: 200px;        }        /*媒体查询，捕捉显示屏幕的宽度，来显示不同的定制效果*/        @media screen and (max-width: 700px) {            .c1 {                background-color: green;            }        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="c1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　媒体查询的使用</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href="bootstrap/css/bootstrap.css" rel="stylesheet"&gt;    &lt;style&gt;        #con1{            /*background-color: red;*/            /*height: 600px;*/        }        .c1{            background-color: red;            height: 40px;        }        .c2{            background-color: green;            height: 40px;        }        @media screen and (min-width: 700px) {            .c1{                background-color: yellow;                height: 40px;            }            .c2{                background-color: blue;                height: 40px;            }        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--&lt;h1&gt;你好，世界！&lt;/h1&gt;--&gt;&lt;!--&lt;div id="con1" class="container"&gt;&lt;/div&gt;--&gt;&lt;!--&lt;div id="con1" class="container-fluid"&gt;--&gt;    &lt;!--&lt;div class="row"&gt;--&gt;        &lt;!--&lt;div class="col-md-2 col-xs-2 c1 col-md-offset-1 col-xs-offset-1"&gt;--&gt;        &lt;!--&lt;/div&gt;--&gt;        &lt;!--&lt;div class="col-md-8 col-xs-8 c2"&gt;--&gt;        &lt;!--&lt;/div&gt;--&gt;    &lt;!--&lt;/div&gt;--&gt;&lt;!--&lt;/div&gt;--&gt;&lt;div id="con1" class="container-fluid"&gt;    &lt;div class="row"&gt;        &lt;div class="col-md-2 col-xs-2 c1 col-md-offset-1 col-xs-offset-1"&gt;        &lt;/div&gt;        &lt;div class="col-md-8 col-xs-8 c2"&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;&lt;script src="bootstrap/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="标题相关"><a href="#标题相关" class="headerlink" title="　　标题相关"></a>　　标题相关</h3><p>　　　　<strong>标题</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;h1&gt;一级标题36px&lt;/h1&gt;&lt;h2&gt;二级标题30px&lt;/h2&gt;&lt;h3&gt;三级标题24px&lt;/h3&gt;&lt;h4&gt;四级标题18px&lt;/h4&gt;&lt;h5&gt;五级标题14px&lt;/h5&gt;&lt;h6&gt;六级标题12px&lt;/h6&gt;&lt;!--除了使用h标签，Bootstrap内置了相应的全局样式--&gt;&lt;!--内联标签应用标题样式--&gt;&lt;span class="h1"&gt;一级标题36px&lt;/span&gt;&lt;span class="h2"&gt;二级标题30px&lt;/span&gt;&lt;span class="h3"&gt;三级标题24px&lt;/span&gt;&lt;span class="h4"&gt;四级标题18px&lt;/span&gt;&lt;span class="h5"&gt;五级标题14px&lt;/span&gt;&lt;span class="h6"&gt;六级标题12px&lt;/span&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong>副标题</strong></p><pre><code>&lt;!--一级标题中嵌入小标题--&gt;&lt;h1&gt;一级标题&lt;small&gt;小标题&lt;/small&gt;&lt;/h1&gt;</code></pre><h3 id="文本对齐"><a href="#文本对齐" class="headerlink" title="　　文本对齐"></a>　　<strong>文本对齐</strong></h3><pre><code>&lt;!--文本对齐--&gt;&lt;p class="text-left"&gt;文本左对齐&lt;/p&gt;&lt;p class="text-center"&gt;文本居中&lt;/p&gt;&lt;p class="text-right"&gt;文本右对齐&lt;/p&gt;</code></pre><h3 id="文本大小写"><a href="#文本大小写" class="headerlink" title="　　文本大小写"></a>　　<strong>文本大小写</strong></h3><pre><code>&lt;!--大小写--&gt;&lt;p class="text-lowercase"&gt;Lowercased text.&lt;/p&gt;&lt;p class="text-uppercase"&gt;Uppercased text.&lt;/p&gt;&lt;p class="text-capitalize"&gt;Capitalized text.&lt;/p&gt;</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="　　表格"></a>　　<strong>表格</strong></h3><table><thead><tr><th>Class</th><th>描述</th></tr></thead><tbody><tr><td>.table-striped</td><td>条纹状表格</td></tr><tr><td>.table-bordered</td><td>带边框的表格</td></tr><tr><td>.table-hover</td><td>鼠标悬停变色的表格</td></tr><tr><td>.table-condensed</td><td>紧缩型表格</td></tr><tr><td>.table-responsive</td><td>响应式表格</td></tr></tbody></table><h3 id="状态类"><a href="#状态类" class="headerlink" title="　　状态类"></a>　　<strong>状态类</strong></h3><table><thead><tr><th>Class</th><th>描述</th></tr></thead><tbody><tr><td><code>.active</code></td><td>鼠标悬停在行或单元格上时所设置的颜色</td></tr><tr><td><code>.success</code></td><td>标识成功或积极的动作</td></tr><tr><td><code>.info</code></td><td>标识普通的提示信息或动作</td></tr><tr><td><code>.warning</code></td><td>标识警告或需要用户注意</td></tr><tr><td><code>.danger</code></td><td>标识危险或潜在的带来负面影响的动作</td></tr></tbody></table><h3 id="表单"><a href="#表单" class="headerlink" title="　　表单"></a>　　<strong>表单</strong></h3><p>　　　　内联表单</p><p>　　　　表单状态</p><p>　　　　带图标的表单</p><h3 id="按钮"><a href="#按钮" class="headerlink" title="　　按钮"></a>　　<strong>按钮</strong></h3><pre><code>&lt;a class="btn btn-default" href="#" role="button"&gt;Link&lt;/a&gt;&lt;button class="btn btn-default" type="submit"&gt;Button&lt;/button&gt;&lt;input class="btn btn-default" type="button" value="Input"&gt;&lt;input class="btn btn-default" type="submit" value="Submit"&gt;</code></pre><p>　　　　按钮样式</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!-- Standard button --&gt;&lt;button type="button" class="btn btn-default"&gt;（默认样式）Default&lt;/button&gt;&lt;!-- Provides extra visual weight and identifies the primary action in a set of buttons --&gt;&lt;button type="button" class="btn btn-primary"&gt;（首选项）Primary&lt;/button&gt;&lt;!-- Indicates a successful or positive action --&gt;&lt;button type="button" class="btn btn-success"&gt;（成功）Success&lt;/button&gt;&lt;!-- Contextual button for informational alert messages --&gt;&lt;button type="button" class="btn btn-info"&gt;（一般信息）Info&lt;/button&gt;&lt;!-- Indicates caution should be taken with this action --&gt;&lt;button type="button" class="btn btn-warning"&gt;（警告）Warning&lt;/button&gt;&lt;!-- Indicates a dangerous or potentially negative action --&gt;&lt;button type="button" class="btn btn-danger"&gt;（危险）Danger&lt;/button&gt;&lt;!-- Deemphasize a button by making it look like a link while maintaining button behavior --&gt;&lt;button type="button" class="btn btn-link"&gt;（链接）Link&lt;/button&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　按钮大小</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;p&gt;  &lt;button type="button" class="btn btn-primary btn-lg"&gt;（大按钮）Large button&lt;/button&gt;  &lt;button type="button" class="btn btn-default btn-lg"&gt;（大按钮）Large button&lt;/button&gt;&lt;/p&gt;&lt;p&gt;  &lt;button type="button" class="btn btn-primary"&gt;（默认尺寸）Default button&lt;/button&gt;  &lt;button type="button" class="btn btn-default"&gt;（默认尺寸）Default button&lt;/button&gt;&lt;/p&gt;&lt;p&gt;  &lt;button type="button" class="btn btn-primary btn-sm"&gt;（小按钮）Small button&lt;/button&gt;  &lt;button type="button" class="btn btn-default btn-sm"&gt;（小按钮）Small button&lt;/button&gt;&lt;/p&gt;&lt;p&gt;  &lt;button type="button" class="btn btn-primary btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt;  &lt;button type="button" class="btn btn-default btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt;&lt;/p&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="图片"><a href="#图片" class="headerlink" title="　　图片"></a>　　<strong>图片</strong></h3><pre><code>&lt;img src="..." class="img-responsive" alt="Responsive image"&gt;</code></pre><p>　　　　图片形状</p><pre><code>&lt;img src="..." alt="..." class="img-rounded"&gt;&lt;img src="..." alt="..." class="img-circle"&gt;&lt;img src="..." alt="..." class="img-thumbnail"&gt;</code></pre><h3 id="辅助类"><a href="#辅助类" class="headerlink" title="　　辅助类"></a>　　<strong>辅助类</strong></h3><p>　　　　文本颜色</p><pre><code>&lt;p class="text-muted"&gt;...&lt;/p&gt;&lt;p class="text-primary"&gt;...&lt;/p&gt;&lt;p class="text-success"&gt;...&lt;/p&gt;&lt;p class="text-info"&gt;...&lt;/p&gt;&lt;p class="text-warning"&gt;...&lt;/p&gt;&lt;p class="text-danger"&gt;...&lt;/p&gt;</code></pre><p>　　　　背景颜色</p><pre><code>&lt;p class="bg-primary"&gt;...&lt;/p&gt;&lt;p class="bg-success"&gt;...&lt;/p&gt;&lt;p class="bg-info"&gt;...&lt;/p&gt;&lt;p class="bg-warning"&gt;...&lt;/p&gt;&lt;p class="bg-danger"&gt;...&lt;/p&gt;</code></pre><p>　　　　关闭按钮</p><pre><code>&lt;button type="button" class="close" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;</code></pre><p>　　　　下拉三角</p><pre><code>&lt;span class="caret"&gt;&lt;/span&gt;</code></pre><p>　　　　快速浮动</p><pre><code>&lt;div class="pull-left"&gt;...&lt;/div&gt;&lt;div class="pull-right"&gt;...&lt;/div&gt;</code></pre><p>　　　　内容块居中</p><pre><code>&lt;div class="center-block"&gt;...&lt;/div&gt;</code></pre><p>　　　　清除浮动</p><pre><code>&lt;!-- Usage as a class --&gt;&lt;div class="clearfix"&gt;...&lt;/div&gt;</code></pre><p>　　　　显示与隐藏</p><pre><code>&lt;div class="show"&gt;...&lt;/div&gt;&lt;div class="hidden"&gt;...&lt;/div&gt;</code></pre><p>　　bootstrap写一个简单的登陆页面：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;登录页面&lt;/title&gt;    &lt;link rel="stylesheet" href="bootstrap-3.3.7/css/bootstrap.css"&gt;    &lt;style&gt;        body {            background-color: #eeeeee;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;    &lt;div class="row"&gt;        &lt;div class="col-md-4 col-md-offset-4" style="margin-top: 70px"&gt;            &lt;h2 class="text-center"&gt;欢迎登录&lt;/h2&gt;            &lt;form&gt;                &lt;div class="form-group"&gt;                    &lt;label for="exampleInputEmail1"&gt;邮箱&lt;/label&gt;                    &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt;                    &lt;span class="help-block"&gt;&lt;/span&gt;                &lt;/div&gt;                &lt;div class="form-group"&gt;                    &lt;label for="exampleInputPassword1"&gt;密码&lt;/label&gt;                    &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt;                    &lt;span class="help-block"&gt;&lt;/span&gt;                &lt;/div&gt;                &lt;div class="checkbox"&gt;                    &lt;label&gt;                        &lt;input type="checkbox"&gt; 记住                    &lt;/label&gt;                &lt;/div&gt;                &lt;button type="submit" id="login-btn" class="btn btn-success btn-block"&gt;登录&lt;/button&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script&gt;    // 给登录按钮绑定点击事件    $('#login-btn').click(function () {        // 定义一个是否允许提交的标志位         var flag = true;        // 1. 找到登录框中所有的input框，判断值是否为空        $('form input').each(function () {            var value = $(this).val();            if (value.length===0){                // 2. 为空就显示提示信息                // 2.1 给下面的span标签设置文本提示信息                var errMsg = $(this).prev().text() + '不能为空';                $(this).next().text(errMsg);                // 2.2 给父标签设置has-error的样式                $(this).parent().addClass('has-error');                // 2.3 阻止表单提交                flag = false;                return false;            }        });        return flag;    });    // 给input框绑定focus事件    $('form input').focus(function () {        // 1. 去掉当前input框后面的span标签的文本        $(this).next().text('');        // 2. 去掉父标签的has-error样式        $(this).parent().removeClass('has-error');    })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="常用Bootstrap组件（就是一些搭配起来的效果，也涉及到一些动作相关的，所以需要引入js文件了）"><a href="#常用Bootstrap组件（就是一些搭配起来的效果，也涉及到一些动作相关的，所以需要引入js文件了）" class="headerlink" title="常用Bootstrap组件（就是一些搭配起来的效果，也涉及到一些动作相关的，所以需要引入js文件了）"></a>常用Bootstrap组件（就是一些搭配起来的效果，也涉及到一些动作相关的，所以需要引入js文件了）</h2><ol><li>字体图标(fontawesome里面比较全)</li><li>下拉菜单</li><li>按钮组</li><li>输入框俎</li><li>导航</li><li>分页</li><li>标签和徽章</li><li>页头</li><li>缩率图</li><li>进度条</li></ol><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213133732924-1770564.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213133747628-47291732.png" alt="img"></p><p>　　作业：来实现这么一个页面</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212220303882-288963531.png" alt="img"></p><p>　　　　就在bootstrap官网的全局css样式里面的右边这个地方找你需要使用的功能。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212220418125-970451954.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ContractedBlock.gif" alt="img"> 作业代码</p><p>　　模拟滚动的进度条：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var $d1 = $("#d1");var width = 0;var theID = setInterval(setValue, 200);function setValue() {  if (width === 100) {    clearInterval(theID);  } else {    width++;    $d1.css("width", width+"%").text(width+"%");  }}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　关于fontawesome的使用</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131313924-840968377.png" alt="img"></p><p>　　　　下载解压，然后放到我们的项目目录里面去，直接引用就行了</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131401354-2118848621.png" alt="img"></p><p>　　　　css文件夹和fonts文件夹必须是同一级目录，因为那个css里面的内容就是通过相对路径来找fonts里面的内容的</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131616708-565710695.png" alt="img"></p><p>　　　　找个微信图标看看：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131941249-1526267016.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131755756-1544951964.png" alt="img"></p><p> 　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213132014608-118857166.png" alt="img"></p><p>　　　　咱们大家再看看font awesome里面的一些用法，比bootstrap里面的图标用起来更高级一些，并且和bootstrap完美兼容。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213133239959-1152513839.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213133247194-803116647.png" alt="img"></p><p> 　　pycharm中设置HTML的模板样式：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213145943906-726201258.png" alt="img"></p><p>　　京东的标签页：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213150256493-216740084.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213150306012-1773504873.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213150350544-872767775.png" alt="img"></p><p>　　　　标签页示例：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel="stylesheet" href="bootstrap-3.3.7/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;    &lt;div&gt;        &lt;!-- Nav tabs --&gt;        &lt;ul class="nav nav-tabs nav-justified" role="tablist"&gt;            &lt;li role="presentation" class="active"&gt;                &lt;a href="#home" aria-controls="home" role="tab" data-toggle="tab"&gt;主页&lt;/a&gt;            &lt;/li&gt;            &lt;li role="presentation"&gt;                &lt;a href="#profile" aria-controls="profile" role="tab" data-toggle="tab"&gt;详情页&lt;/a&gt;            &lt;/li&gt;            &lt;li role="presentation"&gt;                &lt;a href="#messages" aria-controls="messages" role="tab" data-toggle="tab"&gt;售后服务&lt;/a&gt;            &lt;/li&gt;            &lt;li role="presentation"&gt;                &lt;a href="#settings" aria-controls="settings" role="tab" data-toggle="tab"&gt;评论专区&lt;/a&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;!-- Tab panes --&gt;        &lt;div class="tab-content"&gt;            &lt;div role="tabpanel" class="tab-pane active" id="home"&gt;这是主页的内容&lt;/div&gt;            &lt;div role="tabpanel" class="tab-pane" id="profile"&gt;这是详情页的内容&lt;/div&gt;            &lt;div role="tabpanel" class="tab-pane" id="messages"&gt;这是售后服务专区的内容&lt;/div&gt;            &lt;div role="tabpanel" class="tab-pane" id="settings"&gt;这是评论区的内容&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="bootstrap-3.3.7/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　巨幕：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213153643468-2003875814.png" alt="img"></p><p> 　　进度条　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel="stylesheet" href="bootstrap-3.3.7/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;    &lt;div class="progress"&gt;      &lt;div id="p1" class="progress-bar progress-bar-info progress-bar-striped active" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 0%;min-width: 2%"&gt;        0%      &lt;/div&gt;    &lt;/div&gt;    &lt;button class="btn btn-success btn-sm" id="b1"&gt;开始&lt;/button&gt;&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="bootstrap-3.3.7/js/bootstrap.js"&gt;&lt;/script&gt;&lt;script&gt;        var n = 0;        var t;    // jQuery操作标签的CSS属性        function foo(){            $('#p1').css('width', n+'%').text(n+'%');            n += 1;            if (n &gt; 100){                clearInterval(t);            }        }    // 点击开始按钮，让滚动条滚动起来    $('#b1').click(function () {        // 每隔一秒钟执行一下上面的代码        t = setInterval(foo, 100);    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　保存网页的方法：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213162853903-590732687.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213163119421-1139294081.png" alt="img"></p><h2 id="响应式开发"><a href="#响应式开发" class="headerlink" title="响应式开发"></a>响应式开发</h2><h3 id="为什么要进行响应式开发？"><a href="#为什么要进行响应式开发？" class="headerlink" title="　　为什么要进行响应式开发？"></a>　　为什么要进行响应式开发？</h3><p>　　　　随着移动设备的流行，网页设计必须要考虑到移动端的设计。同一个网站为了兼容PC端和移动端显示，就需要进行响应式开发。</p><h3 id="什么是响应式？"><a href="#什么是响应式？" class="headerlink" title="　　什么是响应式？"></a>　　什么是响应式？</h3><p>　　　　利用媒体查询，让同一个网站兼容不同的终端（PC端、移动端）呈现不同的页面布局。</p><h3 id="用到的技术："><a href="#用到的技术：" class="headerlink" title="　　用到的技术："></a>　　<strong>用到的技术：</strong></h3><p>　　　　<strong>CSS3@media查询</strong></p><p>　　　　用于查询设备是否符合某一特定条件，这些特定条件包括屏幕尺寸、是否可触摸、屏幕精度、横屏竖屏等信息。</p><p>　　　　常见属性：</p><p>　　　　　　1.device-width, device-height 屏幕宽、高</p><p>　　　　　　2.width,height 渲染窗口宽、高</p><p>　　　　　　3.orientation 设备方向</p><p>　　　　　　4.resolution 设备分辨率</p><p>　　　　　　语法：</p><pre><code>@media mediatype and|not|only (media feature) {    CSS-Code;}</code></pre><p>　　　　不同的媒体使用不同的stylesheet</p><pre><code>&lt;link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"&gt;</code></pre><p>　　　　<strong>viewport</strong></p><p>　　　　　　手机浏览器是把页面放在一个虚拟的”窗口”（viewport）中，通常这个虚拟的”窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。</p><p>　　　　　　设置viewport</p><p>　　　　　　一个常用的针对移动网页优化过的页面的 viewport meta 标签大致如下：</p><pre><code>&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1″&gt;</code></pre><ul><li>width：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。</li><li>height：和 width 相对应，指定高度。</li><li>initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</li><li>maximum-scale：允许用户缩放到的最大比例。</li><li>minimum-scale：允许用户缩放到的最小比例。</li><li>user-scalable：用户是否可以手动缩放。</li></ul><p>　　　　<strong>Bootstrap的栅格系统</strong></p><ul><li>container</li><li>row</li><li>column</li></ul><p>　　　　注意事项： 使用Bootstrap的时候不要让自己的名字与Bootstrap的类名冲突。</p><h2 id="JavaScript插件"><a href="#JavaScript插件" class="headerlink" title="JavaScript插件"></a>JavaScript插件</h2><p><a href="http://www.cnblogs.com/liwenzhou/articles/8243227.html">常用的Bootstrap自带插件</a></p><p><a href="http://www.cnblogs.com/liwenzhou/articles/8243279.html">其他常用插件</a></p><h2 id="Bootstrap实例精选："><a href="#Bootstrap实例精选：" class="headerlink" title="Bootstrap实例精选："></a>Bootstrap实例精选：</h2><ul><li>封面图</li><li>Carousel</li><li>博客页面</li><li>控制台</li><li>登录页</li><li>Offcanvas</li></ul><p><strong>补充一些内容：</strong></p><p>　　pycharm如何连接上数据库</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122246384-1299651798.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122336693-400210768.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122418613-1162456324.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122550283-1840700978.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122634987-953835999.png" alt="img"></p><p>　　然后就可以在pycharm上看到这个库和里面的表了</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122727952-532451495.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122930783-822988179.png" alt="img"></p><p>　　还可以在里面写sql语句</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213123412678-1864001066.png" alt="img"></p><p>　　我们设计三张表，书籍、作者、出版社，方便之后django的学习：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213123258158-316793110.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213124824441-1903259483.png" alt="img"></p><p>　　　　大家通过sql语句将表和表关系创建出来吧(使用上foreign key吧)</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213125401348-808152711.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213125417339-1866473179.png" alt="img"></p><p><strong>课后作业</strong>：</p><p>　　修改成下面这样的效果</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213171823109-1386351672.png" alt="img"></p><ul><li>后台管理页面（修改Dashbord，<a href="https://v3.bootcss.com/examples/dashboard/%EF%BC%89">https://v3.bootcss.com/examples/dashboard/）</a></li><li>常用组件练习</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端HTML</title>
      <link href="2019/11/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AFHTML/"/>
      <url>2019/11/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AFHTML/</url>
      
        <content type="html"><![CDATA[<p>　　iconfont的使用：<a href="https://www.cnblogs.com/clschao/articles/10387580.html">https://www.cnblogs.com/clschao/articles/10387580.html</a></p><h2 id="Bootstrap介绍"><a href="#Bootstrap介绍" class="headerlink" title="Bootstrap介绍"></a>Bootstrap介绍</h2><p>　　Bootstrap是Twitter开源的基于HTML、CSS、JavaScript的前端框架。</p><p>　　它是为实现快速开发Web应用程序而设计的一套前端工具包。</p><p>　　它支持响应式布局，并且在V3版本之后坚持移动设备优先。</p><p>​       就是复制黏贴一把梭，html\css\js代码的封装组合</p><h2 id="为什么要使用Bootstrap？"><a href="#为什么要使用Bootstrap？" class="headerlink" title="为什么要使用Bootstrap？"></a>为什么要使用Bootstrap？</h2><p>　　在Bootstrap出现之前：</p><p>　　命名：重复、复杂、无意义（想个名字费劲）</p><p>　　样式：重复、冗余、不规范、不和谐</p><p>　　页面：错乱、不规范、不和谐</p><p>　　在使用Bootstrap之后： 各种命名都统一并且规范化。 页面风格统一，画面和谐。</p><h2 id="Bootstrap下载"><a href="#Bootstrap下载" class="headerlink" title="Bootstrap下载"></a>Bootstrap下载</h2><p>　　官方地址：<a href="https://getbootstrap.com/">https://getbootstrap.com</a></p><p>　　中文地址：<a href="http://www.bootcss.com/">http://www.bootcss.com/</a></p><p>　　我们使用V3版本的Bootstrap，我们下载的是用于生产环境的Bootstrap。</p><h2 id="Bootstrap环境搭建"><a href="#Bootstrap环境搭建" class="headerlink" title="Bootstrap环境搭建"></a>Bootstrap环境搭建</h2><p>　　目录结构：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>bootstrap-3.3.7-dist/ ├── css  // CSS文件│   ├── bootstrap-theme.css  // Bootstrap主题样式文件,官方提供的，一般不用│   ├── bootstrap-theme.css.map│   ├── bootstrap-theme.min.css  // 主题相关样式压缩文件│   ├── bootstrap-theme.min.css.map│   ├── bootstrap.css  //引用的时候，引用这一个或者下面那个bootstrap.min.css文件就可以了│   ├── bootstrap.css.map│   ├── bootstrap.min.css  // 核心CSS样式压缩文件，其他的文件都是在这个核心文件的基础上加了一些其他的样式│   └── bootstrap.min.css.map├── fonts  // 字体文件│   ├── glyphicons-halflings-regular.eot│   ├── glyphicons-halflings-regular.svg│   ├── glyphicons-halflings-regular.ttf│   ├── glyphicons-halflings-regular.woff│   └── glyphicons-halflings-regular.woff2└── js  // JS文件    ├── bootstrap.js    ├── bootstrap.min.js  // 核心JS压缩文件    └── npm.js</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　处理依赖</p><p>　　由于Bootstrap的某些组件依赖于jQuery，所以请确保下载对应版本的jQuery文件，来保证Bootstrap相关组件运行正常。</p><p>　　引入：</p><p>　　　　将下载解压的那个文件夹放到我们的项目目录下就能够使用了</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212154036868-1603171112.png" alt="img"></p><p>　　　　　　可以把主题那些你用不到的css等文件删除。</p><p>　　　　然后引入一下就能用了，很简单</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212154159596-971708048.png" alt="img"></p><h2 id="Bootstrap全局样式"><a href="#Bootstrap全局样式" class="headerlink" title="Bootstrap全局样式"></a>Bootstrap全局样式</h2><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212150207724-96437654.png" alt="img"></p><p>　　排版、按钮、表格、表单、图片等我们常用的HTML元素，Bootstrap中都提供了全局样式。</p><p>　　我们只要在基本的HTML元素上通过设置class就能够应用上Bootstrap的样式，从而使我们的页面更美观和谐。</p><p>　　基础模板：简单看看结构</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;  &lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;!--页面宽度自适应设备的屏幕宽度--&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt;    &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;    &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;    &lt;!--[if lt IE 9]&gt;        &lt;script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"&gt;&lt;/script&gt;      &lt;script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"&gt;&lt;/script&gt;    &lt;![endif]--&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;你好，世界！&lt;/h1&gt;    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt;    &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　    <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212155314635-1174684386.png" alt="img"></p><p> 　　想让手机端能够显示完整的页面，就需要写上</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212160127448-140756534.png" alt="img"></p><p>　　使用栅格进行布局的时候注意人家bootstrap官网里面写的要求：写法就按照下面的来，写到布局容器里面，列是行里面的元素。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212160720357-328395774.png" alt="img"></p><p>　　　　效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212160813218-2044476748.png" alt="img"></p><p>　　　　如果里面的列元素没有占满12份，那么右边就会空出来几份的宽度。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212161105807-909503549.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212161116682-1645764212.png" alt="img"></p><p>　　　　还有：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212161304815-1598512867.png" alt="img"></p><p>　　列偏移　　</p><p>　　关于媒体查询：　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;    &lt;style&gt;        body {            margin: 0;        }        .c1 {            background-color: red;            height: 200px;        }        /*媒体查询，捕捉显示屏幕的宽度，来显示不同的定制效果*/        @media screen and (max-width: 700px) {            .c1 {                background-color: green;            }        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="c1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　媒体查询的使用</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href="bootstrap/css/bootstrap.css" rel="stylesheet"&gt;    &lt;style&gt;        #con1{            /*background-color: red;*/            /*height: 600px;*/        }        .c1{            background-color: red;            height: 40px;        }        .c2{            background-color: green;            height: 40px;        }        @media screen and (min-width: 700px) {            .c1{                background-color: yellow;                height: 40px;            }            .c2{                background-color: blue;                height: 40px;            }        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--&lt;h1&gt;你好，世界！&lt;/h1&gt;--&gt;&lt;!--&lt;div id="con1" class="container"&gt;&lt;/div&gt;--&gt;&lt;!--&lt;div id="con1" class="container-fluid"&gt;--&gt;    &lt;!--&lt;div class="row"&gt;--&gt;        &lt;!--&lt;div class="col-md-2 col-xs-2 c1 col-md-offset-1 col-xs-offset-1"&gt;--&gt;        &lt;!--&lt;/div&gt;--&gt;        &lt;!--&lt;div class="col-md-8 col-xs-8 c2"&gt;--&gt;        &lt;!--&lt;/div&gt;--&gt;    &lt;!--&lt;/div&gt;--&gt;&lt;!--&lt;/div&gt;--&gt;&lt;div id="con1" class="container-fluid"&gt;    &lt;div class="row"&gt;        &lt;div class="col-md-2 col-xs-2 c1 col-md-offset-1 col-xs-offset-1"&gt;        &lt;/div&gt;        &lt;div class="col-md-8 col-xs-8 c2"&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;&lt;script src="bootstrap/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="标题相关"><a href="#标题相关" class="headerlink" title="　　标题相关"></a>　　标题相关</h3><p>　　　　<strong>标题</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;h1&gt;一级标题36px&lt;/h1&gt;&lt;h2&gt;二级标题30px&lt;/h2&gt;&lt;h3&gt;三级标题24px&lt;/h3&gt;&lt;h4&gt;四级标题18px&lt;/h4&gt;&lt;h5&gt;五级标题14px&lt;/h5&gt;&lt;h6&gt;六级标题12px&lt;/h6&gt;&lt;!--除了使用h标签，Bootstrap内置了相应的全局样式--&gt;&lt;!--内联标签应用标题样式--&gt;&lt;span class="h1"&gt;一级标题36px&lt;/span&gt;&lt;span class="h2"&gt;二级标题30px&lt;/span&gt;&lt;span class="h3"&gt;三级标题24px&lt;/span&gt;&lt;span class="h4"&gt;四级标题18px&lt;/span&gt;&lt;span class="h5"&gt;五级标题14px&lt;/span&gt;&lt;span class="h6"&gt;六级标题12px&lt;/span&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong>副标题</strong></p><pre><code>&lt;!--一级标题中嵌入小标题--&gt;&lt;h1&gt;一级标题&lt;small&gt;小标题&lt;/small&gt;&lt;/h1&gt;</code></pre><h3 id="文本对齐"><a href="#文本对齐" class="headerlink" title="　　文本对齐"></a>　　<strong>文本对齐</strong></h3><pre><code>&lt;!--文本对齐--&gt;&lt;p class="text-left"&gt;文本左对齐&lt;/p&gt;&lt;p class="text-center"&gt;文本居中&lt;/p&gt;&lt;p class="text-right"&gt;文本右对齐&lt;/p&gt;</code></pre><h3 id="文本大小写"><a href="#文本大小写" class="headerlink" title="　　文本大小写"></a>　　<strong>文本大小写</strong></h3><pre><code>&lt;!--大小写--&gt;&lt;p class="text-lowercase"&gt;Lowercased text.&lt;/p&gt;&lt;p class="text-uppercase"&gt;Uppercased text.&lt;/p&gt;&lt;p class="text-capitalize"&gt;Capitalized text.&lt;/p&gt;</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="　　表格"></a>　　<strong>表格</strong></h3><table><thead><tr><th>Class</th><th>描述</th></tr></thead><tbody><tr><td>.table-striped</td><td>条纹状表格</td></tr><tr><td>.table-bordered</td><td>带边框的表格</td></tr><tr><td>.table-hover</td><td>鼠标悬停变色的表格</td></tr><tr><td>.table-condensed</td><td>紧缩型表格</td></tr><tr><td>.table-responsive</td><td>响应式表格</td></tr></tbody></table><h3 id="状态类"><a href="#状态类" class="headerlink" title="　　状态类"></a>　　<strong>状态类</strong></h3><table><thead><tr><th>Class</th><th>描述</th></tr></thead><tbody><tr><td><code>.active</code></td><td>鼠标悬停在行或单元格上时所设置的颜色</td></tr><tr><td><code>.success</code></td><td>标识成功或积极的动作</td></tr><tr><td><code>.info</code></td><td>标识普通的提示信息或动作</td></tr><tr><td><code>.warning</code></td><td>标识警告或需要用户注意</td></tr><tr><td><code>.danger</code></td><td>标识危险或潜在的带来负面影响的动作</td></tr></tbody></table><h3 id="表单"><a href="#表单" class="headerlink" title="　　表单"></a>　　<strong>表单</strong></h3><p>　　　　内联表单</p><p>　　　　表单状态</p><p>　　　　带图标的表单</p><h3 id="按钮"><a href="#按钮" class="headerlink" title="　　按钮"></a>　　<strong>按钮</strong></h3><pre><code>&lt;a class="btn btn-default" href="#" role="button"&gt;Link&lt;/a&gt;&lt;button class="btn btn-default" type="submit"&gt;Button&lt;/button&gt;&lt;input class="btn btn-default" type="button" value="Input"&gt;&lt;input class="btn btn-default" type="submit" value="Submit"&gt;</code></pre><p>　　　　按钮样式</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!-- Standard button --&gt;&lt;button type="button" class="btn btn-default"&gt;（默认样式）Default&lt;/button&gt;&lt;!-- Provides extra visual weight and identifies the primary action in a set of buttons --&gt;&lt;button type="button" class="btn btn-primary"&gt;（首选项）Primary&lt;/button&gt;&lt;!-- Indicates a successful or positive action --&gt;&lt;button type="button" class="btn btn-success"&gt;（成功）Success&lt;/button&gt;&lt;!-- Contextual button for informational alert messages --&gt;&lt;button type="button" class="btn btn-info"&gt;（一般信息）Info&lt;/button&gt;&lt;!-- Indicates caution should be taken with this action --&gt;&lt;button type="button" class="btn btn-warning"&gt;（警告）Warning&lt;/button&gt;&lt;!-- Indicates a dangerous or potentially negative action --&gt;&lt;button type="button" class="btn btn-danger"&gt;（危险）Danger&lt;/button&gt;&lt;!-- Deemphasize a button by making it look like a link while maintaining button behavior --&gt;&lt;button type="button" class="btn btn-link"&gt;（链接）Link&lt;/button&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　按钮大小</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;p&gt;  &lt;button type="button" class="btn btn-primary btn-lg"&gt;（大按钮）Large button&lt;/button&gt;  &lt;button type="button" class="btn btn-default btn-lg"&gt;（大按钮）Large button&lt;/button&gt;&lt;/p&gt;&lt;p&gt;  &lt;button type="button" class="btn btn-primary"&gt;（默认尺寸）Default button&lt;/button&gt;  &lt;button type="button" class="btn btn-default"&gt;（默认尺寸）Default button&lt;/button&gt;&lt;/p&gt;&lt;p&gt;  &lt;button type="button" class="btn btn-primary btn-sm"&gt;（小按钮）Small button&lt;/button&gt;  &lt;button type="button" class="btn btn-default btn-sm"&gt;（小按钮）Small button&lt;/button&gt;&lt;/p&gt;&lt;p&gt;  &lt;button type="button" class="btn btn-primary btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt;  &lt;button type="button" class="btn btn-default btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt;&lt;/p&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="图片"><a href="#图片" class="headerlink" title="　　图片"></a>　　<strong>图片</strong></h3><pre><code>&lt;img src="..." class="img-responsive" alt="Responsive image"&gt;</code></pre><p>　　　　图片形状</p><pre><code>&lt;img src="..." alt="..." class="img-rounded"&gt;&lt;img src="..." alt="..." class="img-circle"&gt;&lt;img src="..." alt="..." class="img-thumbnail"&gt;</code></pre><h3 id="辅助类"><a href="#辅助类" class="headerlink" title="　　辅助类"></a>　　<strong>辅助类</strong></h3><p>　　　　文本颜色</p><pre><code>&lt;p class="text-muted"&gt;...&lt;/p&gt;&lt;p class="text-primary"&gt;...&lt;/p&gt;&lt;p class="text-success"&gt;...&lt;/p&gt;&lt;p class="text-info"&gt;...&lt;/p&gt;&lt;p class="text-warning"&gt;...&lt;/p&gt;&lt;p class="text-danger"&gt;...&lt;/p&gt;</code></pre><p>　　　　背景颜色</p><pre><code>&lt;p class="bg-primary"&gt;...&lt;/p&gt;&lt;p class="bg-success"&gt;...&lt;/p&gt;&lt;p class="bg-info"&gt;...&lt;/p&gt;&lt;p class="bg-warning"&gt;...&lt;/p&gt;&lt;p class="bg-danger"&gt;...&lt;/p&gt;</code></pre><p>　　　　关闭按钮</p><pre><code>&lt;button type="button" class="close" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;</code></pre><p>　　　　下拉三角</p><pre><code>&lt;span class="caret"&gt;&lt;/span&gt;</code></pre><p>　　　　快速浮动</p><pre><code>&lt;div class="pull-left"&gt;...&lt;/div&gt;&lt;div class="pull-right"&gt;...&lt;/div&gt;</code></pre><p>　　　　内容块居中</p><pre><code>&lt;div class="center-block"&gt;...&lt;/div&gt;</code></pre><p>　　　　清除浮动</p><pre><code>&lt;!-- Usage as a class --&gt;&lt;div class="clearfix"&gt;...&lt;/div&gt;</code></pre><p>　　　　显示与隐藏</p><pre><code>&lt;div class="show"&gt;...&lt;/div&gt;&lt;div class="hidden"&gt;...&lt;/div&gt;</code></pre><p>　　bootstrap写一个简单的登陆页面：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;登录页面&lt;/title&gt;    &lt;link rel="stylesheet" href="bootstrap-3.3.7/css/bootstrap.css"&gt;    &lt;style&gt;        body {            background-color: #eeeeee;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;    &lt;div class="row"&gt;        &lt;div class="col-md-4 col-md-offset-4" style="margin-top: 70px"&gt;            &lt;h2 class="text-center"&gt;欢迎登录&lt;/h2&gt;            &lt;form&gt;                &lt;div class="form-group"&gt;                    &lt;label for="exampleInputEmail1"&gt;邮箱&lt;/label&gt;                    &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt;                    &lt;span class="help-block"&gt;&lt;/span&gt;                &lt;/div&gt;                &lt;div class="form-group"&gt;                    &lt;label for="exampleInputPassword1"&gt;密码&lt;/label&gt;                    &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt;                    &lt;span class="help-block"&gt;&lt;/span&gt;                &lt;/div&gt;                &lt;div class="checkbox"&gt;                    &lt;label&gt;                        &lt;input type="checkbox"&gt; 记住                    &lt;/label&gt;                &lt;/div&gt;                &lt;button type="submit" id="login-btn" class="btn btn-success btn-block"&gt;登录&lt;/button&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script&gt;    // 给登录按钮绑定点击事件    $('#login-btn').click(function () {        // 定义一个是否允许提交的标志位         var flag = true;        // 1. 找到登录框中所有的input框，判断值是否为空        $('form input').each(function () {            var value = $(this).val();            if (value.length===0){                // 2. 为空就显示提示信息                // 2.1 给下面的span标签设置文本提示信息                var errMsg = $(this).prev().text() + '不能为空';                $(this).next().text(errMsg);                // 2.2 给父标签设置has-error的样式                $(this).parent().addClass('has-error');                // 2.3 阻止表单提交                flag = false;                return false;            }        });        return flag;    });    // 给input框绑定focus事件    $('form input').focus(function () {        // 1. 去掉当前input框后面的span标签的文本        $(this).next().text('');        // 2. 去掉父标签的has-error样式        $(this).parent().removeClass('has-error');    })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="常用Bootstrap组件（就是一些搭配起来的效果，也涉及到一些动作相关的，所以需要引入js文件了）"><a href="#常用Bootstrap组件（就是一些搭配起来的效果，也涉及到一些动作相关的，所以需要引入js文件了）" class="headerlink" title="常用Bootstrap组件（就是一些搭配起来的效果，也涉及到一些动作相关的，所以需要引入js文件了）"></a>常用Bootstrap组件（就是一些搭配起来的效果，也涉及到一些动作相关的，所以需要引入js文件了）</h2><ol><li>字体图标(fontawesome里面比较全)</li><li>下拉菜单</li><li>按钮组</li><li>输入框俎</li><li>导航</li><li>分页</li><li>标签和徽章</li><li>页头</li><li>缩率图</li><li>进度条</li></ol><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213133732924-1770564.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213133747628-47291732.png" alt="img"></p><p>　　作业：来实现这么一个页面</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212220303882-288963531.png" alt="img"></p><p>　　　　就在bootstrap官网的全局css样式里面的右边这个地方找你需要使用的功能。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190212220418125-970451954.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel="stylesheet" href="bootstrap-3.3.7/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;    &lt;div class="row"&gt;        &lt;div class="col-md-12"&gt;            &lt;div class="page-header"&gt;                &lt;h1&gt;信息收集卡                    &lt;small&gt;共三步&lt;/small&gt;                &lt;/h1&gt;            &lt;/div&gt;            &lt;div class="progress"&gt;                &lt;div class="progress-bar progress-bar-success" role="progressbar" aria-valuenow="60" aria-valuemin="0"                     aria-valuemax="100" style="width: 33.33%;"&gt;                    1/3                &lt;/div&gt;            &lt;/div&gt;            &lt;!--面板--&gt;            &lt;div class="panel panel-primary"&gt;                &lt;div class="panel-heading"&gt;                    &lt;h3 class="panel-title"&gt;基本信息&lt;span class="glyphicon glyphicon-pushpin pull-right"&gt;&lt;/span&gt;&lt;/h3&gt;                &lt;/div&gt;                &lt;div class="panel-body"&gt;                    &lt;!--表单--&gt;                    &lt;form class="form-horizontal"&gt;                        &lt;div class="form-group"&gt;                            &lt;label for="inputEmail1" class="col-sm-2 control-label"&gt;Email&lt;/label&gt;                            &lt;div class="col-sm-4"&gt;                                &lt;input type="email" class="form-control" id="inputEmail1" placeholder="Email"&gt;                            &lt;/div&gt;                        &lt;/div&gt;                        &lt;div class="form-group"&gt;                            &lt;label for="inputPassword2" class="col-sm-2 control-label"&gt;Password&lt;/label&gt;                            &lt;div class="col-sm-4"&gt;                                &lt;input type="password" class="form-control" id="inputPassword2" placeholder="Password"&gt;                            &lt;/div&gt;                        &lt;/div&gt;                        &lt;div class="form-group"&gt;                            &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;Email&lt;/label&gt;                            &lt;div class="col-sm-4"&gt;                                &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt;                            &lt;/div&gt;                        &lt;/div&gt;                        &lt;div class="form-group"&gt;                            &lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;Password&lt;/label&gt;                            &lt;div class="col-sm-4"&gt;                                &lt;input type="password" class="form-control" id="inputPassword3" placeholder="Password"&gt;                            &lt;/div&gt;                        &lt;/div&gt;                        &lt;div class="form-group"&gt;                            &lt;label for="inputFile" class="col-sm-2 control-label"&gt;Password&lt;/label&gt;                            &lt;div class="col-sm-4"&gt;                                &lt;input type="file" class="" id="inputFile" placeholder="Password"&gt;                                &lt;span class="help-block"&gt;只支持png&lt;/span&gt;                            &lt;/div&gt;                        &lt;/div&gt;                        &lt;hr&gt;                        &lt;div class="form-group"&gt;                            &lt;div class="col-sm-2 control-label"&gt;属性&lt;/div&gt;                            &lt;div class="col-sm-4"&gt;                                &lt;div class="radio"&gt;                                    &lt;label&gt;                                        &lt;input type="radio" name="optionsRadios" id="optionsRadios1" value="option1"                                               checked&gt;                                        我是一个好人                                    &lt;/label&gt;                                &lt;/div&gt;                                &lt;div class="radio"&gt;                                    &lt;label&gt;                                        &lt;input type="radio" name="optionsRadios" id="optionsRadios2" value="option2"&gt;                                         我是一个坏人                                    &lt;/label&gt;                                &lt;/div&gt;                                &lt;div class="radio disabled"&gt;                                    &lt;label&gt;                                        &lt;input type="radio" name="optionsRadios" id="optionsRadios3" value="option3"                                               disabled&gt;                                        我不是一个人                                    &lt;/label&gt;                                &lt;/div&gt;                            &lt;/div&gt;                        &lt;/div&gt;                    &lt;/form&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;!--下一步按钮--&gt;            &lt;div&gt;                &lt;button class="btn btn-success pull-right"&gt;下一步&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="bootstrap-3.3.7/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　模拟滚动的进度条：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var $d1 = $("#d1");var width = 0;var theID = setInterval(setValue, 200);function setValue() {  if (width === 100) {    clearInterval(theID);  } else {    width++;    $d1.css("width", width+"%").text(width+"%");  }}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　关于fontawesome的使用</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131313924-840968377.png" alt="img"></p><p>　　　　下载解压，然后放到我们的项目目录里面去，直接引用就行了</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131401354-2118848621.png" alt="img"></p><p>　　　　css文件夹和fonts文件夹必须是同一级目录，因为那个css里面的内容就是通过相对路径来找fonts里面的内容的</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131616708-565710695.png" alt="img"></p><p>　　　　找个微信图标看看：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131941249-1526267016.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213131755756-1544951964.png" alt="img"></p><p> 　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213132014608-118857166.png" alt="img"></p><p>　　　　咱们大家再看看font awesome里面的一些用法，比bootstrap里面的图标用起来更高级一些，并且和bootstrap完美兼容。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213133239959-1152513839.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213133247194-803116647.png" alt="img"></p><p> 　　pycharm中设置HTML的模板样式：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213145943906-726201258.png" alt="img"></p><p>　　京东的标签页：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213150256493-216740084.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213150306012-1773504873.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213150350544-872767775.png" alt="img"></p><p>　　　　标签页示例：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel="stylesheet" href="bootstrap-3.3.7/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;    &lt;div&gt;        &lt;!-- Nav tabs --&gt;        &lt;ul class="nav nav-tabs nav-justified" role="tablist"&gt;            &lt;li role="presentation" class="active"&gt;                &lt;a href="#home" aria-controls="home" role="tab" data-toggle="tab"&gt;主页&lt;/a&gt;            &lt;/li&gt;            &lt;li role="presentation"&gt;                &lt;a href="#profile" aria-controls="profile" role="tab" data-toggle="tab"&gt;详情页&lt;/a&gt;            &lt;/li&gt;            &lt;li role="presentation"&gt;                &lt;a href="#messages" aria-controls="messages" role="tab" data-toggle="tab"&gt;售后服务&lt;/a&gt;            &lt;/li&gt;            &lt;li role="presentation"&gt;                &lt;a href="#settings" aria-controls="settings" role="tab" data-toggle="tab"&gt;评论专区&lt;/a&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;!-- Tab panes --&gt;        &lt;div class="tab-content"&gt;            &lt;div role="tabpanel" class="tab-pane active" id="home"&gt;这是主页的内容&lt;/div&gt;            &lt;div role="tabpanel" class="tab-pane" id="profile"&gt;这是详情页的内容&lt;/div&gt;            &lt;div role="tabpanel" class="tab-pane" id="messages"&gt;这是售后服务专区的内容&lt;/div&gt;            &lt;div role="tabpanel" class="tab-pane" id="settings"&gt;这是评论区的内容&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="bootstrap-3.3.7/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　巨幕：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213153643468-2003875814.png" alt="img"></p><p> 　　进度条　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel="stylesheet" href="bootstrap-3.3.7/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;    &lt;div class="progress"&gt;      &lt;div id="p1" class="progress-bar progress-bar-info progress-bar-striped active" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 0%;min-width: 2%"&gt;        0%      &lt;/div&gt;    &lt;/div&gt;    &lt;button class="btn btn-success btn-sm" id="b1"&gt;开始&lt;/button&gt;&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="bootstrap-3.3.7/js/bootstrap.js"&gt;&lt;/script&gt;&lt;script&gt;        var n = 0;        var t;    // jQuery操作标签的CSS属性        function foo(){            $('#p1').css('width', n+'%').text(n+'%');            n += 1;            if (n &gt; 100){                clearInterval(t);            }        }    // 点击开始按钮，让滚动条滚动起来    $('#b1').click(function () {        // 每隔一秒钟执行一下上面的代码        t = setInterval(foo, 100);    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　保存网页的方法：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213162853903-590732687.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213163119421-1139294081.png" alt="img"></p><h2 id="响应式开发"><a href="#响应式开发" class="headerlink" title="响应式开发"></a>响应式开发</h2><h3 id="为什么要进行响应式开发？"><a href="#为什么要进行响应式开发？" class="headerlink" title="　　为什么要进行响应式开发？"></a>　　为什么要进行响应式开发？</h3><p>　　　　随着移动设备的流行，网页设计必须要考虑到移动端的设计。同一个网站为了兼容PC端和移动端显示，就需要进行响应式开发。</p><h3 id="什么是响应式？"><a href="#什么是响应式？" class="headerlink" title="　　什么是响应式？"></a>　　什么是响应式？</h3><p>　　　　利用媒体查询，让同一个网站兼容不同的终端（PC端、移动端）呈现不同的页面布局。</p><h3 id="用到的技术："><a href="#用到的技术：" class="headerlink" title="　　用到的技术："></a>　　<strong>用到的技术：</strong></h3><p>　　　　<strong>CSS3@media查询</strong></p><p>　　　　用于查询设备是否符合某一特定条件，这些特定条件包括屏幕尺寸、是否可触摸、屏幕精度、横屏竖屏等信息。</p><p>　　　　常见属性：</p><p>　　　　　　1.device-width, device-height 屏幕宽、高</p><p>　　　　　　2.width,height 渲染窗口宽、高</p><p>　　　　　　3.orientation 设备方向</p><p>　　　　　　4.resolution 设备分辨率</p><p>　　　　　　语法：</p><pre><code>@media mediatype and|not|only (media feature) {    CSS-Code;}</code></pre><p>　　　　不同的媒体使用不同的stylesheet</p><pre><code>&lt;link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"&gt;</code></pre><p>　　　　<strong>viewport</strong></p><p>　　　　　　手机浏览器是把页面放在一个虚拟的”窗口”（viewport）中，通常这个虚拟的”窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。</p><p>　　　　　　设置viewport</p><p>　　　　　　一个常用的针对移动网页优化过的页面的 viewport meta 标签大致如下：</p><pre><code>&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1″&gt;</code></pre><ul><li>width：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。</li><li>height：和 width 相对应，指定高度。</li><li>initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</li><li>maximum-scale：允许用户缩放到的最大比例。</li><li>minimum-scale：允许用户缩放到的最小比例。</li><li>user-scalable：用户是否可以手动缩放。</li></ul><p>　　　　<strong>Bootstrap的栅格系统</strong></p><ul><li>container</li><li>row</li><li>column</li></ul><p>　　　　注意事项： 使用Bootstrap的时候不要让自己的名字与Bootstrap的类名冲突。</p><h2 id="JavaScript插件"><a href="#JavaScript插件" class="headerlink" title="JavaScript插件"></a>JavaScript插件</h2><p><a href="http://www.cnblogs.com/liwenzhou/articles/8243227.html">常用的Bootstrap自带插件</a></p><p><a href="http://www.cnblogs.com/liwenzhou/articles/8243279.html">其他常用插件</a></p><h2 id="Bootstrap实例精选："><a href="#Bootstrap实例精选：" class="headerlink" title="Bootstrap实例精选："></a>Bootstrap实例精选：</h2><ul><li>封面图</li><li>Carousel</li><li>博客页面</li><li>控制台</li><li>登录页</li><li>Offcanvas</li></ul><p><strong>补充一些内容：</strong></p><p>　　pycharm如何连接上数据库</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122246384-1299651798.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122336693-400210768.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122418613-1162456324.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122550283-1840700978.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122634987-953835999.png" alt="img"></p><p>　　然后就可以在pycharm上看到这个库和里面的表了</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122727952-532451495.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213122930783-822988179.png" alt="img"></p><p>　　还可以在里面写sql语句</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213123412678-1864001066.png" alt="img"></p><p>　　我们设计三张表，书籍、作者、出版社，方便之后django的学习：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213123258158-316793110.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213124824441-1903259483.png" alt="img"></p><p>　　　　大家通过sql语句将表和表关系创建出来吧(使用上foreign key吧)</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213125401348-808152711.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213125417339-1866473179.png" alt="img"></p><p><strong>课后作业</strong>：</p><p>　　修改成下面这样的效果</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190213171823109-1386351672.png" alt="img"></p><ul><li>后台管理页面（修改Dashbord，<a href="https://v3.bootcss.com/examples/dashboard/%EF%BC%89">https://v3.bootcss.com/examples/dashboard/）</a></li><li>常用组件练习</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript学习</title>
      <link href="2019/11/15/%E5%89%8D%E7%AB%AF/Javascript%E5%AD%A6%E4%B9%A0/"/>
      <url>2019/11/15/%E5%89%8D%E7%AB%AF/Javascript%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript概述"><a href="#JavaScript概述" class="headerlink" title="JavaScript概述"></a>JavaScript概述</h1><h2 id="ECMAScript和JavaScript的关系"><a href="#ECMAScript和JavaScript的关系" class="headerlink" title="　　ECMAScript和JavaScript的关系"></a>　　ECMAScript和JavaScript的关系</h2><p>　　　　1996年11月，JavaScript的创造者–Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这门语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。</p><p>　　　　该标准一开始就是针对JavaScript语言制定的，但是没有称其为JavaScript，有两个方面的原因。一是商标，JavaScript本身已被Netscape注册为商标。二是想体现这门语言的制定者是ECMA，而不是Netscape，这样有利于保证这门语言的开发性和中立性。</p><p>　　　　因此ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。</p><h2 id="ECMAScript的历史"><a href="#ECMAScript的历史" class="headerlink" title="　　ECMAScript的历史"></a>　　ECMAScript的历史</h2><table><thead><tr><th>年份</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1997</td><td>ECMAScript 1</td><td>第一个版本</td></tr><tr><td>1998</td><td>ECMAScript 2</td><td>版本变更</td></tr><tr><td>1999</td><td>ECMAScript 3</td><td>添加正则表达式添加try/catch</td></tr><tr><td></td><td>ECMAScript 4</td><td>没有发布</td></tr><tr><td>2009</td><td>ECMAScript 5</td><td>添加”strict mode”严格模式添加JSON支持</td></tr><tr><td>2011</td><td>ECMAScript 5.1</td><td>版本变更</td></tr><tr><td>2015</td><td>ECMAScript 6</td><td>添加类和模块</td></tr><tr><td>2016</td><td>ECMAScript 7</td><td>增加指数运算符（**）增加Array.prototype.includes</td></tr></tbody></table><p>　　　　注：ES6就是指ECMAScript 6。</p><p>　　　　尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：</p><ul><li>核心（ECMAScript） </li><li>文档对象模型（DOM） Document object model (整合js，css，html)</li><li>浏览器对象模型（BOM） Broswer object model（整合js和浏览器）</li></ul><p>　　　　简单地说，ECMAScript 描述了JavaScript语言本身的相关内容。</p><p>　　　　JavaScript 是脚本语言<br>　　　　JavaScript 是一种轻量级的编程语言。后来出现了node.js，可以作为后端语言来开发项目，js是一个既能做前端又能做后端的语言，但是js这个作者用了10天就开发了这么个语言，所以写的不是很完善，这个语言有很多的槽点，后面学习起来大家就知道啦。</p><p>　　　　JavaScript 是可插入 HTML 页面的编程代码。</p><p>　　　　JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</p><p>　　　　JavaScript 很容易学习。</p><h2 id="JavaScript引入方式"><a href="#JavaScript引入方式" class="headerlink" title="　　JavaScript引入方式"></a>　　JavaScript引入方式</h2><h3 id="Script标签内写代码"><a href="#Script标签内写代码" class="headerlink" title="　　　　Script标签内写代码"></a>　　　　Script标签内写代码</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>在head标签里面可以写，在body标签里面也可以写，放到head标签里面和放到body标签里面到底有什么区别，我们后续在讲~&lt;script&gt;  // 在这里写你的JS代码　//console.log('骑士计划！') #f12建打开浏览器的调试窗口，然后在console这个调试台就能看到这个内容了  //alert('骑士计划！')  #这个是浏览器窗口一打开咱们这个文件，就弹出一个窗口&lt;/script&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　console：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210151539583-2117272358.png" alt="img"></p><p>　　　　alert：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210151657102-1029781765.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210153051395-1202985431.png" alt="img"></p><h3 id="引入额外的JS文件"><a href="#引入额外的JS文件" class="headerlink" title="　　　　引入额外的JS文件"></a>　　　　引入额外的JS文件</h3><pre><code>&lt;script src="myscript.js"&gt;&lt;/script&gt;</code></pre><h2 id="JavaScript语言规范"><a href="#JavaScript语言规范" class="headerlink" title="　　JavaScript语言规范"></a>　　JavaScript语言规范</h2><h3 id="注释（注释是代码之母）"><a href="#注释（注释是代码之母）" class="headerlink" title="　　　　注释（注释是代码之母）"></a>　　　　注释（注释是代码之母）</h3><pre><code>// 这是单行注释/*这是多行注释*/</code></pre><h3 id="结束符"><a href="#结束符" class="headerlink" title="　　结束符"></a>　　结束符</h3><p>　　　　JavaScript中的语句要以分号（;）为结束符。也就是说和缩进没关系了</p><h2 id="JavaScript语言基础"><a href="#JavaScript语言基础" class="headerlink" title="　　JavaScript语言基础"></a>　　JavaScript语言基础</h2><h3 id="变量声明（我们就通过浏览器自带的那个调试台来写吧-）"><a href="#变量声明（我们就通过浏览器自带的那个调试台来写吧-）" class="headerlink" title="　　　　变量声明（我们就通过浏览器自带的那个调试台来写吧~~）"></a>　　　　变量声明（我们就通过浏览器自带的那个调试台来写吧~~）</h3><p>　　　　1.JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。</p><p>　　　　2.声明变量使用 var 变量名; 的格式来进行声明</p><pre><code>var name = "Alex";也可以分两步，声明变量var name;然后name='Alex'，但是通常我们都是一步写完var age = 18;</code></pre><p>　　　　注意：</p><p>　　　　　　变量名是区分大小写的。</p><p>　　　　　　推荐使用驼峰式命名规则。首字母大写</p><p>　　　　　　保留字不能用做变量名。</p><p>　　　　<em>补充：（ES6新特性，等咱们学到 VUE 在细说，简单了解一下就行了**）</em></p><p>　　　　　　<em>ES6新增了let命令，用于声明变量。其用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。例如：for循环的计数器就很适合使用let命令。</em></p><pre><code>for (let i=0;i&lt;arr.length;i++){...}</code></pre><p>　　　　　　<em>ES6新增const用来声明常量。一旦声明，其值就不能改变。这个东西就是为了定义一个固定的常量，供大家使用，这个常量不会改变</em></p><pre><code>const PI = 3.1415;PI // 3.1415PI = 3// TypeError: "PI" is read-only</code></pre><p>　　　　<em>再次补充：保留字列表，不用硬记，写多了自然就知道了</em></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>abstractbooleanbytecharclassconstdebuggerdoubleenumexportextendsfinalfloatgotoimplementsimportintinterfacelongnativepackageprivateprotectedpublicshortstaticsupersynchronizedthrowstransientvolatile</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="　　JavaScript数据类型"></a>　　JavaScript数据类型</h2><p>　　　　<strong>JavaScript拥有动态类型（python也是动态的）</strong></p><pre><code>var x;  // 此时x是undefined  静态语言比如c：创建变量的时候，要指定变量的类型，python3.6也出现了类型注解的新特性def func(x:int,y:int) --&gt; int: return x + y，意思是参数是int类型，返回值也是int类型的，就是个注释的作用var x = 1;  // 此时x是数字var x = "Alex"  // 此时x是字符串 </code></pre><h3 id="数值-Number"><a href="#数值-Number" class="headerlink" title="　　　　数值(Number)"></a>　　　　<strong>数值(Number)</strong></h3><p>　　　　　　JavaScript不区分整型和浮点型，就只有一种数字类型。</p><pre><code>var a = 12.34;var b = 20;var c = 123e5;  // 12300000var d = 123e-5;  // 0.00123</code></pre><p>　　　　　　还有一种NaN，表示不是一个数字（Not a Number），也就是说是一个值，但不是数字。</p><p>　　　　　　常用方法：</p><pre><code>parseInt("123")  // 返回123parseInt("ABC")  // 返回NaN,NaN属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。parseFloat("123.456")  // 返回123.456</code></pre><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="　　　　字符串(String)"></a>　　　　<strong>字符串(String)</strong></h3><pre><code>var a = "Hello"var b = "world;var c = a + b; console.log(c);  // 得到Helloworld</code></pre><p>　　　　　　常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.length   #不加括号的是属性</td><td>返回长度</td></tr><tr><td>.trim()    #得到一个新值</td><td>移除空白</td></tr><tr><td>.trimLeft()</td><td>移除左边的空白</td></tr><tr><td>.trimRight()</td><td>移除右边的空白</td></tr><tr><td>.charAt(n) #n类似索引，从0开始，超过最大值返回’’空字符串</td><td>返回第n个字符</td></tr><tr><td>.concat(value, …) #s1=’hello’;s.concat(‘xx’);得到helloxx</td><td>拼接</td></tr><tr><td>.indexOf(substring, start) #这个start是从索引几开始找，没有返回-1</td><td>子序列位置</td></tr><tr><td>.substring(from, to) #不支持负数，所以一般都不用它，了解一下就行了</td><td>根据索引获取子序列</td></tr><tr><td>.slice(start, end) #var s1=’helloworld’;s1.slice(0,-5)看结果，就用它</td><td>切片</td></tr><tr><td>.toLowerCase() #全部变小写</td><td>小写</td></tr><tr><td>.toUpperCase()  #全部变大写</td><td>大写</td></tr><tr><td>.split(delimiter, limit)#分隔,s1.splite(‘ ‘),后面还可以加参数s1.split(‘ ‘，2),返回切割后的元素个数</td><td>分割</td></tr></tbody></table><p>　　　　　　拼接字符串一般使用“+”</p><p>　　　　slice和substring的区别：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>string.slice(start, stop)和string.substring(start, stop)：两者的相同点：如果start等于end，返回空字符串如果stop参数省略，则取到字符串末如果某个参数超过string的长度，这个参数会被替换为string的长度substirng()的特点：如果 start &gt; stop ，start和stop将被交换如果参数是负数或者不是数字，将会被0替换silce()的特点：如果 start &gt; stop 不会交换两者如果start小于0，则切割从字符串末尾往前数的第abs(start)个的字符开始(包括该位置的字符)如果stop小于0，则切割在从字符串末尾往前数的第abs(stop)个字符结束(不包含该位置字符)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<em>补充：</em></p><p>　　　　　　<em>ES6中引入了模板字符串。模板字符串（template string）是增强版的字符串，用反引号（`）标识，ESC键下面那个键就是反引号。它可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。你使用chorme浏览器就行，chorme浏览器支持ES6</em></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>// 普通字符串`这是普通字符串！`// 多行文本`这是多行的文本`// 字符串中嵌入变量var name = "q1mi", time = "today";`Hello ${name}, how are you ${time}?`</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<em><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210172855323-890290843.png" alt="img"></em></p><p>　　　　上面的写法是ES6中的，并且在console中输入内容的时候，按着shift+回车来进行换行，就能够不执行代码直接换行了<del>~</del></p><p>　　　　<em>注意：</em></p><p>　　　　　　<em>如果模板字符串中需要使用反引号，则在其前面要用反斜杠转义。</em></p><p>　　　　　　<em>JSHint启用ES6语法支持:/\</em> jshint esversion: 6 */*</p><h3 id="布尔值-Boolean"><a href="#布尔值-Boolean" class="headerlink" title="　　布尔值(Boolean)"></a>　　布尔值(Boolean)</h3><p>　　　　区别于Python，true和false都是小写。</p><pre><code>var a = true;var b = false;</code></pre><p>　　　　“”(空字符串)、0、null、undefined、NaN都是false。</p><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="　　null和undefined"></a>　　null和undefined</h3><ul><li>null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null;</li><li>undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。还有就是函数无明确的返回值时，返回的也是undefined。</li></ul><p>　　　　null表示变量的值是空，undefined则表示只声明了变量，但还没有赋值。</p><p>　　　　还不明白，上图吧！</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/867021-20180226115608671-110898150.jpg" alt="img"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/867021-20180226114954211-338562205.jpg" alt="img"></p><h3 id="对象-Object"><a href="#对象-Object" class="headerlink" title="　　对象(Object)"></a>　　对象(Object)</h3><p>　　　　JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…此外，JavaScript 允许自定义对象。</p><p>　　　　JavaScript 提供多个内建对象，比如 String、Date、Array 等等。</p><p>　　　　对象只是带有属性和方法的特殊数据类型。</p><p>　　　　<strong>数组</strong></p><p>　　　　　　数组对象的作用是：使用单独的变量名来存储一系列的值。类似于Python中的列表。</p><pre><code>var a = [123, "ABC"]; console.log(a[1]);  // 输出"ABC"</code></pre><p>　　　　 　　常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.length</td><td>数组的大小</td></tr><tr><td>.push(ele)</td><td>尾部追加元素</td></tr><tr><td>.pop()</td><td>获取尾部的元素</td></tr><tr><td>.unshift(ele)</td><td>头部插入元素</td></tr><tr><td>.shift()</td><td>头部移除元素</td></tr><tr><td>.slice(start, end)</td><td>切片</td></tr><tr><td>.reverse() #在原数组上改的</td><td>反转</td></tr><tr><td>.join(seq)#a1.join(‘+’)，seq是连接符</td><td>将数组元素连接成字符串</td></tr><tr><td>.concat(val, …) #连个数组合并</td><td>连接数组</td></tr><tr><td>.sort()</td><td>排序</td></tr><tr><td>.forEach() #讲了函数再说</td><td>将数组的每个元素传递给回调函数</td></tr><tr><td>.splice()</td><td>删除元素，并向数组添加新元素。</td></tr><tr><td>.map()  #讲了函数再说</td><td>返回一个数组元素调用函数处理后的值的新数组</td></tr></tbody></table><p>　　　　　　</p><p>　　　　　　concat示例：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210174247538-2073153320.png" alt="img"></p><p>　　　　　　关于sort()需要注意：</p><p>　　　　　　如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210174453200-368206811.png" alt="img"></p><p>　　　　　　上面的这种比较方式不是我们想要的啊，怎么办？</p><p>　　　　　　如果想按照其他标准进行排序，就需要提供比较函数，也就是自己提供一个函数提供排序规则，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p><p>　　　　　　若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>　　　　　　若 a 等于 b，则返回 0。<br>　　　　　　若 a 大于 b，则返回一个大于 0 的值。</p><p>　　　　　　示例：</p><pre><code>function sortNumber(a,b){    return a - b}var arr1 = [11, 100, 22, 55, 33, 44]arr1.sort(sortNumber)</code></pre><p>　　　　关于遍历数组中的元素，可以使用下面的方式：</p><pre><code>var a = [10, 20, 30, 40];for (var i=0;i&lt;a.length;i++) {  console.log(a[i]);}</code></pre><h3 id="forEach-（等学到后面再说这个）"><a href="#forEach-（等学到后面再说这个）" class="headerlink" title="　　forEach()（等学到后面再说这个）"></a>　　forEach()（等学到后面再说这个）</h3><p>　　　　<strong>语法：</strong></p><p>　　　　　　forEach(function(currentValue, index, arr), thisValue)</p><p>　　　　<strong>参数：</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>function(currentValue, index, arr)</em></td><td>必需。 数组中每个元素需要调用的函数。 函数参数:参数描述<em>currentValue</em>必需。当前元素<em>index</em>可选。当前元素的索引值。<em>arr</em>可选。当前元素所属的数组对象。</td></tr><tr><td><em>thisValue</em></td><td>可选。传递给函数的值一般用 “this” 值。 如果这个参数为空， “undefined” 会传递给 “this” 值</td></tr></tbody></table><h3 id="splice"><a href="#splice" class="headerlink" title="　　splice()"></a>　　splice()</h3><p>　　　　<strong>语法：</strong></p><p>　　　　　　splice(index,howmany,item1,…..,itemX)</p><p>　　　　<strong>参数：</strong> </p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>index</em></td><td>必需。规定从何处添加/删除元素。 该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</td></tr><tr><td><em>howmany</em></td><td>必需。规定应该删除多少元素。必须是数字，但可以是 “0”。 如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</td></tr><tr><td><em>item1</em>, …, <em>itemX</em></td><td>可选。要添加到数组的新元素</td></tr></tbody></table><p>　　　　　　看使用：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210175410381-1012157373.png" alt="img"></p><h3 id="map-（后面再讲）"><a href="#map-（后面再讲）" class="headerlink" title="　　map()（后面再讲）"></a>　　map()（后面再讲）</h3><p>　　　　<strong>语法：</strong></p><p>　　　　　　map(function(currentValue,index,arr), thisValue)</p><p>　　　　<strong>参数：</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>function(currentValue, index,arr)</em></td><td>必须。函数，数组中的每个元素都会执行这个函数 函数参数: 参数描述<em>currentValue</em>必须。当前元素的值<em>index</em>可选。当期元素的索引值<em>arr</em>可选。当期元素属于的数组对象</td></tr><tr><td><em>thisValue</em></td><td>可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue ，”this” 的值为 “undefined”</td></tr></tbody></table><p>　　　　<strong>补充：</strong></p><p>　　　　　　<em>ES6新引入了一种新的原始数据类型（Symbol），表示独一无二的值。它是JavaScript语言的第7种数据类型。</em></p><p>　　</p><h3 id="自定义对象"><a href="#自定义对象" class="headerlink" title="　　自定义对象"></a>　　自定义对象</h3><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210175831616-1189569900.png" alt="img"></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210180212685-1263241757.png" alt="img"></p><h3 id="类型查询"><a href="#类型查询" class="headerlink" title="　　类型查询"></a>　　类型查询</h3><pre><code>typeof "abc"  // "string"typeof null  // "object"typeof true  // "boolean"typeof 123  typeof NAN // "number"typeof undefined  //undefined</code></pre><p>　　　　typeof是一个一元运算符（就像++，–，！，- 等一元运算符），不是一个函数，也不是一个语句。</p><p>　　对变量或值调用 typeof 运算符将返回下列值之一：</p><ul><li>undefined - 如果变量是 Undefined 类型的</li><li>boolean - 如果变量是 Boolean 类型的</li><li>number - 如果变量是 Number 类型的</li><li>string - 如果变量是 String 类型的</li><li>object - 如果变量是一种引用类型或 Null 类型的</li></ul><h3 id=""><a href="#" class="headerlink" title="　　"></a>　　</h3><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="　　算数运算符"></a>　　算数运算符</h3><pre><code>+ - * / % ++ --  i++,是i自加1，i--是i自减1</code></pre><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="　　比较运算符"></a>　　<strong>比较运算符</strong></h3><pre><code>&gt; &gt;= &lt; &lt;= != == === !==</code></pre><p>　　注意：</p><pre><code>1 == “1”  // true  #弱等于，将1转换为字符串'1',在=号两个数据类型不同的时候，会自动给你变成相同的，具体怎么一个变换规则，先不用理他，因为这种比较不好，因为以后咱们就尽量用===。1 === "1"  // false #强等于，比较类型也比较值</code></pre><p>　　<strong>提一个输入法的高级用法：搜狗输入法的一个高级用法：不认识的字：先输入一个字母uhuohuohuo,就看到了焱，不会写大写的12345怎么办？先输入一个v12345，你就看到壹万贰仟叁佰肆拾伍了。</strong></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="　　逻辑运算符"></a>　　<strong>逻辑运算符</strong></h3><pre><code>&amp;&amp; || !  #and，or，非（取反）!null返回true</code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="　　赋值运算符"></a>　　<strong>赋值运算符</strong></h3><pre><code>= += -= *= /=  #n += 1其实就是n = n + 1</code></pre><p>好了同志们，学到这里就练习练习吧<del>然后在学</del></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="　　if-else"></a>　　if-else</h3><pre><code>var a = 10;if (a &gt; 5){  console.log("yes");}else {  console.log("no");}</code></pre><h3 id="if-else-if-else-多条件"><a href="#if-else-if-else-多条件" class="headerlink" title="　　if-else if-else  #多条件"></a>　　if-else if-else  #多条件</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var a = 10;if (a &gt; 5){  console.log("a &gt; 5");}else if (a &lt; 5) {  console.log("a &lt; 5");}else {  console.log("a = 5");}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="switch-切换"><a href="#switch-切换" class="headerlink" title="　　switch 切换"></a>　　switch 切换</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var day = new Date().getDay(); //示例化一个今天的日期对象，getDay()是获取天数的编号，0表示星期日switch (day) {  //这里day这个参数必须是一个值或者是一个能够得到一个值的算式才行，这个值和后面写的case后面的值逐个比较，满足其中一个就执行case对应的下面的语句，然后break，如果没有加break，还会继续往下判断  case 0: //如果day是0  console.log("Sunday"); //执行它  break; //然后break跳出  case 1:  console.log("Monday");  break;default:  //如果没有任何满足条件的，就执行它  console.log("...")}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　switch中的case子句通常都会加break语句，否则程序会继续执行后续case中的语句。</p><h3 id="for"><a href="#for" class="headerlink" title="　　for"></a>　　for</h3><pre><code>for (var i=0;i&lt;10;i++) {  //就这么个写法，声明一个变量，变量小于10，变量每次循环自增1，for(;;){console.log(i)}；这种写法就是个死循环，会一直循环，直到你的浏览器崩了，就不工作了，回头可以拿别人的电脑试试~~  console.log(i);}</code></pre><h3 id="while"><a href="#while" class="headerlink" title="　　while"></a>　　while</h3><pre><code>var i = 0;while (i &lt; 10) {  console.log(i);  i++;}</code></pre><h3 id="三元运算"><a href="#三元运算" class="headerlink" title="　　三元运算"></a>　　三元运算</h3><pre><code>var a = 1;var b = 2;var c = a &gt; b ? a : b //如果a&gt;b这个条件成立，就把冒号前面的值给c，否则把冒号后面的值给c   //python中的：a = x if x&gt;y else y</code></pre><p>来吧，大家练习一下<del>~</del></p><p>　　在我们的pycharm中可以更改js的版本</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210203546527-1669086543.png" alt="img"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="　　函数定义"></a>　　函数定义</h3><p>　　　　JavaScript中的函数和Python中的非常类似，只是定义方式有点区别。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>// 普通函数定义function f1() {  console.log("Hello world!");}// 带参数的函数function f2(a, b) {  console.log(arguments);  // 内置的arguments对象  console.log(arguments.length);  console.log(a, b);}// 带返回值的函数function sum(a, b){  return a + b;  //在js中，如果你想返回多个值是不行的，比如return a ，b；只能给你返回最后一个值，如果就想返回多个值，你可以用数组包裹起来 return [a,b]；}sum(1, 2);  // 调用函数  sum(1,2,3,4,5)参数给多了，也不会报错，还是执行前两个参数的和，sum(1)，少参数或者没参数也不报错，不过返回值就会是NAN// 匿名函数方式，多和其他函数配合使用，后面我们就会用到了var sum = function(a, b){  //在es6中，使用var，可能会飘黄，是因为在es6中，建议你使用let来定义变量，不过不影响你使用  return a + b;  }sum(1, 2);// 立即执行函数，页面加载到这里，这个函数就直接执行了，不需要被调用执行(function(a, b){  return a + b;})(1, 2);  //python中写可以这么写：ret=(lambda x,y:x+y)(10,20) 然后print(ret)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<em>补充：</em></p><p>　　　　ES6中允许使用“箭头”（=&gt;）定义函数，可以理解为匿名函数，用的不多。</p><pre><code>var f = v =&gt; v;// 等同于var f = function(v){  return v;}</code></pre><p>　　　　如果箭头函数不需要参数或需要多个参数，就是用圆括号代表参数部分：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var f = () =&gt; 5;// 等同于var f = function(){return 5};var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2){  return num1 + num2;}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="函数中的arguments参数（看一下就行了）"><a href="#函数中的arguments参数（看一下就行了）" class="headerlink" title="　　函数中的arguments参数（看一下就行了）"></a>　　函数中的arguments参数（看一下就行了）</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>function add(a,b){  console.log(a+b);  console.log(arguments.length) //获取传入的参数的个数，arguments就是指的你传入的所有的实参，放在一个数组里面，这个arguments.length是统计这个数组的元素的个数。}add(1,2)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　输出：</p><pre><code>32</code></pre><p>　　<em>注意：</em></p><p>　　　　函数只能返回一个值，如果要返回多个值，只能将其放在数组或对象中返回。</p><h3 id="函数的全局变量和局部变量"><a href="#函数的全局变量和局部变量" class="headerlink" title="　　函数的全局变量和局部变量"></a>　　函数的全局变量和局部变量</h3><p>　　　　<strong>局部变量</strong>：</p><p>　　　　　　在JavaScript函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它（该变量的作用域是函数内部）。只要函数运行完毕，本地变量就会被删除。</p><p>　　　　<strong>全局变量：</strong></p><p>　　　　　　在函数外声明的变量是<em>全局</em>变量，网页上的所有脚本和函数都能访问它。</p><p>　　　　<strong>变量生存周期：</strong></p><p>　　　　　　JavaScript变量的生命期从它们被声明的时间开始。</p><p>　　　　　　局部变量会在函数运行以后被删除。</p><p>　　　　　　全局变量会在页面关闭后被删除。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="　　作用域"></a>　　作用域</h3><p>　　　　首先在函数内部查找变量，找不到则到外层函数查找，逐步找到最外层。</p><p>　　　　<strong>几个例子：</strong></p><p>　　　　1.</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var city = "BeiJing";function f() {  var city = "ShangHai";  function inner(){    var city = "ShenZhen";    console.log(city);  }  inner();}f();  //输出结果是？ ---&gt; ShenZhen</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　2.</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var city = "BeiJing";function Bar() {  console.log(city);}function f() {  var city = "ShangHai";  return Bar;}var ret = f();ret();  // 打印结果是？---&gt; BeiJing</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　3.闭包</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var city = "BeiJing";function f(){    var city = "ShangHai";    function inner(){        console.log(city);    }    return inner;}var ret = f();ret();   ---&gt; ShangHai</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"> </p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="词法分析（尝试理解不理解也没事儿不讲-）"><a href="#词法分析（尝试理解不理解也没事儿不讲-）" class="headerlink" title="　　词法分析（尝试理解不理解也没事儿不讲~~）"></a>　　词法分析（尝试理解<del>不理解也没事儿</del>不讲~~）</h2><p>　　　　JavaScript中在调用函数的那一瞬间，会先进行词法分析。</p><p>　　　　<strong>词法分析的过程：</strong></p><p>　　　　当函数调用的前一瞬间，会先形成一个激活对象：Avtive Object（AO），并会分析以下3个方面：</p><p>　　　　　　1:函数参数，如果有，则将此参数赋值给AO，且值为undefined。如果没有，则不做任何操作。<br>　　　　　　2:函数局部变量，如果AO上有同名的值，则不做任何操作。如果没有，则将此变量赋值给AO，并且值为undefined。<br>　　　　　　3:函数声明，如果AO上有，则会将AO上的对象覆盖。如果没有，则不做任何操作。</p><p>　　　　函数内部无论是使用参数还是使用局部变量都到AO上找。</p><p>　　　　看两个例子：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var age = 18;function foo(){  console.log(age);  //分析到这一步的时候，发现你下面有age变量声明，那么age变量就在AO对象上村上了，并且值为undefined，所以函数在执行的时候，还没有到age=22这步的时候，age=undefined  var age = 22;      //如果没有这个变量声明，那么打印的结果应该是18  console.log(age);}foo();  // 问：执行foo()之后的结果是？undefined22</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　第二题：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var age = 18;function foo(){  console.log(age);  var age = 22;  console.log(age);  function age(){   #发现age这个函数名也是变量，将OA上的变量给替换了，那么函数在执行的时候，去OA上找，发现OA是个函数，然后执行到age=22的时候，age才被重新赋值    console.log("呵呵");  }  console.log(age);}foo();  // 执行后的结果是？结果：</code></pre><p>　　function age(){<br>　　　　console.log(“呵呵”);<br>　　}<br>　　22<br>　　22</p><pre><code></code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　答案解析：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>词法分析过程：1、分析参数，有一个参数，形成一个 AO.age=undefine;2、分析变量声明，有一个 var age, 发现 AO 上面已经有一个 AO.age，因此不做任何处理3、分析函数声明，有一个 function age(){...} 声明， 则把原有的 age 覆盖成 AO.age=function(){...};最终，AO上的属性只有一个age，并且值为一个函数声明执行过程：注意：执行过程中所有的值都是从AO对象上去寻找1、执行第一个 console.log(age) 时，此时的 AO.age 是一个函数，所以第一个输出的一个函数2、这句 var age=22; 是对 AO.age 的属性赋值， 此时AO.age=22 ，所以在第二个输出的是 223、同理第三个输出的还是22, 因为中间再没有改变age值的语句了这些内容就是好多人搞不明白的，经常写js代码的时候，发现自己的结果不对啊，什么情况，就是因为这个没搞清楚~~~</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="内置对象和方法"><a href="#内置对象和方法" class="headerlink" title="内置对象和方法"></a>内置对象和方法</h2><p>　　　　JavaScript中的所有事物都是对象：字符串、数字、数组、日期，等等。在JavaScript中，对象是拥有属性和方法的数据。</p><p>　　　　我们在学习基本数据类型的时候已经带大家了解了，JavaScript中的Number对象、String对象、Array对象等。</p><p>　　　　注意var s1 = “abc”和var s2 = new String(“abc”)的区别：typeof s1 –&gt; string而 typeof s2 –&gt; Object</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/867021-20180311224027096-1902975546.png" alt="img"></p><h3 id="自定义对象-1"><a href="#自定义对象-1" class="headerlink" title="　　自定义对象"></a>　　自定义对象</h3><p>　　　　JavaScript的对象（Object）本质上是键值对的集合（Hash结构），但是只能用字符串作为键。</p><pre><code>var a = {"name": "Alex", "age": 18};console.log(a.name);console.log(a["age"]);</code></pre><p>　　　　遍历对象中的内容：</p><pre><code>var a = {"name": "Alex", "age": 18};for (var i in a){  console.log(i, a[i]);}</code></pre><p><a href="https://stackoverflow.com/questions/684672/how-do-i-loop-through-or-enumerate-a-javascript-object">事情并没有那么简单…</a></p><p>　　　　<strong>创建对象：</strong></p><pre><code>var person=new Object();  // 创建一个person对象person.name="Alex";  // person对象的name属性person.age=18;  // person对象的age属性</code></pre><p>　　　　面向对象，在ES5中没有类的概念，只有个构造函数，命名的首字母要大写，实例化的时候使用new关键字进行实例化</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>function Person(name){    this.name=name}console.log(p1.name)  Person.prototype.func1 = function(){  //添加一些方法，使用prototype，叫做原型链 方法    console.log(this.name,'爱编程！')}var p1 = new Person('chao');p1.func1()#chao#chao 爱编程！类似于python中的面向对象,了解一下就可以了</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<em>注意：</em></p><p>　　　　　　<em>ES6中提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。</em></p><p>　　　　　　<em>也就是说，Object结构提供了“字符串–值”的对应，Map结构提供了“值–值”的对应，是一种更完善的Hash结构实现。</em></p><p>　　map的使用:（map也是了解内容，有兴趣的可以研究一下）</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var m = new Map();var o = {p: "Hello World"}m.set(o, "content"}m.get(o)  // "content"m.has(o)  // truem.delete(o)  // truem.has(o) // false</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　<strong>扩展：JavaScript面向对象之继承：（目前作为了解，大家有兴趣的可以自行研究一下）</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>// 父类构造函数var Car = function (loc) {  this.loc = loc;};// 父类方法Car.prototype.move = function () {  this.loc ++;};// 子类构造函数var Van = function (loc) {  Car.call(this, loc);};// 继承父类的方法Van.prototype = Object.create(Car.prototype);// 修复 constructorVan.prototype.constructor = Van;// 扩展方法Van.prototype.grab = function () {  /* ... */};</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="Date对象"><a href="#Date对象" class="headerlink" title="　　Date对象"></a>　　Date对象</h3><p>　　　　<strong>创建Date对象</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>//方法1：不指定参数var d1 = new Date(); //获取当前时间console.log(d1.toLocaleString());  //当前时间日期的字符串表示//方法2：参数为日期字符串var d2 = new Date("2004/3/20 11:12");console.log(d2.toLocaleString());var d3 = new Date("04/03/20 11:12");console.log(d3.toLocaleString());//方法3：参数为毫秒数，了解一下就行var d3 = new Date(5000);  console.log(d3.toLocaleString());console.log(d3.toUTCString());  //方法4：参数为年月日小时分钟秒毫秒var d4 = new Date(2004,2,20,11,12,0,300);console.log(d4.toLocaleString());  //毫秒并不直接显示</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　</p><p>　　　　<strong>Date对象的方法：</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>var d = new Date(); //getDate()                 获取日//getDay ()                 获取星期//getMonth ()               获取月（0-11）//getFullYear ()            获取完整年份//getHours ()               获取小时//getMinutes ()             获取分钟//getSeconds ()             获取秒//getMilliseconds ()        获取毫秒//getTime ()                返回累计毫秒数(从1970/1/1午夜)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong>练习：</strong></p><p>　　　　　　编写js代码，将当前日期按“2017-12-27 11:11 星期三”格式输出。</p><p>　　　　详细Date对象方法：<a href="http://www.w3school.com.cn/jsref/jsref_obj_date.asp">点我</a></p><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="　　JSON对象"></a>　　JSON对象</h3><pre><code>var str1 = '{"name": "Alex", "age": 18}';var obj1 = {"name": "Alex", "age": 18};// JSON字符串转换成对象var obj = JSON.parse(str1); // 对象转换成JSON字符串var str = JSON.stringify(obj1);</code></pre><h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="　　RegExp对象"></a>　　RegExp对象</h3><p>　　RegExp相关：用的比较多 </p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>//RegExp对象//创建正则对象方式1// 参数1 正则表达式(不能有空格)// 参数2 匹配模式：常用g(全局匹配;找到所有匹配，而不是在第一个匹配后停止)和i(忽略大小写)// 用户名只能是英文字母、数字和_，并且首字母必须是英文字母。长度最短不能少于6位 最长不能超过12位。// 创建RegExp对象方式（逗号后面不要加空格），假如匹配用户名是只能字母开头后面是字母加数字加下划线的5到11位的var reg1 = new RegExp("^[a-zA-Z][a-zA-Z0-9_]{5,11}$"); //注意，写规则的时候，里面千万不能有空格，不然匹配不出来你想要的内容，除非你想要的内容本身就想要空格，比如最后这个{5,11},里面不能有空格// 匹配响应的字符串var s1 = "bc123";//RegExp对象的test方法，测试一个字符串是否符合对应的正则规则，返回值是true或false。reg1.test(s1);  // true// 创建方式2，简写的方式// /填写正则表达式/匹配模式（逗号后面不要加空格）var reg2 = /^[a-zA-Z][a-zA-Z0-9_]{5,11}$/; reg2.test(s1);  // true注意，此处有坑：如果你直接写一个reg2.test()，test里面啥也不传，直接执行，会返回一个true，用其他的正则规则，可能会返回false，是因为，test里面什么也不传，默认传的是一个undefined，并且给你变成字符串undefined，所以能够匹配undefined的规则，就能返回true，不然返回false// String对象与正则结合的4个方法var s2 = "hello world";s2.match(/o/g);         // ["o", "o"]             查找字符串中 符合正则 的内容 ，/o/g后面这个g的意思是匹配所有的os2.search(/h/g);        // 0                      查找字符串中符合正则表达式的内容位置s2.split(/o/g);         // ["hell", " w", "rld"]  按照正则表达式对字符串进行切割s2.replace(/o/g, "s");  // "hells wsrld"          对字符串按照正则进行替换// 关于匹配模式：g和i的简单示例var s1 = "name:Alex age:18";s1.replace(/a/, "哈哈哈");      // "n哈哈哈me:Alex age:18"s1.replace(/a/g, "哈哈哈");     // "n哈哈哈me:Alex 哈哈哈ge:18"      全局匹配s1.replace(/a/gi, "哈哈哈");    // "n哈哈哈me:哈哈哈lex 哈哈哈ge:18"  不区分大小写// 注意事项1：// 如果regExpObject带有全局标志g，test()函数不是从字符串的开头开始查找，而是从属性regExpObject.lastIndex所指定的索引处开始查找。// 该属性值默认为0，所以第一次仍然是从字符串的开头查找。// 当找到一个匹配时，test()函数会将regExpObject.lastIndex的值改为字符串中本次匹配内容的最后一个字符的下一个索引位置。// 当再次执行test()函数时，将会从该索引位置处开始查找，从而找到下一个匹配。// 因此，当我们使用test()函数执行了一次匹配之后，如果想要重新使用test()函数从头开始查找，则需要手动将regExpObject.lastIndex的值重置为 0。// 如果test()函数再也找不到可以匹配的文本时，该函数会自动把regExpObject.lastIndex属性重置为 0。var reg3 = /foo/g;// 此时 regex.lastIndex=0reg3.test('foo'); // 返回true// 此时 regex.lastIndex=3reg3.test('xxxfoo'); // 还是返回true// 所以我们在使用test()方法校验一个字符串是否完全匹配时，一定要加上^和$符号，把匹配规则写的确定一些，尽量不用上面这种的写法/xxx/。// 注意事项2(说出来你可能不信系列)：// 当我们不加参数调用RegExpObj.test()方法时, 相当于执行RegExpObj.test(undefined)，然后将这个undefined又转为字符串"undefined",去进行匹配了, 并且/undefined/.test()默认返回true。var reg4 = /^undefined$/;reg4.test(); // 返回truereg4.test(undefined); // 返回truereg4.test("undefined"); // 返回true</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">扩展阅读</a></p><h3 id="Math对象（类似于python的内置函数）"><a href="#Math对象（类似于python的内置函数）" class="headerlink" title="　　Math对象（类似于python的内置函数）"></a>　　Math对象（类似于python的内置函数）</h3><p>　　　　Math：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>abs(x)      返回数的绝对值。exp(x)      返回 e 的指数。floor(x)    对数进行下舍入。log(x)      返回数的自然对数（底为e）。max(x,y)    返回 x 和 y 中的最高值。min(x,y)    返回 x 和 y 中的最低值。pow(x,y)    返回 x 的 y 次幂。random()    返回 0 ~ 1 之间的随机数。round(x)    把数四舍五入为最接近的整数。sin(x)      返回数的正弦。sqrt(x)     返回数的平方根。tan(x)      返回角的正切。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181211173002085-836545099.png" alt="img"></p><p>　　　　js里面没有这个问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端CSS</title>
      <link href="2019/11/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AFCSS/"/>
      <url>2019/11/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AFCSS/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS介绍"><a href="#CSS介绍" class="headerlink" title="CSS介绍"></a>CSS介绍</h1><p>　　CSS（<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heet，层叠样式表)定义<strong>如何显示</strong>HTML元素，给HTML设置样式，让它更加美观。</p><p>　　当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化（渲染）。</p><h1 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h1><h2 id="CSS实例"><a href="#CSS实例" class="headerlink" title="　　CSS实例"></a>　　CSS实例</h2><p>　　　　每个CSS样式由两个组成部分：选择器和声明。声明又包括属性和属性值。每个声明之后用分号结束。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/867021-20171215115756808-909989248.png" alt="img"></p><h2 id="CSS注释"><a href="#CSS注释" class="headerlink" title="　　CSS注释"></a>　　CSS注释</h2><pre><code>/*这是注释*/</code></pre><p>　　　　</p><h1 id="CSS的几种引入方式"><a href="#CSS的几种引入方式" class="headerlink" title="CSS的几种引入方式"></a>CSS的几种引入方式</h1><h2 id="行内样式"><a href="#行内样式" class="headerlink" title="　　行内样式"></a>　　行内样式</h2><p>　　　　行内式是在标记的style属性中设定CSS样式。不推荐大规模使用。</p><pre><code>&lt;p style="color: red"&gt;Hello world.&lt;/p&gt;</code></pre><h2 id="内部样式"><a href="#内部样式" class="headerlink" title="　　内部样式"></a>　　内部样式</h2><p>　　　　嵌入式是将CSS样式集中写在网页的标签对的<style></style>标签对中。格式如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        p{            background-color: #2b99ff;        }    &lt;/style&gt;&lt;/head&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="外部样式"><a href="#外部样式" class="headerlink" title="　　外部样式"></a>　　外部样式</h2><p>　　　　外部样式就是将css写在一个单独的文件中，然后在页面进行引入即可。推荐使用此方式。</p><pre><code>&lt;link href="mystyle.css" rel="stylesheet" type="text/css"/&gt;  #现在写的这个.css文件是和你的html是一个目录下，如果不是一个目录，href里面记得写上这个.css文件的路径</code></pre><h1 id="文件内容是-："><a href="#文件内容是-：" class="headerlink" title="　　　　文件内容是 ："></a>　　　　文件内容是 ：</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>p {color:blue;}/*注释*/注释一般都使用来描述后面这段css代码是给页面上哪一个板块用的/*标题样式*/xxxxx/*个人中心设置*/</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="CSS选择器（如何找到对应的标签）"><a href="#CSS选择器（如何找到对应的标签）" class="headerlink" title="CSS选择器（如何找到对应的标签）"></a>CSS选择器（如何找到对应的标签）</h1><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="　　基本选择器"></a>　　基本选择器</h2><h3 id="元素选择器（标签名）"><a href="#元素选择器（标签名）" class="headerlink" title="　　　　元素选择器（标签名）"></a>　　　　元素选择器（标签名）</h3><pre><code>p {color: "red";}</code></pre><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207154535392-1283987175.png" alt="img"></p><p>　　那如果有多个p标签，我像把其中一个p标签中的文字颜色改为红了，或者背景改成红色怎么办？看下面的选择器：</p><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="　　　　ID选择器"></a>　　　　ID选择器</h3><pre><code>#i1 {   #号表示id属性，后面的i1表示id属性的值  background-color: red;  #背景色，color:red是字体颜色，这个简单知道一下就行了，明天我们再学这些具体的css样式}</code></pre><h3 id=""><a href="#" class="headerlink" title="　　"></a>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207153602491-33262802.png" alt="img"></h3><p>　　id不能重复，如果想给多个p标签同时添加一个css样式怎么办？挨个添加id属性吗？并且，如果是不同的标签，但是他们的css样式要一样，怎么办？看下面</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="　　类选择器"></a>　　类选择器</h3><pre><code>.c1 {  .表示class属性，c1表示class的值  font-size: 14px;}p.c1 {  找到所有p标签里面含有class属性的值为c1的p标签，注意他俩之间没有空格昂  color: red;}</code></pre><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207154821357-384846956.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207154839045-1988394987.png" alt="img"></p><p>　　　　效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207154850682-1189151070.png" alt="img"></p><p>　　注意：</p><p>　　　　　　样式类名不要用数字开头（有的浏览器不认）。</p><p>　　　　　　标签中的class属性如果有多个，要用空格分隔。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207155053020-334897599.png" alt="img"></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207155038265-444493330.png" alt="img"></p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207155201914-1801640927.png" alt="img"></p><h3 id="通用选择器"><a href="#通用选择器" class="headerlink" title="　　　　通用选择器"></a>　　　　通用选择器</h3><pre><code>* {  *表示所有的标签  color: white;}</code></pre><p>　　　　来吧，大家练习一波，然后我们重新创建一个html文件，再学下面的内容。</p><h2 id="组合选择器"><a href="#组合选择器" class="headerlink" title="　　组合选择器"></a>　　组合选择器</h2><h3 id="后代选择器（子子孙孙）"><a href="#后代选择器（子子孙孙）" class="headerlink" title="　　　　后代选择器（子子孙孙）"></a>　　　　后代选择器（子子孙孙）</h3><pre><code>/*li内部的a标签设置字体颜色*/li a {  color: green;}</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207163748136-1783319719.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207163802796-1673302120.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207163826196-470686187.png" alt="img"></p><h3 id="儿子选择器（只找儿子）"><a href="#儿子选择器（只找儿子）" class="headerlink" title="　　　　儿子选择器（只找儿子）"></a>　　　　儿子选择器（只找儿子）</h3><pre><code>/*选择所有父级是 &lt;div&gt; 元素的 &lt;p&gt; 元素*/div&gt;p {  font-family: "Arial Black", arial-black, cursive;}</code></pre><h3 id="毗邻选择器"><a href="#毗邻选择器" class="headerlink" title="　　　　毗邻选择器"></a>　　　　毗邻选择器</h3><pre><code>/*选择所有紧接着&lt;div&gt;元素之后的&lt;p&gt;元素*/div+p {  margin: 5px;}</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207164109814-1949794423.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207163955780-1105802712.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207164121448-1753236300.png" alt="img"></p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207164331412-1198604198.png" alt="img"></p><h3 id="弟弟选择器"><a href="#弟弟选择器" class="headerlink" title="　　　　弟弟选择器"></a>　　　　弟弟选择器</h3><pre><code>/*i1后面所有的兄弟p标签*/#i1~p {  border: 2px solid royalblue;}</code></pre><p>　　　</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207164314772-187291471.png" alt="img"></p><p>　　　　找id为d2的div标签下的兄弟标签中的p标签，往下找</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207164521198-435909979.png" alt="img"></p><p>　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207164255117-1940454691.png" alt="img"></p><p> 　　来吧，兄弟们，练习一波，然后我们再重新创建一个html文件，再学下面的内容。</p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="　　属性选择器"></a>　　属性选择器</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>/*用于选取带有指定属性的元素。*/p[title] {  color: red;}/*用于选取带有指定属性和值的元素。*/p[title="213"] {  color: green;}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　通过属性或者属性的值来查找，这个属性是我们自己定义的，不是id啊class啊这种html自带的属性</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207172603956-754637152.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207172623777-933352862.png" alt="img"></p><p>　　每个标签里面都可以可一个title属性，这个属性就是鼠标移动到这个标签上，就显示出一个title属性的值</p><p>　　还有下面这些不太常用的，正则的写法，属性值以什么开头，以什么结尾等</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>/*找到所有title属性以hello开头的元素*/[title^="hello"] {  color: red;}/*找到所有title属性以hello结尾的元素*/[title$="hello"] {  color: yellow;}/*找到所有title属性中包含（字符串包含）hello的元素*/[title*="hello"] {  color: red;}/*找到所有title属性(有多个值或值以空格分割)中有一个值为hello的元素：*/[title~="hello"] {  color: green;}</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　看示例：title*=’hello’</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207173144383-514496721.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207173216433-1105814886.png" alt="img"></p><p>　　　　看示例：title~=’hello‘</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207173520306-1036032135.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207173357177-980916999.png" alt="img"></p><p>　　　　上面这个属性选择器不常用，简单了解一下就行了。</p><h3 id="分组和嵌套"><a href="#分组和嵌套" class="headerlink" title="　　分组和嵌套"></a>　　分组和嵌套</h3><h3 id="分组（多个选择器逗号分隔）"><a href="#分组（多个选择器逗号分隔）" class="headerlink" title="　　　　分组（多个选择器逗号分隔）"></a>　　　　分组（多个选择器逗号分隔）</h3><p>　　　　　　当多个元素的样式相同的时候，我们没有必要重复地为每个元素都设置样式，我们可以通过在多个选择器之间使用逗号分隔的分组选择器来统一设置元素样式。 </p><p>　　　　　　例如：</p><pre><code>div, p {  color: red;}</code></pre><p>　　　　　　上面的代码为div标签和p标签统一设置字体为红色。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207173824845-656763365.png" alt="img"></p><p>　　　　　　通常，我们会分两行来写，更清晰:</p><pre><code>div, #如果你这样写，千万别忘了逗号，不然就成了div下的子子孙孙里面找p标签p {  color: red;}</code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="　　　　嵌套"></a>　　　　嵌套</h3><p>　　　　　　多种选择器可以混合起来使用，比如：.c1类内部所有p标签设置字体颜色为红色。</p><pre><code>.c1 p {  color: red;}</code></pre><h2 id="伪类选择器（比较特殊，CSS3版本新加的特性）"><a href="#伪类选择器（比较特殊，CSS3版本新加的特性）" class="headerlink" title="　　伪类选择器（比较特殊，CSS3版本新加的特性）"></a>　　伪类选择器（比较特殊，CSS3版本新加的特性）</h2><p>　　　　可以根据标签的不同状态再进行进一步的区分，比如一个a标签，点击前，点击时，点击后有不同的三个状态。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>/* 未访问的链接 */a:link {  color: #FF0000}/* 已访问的链接 */a:visited {  color: #00FF00} /* 鼠标移动到链接上 */  这个用的比较多a:hover {  color: #FF00FF} /* 选定的链接 */ 就是鼠标点下去还没有抬起来的那个瞬间，可以让它变颜色a:active {  color: #0000FF}/*input输入框获取焦点时样式*/input:focus {   #input默认的有个样式，鼠标点进去的时候，input框会变浅蓝色的那么个感觉  #outline: none;  background-color: #eee; #框里面的背景色}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="伪元素选择器（通过css来造标签，不推荐使用）"><a href="#伪元素选择器（通过css来造标签，不推荐使用）" class="headerlink" title="　　伪元素选择器（通过css来造标签，不推荐使用）"></a>　　伪元素选择器（通过css来造标签，不推荐使用）</h2><h3 id="first-letter"><a href="#first-letter" class="headerlink" title="　　　　first-letter"></a>　　　　first-letter</h3><p>　　　　　　常用的给首字母设置特殊样式：</p><pre><code>#将p标签中的文本的第一个字变颜色变大小p:first-letter {   font-size: 48px;  color: red;}</code></pre><h3 id="-1"><a href="#-1" class="headerlink" title="　　　　"></a>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207205139328-625682764.png" alt="img"></h3><h3 id="before"><a href="#before" class="headerlink" title="　　　　before"></a>　　　　before</h3><pre><code>/*在每个&lt;p&gt;元素之前插入内容*/p:before {  content:"*";  color:red;}</code></pre><h3 id="-2"><a href="#-2" class="headerlink" title="　　　　"></a>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207205234128-599696388.png" alt="img"></h3><h3 id="after"><a href="#after" class="headerlink" title="　　　　after"></a>　　　　after</h3><pre><code>/*在每个&lt;p&gt;元素之后插入内容*/p:after {  content:"[?]";  color:blue;} </code></pre><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207205335813-740898590.png" alt="img"></p><p>　　　　　　上面的这些前后添加的文本内容在页面上是无法选中的，正常的标签或者文字是可以选中的。</p><p>　　　　　　before和after多用于清除浮动。后面讲</p><h2 id="选择器的优先级（难点）"><a href="#选择器的优先级（难点）" class="headerlink" title="　　选择器的优先级（难点）"></a>　　选择器的优先级（难点）</h2><h3 id="CSS继承"><a href="#CSS继承" class="headerlink" title="　　　　CSS继承"></a>　　　　CSS继承</h3><p>　　　　　　我们通过上面的学习可以发现，我们可以通过很多种选择器来选择标签，如果有不同的选择器选中了相同的标签，并且赋予了不同的css样式，那么该按照哪个css样式来进行渲染呢？首要浏览器拿到我们给他的HTML文件的时候，它是从上到下加载我们的文件内容的，这也是为什么你会先看到head标签里面的内容，比如那个title标签。再看下面的例子：我在style里面写了两个#p1并且设置了不同的css样式，还有一个10.css文件，文件里面也写了一个#p1，对应一个其他的css样式，最后页面渲染的时候是选择的最后一个link那个文件中的#p1对应的那个css样式来渲染的，是因为按照顺序加载导致的，一个把一个覆盖了</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207210600224-118716218.png" alt="img"></p><p>　　　　　　10.css文件里的内容：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207210830054-1277465540.png" alt="img"></p><p>　　　　　　最终效果：为蓝色</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207210922975-606064073.png" alt="img"></p><p>　　　　　　总结：当选择器相同的时候，按照顺序来看css样式，谁最后就按照谁渲染。那如果是不同的选择器的时候呢？就要学习我们下面的优先级了，首先看一下继承：</p><p>　　　　　　继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个body定义了的字体颜色值也会应用到段落的文本中。</p><pre><code>body {  color: red;}</code></pre><p>　　　　　　此时页面上所有标签都会继承body的字体颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的，他的权重是0。</p><p>　　　　　　我们只要给对应的标签设置字体颜色就可覆盖掉它继承的样式。</p><pre><code>p {  color: green;}</code></pre><p>　　　　　　此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin, padding, background等。</p><h3 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="　　选择器的优先级"></a>　　选择器的优先级</h3><p>　　　　我们上面学了很多的选择器，也就是说在一个HTML页面中有很多种方式找到一个元素并且为其设置样式，那浏览器根据什么来决定应该应用哪个样式呢？</p><p>　　　　其实是按照不同选择器的权重来决定的，具体的选择器权重计算方式如下图：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/867021-20180305155201408-1680872107.png" alt="img"></p><p>　　　　注：内联样式的意思是把css样式写在标签里面：</p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207211608760-1800506928.png" alt="img"></p><p>　　　　　　　　其他的权重：但是有一点说一下，就是上面那个权重计算永不进位的意思是：我们看上面知道class的权重是10，但是即便是11个class相加起来大于id的100权重，也还是id生效，也就是说，不会进位，class组合起来也无法超过id的权重</p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207211708586-1859067719.png" alt="img"></p><p>　　　　除此之外还可以通过添加 !important方式来强制让样式生效，不讲道理的操作，但并不推荐使用。因为如果过多的使用!important会使样式文件混乱不易维护，使用方法：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181207212107609-1208258871.png" alt="img"></p><p>　　　　<strong>万不得已可以使用!important</strong></p><p>　　好了同志们，练习一下吧，没啥捷径，就是多练。。。练习一下在继续学习下面的内容~~</p><h1 id="CSS属性相关"><a href="#CSS属性相关" class="headerlink" title="CSS属性相关"></a>CSS属性相关</h1><h2 id="宽和高"><a href="#宽和高" class="headerlink" title="　　宽和高"></a>　　宽和高</h2><p>　　　　width属性可以为元素设置宽度。</p><p>　　　　height属性可以为元素设置高度。</p><p>　　　　块级标签才能设置宽度，内联标签的宽度由内容来决定。</p><h2 id="字体属性"><a href="#字体属性" class="headerlink" title="　　字体属性"></a>　　字体属性</h2><h3 id="文字字体"><a href="#文字字体" class="headerlink" title="　　　　文字字体"></a>　　　　文字字体</h3><p>　　　　　　font-family可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。浏览器会使用它可识别的第一个值。</p><p>　　　　　　简单实例：</p><pre><code>body {  font-family: "Microsoft Yahei", "微软雅黑", "Arial", sans-serif}</code></pre><h3 id="字体大小"><a href="#字体大小" class="headerlink" title="　　　　字体大小"></a>　　　　字体大小</h3><pre><code>p {  font-size: 14px;}</code></pre><p>　　　　　　如果设置成inherit表示继承父元素的字体大小值。</p><h3 id="字重（粗细）"><a href="#字重（粗细）" class="headerlink" title="　　　　字重（粗细）"></a>　　　　字重（粗细）</h3><p>　　　　　　font-weight用来设置字体的字重（粗细）。</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">normal</td><td align="center">默认值，标准粗细</td></tr><tr><td align="center">bold</td><td align="center">粗体</td></tr><tr><td align="center">bolder</td><td align="center">更粗</td></tr><tr><td align="center">lighter</td><td align="center">更细</td></tr><tr><td align="center">100~900</td><td align="center">设置具体粗细，400等同于normal，而700等同于bold</td></tr><tr><td align="center">inherit</td><td align="center">继承父元素字体的粗细值</td></tr></tbody></table><h2 id="文本颜色"><a href="#文本颜色" class="headerlink" title="　　文本颜色"></a>　　文本颜色</h2><p>　　　　　　颜色属性被用来设置文字的颜色。</p><p>　　　　　　颜色是通过CSS最经常的指定：</p><p>　　　　　　　　1.十六进制值 - 如: <strong>＃</strong>FF0000 #前两位是表示红，中间两位表示绿，后面两位表示蓝，F是最高级别，0表示最低级别（无色）</p><p>　　　　　　　　2.一个RGB值 - 如: RGB(255,0,0) #红绿蓝就是RGB的意思，第一个参数是红，最高255，最低0</p><p>　　　　　　　　3.颜色的名称 - 如:  red</p><p>　　　　　　还有rgba(255,0,0,0.3)，第四个值为alpha, 指定了色彩的透明度/不透明度，它的范围为0.0到1.0之间。</p><h2 id="文字属性"><a href="#文字属性" class="headerlink" title="　　文字属性"></a>　　文字属性</h2><h3 id="文字对齐"><a href="#文字对齐" class="headerlink" title="　　　　文字对齐"></a>　　　　文字对齐</h3><p>　　　　　　text-align 属性规定元素中的文本的水平对齐方式。</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">左边对齐 默认值</td></tr><tr><td align="center">right</td><td align="center">右对齐</td></tr><tr><td align="center">center</td><td align="center">居中对齐</td></tr><tr><td align="center">justify</td><td align="center">两端对齐</td></tr></tbody></table><h3 id="文字装饰"><a href="#文字装饰" class="headerlink" title="　　　　文字装饰"></a>　　　　文字装饰</h3><p>　　　　　　text-decoration 属性用来给文字添加特殊效果。</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">none</td><td align="center">默认。定义标准的文本。</td></tr><tr><td align="center">underline</td><td align="center">定义文本下的一条线。</td></tr><tr><td align="center">overline</td><td align="center">定义文本上的一条线。</td></tr><tr><td align="center">line-through</td><td align="center">定义穿过文本下的一条线。</td></tr><tr><td align="center">inherit</td><td align="center">继承父元素的text-decoration属性的值。</td></tr></tbody></table><p>　　　　　　常用的为去掉a标签默认的自划线：</p><pre><code>a {  text-decoration: none;}</code></pre><h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="　　　　首行缩进"></a>　　　　首行缩进</h3><p>　　　　　　将段落的第一行缩进 32像素：</p><pre><code>p {  text-indent: 32px; #首行缩进两个字符，因为我记得一个字在页面上的默认大小为16px}</code></pre><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="　　背景属性"></a>　　背景属性</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>/*背景颜色*/background-color: red;/*背景图片*/background-image: url('1.jpg');  #url里面是图片路径，如果和你的html文件在一个目录下，使用这种相对路径就行了，来个葫芦娃图片试一下background-repeat: no-repeat; /* 背景重复 repeat(默认):背景图片沿着x轴和y轴重复平铺，铺满整个包裹它的标签 repeat-x：背景图片只在水平方向上平铺 repeat-y：背景图片只在垂直方向上平铺 no-repeat：背景图片不平铺*//*背景位置*/background-position: right top;/*background-position: 200px 200px;*/ #以前大家都用雪碧图，就是将很多的网页上需要的小图片组合成一个大图，用这个图中哪个位置的小图片，就通过这个参数来调整，看下面的示例操作，现在很少用这个了</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208114700748-1260644052.png" alt="img">注意，qq截图的时候可以给你显示像素，这个是200px*200px</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208115339916-1043227934.png" alt="img"></p><p>　　　　下面是浏览器的坐标系：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208114930964-1784552847.png" alt="img"></p><p> 　　　　no-repeat  和  right top：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208115608776-1350296366.png" alt="img"></p><p>　　　　效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208115443003-883153296.png" alt="img"></p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208115537736-1122010862.png" alt="img"></p><p>　　　　background-position：200px 200px；这种参数的示例：</p><p>　　　　在抽屉上还可以找到这个图片：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208120318062-1067652173.png" alt="img"></p><p>　　　　然后：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208120413524-669062496.png" alt="img"></p><p>　　　　你就会看到它：好多个小图片组成的</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208120443079-1842065687.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208120535986-216094331.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208120642285-634482278.png" alt="img"></p><p>　　　　那么有同学会疑问，为什么要将这些小图片做成一个大图呢？因为其实页面在加载到img标签之后，会单独的往后端发请求，来请求这个图，如果小图很多的话，页面要发好多个请求，那么页面加载的就慢，所以放到一个大图上，每个用这个大图上面的小图的地方，img里面的url都指向这个一个图片的url，这样加载就很快了，因为只需要请求一次，你的网页就拿到了这个图片，其他的请求都可以直接用这个图，而不需要多次请求这个图了，然后通过这个background-position的值来调整。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208121155458-936185248.png" alt="img"></p><p>　　　　点击小灯泡的第一个，就看到效果了，自动帮你优化写法，这个小灯泡就是pycharm帮你提供的一些帮助吧算是</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208121330646-252034880.png" alt="img"></p><p>　　　　</p><p>　　　　支持简写：</p><pre><code>background:#ffffff url('1.png') no-repeat right top;</code></pre><p>　　　　使用背景图片的一个常见案例就是很多网站会把很多小图标放在一张图片上，然后根据位置去显示图片。减少频繁的图片请求，就是我们刚才说的雪碧图。</p><p><a href="http://www.w3school.com.cn/css/css_background.asp"> 参考链接点我</a></p><p>　　　　一个有趣的例子：鼠标滚动但是背景不动，就是最近发现的，很多电商都在这么搞，你们看过这种效果没有。下面是我模仿着写的一个小例子</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;滚动背景图示例&lt;/title&gt;    &lt;style&gt;        * {            margin: 0;        }        .box {            width: 100%;  #凡是这种使用百分比的，都是按照你父标签的宽度的百分之多少来显示            height: 500px;            background: url("https://www.luffycity.com/static/img/width-bank.1c9d1b0.png") no-repeat center center; #这个图片好像没有了，自己找一个网上的图片，把这个url路径换一下，可以到摄图网去看看，国内免费的一个图片网站            background-attachment: fixed;  #就是这个属性，让你的背景图片固定住的意思，attachment是附属、依附的意思        }        .d1 {            height: 500px;            background-color: tomato;        }        .d2 {            height: 500px;            background-color: steelblue;        }        .d3 {            height: 500px;            background-color: mediumorchid;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class="d1"&gt;&lt;/div&gt;    &lt;div class="box"&gt;&lt;/div&gt;    &lt;div class="d2"&gt;&lt;/div&gt;    &lt;div class="d3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="边框"><a href="#边框" class="headerlink" title="　　边框"></a>　　边框</h2><p>　　　　边框属性 </p><p>　　　　　　1.border-width  宽度</p><p>　　　　　　2.border-style   样式</p><p>　　　　　　3.border-color   颜色</p><pre><code>#i1 {  border-width: 2px;    border-style: solid;  border-color: red;}</code></pre><p>　　　　通常使用简写方式：</p><pre><code>#i1 {  border: 2px solid red;}</code></pre><p>　　　　边框样式</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">none</td><td align="center">无边框。</td></tr><tr><td align="center">dotted</td><td align="center">点状虚线边框。</td></tr><tr><td align="center">dashed</td><td align="center">矩形虚线边框。</td></tr><tr><td align="center">solid</td><td align="center">实线边框。</td></tr></tbody></table><p>　　　　除了可以统一设置边框外还可以单独为某一个边框设置样式，如下所示：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>#i1 {  border-top-style:dotted;  border-top-color: red;  border-right-style:solid;  border-bottom-style:dotted;  border-left-style:none;}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　单独设置一下左边的边框：</p><h2 id="-3"><a href="#-3" class="headerlink" title="　　　"></a>　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208130046585-568704532.png" alt="img"></h2><p>　　　　只显示左边的边框：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208130220100-179622676.png" alt="img"></p><p>　　　　</p><h2 id="border-radius"><a href="#border-radius" class="headerlink" title="　　border-radius"></a>　　border-radius</h2><p>　　　　用这个属性能实现圆角边框的效果。</p><p>　　　　将border-radius设置为长或高的一半即可得到一个圆形。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208130319771-1963248685.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208130348521-828431269.png" alt="img"></p><p>　　　　效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208130359972-393205540.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208130446466-1069777318.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208130529621-2048119615.png" alt="img"></p><p>　　　　还可在调试窗口调整颜色来测试（调试窗口：页面上右键–检查，或者f12）</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208130739887-2037903737.png" alt="img"></p><p>　　　　调整好之后，把调整后的值复制到我们的css属性里面就行了</p><p>　　　　还可以通过hover来设置鼠标移动上去变颜色：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208130853437-793837491.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208131049951-1399568454.png" alt="img"></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208131143872-585826999.png" alt="img"></p><p>　　　　　　你会看到之前的background-color有了一个横线，这是不生效的效果，因为你查看的hover的样式</p><p>　　　　　　还可以看到class</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208131339585-37060984.png" alt="img"></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208131439471-788285188.png" alt="img"></p><p>　　　　　　把对勾去了，这个class的样式就不显示了</p><p>　　　　　　通过调试窗口还可以玩一个神奇的东西：document.body.contentEditable=true</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208131857155-1100473108.png" alt="img"></p><p>　　　　　　不用ps就能够改了：注意昂，只能改当前页面的显示内容，改不了真实的值，并且页面一刷新，这个指令就失效了，需要重新输入</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208131945592-520369186.png" alt="img"></p><h2 id="display属性"><a href="#display属性" class="headerlink" title="　　display属性"></a>　　display属性</h2><p>　　　　用于控制HTML元素的显示效果。</p><table><thead><tr><th>值</th><th>意义</th></tr></thead><tbody><tr><td>display:”none”</td><td>HTML文档中元素存在，但是在浏览器中不显示。一般用于配合JavaScript代码使用。</td></tr><tr><td>display:”block”</td><td>默认占满整个页面宽度，如果设置了指定宽度，则会用margin填充剩下的部分。</td></tr><tr><td>display:”inline”</td><td>按行内元素显示，此时再设置元素的width、height、margin-top、margin-bottom和float属性都不会有什么影响。</td></tr><tr><td>display:”inline-block”</td><td>使元素同时具有行内元素和块级元素的特点。</td></tr></tbody></table><p>　　　　<strong>display:”none”与visibility:hidden的区别：</strong></p><p>　　　　visibility:hidden: 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。</p><p>　　　　display:none: 可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。</p><p>　　　　教大家一些创建标签时的简写方法：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132411366-1950884846.png" alt="img"></p><p>　　　　看效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132429454-611609661.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132458895-1321890680.png" alt="img"></p><p>　　　　或者简写：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132520526-1708123786.png" alt="img"></p><p>　　　　然后按一下tab键：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132536272-631750425.png" alt="img"></p><p>　　　　然后看div里面套一个a标签</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132555566-1850944602.png" alt="img"></p><p>　　　　然后一回车</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132614543-202629946.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132630741-366791832.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132637871-9049468.png" alt="img"></p><p>　　　　这些都是编辑器帮你提供的快捷方式。有兴趣的同学可以去研究研究，有好多，一个nb的前端工程师，写一个页面非常快速</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132742204-277504008.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132749847-856807129.png" alt="img"></p><p>　　　　在加一个$符号：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132815647-2079252021.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132828931-306589089.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132932648-134814913.png" alt="img"></p><p>　　　　按delete删除：</p><p>　　　　一下就删除了三个了：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208132955679-189701953.png" alt="img"></p><p> 　　注意一点昂：块级标签不管你设置的宽度是多少，都会占用你整个页面宽度的空间，看下面</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133210004-1162032128.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133240193-64552318.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133229686-193235005.png" alt="img"></p><p> 　　　　然后我们看一下display的效果inline-block，高度宽度还可以设置，包含内联和块级标签的属性</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133359614-778916057.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133405699-347506321.png" alt="img"></p><p>　　　　还可以通过display：block将内联标签改为块级标签的效果</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133617134-711758482.png" alt="img"></p><p>　　　　看效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133701377-625991503.png" alt="img"></p><p>　　　　</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133733567-1485371098.png" alt="img"></p><p>　　　　看效果　　　　</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133801433-1747288358.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133816742-1011326105.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208133827281-74574900.png" alt="img"></p><p>　　　　不占用位置，也不显示</p><p>　　　　来吧，大家练习一下，然后再继续学习<del>~</del></p><h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="　　CSS盒子模型"></a>　　CSS盒子模型</h2><p>　　　　在css里面，每个标签可以称为一个盒子模型，看下面的图：</p><p>　　　　1.<strong>margin</strong>:            外边距：用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。</p><p>　　　　2.<strong>padding</strong>:           内边距：用于控制内容与边框之间的距离；   </p><p>　　　　3.<strong>Border</strong>(边框):     围绕在内边距和内容外的边框。</p><p>　　　　4.<strong>Content</strong>(内容):   盒子的内容，显示文本和图像。</p><p>　　　　看图吧：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/867021-20180305155247808-885981996.png" alt="img"></p><h2 id="margin外边距"><a href="#margin外边距" class="headerlink" title="　　margin外边距"></a>　　margin外边距</h2><pre><code>.margin-test {  margin-top:5px;  margin-right:10px;  margin-bottom:15px;  margin-left:20px;}</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208143850401-1536915759.png" alt="img"></p><p>　　　　所以在写css样式的时候，都会先写一个</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208143927238-1291838734.png" alt="img"></p><p>　　　  意思是说，body的上下左右的margin都设置为0.</p><p>　　　　在看一个，如果将上下两个标签都设置了margin是什么效果</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208144815646-1569892898.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208144951666-550373323.png" alt="img"></p><p>　　　　</p><p>　　　　推荐使用简写：</p><pre><code>.margin-test {  margin: 5px 10px 15px 20px;}</code></pre><p>　　　　顺序：上右下左</p><p>　　　　常见居中：</p><pre><code>.mycenter {  margin: 0 auto;  #上下0像素，左右自适应，居中的效果}如果你写的是三个：margin: 10px 20px 10px;意思是上为10，左右为20，下为10</code></pre><h2 id="padding内填充"><a href="#padding内填充" class="headerlink" title="　　padding内填充"></a>　　padding内填充</h2><pre><code>.padding-test {  padding-top: 5px;  padding-right: 10px;  padding-bottom: 15px;  padding-left: 20px;}</code></pre><p>　　　　推荐使用简写：</p><pre><code>.padding-test {  padding: 5px 10px 15px 20px;}</code></pre><p>　　　　顺序：上右下左</p><p>　　　　补充padding的常用简写方式：</p><ul><li>提供一个，用于四边；</li><li>提供两个，第一个用于上－下，第二个用于左－右；</li><li>如果提供三个，第一个用于上，第二个用于左－右，第三个用于下；</li><li>提供四个参数值，将按上－右－下－左的顺序作用于四边；</li></ul><p>　　接下来我们来学一下浮动：</p><h2 id="float"><a href="#float" class="headerlink" title="　　float"></a>　　float</h2><p>　　　　在 CSS 中，任何元素都可以浮动。最开始出现浮动这个东西是为了什么呢，记不记得一个word文档里面，插入图片的时候，有一个文字环绕的效果啊：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208145322333-1379807325.png" alt="img"></p><p>　　　　最开始浮动这个东西是想要做上面这种效果用的，现在多数用来做网页布局的。你记不记得很多的网站都是左边一个菜单栏，右边一堆的其他内容啊</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208145621250-118297115.png" alt="img"></p><p>　　　　你看昂：我们如果这样写</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208145732114-1914956797.png" alt="img"></p><p>　　　　看效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208145753965-120134027.png" alt="img"></p><p>　　　　那怎么让绿色的这个跑到红色的左边呢？</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208145836254-408000548.png" alt="img"></p><p>　　　　</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208145845674-86898454.png" alt="img"></p><p>　　　　上面是浮动的一个最简单的用法，但是浮动有一个副作用，看：</p><p>　　　　重新创建一个htnl文件，我们写上下面的内容</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208150301858-1376006763.png" alt="img"></p><p>　　　　css样式：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208150316858-565893934.png" alt="img"></p><p>　　　　效果是这样的：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208150105395-576139777.png" alt="img"></p><p>　　　　怎么让下面这个粉色的跑到右边去啊</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208150357134-105858762.png" alt="img"></p><p>　　　　刷新看看效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208150155496-1125102331.png" alt="img"></p><p>　　　　发现是不是有问题啊，两个红色的设置了一个往左浮动一个往右浮动，c3那个标签没有设置浮动之后，发现红色的两个虽然浮动了，但是粉色的这个跑上去了，两个红色的压在这个粉色的标签上了。</p><p>　　　　先看这个问题昂：在给c2的div标签加上浮动之前是下面这样的效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208150634321-1793677642.png" alt="img"></p><p>　　　　我并没有给c1那个div标签设置高度，但是你发现c1这个div标签是有高度的，这是因为里面两个c2div我设置了高度了，这两个div将c1这个div标签撑起来了</p><p>　　　　当我们加上浮动之后，你再看这个c1的div标签的高度：发现c1这个div的高度没有了，显示的高度是1.99，是因为我给它设置了边框，上下边框加起来正好2px，这里显示了个约等的值，别在意昂</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208150842390-1784398455.png" alt="img"></p><p>　　　　这就看到了浮动的副作用，浮动起来以后脱离了你整个页面文档，然后两个c1的div标签，一个往左靠，一个往右靠，无法撑起自己的父级标签了，也就是那个c1的div标签，那么粉色的c3那个标签就上去了。影响了我们页面的整个布局。</p><p>　　　　我们不想让粉色的这个标签顶上去怎么办，看一下c1这个标签的子标签的高度(内边距+外边距+边框宽度+标签高度)，然后给c1这个父标签的高度设置成这个值，当然是可以的，但是如果两个子标签的高度不相等呢，你按照哪一个来算高度啊，并且将来这样的标签要是很多怎么办，没法算对不对，所以我们一般不用这种方法来解决浮动的问题，看下面我们要学的clear，清除浮动。</p><p>　　　　</p><p>　　　　浮动元素会生成一个块级框，而不论它本身是何种元素。</p><p>　　　　关于浮动的两个特点：</p><ul><li>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li><li>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</li></ul><h3 id="三种取值"><a href="#三种取值" class="headerlink" title="　　三种取值"></a>　　三种取值</h3><p>　　　　left：向左浮动</p><p>　　　　right：向右浮动</p><p>　　　　none：默认值，不浮动</p><p><a href="http://www.w3school.com.cn/css/css_positioning_floating.asp">参考示例</a></p><h2 id="clear"><a href="#clear" class="headerlink" title="　　clear"></a>　　clear</h2><p>　　　　clear属性规定元素的哪一侧不允许其他浮动元素。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>在左侧不允许浮动元素。</td></tr><tr><td>right</td><td>在右侧不允许浮动元素。</td></tr><tr><td>both</td><td>在左右两侧均不允许浮动元素。</td></tr><tr><td>none</td><td>默认值。允许浮动元素出现在两侧。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 clear 属性的值。</td></tr></tbody></table><p>　　　　注意：clear属性只会对<strong>自身</strong>起作用，而不会影响其他元素。按照我们上面那个例子的意思就是说，我们可以给粉色的那个c3属性的div标签设置一个clear：both，意思是说，这个标签的左右都不能有浮动的标签，那么它只能跑到两个浮动的c2div标签的下面，但是一般我们都会再c2和c3的中间加一个别的标签，给这个标签设置一个clear属性，并且高度设置为0，或者不给高度，因为浮动的标签是你自己c1里面的，所以你要自己解决，才能撑起你自己的高度，并且再用其他的标签的时候，我们就不需要再考虑浮动的问题了，直接写自己的样式就可以了，不然你每次加其他的标签都要去看看上面的标签有没有浮动的啊，对不对。</p><p>　　　　接着看上面这个示例，如果我们这样设置：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208152435826-353168695.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208152443489-535497409.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208152651634-1441650559.png" alt="img"></p><p>　　　　这样粉色的这个标签就上不去了</p><p>　　　　</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="　　清除浮动"></a>　　清除浮动</h3><p>　　　　浮动的副作用（父标签塌陷问题），所以要清除浮动</p><p>　　　　主要有三种方式：</p><ul><li>固定高度  就是我们刚才的示例，在父标签里面加一个其他的标签</li><li>伪元素清除法  css来解决</li><li>overflow:hidden</li></ul><p>　　　　伪元素清除法（使用较多）：</p><pre><code>.clearfix:after {  content: "";  display: block;  clear: both;}</code></pre><p> 　　我们通过微元素清除法来清除一下浮动：</p><p>　　</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208153433550-863716120.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208153540566-1263790889.png" alt="img"></p><p>　　　　效果是一样的：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208153615427-452192634.png" alt="img"></p><p>　　　　一般业内约定成俗，都把这个清除浮动的class属性命名为clearfix，而不是cc，如果你在别的网页看到了这个clearfix，这个一定是用来清除浮动的。</p><p> 　　　　总结一下：为什么要有浮动啊，是想做页面布局，但是浮动有副作用，父级标签塌陷，所以要想办法去掉这个副作用，使用了clear来清除浮动带来的副作用，我们当然也可以通过设置标签为inline-block来实现这种布局效果，但是把一个块级标签变成一个类似内敛标签的感觉，不好操控，容易混乱，所以一般都用浮动来进行布局。</p><p>　　　　来吧，大家试试把，然后我们再继续学习~~</p><h2 id="overflow溢出属性-（先看下面的例子）"><a href="#overflow溢出属性-（先看下面的例子）" class="headerlink" title="　　overflow溢出属性 （先看下面的例子）"></a>　　overflow溢出属性 （先看下面的例子）</h2><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>visible</td><td>默认值。内容不会被修剪，会呈现在元素框之外。</td></tr><tr><td>hidden</td><td>内容会被修剪，并且其余内容是不可见的。</td></tr><tr><td>scroll</td><td>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td>auto</td><td>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 overflow 属性的值。</td></tr></tbody></table><ul><li>overflow（水平和垂直均设置）</li><li>overflow-x（设置水平方向，只出现x轴的滚动条）</li><li>overflow-y（设置垂直方向，只出现y轴的滚动条）</li></ul><p>　　举个例子：</p><p>　　　　比如我们在一个标签里面写了一堆的文字，然后把标签的高度和宽度设置的比较小的时候，文字就溢出了：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208155013745-1334081272.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208155049528-815492969.png" alt="img"></p><p>　　　　然后我们就可以设置一下，如果文字溢出了，溢出的部分怎么办，设置一个overflow为hidden：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208155205217-1815585252.png" alt="img"></p><p>　　　　再看效果，溢出的文字就不显示了。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208155214151-1037425666.png" alt="img"></p><p>　　　　如果设置成overflow为scroll，就会出现滚动条，我们改动一个下标签的高度和宽度昂，要不然不好看出效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208155331129-324851617.png" alt="img"></p><p>　　　　看效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208155402017-2018949486.png" alt="img"></p><p>　　　　</p><h3 id="圆形头像示例"><a href="#圆形头像示例" class="headerlink" title="　　圆形头像示例"></a>　　圆形头像示例</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;圆形的头像示例&lt;/title&gt;  &lt;style&gt;    * {      margin: 0;      padding: 0;      background-color: #eeeeee;    }    .header-img {      width: 150px;  #如果这个高度和宽度比图片的像素小怎么办，图片显示不全啊，因为用户上传的头像没准多大像素的，就需要设置下面哈格.header-mg&gt;img，里面写上max-width:100%了      height: 150px;      border: 3px solid white;      border-radius: 50%;  #圆形的边框      overflow: hidden;    #溢出的内容隐藏    }    .header-img&gt;img {      max-width: 100%; #相当于将图片的大小设置为父级标签的大小来显示了，因为用户上传的头像的像素我们是不知道的，就让它按照父级标签的大小来，就能放下整个头像了，就不会出现头像显示不全的问题了　　　　#直接写width:100%就行，上面写max-width的意思是如果图片大于咱们设置的标签高宽的时候，就按照父级标签的大小来，比父级标签的高宽小的时候，就不需要按照父级标签的大小来了，了解一下就行了    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="header-img"&gt;  &lt;img src="https://q1mi.github.io/Blog/asset/img/head_img.jpg" alt=""&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208160326202-1175858535.png" alt="img"></p><p>　　下面我们来学习定位：也是用来布局的，一般用来做一些小的布局，例如小米商城：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208160850518-974384966.png" alt="img"></p><p>　　　　还有网站右上角这个东西：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208161009509-1636132809.png" alt="img"></p><p>　　　　这些小范围的布局一般都是定位做的，大范围的布局一般都是用float来做的</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208161059442-994297110.png" alt="img"></p><p>　　　　下面我们来看看定位的用法</p><h2 id="定位（position）"><a href="#定位（position）" class="headerlink" title="　　定位（position）"></a>　　定位（position）</h2><h3 id="static（无定位，咱就不说了，主要看相对和绝对定位）"><a href="#static（无定位，咱就不说了，主要看相对和绝对定位）" class="headerlink" title="　　　　static（无定位，咱就不说了，主要看相对和绝对定位）"></a>　　　　static（无定位，咱就不说了，主要看相对和绝对定位）</h3><p>　　　　　　static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。</p><h3 id="relative（相对定位）"><a href="#relative（相对定位）" class="headerlink" title="　　　　relative（相对定位）"></a>　　　　relative（相对定位）</h3><p>　　　　　　相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置左上角为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，所以不会出现像浮动那种父级标签塌陷的副作用，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。往上移动:top:-100px（注意是负值）或者bottom：-100px（负值），往左移动：left:-100px（也是负值）或者right：-100px，往下移动:bottom：100px（正值）或者top：100px（正值），往右移动：right:100px（正值）或者left：100px。大家记住一点昂，凡是标签要进行移动，不管是float还是relative还是线面的absolute，都是按照元素自己的左上角进行计算的</p><p>　　　　　　注意：position：relative的一个主要用法：方便下面要学的绝对定位元素找到参照物。可以将元素设置成relative，不设置任何的top、left、right、bottom等，它还是它原来的位置</p><h3 id="absolute（绝对定位）"><a href="#absolute（绝对定位）" class="headerlink" title="　　　　absolute（绝对定位）"></a>　　　　absolute（绝对定位）</h3><p>　　　　　　定义：设置为绝对定位的元素框从文档流完全删除，也会有父级标签塌陷的问题，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</p><p>　　　　　　重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。</p><p>　　　　　　另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。</p><h3 id="fixed（固定）不管页面怎么动，都在整个屏幕的某个位置"><a href="#fixed（固定）不管页面怎么动，都在整个屏幕的某个位置" class="headerlink" title="　　　　fixed（固定）不管页面怎么动，都在整个屏幕的某个位置"></a>　　　　fixed（固定）不管页面怎么动，都在整个屏幕的某个位置</h3><p>　　　　　　fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是“定位流”。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。</p><p>　　　　　　在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。</p><p>　　　　　　示例代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;返回顶部示例&lt;/title&gt;  &lt;style&gt;    * {      margin: 0;    }    .d1 {      height: 1000px;      background-color: #eeee;    }    .scrollTop {      background-color: darkgrey;      padding: 10px;      text-align: center;  #水平居中      position: fixed;      right: 10px;  #距离窗口右边框的距离      bottom: 20px; #距离窗口下边框的距离      /*height：20px；　　　 line-height：20；当line-height等于height的值的时候，就能实现一个文本居中的效果 */    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="d1"&gt;111&lt;/div&gt;&lt;div class="scrollTop"&gt;返回顶部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="z-index"><a href="#z-index" class="headerlink" title="　　　　z-index"></a>　　　　z-index</h2><pre><code>#i2 {  z-index: 999;}</code></pre><p>　　　　　　设置对象的层叠顺序。一般用在模态对话框上：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208164152428-1959185383.png" alt="img"></p><p> 　　　　　那么谁在上面显示，谁被压在下面的呢，就是通过这个z-index来设置的。</p><ol><li>z-index 值表示谁压着谁，数值大的压盖住数值小的，</li><li>只有定位了的元素，才能有z-index,也就是说，不管相对定位，绝对定位，固定定位，都可以使用z-index，而浮动元素float不能使用z-index</li><li>z-index值没有单位，就是一个正整数，默认的z-index值为0如果大家都没有z-index值，或者z-index值一样，那么谁写在HTML后面，谁在上面压着别人，定位了元素，永远压住没有定位的元素。</li><li>从父现象：父亲怂了，儿子再牛逼也没用</li></ol><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p>　　#自定义的一个模态对话框示例代码：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;自定义模态框&lt;/title&gt;  &lt;style&gt;    .cover {      background-color: rgba(0,0,0,0.65); #rgba的最后一个参数就是透明度的意思，所以如果我们这样写，就不需要写下面那个opcity了，但是这个只表示的背景颜色的透明度，opcity是标签的透明度及标签的内容(包括里面的文字)及标签下面的子标签的透明度      position: fixed;      top: 0;      right: 0;  top\right\bottom\left都设置为0，意思就是全屏，这个标签把全屏都覆盖了      bottom: 0;      left: 0;      z-index: 998;      #opcity:0.4; #设置元素的透明度    }    .modal {      background-color: white;      position: fixed;      width: 600px;      height: 400px;      left: 50%;  #设置了left：50%和top：50%，你就会发现，你这个标签的左上角相对于页面的左面是50%，上面是50%，所以我们还要移动窗口，往左移动标签宽度的一半，往上移动高度的一半就行了。就是下面的margin设置      top: 50%;      margin: -200px 0 0 -300px; #左下右上，别忘了，往左移动要负值，往上移动要负值，因为它的移动是按照自己标签的左上角来移动的。      z-index: 1000;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="cover"&gt;&lt;/div&gt;&lt;div class="modal"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　来再教大家一个pycharm的用法，自定义快捷键：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208165037599-167607222.png" alt="img"></p><p>　　　　　　然后点击apply和ok：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208164917112-814808302.png" alt="img"></p><p>　　　　在到html页面中也一个hya：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208165142379-297836882.png" alt="img"></p><p>　　　　就看到了这些文字：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208165158044-1930711385.png" alt="img"></p><p>　　　　在pycharm的使用秘籍里面都有昂，自己去学吧<del>~</del>，网上一搜pycharm的使用，就有</p><h2 id="opacity"><a href="#opacity" class="headerlink" title="　　opacity"></a>　　opacity</h2><p>　　　　　　用来定义透明效果。取值范围是0~1，0是完全透明，1是完全不透明。</p><h1 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h1><h2 id="顶部导航菜单"><a href="#顶部导航菜单" class="headerlink" title="　　顶部导航菜单"></a>　　顶部导航菜单</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;li标签的float示例&lt;/title&gt;  &lt;style&gt;    /*清除浏览器默认外边距和内填充*/    * {      margin: 0;      padding: 0;    }    a {      text-decoration: none; /*去除a标签默认的下划线*/    }    .nav {      background-color: black;      height: 40px;      width: 100%;      position: fixed;      top: 0;    }    ul {      list-style-type: none; /*删除列表默认的圆点样式*/      margin: 0; /*删除列表默认的外边距*/      padding: 0; /*删除列表默认的内填充*/    }    /*li元素向左浮动*/    li {      float: left;    }    li &gt; a {      display: block; /*让链接显示为块级标签*/      padding: 0 15px; /*设置左右各15像素的填充*/      color: #b0b0b0; /*设置字体颜色*/      line-height: 40px; /*设置行高*/    }    /*鼠标移上去颜色变白*/    li &gt; a:hover {      color: #fff;    }    /*清除浮动 解决父级塌陷问题*/    .clearfix:after {      content: "";      display: block;      clear: both;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 顶部导航栏 开始 --&gt;&lt;div class="nav"&gt;  &lt;ul class="clearfix"&gt;    &lt;li&gt;&lt;a href=""&gt;玉米商城&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=""&gt;MIUI&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=""&gt;ioT&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=""&gt;云服务&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=""&gt;水滴&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=""&gt;金融&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=""&gt;优品&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;!-- 顶部导航栏 结束 --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　上面的导航栏的效果：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208172338278-1287460186.png" alt="img"></p><p>　　将来我们在写一个页面的时候，首先写页面的整体结构，就是布局，大块先搞出来，再大块的基础上来来写小块，然后一级一级的这么写。看下面的小米商城的示例，按照红框–黄框–子框–蓝框来看整个布局：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181208171930811-81553830.png" alt="img"></p><p>　　产品经理需求–&gt;UI（视觉、交互等各种UI）将这些页面做成图片（包括里面的文字大小图片大小等都给你准备好，标的很清楚）–&gt;前端工程师（通过前端代码来实现UI的页面）–&gt;后端工程师（写提供数据、处理数据的逻辑）–&gt;DBA管理数据</p><p> 　最后给大家一个css只做动画效果的方式：鼠标移动到标签上的时候，出现动态效果和阴影的效果：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        /*给标签加上鼠标移动上去的一些效果*/        #test{            height: 200px;            border: 1px solid black;        }        #test:hover{            box-shadow: 0 5px 10px;  /*给标签加阴影的效果，参数1是水平方向的阴影，参数2的5px是垂直方向上的阴影，参数3是阴影的范围*/            transform: translate3d(3px,-2px,0); /*鼠标移动上去之后有个标签往上台的效果，三个参数是：x轴，y轴，z轴，现在的效果是y轴方向往上移动2px,x轴往右移动3px*/            transition:all,.2s linear; /*这个的意思是所有的新样式改变，在0.2秒内慢慢的显示出来*/        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="test"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　有一个做网页的时候的一个图片示例的网址：<a href="https://dummyimage.com/">https://dummyimage.com/</a></p><p>　　如果在这个网址后面输入下面的内容：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210141333352-480132126.png" alt="img"></p><p>　　　　一回车，你就看到下面的这个图：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20181210141407737-1557279844.png" alt="img"></p><p>　　</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery快速入门</title>
      <link href="2019/11/15/%E5%89%8D%E7%AB%AF/jQuery%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>2019/11/15/%E5%89%8D%E7%AB%AF/jQuery%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="　　jQuery介绍"></a>　　jQuery介绍</h2><p>　　　　1.jQuery是一个轻量级的、兼容多浏览器的JavaScript库。</p><p>　　　　2.jQuery使用户能够更方便地处理HTML Document、Events、实现动画效果、方便地进行Ajax交互，能够极大地简化JavaScript编程。它的宗旨就是：“Write less, do more.“</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190123170120888-291459255.png" alt="img"></p><h2 id="jQuery的优势"><a href="#jQuery的优势" class="headerlink" title="　　jQuery的优势"></a>　　jQuery的优势</h2><ol><li>一款轻量级的JS框架。jQuery核心js文件才几十kb，不会影响页面加载速度。</li><li>丰富的DOM选择器,jQuery的选择器用起来很方便，比如要找到某个DOM对象的相邻元素，JS可能要写好几行代码，而jQuery一行代码就搞定了，再比如要将一个表格的隔行变色，jQuery也是一行代码搞定。</li><li>链式表达式。jQuery的链式操作可以把多个操作写在一行代码里，更加简洁。</li><li>事件、样式、动画支持。jQuery还简化了js操作css的代码，并且代码的可读性也比js要强。</li><li>Ajax操作支持。jQuery简化了AJAX操作，后端只需返回一个JSON格式的字符串就能完成与前端的通信。</li><li>跨浏览器兼容。jQuery基本兼容了现在主流的浏览器，不用再为浏览器的兼容问题而伤透脑筋。</li><li>插件扩展开发。jQuery有着丰富的第三方的插件，例如：树形菜单、日期控件、图片切换插件、弹出窗口等等基本前端页面上的组件都有对应插件，并且用jQuery插件做出来的效果很炫，并且可以根据自己需要去改写和封装插件，简单实用。</li></ol><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190123170432392-84549366.png" alt="img"></p><p>　　　　　　原生DOM的写法就是写JS代码，而以后我们多数都用jQuery来写，因为jQuery的优势很多，看上面，并且查找标签的方式有很多，比原生的DOM丰富的多，很便利，还有重要的一点就是不需要考虑浏览器的兼容性，因为jQuery做到了各大浏览器兼容的功能。</p><h2 id="jQuery内容："><a href="#jQuery内容：" class="headerlink" title="　　jQuery内容："></a>　　jQuery内容：</h2><ol><li>选择器</li><li>筛选器</li><li>样式操作</li><li>文本操作</li><li>属性操作</li><li>文档处理</li><li>事件</li><li>动画效果</li><li>插件</li><li>each、data、Ajax</li></ol><p>　　　　下载链接：<a href="https://jquery.com/">jQuery官网</a>，首先需要下载这个jQuery的文件，然后在HTML文件中引入这个文件，就可以使用这个文件中帮我们提供的jquery的接口了。</p><p>　　　　中文文档：<a href="http://jquery.cuishifeng.cn/">jQuery AP中文文档</a></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190123170948232-1288714209.png" alt="img"></p><p>　　　　　　用压缩的也行，不用压缩的也行，文件都不大，对页面内容的加载速度差的不是很多，如果文件大很多，就考虑压缩版的，一般线上都是压缩版的，尽量提高页面加载速度。</p><p>　　　　　jQuery的引入方式有两种：</p><p>　　　　　　1.直接下载文件到本地（最常用），从本地中导入</p><p>　　　　　　2.使用文件的网络地址，就像我们img标签里面的那个src的用法差不多。</p><p>　　　　引入完之后，就可以直接使用jQuery的语法来写了，但是还是要写在script标签里面，并且要注意引入顺序，先引入文件，再在script标签里面写jQuery的代码，先导入再使用。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190123172109487-154977033.png" alt="img"></p><p>　　　　　　会报错：在浏览器的调试窗口的console里面可以看到，记住这个昂，以后出现这个错误，不能问昂<del>~</del></p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190123172150480-206111165.png" alt="img"></p><h2 id="jQuery版本"><a href="#jQuery版本" class="headerlink" title="　　jQuery版本"></a>　　jQuery版本</h2><ul><li>1.x：兼容IE678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</li><li>2.x：不兼容IE678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</li><li>3.x：不兼容IE678，只支持最新的浏览器。需要注意的是很多老的jQuery插件不支持3.x版。目前该版本是官方主要更新维护的版本，我们学习就用3.几的就行了，工作中如果需要兼容IE678，就用1.几版本的就行，2.几版本的就别用了。</li></ul><p>　　　　<em>维护IE678是一件让人头疼的事情，一般我们都会额外加载一个CSS和JS单独处理。值得庆幸的是使用这些浏览器的人也逐步减少，PC端用户已经逐步被移动端用户所取代，如果没有特殊要求的话，一般都会选择放弃对678的支持。</em></p><h2 id="jQuery对象（先看一下jQuery语法和选择器我们再回来看这个对象）"><a href="#jQuery对象（先看一下jQuery语法和选择器我们再回来看这个对象）" class="headerlink" title="　　jQuery对象（先看一下jQuery语法和选择器我们再回来看这个对象）"></a>　　jQuery对象（先看一下jQuery语法和选择器我们再回来看这个对象）</h2><p>　　　　<strong>jQuery对象</strong>就是通过jQuery包装DOM对象后产生的对象。<strong>jQuery对象</strong>是 jQuery独有的。如果一个对象是 <strong>jQuery对象</strong>，那么它就可以使用<strong>jQuery</strong>里提供的方法：例如$(“#i1”).html()。</p><p><code>　　　　$("#i1").html()</code>的意思是：获取id值为 <code>i1</code>的元素的html代码。其中 <code>html()</code>是jQuery里的方法。</p><p>　　　　相当于： <code>document.getElementById("i1").innerHTML;</code></p><p>　　　　虽然 <code>jQuery对象</code>是包装 <code>DOM对象</code>后产生的，但是 <code>jQuery对象</code>无法使用 <code>DOM对象</code>的任何方法，同理 <code>DOM对象</code>也没不能使用 <code>jQuery</code>里的方法。</p><p>　　　　一个约定，我们在声明一个jQuery对象变量的时候在变量名前面加上$：</p><pre><code>var $variable = jQuery对像var variable = DOM对象$variable[0]//jQuery对象转成DOM对象，通过一个jQuery对象+[0]索引零，就变成了DOM对象，就可以使用JS的代码方法了，DOM对象转换成jQuery对象：$(DOM对象)，通过$符号包裹一下就可以了</code></pre><p>　　　　拿上面那个例子举例，jQuery对象和DOM对象的使用：</p><pre><code>$("#i1").html();//jQuery对象可以使用jQuery的方法$("#i1")[0].innerHTML;// DOM对象使用DOM的方法</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190123174304626-1353170815.png" alt="img"></p><h2 id="jQuery基础语法"><a href="#jQuery基础语法" class="headerlink" title="jQuery基础语法"></a>jQuery基础语法</h2><pre><code>　　$(selector).action()  #$(selector)找到某个标签，.action()通过这个标签对象调用它的一些方法。</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190123173558130-1641556450.png" alt="img"></p><h2 id="查找标签"><a href="#查找标签" class="headerlink" title="　　查找标签"></a>　　查找标签</h2><h3 id="基本选择器（同css）"><a href="#基本选择器（同css）" class="headerlink" title="　　　　基本选择器（同css）"></a>　　　　基本选择器（同css）</h3><p>　　　　　　<strong>id选择器：</strong></p><pre><code>$("#id")  #不管找什么标签，用什么选择器，都必须要写$("")，引号里面再写选择器，通过jQuery找到的标签对象就是一个jQuery对象，用原生JS找到的标签对象叫做DOM对象，看我们上面的jQuery对象部分的内容</code></pre><p>　　　　　　<strong>标签选择器：</strong></p><pre><code>$("tagName")</code></pre><p>　　　　　　<strong>class选择器：</strong></p><pre><code>$(".className")</code></pre><p>　　　　　　<strong>配合使用：</strong></p><pre><code>$("div.c1")  // 找到有c1 class类的div标签</code></pre><p>　　　　　　<strong>所有元素选择器：</strong></p><pre><code>$("*")</code></pre><p>　　　　　　<strong>组合选择器：</strong></p><pre><code>$("#id, .className, tagName")</code></pre><h3 id="层级选择器：（同css）"><a href="#层级选择器：（同css）" class="headerlink" title="　　　　层级选择器：（同css）"></a>　　　　<strong>层级选择器：（同css）</strong></h3><p>　　　　　　<em>x和y可以为任意选择器</em></p><pre><code>$("x y");// x的所有后代y（子子孙孙）$("x &gt; y");// x的所有儿子y（儿子）$("x + y")// 找到所有紧挨在x后面的y$("x ~ y")// x之后所有的兄弟y</code></pre><h3 id="基本筛选器（选择之后进行过滤）："><a href="#基本筛选器（选择之后进行过滤）：" class="headerlink" title="　　　　基本筛选器（选择之后进行过滤）："></a>　　　　<strong>基本筛选器（选择之后进行过滤）：</strong></h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>:first // 第一个:last // 最后一个:eq(index)// 索引等于index的那个元素:even // 匹配所有索引值为偶数的元素，从 0 开始计数:odd // 匹配所有索引值为奇数的元素，从 0 开始计数:gt(index)// 匹配所有大于给定索引值的元素:lt(index)// 匹配所有小于给定索引值的元素:not(元素选择器)// 移除所有满足not条件的标签:has(元素选择器)// 选取所有包含一个或多个标签在其内的标签(指的是从后代元素找)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　<strong>例子：</strong></p><p>　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124103439611-1887551482.png" alt="img"></strong></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124103625866-423031172.png" alt="img"></p><pre><code>$("div:has(h1)")// 找到所有后代中有h1标签的div标签，意思是首先找到所有div标签，把这些div标签的后代中有h1的div标签筛选出来$("div:has(.c1)")// 找到所有后代中有c1样式类（类属性class='c1'）的div标签$("li:not(.c1)")// 找到所有不包含c1样式类的li标签$("li:not(:has(a))")// 找到所有后代中不含a标签的li标签</code></pre><p>　　　　　　练习（先看一个jQuery的click事件绑定）：</p><p>　　　　　　　　自定义模态框，使用jQuery实现弹出和隐藏功能。jQuery版自定义模态框:</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;自定义模态框&lt;/title&gt;  &lt;style&gt;    .cover {      position: fixed;      left: 0;      right: 0;      top: 0;      bottom: 0;      background-color: darkgrey;      z-index: 999;    }    .modal {      width: 600px;      height: 400px;      background-color: white;      position: fixed;      left: 50%;      top: 50%;      margin-left: -300px;      margin-top: -200px;      z-index: 1000;    }    .hide {      display: none;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="弹" id="i0"&gt;&lt;div class="cover hide"&gt;&lt;/div&gt;&lt;div class="modal hide"&gt;  &lt;label for="i1"&gt;姓名&lt;/label&gt;  &lt;input id="i1" type="text"&gt;   &lt;label for="i2"&gt;爱好&lt;/label&gt;  &lt;input id="i2" type="text"&gt;  &lt;input type="button" id="i3" value="关闭"&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;  var tButton = $("#i0")[0];  tButton.onclick=function () {  #jQuery绑定事件的时候也有个简单的方式，往后面学    var coverEle = $(".cover")[0];    var modalEle = $(".modal")[0];    $(coverEle).removeClass("hide");    $(modalEle).removeClass("hide");　　    #jQuery版：    #$(".cover,.modal").removeClass('hide'); #看完这个之后，去下面先学一下下面的标签操作中的样式操作那一节  };  var cButton = $("#i3")[0];  cButton.onclick=function () {    var coverEle = $(".cover")[0];    var modalEle = $(".modal")[0];    $(coverEle).addClass("hide");    $(modalEle).addClass("hide");　　#jQuery版：　　#$(".cover,.modal").addClass('hide');  }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="　　　　属性选择器："></a>　　　　<strong>属性选择器：</strong></h3><pre><code>[attribute][attribute=value]// 属性等于[attribute!=value]// 属性不等于</code></pre><p>　　　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124114453236-1006582852.png" alt="img"></strong></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124114503883-436429378.png" alt="img"></p><p>　　　　　　<strong>例子：</strong></p><pre><code>// 示例,多用于input标签&lt;input type="text"&gt;&lt;input type="password"&gt;&lt;input type="checkbox"&gt;$("input[type='checkbox']");// 取到checkbox类型的input标签$("input[type!='text']");// 取到类型不是text的input标签</code></pre><h3 id="表单筛选器（多用于找form表单里面出现的input标签，当然通过属性选择器找肯定也是没问题的，这样就是写着简单一些）："><a href="#表单筛选器（多用于找form表单里面出现的input标签，当然通过属性选择器找肯定也是没问题的，这样就是写着简单一些）：" class="headerlink" title="　　　　表单筛选器（多用于找form表单里面出现的input标签，当然通过属性选择器找肯定也是没问题的，这样就是写着简单一些）："></a>　　　　<strong>表单筛选器（多用于找form表单里面出现的input标签，当然通过属性选择器找肯定也是没问题的，这样就是写着简单一些）</strong>：</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>:text:password:file:radio:checkbox:submit:reset:button</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　<strong>例子：</strong></p><pre><code>$(":checkbox")  // 找到所有的checkbox</code></pre><p>　　　　　　表单对象属性:</p><pre><code>:enabled:disabled:checked:selected</code></pre><p>　　　　<strong>注意checked：</strong></p><p>　　　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124115437907-1079432294.png" alt="img"></strong></p><p>　　</p><p>　　　　<strong>其他例子：</strong></p><p>　　　　　　　　找到可用的input标签</p><pre><code>&lt;form&gt;  &lt;input name="email" disabled="disabled" /&gt;  &lt;input name="id" /&gt;&lt;/form&gt;$("input:enabled")  // 找到可用的input标签</code></pre><p> 　　　　　　　　找到被选中的option：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;select id="s1"&gt;  &lt;option value="beijing"&gt;北京市&lt;/option&gt;  &lt;option value="shanghai"&gt;上海市&lt;/option&gt;  &lt;option selected value="guangzhou"&gt;广州市&lt;/option&gt;  &lt;option value="shenzhen"&gt;深圳市&lt;/option&gt;&lt;/select&gt;$(":selected")  // 找到所有被选中的option</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="筛选器方法（将来用的很多）"><a href="#筛选器方法（将来用的很多）" class="headerlink" title="筛选器方法（将来用的很多）"></a>筛选器方法（将来用的很多）</h2><p>　　选择器或者筛选器选择出来的都是对象，而筛选器方法其实就是通过对象来调用一个进一步过滤作用的方法，写在对象后面加括号，不再是写在选择器里面的了。</p><p>　　下一个元素：</p><pre><code>$("#id").next()$("#id").nextAll()$("#id").nextUntil("#i2") #直到找到id为i2的标签就结束查找，不包含它</code></pre><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124115811104-1182369456.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124115823699-864639093.png" alt="img"></p><p>　　加两个id属性作为一会筛选的时候的区分：</p><p> 　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124120144655-2051997013.png" alt="img"></p><p>　　上一个元素：</p><pre><code>$("#id").prev()$("#id").prevAll()$("#id").prevUntil("#i2")</code></pre><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124120129642-1991477904.png" alt="img"></p><p>　　父亲元素：</p><pre><code>$("#id").parent()$("#id").parents()  // 查找当前元素的所有的父辈元素（爷爷辈、祖先辈都找到）$("#id").parentsUntil('body') // 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止，这里直到body标签，不包含body标签，基本选择器都可以放到这里面使用。</code></pre><p>　　儿子和兄弟元素：</p><pre><code>$("#id").children();// 儿子们$("#id").siblings();// 兄弟们，不包含自己，.siblings('#id')，可以在添加选择器进行进一步筛选</code></pre><p>　　查找</p><p>　　　　搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。</p><pre><code>$("div").find("p")</code></pre><p>　　　　等价于$(“div p”)</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124121138748-1107079765.png" alt="img"></p><p>　　筛选</p><p>　　　　筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配的范围。用逗号分隔多个表达式。</p><pre><code>$("div").filter(".c1")  // 从结果集中过滤出有c1样式类的，从所有的div标签中过滤出有class='c1'属性的div，和find不同，find是找div标签的子子孙孙中找到一个符合条件的标签</code></pre><p>　　　　等价于 $(“div.c1”)</p><p>　　补充（和前面使用冒号的一样  :first等，只不过冒号的那个是写在选择器里面的，而下面的这几个是方法，如此而已，就不说啦）：</p><pre><code>.first() // 获取匹配的第一个元素.last() // 获取匹配的最后一个元素.not() // 从匹配元素的集合中删除与指定表达式匹配的元素.has() // 保留包含特定后代的元素，去掉那些不含有指定后代的元素。.eq() // 索引值等于指定值的元素</code></pre><p>　　示例：左侧菜单示例，也是今天的作业啦，要的效果是下面这样的：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124122636614-1752703591.png" alt="img"></p><p> 　　大家今天就先学到这里，明天在继续吧~~</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;左侧菜单示例&lt;/title&gt;  &lt;style&gt;    .left {      position: fixed;      left: 0;      top: 0;      width: 20%;      height: 100%;      background-color: rgb(47, 53, 61);    }    .right {      width: 80%;      height: 100%;    }    .menu {      color: white;    }    .title {      text-align: center;      padding: 10px 15px;      border-bottom: 1px solid #23282e;    }    .items {      background-color: #181c20;    }    .item {      padding: 5px 10px;      border-bottom: 1px solid #23282e;    }    .hide {      display: none;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="left"&gt;  &lt;div class="menu"&gt;    &lt;div class="title"&gt;菜单一&lt;/div&gt;    &lt;div class="items"&gt;      &lt;div class="item"&gt;111&lt;/div&gt;      &lt;div class="item"&gt;222&lt;/div&gt;      &lt;div class="item"&gt;333&lt;/div&gt;    &lt;/div&gt;    &lt;div class="title"&gt;菜单二&lt;/div&gt;    &lt;div class="items hide"&gt;      &lt;div class="item"&gt;111&lt;/div&gt;      &lt;div class="item"&gt;222&lt;/div&gt;      &lt;div class="item"&gt;333&lt;/div&gt;    &lt;/div&gt;    &lt;div class="title"&gt;菜单三&lt;/div&gt;    &lt;div class="items hide"&gt;      &lt;div class="item"&gt;111&lt;/div&gt;      &lt;div class="item"&gt;222&lt;/div&gt;      &lt;div class="item"&gt;333&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;  $(".title").click(function (){  // jQuery绑定事件    // 隐藏所有class里有.items的标签    $(".items").addClass("hide");  //批量操作    $(this).next().removeClass("hide");  });&lt;/script&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　JS版本的：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124151439553-1548699670.png" alt="img"></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124151621092-1278373008.png" alt="img"></p><p>　　JS一句话的写法：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124152021046-1823949336.png" alt="img"></p><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="　　样式操作"></a>　　样式操作</h3><p>　　　　样式类（添加删除class类的值来修改样式）</p><pre><code>addClass();// 添加指定的CSS类名。removeClass();// 移除指定的CSS类名。hasClass();// 判断样式存不存在toggleClass();// 切换CSS类名，如果有就移除，如果没有就添加。</code></pre><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124105757278-1026555440.png" alt="img"></p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124105819869-344545517.png" alt="img"></p><p>　　　　示例：开关灯和模态框</p><p>　　　　CSS（直接修改css的属性来修改样式）</p><pre><code>css("color","red")//DOM操作：tag.style.color="red"</code></pre><p>　　　　示例：</p><pre><code>$("p").css("color", "red"); //将所有p标签的字体设置为红色</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124110148814-1623702075.png" alt="img"></p><h3 id="位置操作"><a href="#位置操作" class="headerlink" title="　　位置操作"></a>　　位置操作</h3><pre><code>offset()// 获取匹配元素在当前窗口的相对偏移或设置元素位置position()// 获取匹配元素相对父元素的偏移，不能设置位置scrollTop()// 获取匹配元素相对滚动条顶部的偏移scrollLeft()// 获取匹配元素相对滚动条左侧的偏移</code></pre><p><code>　　　　.offset()</code>方法允许我们检索一个元素相对于文档（document）的当前位置。</p><p>　　　　和 <code>.position()</code>的差别在于： <code>.position()</code>是相对于父级元素的位移。看例子：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124153146740-825875201.png" alt="img"></p><p>　　　　通过offset设置位置偏移</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124153400256-812428621.png" alt="img"></p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124162351712-161166953.png" alt="img"></p><p>　　　　示例：返回顶部示例：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;位置相关示例之返回顶部&lt;/title&gt;  &lt;style&gt;    .c1 {      width: 100px;      height: 200px;      background-color: red;    }    .c2 {      height: 50px;      width: 50px;      position: fixed;      bottom: 15px;      right: 15px;      background-color: #2b669a;    }    .hide {      display: none;    }    .c3 {      height: 100px;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="b1" class="btn btn-default"&gt;点我&lt;/button&gt;&lt;div class="c1"&gt;&lt;/div&gt;&lt;div class="c3"&gt;1&lt;/div&gt;&lt;div class="c3"&gt;2&lt;/div&gt;&lt;div class="c3"&gt;3&lt;/div&gt;&lt;div class="c3"&gt;4&lt;/div&gt;&lt;div class="c3"&gt;5&lt;/div&gt;&lt;div class="c3"&gt;6&lt;/div&gt;&lt;div class="c3"&gt;7&lt;/div&gt;&lt;div class="c3"&gt;8&lt;/div&gt;&lt;div class="c3"&gt;9&lt;/div&gt;&lt;div class="c3"&gt;10&lt;/div&gt;&lt;div class="c3"&gt;11&lt;/div&gt;&lt;div class="c3"&gt;12&lt;/div&gt;&lt;div class="c3"&gt;13&lt;/div&gt;&lt;div class="c3"&gt;14&lt;/div&gt;&lt;div class="c3"&gt;15&lt;/div&gt;&lt;div class="c3"&gt;16&lt;/div&gt;&lt;div class="c3"&gt;17&lt;/div&gt;&lt;div class="c3"&gt;18&lt;/div&gt;&lt;div class="c3"&gt;19&lt;/div&gt;&lt;div class="c3"&gt;20&lt;/div&gt;&lt;div class="c3"&gt;21&lt;/div&gt;&lt;div class="c3"&gt;22&lt;/div&gt;&lt;div class="c3"&gt;23&lt;/div&gt;&lt;div class="c3"&gt;24&lt;/div&gt;&lt;div class="c3"&gt;25&lt;/div&gt;&lt;div class="c3"&gt;26&lt;/div&gt;&lt;div class="c3"&gt;27&lt;/div&gt;&lt;div class="c3"&gt;28&lt;/div&gt;&lt;div class="c3"&gt;29&lt;/div&gt;&lt;div class="c3"&gt;30&lt;/div&gt;&lt;div class="c3"&gt;31&lt;/div&gt;&lt;div class="c3"&gt;32&lt;/div&gt;&lt;div class="c3"&gt;33&lt;/div&gt;&lt;div class="c3"&gt;34&lt;/div&gt;&lt;div class="c3"&gt;35&lt;/div&gt;&lt;div class="c3"&gt;36&lt;/div&gt;&lt;div class="c3"&gt;37&lt;/div&gt;&lt;div class="c3"&gt;38&lt;/div&gt;&lt;div class="c3"&gt;39&lt;/div&gt;&lt;div class="c3"&gt;40&lt;/div&gt;&lt;div class="c3"&gt;41&lt;/div&gt;&lt;div class="c3"&gt;42&lt;/div&gt;&lt;div class="c3"&gt;43&lt;/div&gt;&lt;div class="c3"&gt;44&lt;/div&gt;&lt;div class="c3"&gt;45&lt;/div&gt;&lt;div class="c3"&gt;46&lt;/div&gt;&lt;div class="c3"&gt;47&lt;/div&gt;&lt;div class="c3"&gt;48&lt;/div&gt;&lt;div class="c3"&gt;49&lt;/div&gt;&lt;div class="c3"&gt;50&lt;/div&gt;&lt;div class="c3"&gt;51&lt;/div&gt;&lt;div class="c3"&gt;52&lt;/div&gt;&lt;div class="c3"&gt;53&lt;/div&gt;&lt;div class="c3"&gt;54&lt;/div&gt;&lt;div class="c3"&gt;55&lt;/div&gt;&lt;div class="c3"&gt;56&lt;/div&gt;&lt;div class="c3"&gt;57&lt;/div&gt;&lt;div class="c3"&gt;58&lt;/div&gt;&lt;div class="c3"&gt;59&lt;/div&gt;&lt;div class="c3"&gt;60&lt;/div&gt;&lt;div class="c3"&gt;61&lt;/div&gt;&lt;div class="c3"&gt;62&lt;/div&gt;&lt;div class="c3"&gt;63&lt;/div&gt;&lt;div class="c3"&gt;64&lt;/div&gt;&lt;div class="c3"&gt;65&lt;/div&gt;&lt;div class="c3"&gt;66&lt;/div&gt;&lt;div class="c3"&gt;67&lt;/div&gt;&lt;div class="c3"&gt;68&lt;/div&gt;&lt;div class="c3"&gt;69&lt;/div&gt;&lt;div class="c3"&gt;70&lt;/div&gt;&lt;div class="c3"&gt;71&lt;/div&gt;&lt;div class="c3"&gt;72&lt;/div&gt;&lt;div class="c3"&gt;73&lt;/div&gt;&lt;div class="c3"&gt;74&lt;/div&gt;&lt;div class="c3"&gt;75&lt;/div&gt;&lt;div class="c3"&gt;76&lt;/div&gt;&lt;div class="c3"&gt;77&lt;/div&gt;&lt;div class="c3"&gt;78&lt;/div&gt;&lt;div class="c3"&gt;79&lt;/div&gt;&lt;div class="c3"&gt;80&lt;/div&gt;&lt;div class="c3"&gt;81&lt;/div&gt;&lt;div class="c3"&gt;82&lt;/div&gt;&lt;div class="c3"&gt;83&lt;/div&gt;&lt;div class="c3"&gt;84&lt;/div&gt;&lt;div class="c3"&gt;85&lt;/div&gt;&lt;div class="c3"&gt;86&lt;/div&gt;&lt;div class="c3"&gt;87&lt;/div&gt;&lt;div class="c3"&gt;88&lt;/div&gt;&lt;div class="c3"&gt;89&lt;/div&gt;&lt;div class="c3"&gt;90&lt;/div&gt;&lt;div class="c3"&gt;91&lt;/div&gt;&lt;div class="c3"&gt;92&lt;/div&gt;&lt;div class="c3"&gt;93&lt;/div&gt;&lt;div class="c3"&gt;94&lt;/div&gt;&lt;div class="c3"&gt;95&lt;/div&gt;&lt;div class="c3"&gt;96&lt;/div&gt;&lt;div class="c3"&gt;97&lt;/div&gt;&lt;div class="c3"&gt;98&lt;/div&gt;&lt;div class="c3"&gt;99&lt;/div&gt;&lt;div class="c3"&gt;100&lt;/div&gt;&lt;button id="b2" class="btn btn-default c2 hide"&gt;返回顶部&lt;/button&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt;  //$("#b1").on("click", function () {  //  $(".c1").offset({left: 200, top:200});  //});  // $(window),window对象是还记得吗？是不是全局的一个对象啊，整个页面窗口对象，通过$符号包裹起来就变成了一个jQuery对象了  $(window).scroll(function () {    if ($(window).scrollTop() &gt; 100) { //当滚动条相对顶部位置的滚动距离大于100的时候才显示那个返回顶部的按钮，这个100你可以理解为窗口和整个页面文档的距离，鼠标向下滑动的距离      $("#b2").removeClass("hide");    }else {      $("#b2").addClass("hide");    }  });  $("#b2").on("click", function () { //jQuery绑定事件第二天我们在学，先作为了解    $(window).scrollTop(0);  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="尺寸："><a href="#尺寸：" class="headerlink" title="　　尺寸："></a>　　尺寸：</h3><pre><code>height() //盒子模型content的大小，就是我们设置的标签的高度和宽度width()innerHeight() //内容content高度 + 两个padding的高度innerWidth()outerHeight() //内容高度 + 两个padding的高度 + 两个border的高度，不包括margin的高度，因为margin不是标签的，是标签和标签之间的距离outerWidth()</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124162957554-1091234743.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124163307127-905835895.png" alt="img"></p><h3 id="文本操作"><a href="#文本操作" class="headerlink" title="　　文本操作"></a>　　文本操作</h3><p>　　　　HTML代码：</p><pre><code>html()// 取得第一个匹配元素的html内容，包含标签内容html(val)// 设置所有匹配元素的html内容，识别标签，能够表现出标签的效果</code></pre><p>　　　　文本值：</p><pre><code>text()// 取得所有匹配元素的内容，只有文本内容，没有标签text(val)// 设置所有匹配元素的内容，不识别标签，将标签作为文本插入进去</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124163607961-795375857.png" alt="img"></p><p>　　　　值：</p><pre><code>val()// 取得第一个匹配元素的当前值val(val)// 设置所有匹配元素的值val([val1, val2])// 设置多选的checkbox、多选select的值</code></pre><p>　　　　例如：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;input type="checkbox" value="basketball" name="hobby"&gt;篮球&lt;input type="checkbox" value="football" name="hobby"&gt;足球&lt;select multiple id="s1"&gt;    &lt;option value="1"&gt;1&lt;/option&gt;    &lt;option value="2"&gt;2&lt;/option&gt;    &lt;option value="3"&gt;3&lt;/option&gt;&lt;/select&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　设置值：</p><pre><code>$("[name='hobby']").val(['basketball', 'football']);$("#s1").val(["1", "2"])</code></pre><p>　　　　示例：</p><p>　　　　　　获取被选中的checkbox或radio的值：</p><pre><code>&lt;label for="c1"&gt;女&lt;/label&gt;&lt;input name="gender" id="c1" type="radio" value="0"&gt;&lt;label for="c2"&gt;男&lt;/label&gt;&lt;input name="gender" id="c2" type="radio" value="1"&gt;</code></pre><p>　　　　可以使用：</p><pre><code>$("input[name='gender']:checked").val()</code></pre><p> 　　　　　注意：</p><p>　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124205212307-2035296453.png" alt="img"></p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190124205311133-1276516697.png" alt="img"></p><p>　　　　自定义登录校验示例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;文本操作之登录验证&lt;/title&gt;  &lt;style&gt;    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=""&gt;  &lt;div&gt;    &lt;label for="input-name"&gt;用户名&lt;/label&gt;    &lt;input type="text" id="input-name" name="name"&gt;    &lt;span class="error"&gt;&lt;/span&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;label for="input-password"&gt;密码&lt;/label&gt;    &lt;input type="password" id="input-password" name="password"&gt;    &lt;span class="error"&gt;&lt;/span&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;input type="button" id="btn" value="提交"&gt;  &lt;/div&gt;&lt;/form&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;  $("#btn").click(function () {    var username = $("#input-name").val();    var password = $("#input-password").val();    if (username.length === 0) {      $("#input-name").siblings(".error").text("用户名不能为空");    }    if (password.length === 0) {      $("#input-password").siblings(".error").text("密码不能为空");    }  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="属性操作"><a href="#属性操作" class="headerlink" title="　　属性操作"></a>　　属性操作</h3><p>　　　　用于ID自带属性等或自定义属性：</p><pre><code>attr(attrName)// 返回第一个匹配元素的属性值attr(attrName, attrValue)// 为所有匹配元素设置一个属性值attr({k1: v1, k2:v2})// 为所有匹配元素设置多个属性值removeAttr()// 从每一个匹配的元素中删除一个属性</code></pre><p>　　　　用于checkbox和radio</p><pre><code>prop() // 获取属性removeProp() // 移除属性</code></pre><p>　　　　<strong>注意：</strong></p><p>　　　　　　在1.x及2.x版本的jQuery中使用attr对checkbox进行赋值操作时会出bug，在3.x版本的jQuery中则没有这个问题。为了兼容性，我们在处理checkbox和radio的时候尽量使用特定的prop()，不要使用attr(“checked”, “checked”)。</p><pre><code>&lt;input type="checkbox" value="1"&gt;&lt;input type="radio" value="2"&gt;&lt;script&gt;  $(":checkbox[value='1']").prop("checked", true);  //设置让其选中  $(":radio[value='2']").prop("checked", true);&lt;/script&gt;</code></pre><p>　　　　<strong>prop和attr的区别：</strong></p><p>　　　　　　attr全称attribute(属性) </p><p>　　　　　　prop全称property(属性)</p><p>　　　　　　虽然都是属性，但他们所指的属性并不相同，attr所指的属性是HTML标签属性，而prop所指的是DOM对象属性，可以认为attr是显式的，而prop是隐式的。</p><p>　　　　　　举个例子：</p><pre><code>&lt;input type="checkbox" id="i1" value="1"&gt;</code></pre><p>　　　　　　针对上面的代码，</p><pre><code>$("#i1").attr("checked")  // undefined$("#i1").prop("checked")  // false</code></pre><p>　　　　　　可以看到attr获取一个标签内没有的东西会得到undefined，而prop获取的是这个DOM对象的属性，因此checked为false。</p><p>　　　　　　如果换成下面的代码：</p><pre><code>&lt;input type="checkbox" checked id="i1" value="1"&gt;</code></pre><p>　　　　　　再执行：</p><pre><code>$("#i1").attr("checked")   // checked$("#i1").prop("checked")  // true</code></pre><p>　　　　　　这已经可以证明attr的局限性，它的作用范围只限于HTML标签内的属性，而prop获取的是这个DOM对象的属性，也可以理解为这个dom对象的状态，选中返回true，没选中返回false。</p><p>　　　　　　接下来再看一下针对自定义属性，attr和prop又有什么区别：</p><pre><code>&lt;input type="checkbox" checked id="i1" value="1" me="自定义属性"&gt;</code></pre><p>　　　　　　执行以下代码：</p><pre><code>$("#i1").attr("me")   // "自定义属性"$("#i1").prop("me")  // undefined</code></pre><p>　　　　　　可以看到prop不支持获取标签的自定义属性。</p><p>　　　　　　<strong>总结一下：</strong></p><p>　　　　　　　　1.对于标签上有的能看到的属性和自定义属性都用attr</p><p>　　　　　　　　2.对于返回布尔值的比如checkbox、radio和option的是否被选中都用prop。</p><p> 　　　　　　　　<strong>具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()</strong></p><p>　　　　练习题：全选、反选、取消</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="all"&gt;全选&lt;/button&gt;&lt;button id="reverse"&gt;反选&lt;/button&gt;&lt;button id="cancel"&gt;取消&lt;/button&gt;&lt;table border="1"&gt;   &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;#&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;爱好&lt;/th&gt;    &lt;/tr&gt;   &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;        &lt;td&gt;金老板&lt;/td&gt;        &lt;td&gt;开车&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;        &lt;td&gt;景女神&lt;/td&gt;        &lt;td&gt;茶道&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;        &lt;td&gt;苑昊（苑局）&lt;/td&gt;        &lt;td&gt;不洗头、不翻车、不要脸&lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script&gt;    // 点击全选按钮 选中所有的checkbox    // DOM绑定事件方法    // $("#all")[0].onclick = function(){}    // jQuery绑定事件方法    $("#all").click(function () {        $(":checkbox").prop('checked', true);    });    // 取消    $("#cancel").on("click", function () {         $(":checkbox").prop('checked', false);    });    // 反选    $("#reverse").click(function () {        // 1. 找到所有选中的checkbox取消选中        // $("input:checked").prop('checked', false);        // // 2. 找到没有选中的checkbox选中        // $("input:not(:checked)").prop('checked', true);        //你会发现上面这么写，不行，为什么呢？因为你做了第一步操作之后，再做第二步操作的时候，所有标签就已经全部取消选中了，所以第二步就把所有标签选中了        // 方法1. for循环所有的checkbox,挨个判断原来选中就取消选中，原来没选中就选中        var $checkbox = $(":checkbox");        for (var i=0;i&lt;$checkbox.length;i++){            // 获取原来的选中与否的状态            var status = $($checkbox[i]).prop('checked');            $($checkbox[i]).prop('checked', !status);        }        // 方法2. 先用变量把标签原来的状态保存下来    //     var $unchecked =  $("input:not(:checked)");    //     var $checked = $("input:checked");    //    //     $unchecked.prop('checked', true);    //     $checked.prop('checked', false);    })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="文档处理"><a href="#文档处理" class="headerlink" title="　　文档处理"></a>　　文档处理</h3><p>　　　　添加到指定元素<strong>内部</strong>的后面</p><pre><code>$(A).append(B)// 把B追加到A$(A).appendTo(B)// 把A追加到B</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190125172017719-1413007260.png" alt="img"></p><p>　　　　添加到指定元素<strong>内部</strong>的前面</p><pre><code>$(A).prepend(B)// 把B前置到A$(A).prependTo(B)// 把A前置到B</code></pre><p>　　　　添加到指定元素<strong>外部</strong>的后面</p><pre><code>$(A).after(B)// 把B放到A的后面$(A).insertAfter(B)// 把A放到B的后面</code></pre><p>　　　　添加到指定元素<strong>外部</strong>的前面</p><pre><code>$(A).before(B)// 把B放到A的前面$(A).insertBefore(B)// 把A放到B的前面</code></pre><p>　　　　移除和清空元素</p><pre><code>remove()// 从DOM中删除所有匹配的元素。empty()// 删除匹配的元素集合中所有的子节点，包括文本被全部删除，但是匹配的元素还在</code></pre><p>　　　　</p><p>　　　　替换</p><pre><code>replaceWith()replaceAll()</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190125172519590-2059082196.png" alt="img"></p><p>　　　　隆</p><pre><code>clone()// 参数，看下面的示例</code></pre><p>　　　　克隆示例：点击复制按钮：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;克隆&lt;/title&gt;  &lt;style&gt;    #b1 {      background-color: deeppink;      padding: 5px;      color: white;      margin: 5px;    }    #b2 {      background-color: dodgerblue;      padding: 5px;      color: white;      margin: 5px;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="b1"&gt;屠龙宝刀，点击就送&lt;/button&gt;&lt;hr&gt;&lt;button id="b2"&gt;屠龙宝刀，点击就送&lt;/button&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt;  // clone方法不加参数true，克隆标签但不克隆标签带的事件  $("#b1").on("click", function () {    $(this).clone().insertAfter(this);  });  // clone方法加参数true，克隆标签并且克隆标签带的事件  $("#b2").on("click", function () {    $(this).clone(true).insertAfter(this);  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><p>　　作业：</p><p>　　　　点击按钮在表格添加一行数据。</p><p>　　　　点击每一行的删除按钮删除当前行数据。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190125173425226-642864562.png" alt="img"></p><p> 　　作业示例代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        .cover {            position: fixed;            top: 0;            right: 0;            bottom: 0;            left: 0;            background-color: rgba(0, 0, 0, 0.3);            z-index: 99;        }        .modal {            width: 300px;            height: 200px;            background-color: white;            position: absolute;            top: 50%;            left: 50%;            margin-top: -100px;            margin-left: -150px;            z-index: 1000;        }        .hide {            display: none;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="add"&gt;新增&lt;/button&gt;&lt;table border="1"&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;#&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;爱好&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;        &lt;td&gt;金老板&lt;/td&gt;        &lt;td&gt;开车&lt;/td&gt;        &lt;td&gt;            &lt;button class="fire"&gt;开除&lt;/button&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;        &lt;td&gt;景女神&lt;/td&gt;        &lt;td&gt;茶道&lt;/td&gt;        &lt;td&gt;            &lt;button class="fire"&gt;开除&lt;/button&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;        &lt;td&gt;苑昊（苑局）&lt;/td&gt;        &lt;td&gt;不洗头、不翻车、不要脸&lt;/td&gt;        &lt;td&gt;            &lt;button class="fire"&gt;开除&lt;/button&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;div class="cover hide"&gt;&lt;/div&gt;&lt;div class="modal hide"&gt;    &lt;div&gt;        &lt;label&gt;姓名：            &lt;input type="text" id="name"&gt;        &lt;/label&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;label&gt;爱好：            &lt;input type="text" id="hobby"&gt;        &lt;/label&gt;    &lt;/div&gt;    &lt;button id="cancel" type="button"&gt;取消&lt;/button&gt;    &lt;button id="submit" type="button"&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script&gt;    // 定义一个清空输入框并且隐藏模态框的方法    function hideModal(){         // 1. 清空input的值        $("#name,#hobby").val('');        // 2. 隐藏起来        $(".cover,.modal").addClass('hide');    }    // 开除按钮的功能    $("table").on('click', '.fire', function () { //我们先去学冒泡事件、事件委托然后再回来学这个例子，事件里面都是用的匿名函数，这里用on是因为我        //们要将新添加进来的每行里面的button标签能够继承这个点击删除的事件        // 点击开除按钮要做的事儿        // 把当前行移除掉        //this  --&gt; 触发当前点击事件的DOM对象        $(this).parent().parent().remove();  // 链式操作    });    // 新增按钮的功能    $("#add").click(function () {        // 点击新增按钮要做的事儿        // 1. 移除cover和modal的hide样式        $(".cover,.modal").removeClass('hide');    });    // 点击modal中的cancel按钮    $("#cancel").click(function () {       hideModal();    });    // 点击modal中的submit按钮    $("#submit").click(function () {        // 1. 获取用户输入的值        var name = $("#name").val();        var hobby = $("#hobby").val();        // 2. 隐藏模态框，清空输入框        hideModal();        // 3. 创建一个tr标签，把数据塞进去        var trEle = document.createElement("tr");        $(trEle).append('&lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;');        $(trEle).append('&lt;td&gt;' + name + '&lt;/td&gt;');        var tdTmp = document.createElement('td');        tdTmp.innerText = hobby;        $(trEle).append(tdTmp);        $(trEle).append('&lt;td&gt;&lt;button class="fire"&gt;开除&lt;/button&gt;&lt;/td&gt;')        // 4. 把上一步的tr追加到表格的tbody后面        $('tbody').append(trEle);    });　　//先用下面这种方式写，你会发现一些问题，我们新添加的每一行数据里面的那个button标签点击删除的时候没有效果    //  // 点击modal中的submit按钮    // $("#submit").on('click', function () { #这个和直接$('submit').click(function ...)是一样的    //     // 1. 获取用户输入的值    //     var name = $("#name").val();    //     var hobby = $("#hobby").val();    //     // 2. 隐藏模态框，清空输入框    //     hideModal();    //     // 3. 创建一个tr标签，把数据塞进去    //     var trEle = document.createElement("tr");    //     $(trEle).append('&lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;');    //     $(trEle).append('&lt;td&gt;' + name + '&lt;/td&gt;');    //     var tdTmp = document.createElement('td');    //     tdTmp.innerText = hobby;    //     $(trEle).append(tdTmp);    //     $(trEle).append('&lt;td&gt;&lt;button class="fire"&gt;开除&lt;/button&gt;&lt;/td&gt;')    //     // 4. 把上一步的tr追加到表格的tbody后面    //     $('tbody').append(trEle);    // })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="常用事件"><a href="#常用事件" class="headerlink" title="　　常用事件"></a>　　常用事件</h3><pre><code>click(function(){...})hover(function(){...})blur(function(){...})focus(function(){...})change(function(){...}) //内容发生变化，input，select等keyup(function(){...})  </code></pre><p>　　　　keydown和keyup事件（键盘按键按下和抬起的事件，还有一些其他的key事件）组合示例：按住shift实现批量操作：</p><p>　　　　　　先把下面的代码都拿过来看看效果：</p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128144156662-14139297.png" alt="img"></p><p>　　　　　　代码示例，html代码自己copy一下就行了，js部分我们自己写写，其实就是键盘的按键和我们的事件绑定到一起了。</p><p>　　　　　　　　先看一下keyCode：键盘上每个按键都对应有一个keyCode：</p><p>　　　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128143923609-1201238811.png" alt="img"></p><p>　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128143838675-843786100.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta http-equiv="content-Type" charset="UTF-8"&gt;    &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1"&gt;  &lt;thead&gt;  &lt;tr&gt;    &lt;th&gt;#&lt;/th&gt;    &lt;th&gt;姓名&lt;/th&gt;    &lt;th&gt;操作&lt;/th&gt;  &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;    &lt;td&gt;Egon&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value="1"&gt;上线&lt;/option&gt;        &lt;option value="2"&gt;下线&lt;/option&gt;        &lt;option value="3"&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;    &lt;td&gt;Alex&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value="1"&gt;上线&lt;/option&gt;        &lt;option value="2"&gt;下线&lt;/option&gt;        &lt;option value="3"&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;    &lt;td&gt;Yuan&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value="1"&gt;上线&lt;/option&gt;        &lt;option value="2"&gt;下线&lt;/option&gt;        &lt;option value="3"&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;    &lt;td&gt;EvaJ&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value="1"&gt;上线&lt;/option&gt;        &lt;option value="2"&gt;下线&lt;/option&gt;        &lt;option value="3"&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;    &lt;td&gt;Gold&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value="1"&gt;上线&lt;/option&gt;        &lt;option value="2"&gt;下线&lt;/option&gt;        &lt;option value="3"&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;&lt;script src="jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;script&gt;    //按下shift就进入批量操作的模式    var flag = false;    // shift按键被按下的时候，键盘上每个按键都对应有一个keyCode值    $(window).keydown(function (event) {        console.log(event.keyCode);        if (event.keyCode === 16){            flag = true;        }    });    // shift按键被抬起的时候    $(window).keyup(function (event) {        console.log(event.keyCode);        if (event.keyCode === 16){            flag = false;        }    });    // select标签的值发生变化的时候    $("select").change(function (event) {        // 如果shift按键被按下，就进入批量编辑模式        // shift按键对应的code是16        // 判断当前select这一行是否被选中        console.log($(this).parent().siblings().first().find(":checkbox"));        var isChecked = $(this).parent().siblings().first().find(":checkbox").prop("checked");        console.log(isChecked);        if (flag &amp;&amp; isChecked) {            // 进入批量编辑模式            // 1. 取到当前select选中的值            var value = $(this).val();//别忘了this是个dom对象，要用$(this)包裹起来变成jQuery对象            // 2. 给其他被选中行的select设置成和我一样的值            // 2.1 找到那些被选中行的select //被选中的行就是$('input:checked')            var $select = $("input:checked").parent().parent().find("select")  //一般jQuery中的变量名，我们在变量名前面加一个$符号区分一下            //var $select = $('tr:has(input:checked)').find('select') 这个也可以，选择某些标签的方法有很多昂            // 2.2 给选中的select赋值            $select.val(value);        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　hover事件示例：hover事件（不是原生dom的那个hover，并且js里面没有onhover事件，这个是jQuery的hover事件，是jQuery封装的，原生js里面没有）：</p><p>　　　　我们先拿代码看看效果，分析一下代码就行啦，你们自己下来练习写</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;hover示例&lt;/title&gt;  &lt;style&gt;    * {      margin: 0;      padding: 0;    }    .nav {      height: 40px;      width: 100%;      background-color: #3d3d3d;      position: fixed;      top: 0;    }    .nav ul {      list-style-type: none;      line-height: 40px;    }    .nav li {      float: left;      padding: 0 10px;      color: #999999;      position: relative;    }    .nav li:hover {      background-color: #0f0f0f;      color: white;    }    .clearfix:after {      content: "";      display: block;      clear: both;    }    .son {      position: absolute;      top: 40px;      right: 0;      height: 50px;      width: 100px;      background-color: #00a9ff;      display: none;  &lt;!--最开始是默认不显示的--&gt;    }    .hover .son {  &lt;!--这个选择器生效的条件是这两个class属性的值都有才生效，如果我们移除了class='hover'，这个.hover就没有了，那么这个选择器就不生效了，那这个样式也就不生效了--&gt;      display: block;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="nav"&gt;  &lt;ul class="clearfix"&gt;    &lt;li&gt;登录&lt;/li&gt;    &lt;li&gt;注册&lt;/li&gt;    &lt;li&gt;购物车      &lt;p class="son hide"&gt;        空空如也...      &lt;/p&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$(".nav li").hover(  　//hover事件分为两步，事件中有两个匿名函数  //第一步：鼠标移动上去  function () {    $(this).addClass("hover");  },  //第二步：鼠标移走  function () {    $(this).removeClass("hover");  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　实时监听input输入值变化示例：input值变化事件：看百度搜索的效果：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128151456658-933950322.png" alt="img"></p><p>　　　　这叫做input事件，看代码：只要input框里面的值发生变化就触发某个事件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;实时监听input输入值变化&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="i1"&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt;  /*  * oninput是HTML5的标准事件  * 能够检测textarea,input:text,input:password和input:search这几个元素的内容变化，  * 在内容修改后立即被触发，不像onchange事件需要失去焦点才触发  * oninput事件在IE9以下版本不支持，需要使用IE特有的onpropertychange事件替代  * 使用jQuery库的话直接使用on同时绑定这两个事件即可。  * */  $("#i1").on("input propertychange", function () {    console.log($(this).val());  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　上面代码的效果</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128151834610-473098613.png" alt="img"></p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="　　事件绑定"></a>　　事件绑定</h3><h3 id="on-events-selector-function"><a href="#on-events-selector-function" class="headerlink" title="　　　　.on( events [, selector ],function(){})"></a>　　　　<code>.on( events [, selector ],function(){})</code></h3><p>　　　　　　1.events： 事件</p><p>　　　　　　2.selector: 选择器（可选的）</p><p>　　　　　　3.function: 事件处理函数</p><h3 id="移除事件（不常用）"><a href="#移除事件（不常用）" class="headerlink" title="　　移除事件（不常用）"></a>　　移除事件（不常用）</h3><h3 id="off-events-selector-function"><a href="#off-events-selector-function" class="headerlink" title="　　　　.off( events [, selector ][,function(){}])"></a>　　　　<code>.off( events [, selector ][,function(){}])</code></h3><p><code>　　　　off()</code> 方法移除用 <code>.on()</code>绑定的事件处理程序。</p><p>　　　　　　1.events： 事件</p><p>　　　　　　2.selector: 选择器（可选的）</p><p>　　　　　　3.function: 事件处理函数</p><h3 id="阻止后续事件执行"><a href="#阻止后续事件执行" class="headerlink" title="　　阻止后续事件执行"></a>　　阻止后续事件执行</h3><p>　　　　1. <code>return false; // 常见阻止表单提交等，如果input标签里面的值为空就组织它提交，就可以使用这两种方法</code></p><p>　　　　2. e.preventDefault();</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;阻止默认事件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=""&gt;  #action里面如果没写url，默认是将内容提交到当前页面的url处    &lt;button id="b1"&gt;点我&lt;/button&gt;&lt;/form&gt;&lt;script src="jquery-3.3.1.min.js"&gt;&lt;/script&gt;&lt;script&gt;    $("#b1").click(function (e) {        alert(123);        //return false;        e.preventDefault();    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　注意：</p><p>　　　　　　像click、keydown等DOM中定义的事件，我们都可以使用<code>.on()</code>方法来绑定事件，但是<code>hover</code>这种jQuery中定义的事件就不能用<code>.on()</code>方法来绑定了。</p><p>　　　　　　想使用事件委托的方式绑定hover事件处理函数，可以参照如下代码分两步绑定事件：</p><pre><code>$('ul').on('mouseenter', 'li', function() {//绑定鼠标进入事件    $(this).addClass('hover');});$('ul').on('mouseleave', 'li', function() {//绑定鼠标划出事件    $(this).removeClass('hover');});</code></pre><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="　　阻止事件冒泡"></a>　　阻止事件冒泡</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;阻止事件冒泡&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;p&gt;        &lt;span&gt;点我&lt;/span&gt;    &lt;/p&gt;&lt;/div&gt;&lt;script src="jquery-3.3.1.min.js"&gt;&lt;/script&gt;&lt;script&gt;    //冒泡的意思就是因为html可以嵌套，如果你给儿子标签绑定了点事件或者没有绑定点击事件，父级标签绑定了点击事件，那么你一点击子标签，不管子标签    有没有绑定事件，都会触发父级标签的点击事件，如果有，会先触发子标签的点击事件，然后触发父级标签的点击事件，不管子标签有没有点击事件，都会一级一级的还往上找点击事件    //所以我们要阻止这种事件冒泡    $("span").click(function (e) { //这个参数e(只是个形参，写evt或者event名字的也很多)表示当前事件本身，这个事件也是一个对象        alert("span");        //return false；这个也可以阻止        e.stopPropagation(); 用事件对象的这个方法就能阻止冒泡 （Propagation：传递的意思）    });    $("p").click(function () {        alert("p");    });    $("div").click(function () {        alert("div");    })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　pycharm的一个功能：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128140959612-1360009053.png" alt="img"></p><p>　</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="　　事件委托"></a>　　事件委托</h3><p>　　　　事件委托是通过事件冒泡的原理，利用父标签去捕获子标签的事件，将未来添加进来的某些子标签自动绑定上事件。</p><p>　　　　示例：</p><p>　　　　表格中每一行的编辑和删除按钮都能触发相应的事件。回去完善一下咱们上面的那个作业吧，添加一行数据的那个作业，然后我们在学习一下上面的那些绑定事件。</p><pre><code>$("table").on("click", ".delete", function () { //中间的参数是个选择器，前面这个$('table')是父级标签选择器，选择的是父级标签，意思就是将子标签（子子孙孙）的点击事件委托给了父级标签  //但是这里注意一点，你console.log(this)；你会发现this还是触发事件的那个子标签，这个记住昂  // 删除按钮绑定的事件 })</code></pre><h3 id="页面载入"><a href="#页面载入" class="headerlink" title="　　页面载入"></a>　　页面载入</h3><p>　　　　当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。</p><p>　　　　还记得我们说将js代码写到head标签和写道body标签下面的作用是不同的吗，写在head标签里面的话，如果你写了操作某个标签的内容的话，那个标签还没加载出来，先加载了你的js代码，就找不到这个标签，所以不会生效，所以写在body标签最下面是一种解决办法，还有一种办法就是window.onload=function(){js的代码}，等页面上所有的元素都加载完，在执行这里面的js代码，还记得吗？，但是这个window.onload有个缺点，这个缺点就是这个操作时给window.onload赋值，如果你自己写了两个js文件，每个js文件中都有一个window.onload的话，那么后引入的文件会把前面引入的文件的window.onload里面的js代码全部覆盖掉，那么第一个文件的js代码就失去了效果，还有一个问题就是，window.onload会等到页面上的文档、图片、视频等所有资源都加载完才执行里面的js代码，导致有些效果的加载比较慢，所以我们使用下面的写法，不存在覆盖问题，而且只要文档加载完就触发，不需要等着一些图片啊视频啊什么的，加载js效果的速度快。</p><p>　　　　两种写法：</p><pre><code>$(document).ready(function(){// 在这里写你的JS代码...})</code></pre><p>　　　　简写：</p><pre><code>$(function(){// 你在这里写你的代码})</code></pre><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128153617625-2138999577.png" alt="img"></p><p>　　　　文档加载完绑定事件，并且阻止默认事件发生：登录校验示例：（这个不讲，大家看看代码就行啦）</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;登录注册示例&lt;/title&gt;  &lt;style&gt;    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form id="myForm"&gt;  &lt;label for="name"&gt;姓名&lt;/label&gt;  &lt;input type="text" id="name"&gt;  &lt;span class="error"&gt;&lt;/span&gt;  &lt;label for="passwd"&gt;密码&lt;/label&gt;  &lt;input type="password" id="passwd"&gt;  &lt;span class="error"&gt;&lt;/span&gt;  &lt;input type="submit" id="modal-submit" value="登录"&gt;&lt;/form&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script src="s7validate.js"&gt;&lt;/script&gt;&lt;script&gt;  function myValidation() {    // 多次用到的jQuery对象存储到一个变量，避免重复查询文档树    var $myForm = $("#myForm");    $myForm.find(":submit").on("click", function () {      // 定义一个标志位，记录表单填写是否正常      var flag = true;      $myForm.find(":text, :password").each(function () {        var val = $(this).val();        if (val.length &lt;= 0 ){          var labelName = $(this).prev("label").text();          $(this).next("span").text(labelName + "不能为空");          flag = false;        }      });      // 表单填写有误就会返回false，阻止submit按钮默认的提交表单事件      return flag;    });    // input输入框获取焦点后移除之前的错误提示信息    $myForm.find("input[type!='submit']").on("focus", function () {      $(this).next(".error").text("");    })  }  // 文档树就绪后执行  $(document).ready(function () {    myValidation();  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="与window-onload的区别"><a href="#与window-onload的区别" class="headerlink" title="　　与window.onload的区别"></a>　　与window.onload的区别</h3><p>　　　　1.window.onload()函数有覆盖现象，必须等待着图片资源加载完成之后才能调用</p><p>　　　　2.jQuery的这个入口函数没有函数覆盖现象，文档加载完成之后就可以调用（建议使用此函数）</p><h3 id=""><a href="#" class="headerlink" title="　　"></a>　　</h3><h2 id="动画效果（了解）"><a href="#动画效果（了解）" class="headerlink" title="动画效果（了解）"></a>动画效果（了解）</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>// 基本show([s,[e],[fn]])  $('.c1').show()  //show(5000),就是5秒之后显示出来这个标签，并且有一个动画效果，（搞个img图片看看效果），后面两个参数先不用管hide([s,[e],[fn]])  $('.c1').head()toggle([s],[e],[fn])//这几个toggle的意思就是你原来是什么效果，我就反着来// 滑动（拉窗帘一样）slideDown([s],[e],[fn])  //使用的时候别忘了给标签设置一个高度和宽度，其实就是控制你的标签高度，如果你写$('#di').slideUp(5000)；意思就是5秒内把你的高度变为0//还有如果你直接操作的是img标签和操作img标签的父级标签，两个的效果是不同的slideUp([s,[e],[fn]]) slideToggle([s],[e],[fn])// 淡入淡出（控制透明度）fadeIn([s],[e],[fn])fadeOut([s],[e],[fn])fadeTo([[s],o,[e],[fn]])  o参数是透明度，0-1的区间，意思是淡入或者淡出到一个多大的透明读fadeToggle([s,[e],[fn]])// 自定义（了解即可）animate(p,[s],[e],[fn])</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128155344603-369394263.png" alt="img"></p><p>　　　　通过animate自定义动画示例：点赞特效简单示例（看看效果，自己看看代码就行啦，你以后大概率上用不到）：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;点赞动画示例&lt;/title&gt;  &lt;style&gt;    div {      position: relative;      display: inline-block;    }    div&gt;i {      display: inline-block;      color: red;      position: absolute;      right: -16px;      top: -5px;      opacity: 1;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="d1"&gt;点赞&lt;/div&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt;  $("#d1").on("click", function () {    var newI = document.createElement("i");    newI.innerText = "+1";    $(this).append(newI);    $(this).children("i").animate({      opacity: 0  //1秒之后透明度变为0，注意写法，animate({属性：值},毫秒数)     }, 1000)  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><p>　　<strong>jQuery.each(collection, callback(indexInArray, valueOfElement))：</strong></p><p>　　　　描述：一个通用的迭代函数，它可以用来无缝迭代对象和数组。数组和类似数组的对象通过一个长度属性（如一个函数的参数对象）来迭代数字索引，从0到length - 1。其他对象通过其属性名进行迭代。</p><pre><code>li =[10,20,30,40]$.each(li,function(i, v){    console.log(i, v);//function里面可以接受两个参数，i是索引，v是每次循环的具体元素。})</code></pre><p>　　　　输出：</p><pre><code>010120230340</code></pre><p>　　<strong>.each(function(index, Element))：</strong></p><p>　　　　描述：遍历一个jQuery对象，为每个匹配元素执行一个函数。</p><p><code>　　　　.each()</code> 方法用来迭代jQuery对象中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)。由于回调函数是在当前DOM元素为上下文的语境中触发的，所以关键字 <code>this</code> 总是指向这个元素。</p><pre><code>// 为每一个li标签添加foo$("li").each(function(){  $(this).addClass("c1");});</code></pre><p>　　　　注意: jQuery的方法返回一个jQuery对象，遍历jQuery集合中的元素 - 被称为隐式<em>迭代</em>的过程。当这种情况发生时，它通常不需要显式地循环的 <code>.each()</code>方法：</p><p>　　　　也就是说，上面的例子没有必要使用each()方法，直接像下面这样写就可以了：</p><pre><code>$("li").addClass("c1");  // 对所有标签做统一操作</code></pre><p>　　<strong>注意：</strong></p><p>　　　　在遍历过程中可以使用 <code>return false</code>提前结束each循环。</p><p>　　　　而直接使用return;后面什么都不加，不写false，就是跳过本次循环的意思</p><p>　　<strong>终止each循环</strong></p><pre><code>return false；</code></pre><p>　　　　　var namelist = [‘a’,’b’,’c’]</p><p>　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128160607655-2132149898.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128160613636-1128765765.png" alt="img"></p><p>　　　　上面是循环一个数组，通过$.each,还需要把数组传进去，我们还可以通过each来循环标签：(this指的是当前循环的那个标签对象，以后循环标签的时候，就不用自己写for循环了，用each就行了)</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128161139610-676796287.png" alt="img"></p><p>　　　　　　</p><p>　　　　伏笔…</p><h3 id="data"><a href="#data" class="headerlink" title="　　.data()"></a>　　.data()</h3><p>　　　　任意jQuery对象都有data方法，可以保存任意值，可以用来代替全局变量</p><p>　　　　在匹配的元素集合中的所有元素上存储任意相关数据或返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。</p><p>　　<strong>.data(key, value): 设置值</strong></p><p>　　　　描述：在匹配的元素上存储任意相关数据。</p><pre><code>$("div").data("k",100);//给所有div标签都保存一个名为k，值为100</code></pre><p>　　<strong>.data(key): 取值，没有的话返回undefined</strong></p><p>　　　　描述: 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值—通过 <code>.data(name, value)</code>或 <code>HTML5 data-*</code>属性设置。</p><pre><code>$("div").data("k");//返回第一个div标签中保存的"k"的值</code></pre><p>　　　　保存值：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128162141696-1437699817.png" alt="img"></p><p>　　　　可以保存标签：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128162308626-10961433.png" alt="img"></p><p>　　　　</p><p>　　<strong>.removeData(key):</strong></p><p>　　　　描述：移除存放在元素上的数据，不加key参数表示移除所有保存的数据。</p><pre><code>$("div").removeData("k");  //移除元素上存放k对应的数据</code></pre><p>　　　　</p><p>　　　　先把作业给大家说一下：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128162714606-1130377182.png" alt="img"></p><p>　　　　　　新增按钮和编辑按钮弹出的是同一个对话框，里面是同一个提交按钮和取消按钮，你需要考虑一下如何区分是新增还是编辑，新增的效果是添加一行，编辑的效果是修改之前的数据。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/988061-20190128162705608-755597405.png" alt="img"></p><p>　　　</p><h3 id="插件-了解即可"><a href="#插件-了解即可" class="headerlink" title="　　插件(了解即可)"></a>　　插件(了解即可)</h3><p>　　　　jQuery.extend(object)</p><p>　　　　jQuery的命名空间下添加新的功能。多用于插件开发者向 jQuery 中添加新函数时使用。</p><p>　　　　示例：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;script&gt;jQuery.extend({ //$.extend({})  min:function(a, b){return a &lt; b ? a : b;}, //自定义了一个min和max方法，min和max作为键，值是一个function  max:function(a, b){return a &gt; b ? a : b;}});jQuery.min(2,3);// =&gt; 2jQuery.max(4,5);// =&gt; 5&lt;/script&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　jQuery.fn.extend(object)</p><p>　　　　一个对象的内容合并到jQuery的原型，以提供新的jQuery实例方法。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>&lt;script&gt;  jQuery.fn.extend({  //给任意的jQuery标签对象添加一个方法    check:function(){      return this.each(function(){this.checked =true;});    },    uncheck:function(){      return this.each(function(){this.checked =false;});    }  });// jQuery对象可以使用新添加的check()方法了。$("input[type='checkbox']").check();&lt;/script&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　单独写在文件中的扩展：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><pre><code>(function(jq){  jq.extend({    funcName:function(){    ...    },  });})(jQuery);</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　例子：jQuery的插件都是这样扩展出来的</p><p>　　　　自定义的jQuery登录验证插件：（自己看看，了解一下就行了）</p><p>　　　　HTML文件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;登录校验示例&lt;/title&gt;  &lt;style&gt;    .login-form {      margin: 100px auto 0;      max-width: 330px;    }    .login-form &gt; div {      margin: 15px 0;    }    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;  &lt;form action="" class="login-form" novalidate&gt;    &lt;div&gt;      &lt;label for="username"&gt;姓名&lt;/label&gt;      &lt;input id="username" type="text" name="name" required autocomplete="off"&gt;      &lt;span class="error"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for="passwd"&gt;密码&lt;/label&gt;      &lt;input id="passwd" type="password" name="password" required autocomplete="off"&gt;      &lt;span class="error"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for="mobile"&gt;手机&lt;/label&gt;      &lt;input id="mobile" type="text" name="mobile" required autocomplete="off"&gt;      &lt;span class="error"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for="where"&gt;来自&lt;/label&gt;      &lt;input id="where" type="text" name="where" autocomplete="off"&gt;      &lt;span class="error"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type="submit" value="登录"&gt;    &lt;/div&gt;  &lt;/form&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="validate.js"&gt;&lt;/script&gt;&lt;script&gt;  $.validate();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　JS文件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>"use strict";(function ($) {  function check() {    // 定义一个标志位，表示验证通过还是验证不通过    var flag = true;    var errMsg;    // 校验规则    $("form input[type!=':submit']").each(function () {      var labelName = $(this).prev().text();      var inputName = $(this).attr("name");      var inputValue = $(this).val();      if ($(this).attr("required")) {        // 如果是必填项        if (inputValue.length === 0) {          // 值为空          errMsg = labelName + "不能为空";          $(this).next().text(errMsg);          flag = false;          return false;        }        // 如果是密码类型，我们就要判断密码的长度是否大于6位        if (inputName === "password") {          // 除了上面判断为不为空还要判断密码长度是否大于6位          if (inputValue.length &lt; 6) {            errMsg = labelName + "必须大于6位";            $(this).next().text(errMsg);            flag = false;            return false;          }        }        // 如果是手机类型，我们需要判断手机的格式是否正确        if (inputName === "mobile") {          // 使用正则表达式校验inputValue是否为正确的手机号码          if (!/^1[345678]\d{9}$/.test(inputValue)) {            // 不是有效的手机号码格式            errMsg = labelName + "格式不正确";            $(this).next().text(errMsg);            flag = false;            return false;          }        }      }    });    return flag;  }  function clearError(arg) {    // 清空之前的错误提示    $(arg).next().text("");  }  // 上面都是我定义的工具函数  $.extend({    validate: function () {      $("form :submit").on("click", function () {      return check();    });    $("form :input[type!='submit']").on("focus", function () {      clearError(this);    });    }  });})(jQuery);</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　传参版插件：</p><p>　　　　HTML文件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;  &lt;title&gt;登录校验示例&lt;/title&gt;  &lt;style&gt;    .login-form {      margin: 100px auto 0;      max-width: 330px;    }    .login-form &gt; div {      margin: 15px 0;    }    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;  &lt;form action="" class="login-form" novalidate&gt;    &lt;div&gt;      &lt;label for="username"&gt;姓名&lt;/label&gt;      &lt;input id="username" type="text" name="name" required autocomplete="off"&gt;      &lt;span class="error"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for="passwd"&gt;密码&lt;/label&gt;      &lt;input id="passwd" type="password" name="password" required autocomplete="off"&gt;      &lt;span class="error"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for="mobile"&gt;手机&lt;/label&gt;      &lt;input id="mobile" type="text" name="mobile" required autocomplete="off"&gt;      &lt;span class="error"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for="where"&gt;来自&lt;/label&gt;      &lt;input id="where" type="text" name="where" autocomplete="off"&gt;      &lt;span class="error"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type="submit" value="登录"&gt;    &lt;/div&gt;  &lt;/form&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="validate3.js"&gt;&lt;/script&gt;&lt;script&gt;  $.validate({"name":{"required": true}, "password": {"required": true, "minLength": 8}, "mobile": {"required": true}});&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　JS文件:</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><pre><code>"use strict";(function ($) {  function check(arg) {    // 定义一个标志位，表示验证通过还是验证不通过    var flag = true;    var errMsg;    // 校验规则    $("form input[type!=':submit']").each(function () {      var labelName = $(this).prev().text();      var inputName = $(this).attr("name");      var inputValue = $(this).val();      if (arg[inputName].required) {        // 如果是必填项        if (inputValue.length === 0) {          // 值为空          errMsg = labelName + "不能为空";          $(this).next().text(errMsg);          flag = false;          return false;        }        // 如果是密码类型，我们就要判断密码的长度是否大于6位        if (inputName === "password") {          // 除了上面判断为不为空还要判断密码长度是否大于6位          if (inputValue.length &lt; arg[inputName].minLength) {            errMsg = labelName + "必须大于"+arg[inputName].minLength+"位";            $(this).next().text(errMsg);            flag = false;            return false;          }        }        // 如果是手机类型，我们需要判断手机的格式是否正确        if (inputName === "mobile") {          // 使用正则表达式校验inputValue是否为正确的手机号码          if (!/^1[345678]\d{9}$/.test(inputValue)) {            // 不是有效的手机号码格式            errMsg = labelName + "格式不正确";            $(this).next().text(errMsg);            flag = false;            return false;          }        }      }    });    return flag;  }  function clearError(arg) {    // 清空之前的错误提示    $(arg).next().text("");  }  // 上面都是我定义的工具函数  $.extend({    validate: function (arg) {      $("form :submit").on("click", function () {      return check(arg);    });    $("form :input[type!='submit']").on("focus", function () {      clearError(this);    });    }  });})(jQuery);</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/qd/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　课后习题：</p><ol><li>登录+验证</li><li>左侧菜单</li><li>表格-增、删、改、查</li></ol><pre><code>键盘上每个按键都对应有一个keyCode值</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQl创建用户和授权</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQl%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%92%8C%E6%8E%88%E6%9D%83/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQl%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%92%8C%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="一-权限管理"><a href="#一-权限管理" class="headerlink" title="一 权限管理"></a>一 权限管理</h1><p>　　</p><p>　　我们知道我们的最高权限管理者是root用户，它拥有着最高的权限操作。包括select、update、delete、update、grant等操作。那么一般情况在公司之后DBA工程师会创建一个用户和密码，让你去连接数据库的操作，并给当前的用户设置某个操作的权限（或者所有权限）。那么这时就需要我们来简单了解一下：</p><ul><li>如何创建用户和密码</li><li>给当前的用户授权</li><li>移除当前用户的权限</li></ul><p>　　如果你想创建一个新的用户，则需要以下操作：</p><p>　　<strong>1.进入到mysql数据库下</strong></p><pre><code>mysql&gt; use mysqlDatabase changed</code></pre><p>　　<strong>2.对新用户增删改</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>1.创建用户:# 指定ip：192.118.1.1的chao用户登录create user 'chao'@'192.118.1.1' identified by '123';# 指定ip：192.118.1.开头的chao用户登录create user 'chao'@'192.118.1.%' identified by '123';# 指定任何ip的chao用户登录create user 'chao'@'%' identified by '123';2.删除用户drop user '用户名'@'IP地址';3.修改用户rename user '用户名'@'IP地址' to '新用户名'@'IP地址';4.修改密码set password for '用户名'@'IP地址'=Password('新密码');</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>3.对当前的用户授权管理</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#查看权限show grants for '用户'@'IP地址'#授权 chao用户仅对db1.t1文件有查询、插入和更新的操作grant select ,insert,update on db1.t1 to "chao"@'%';# 表示有所有的权限，除了grant这个命令，这个命令是root才有的。chao用户对db1下的t1文件有任意操作grant all privileges  on db1.t1 to "chao"@'%';#chao用户对db1数据库中的文件执行任何操作grant all privileges  on db1.* to "chao"@'%';#chao用户对所有数据库中文件有任何操作grant all privileges  on *.*  to "chao"@'%';#取消权限# 取消chao用户对db1的t1文件的任意操作revoke all on db1.t1 from 'chao'@"%";  # 取消来自远程服务器的chao用户对数据库db1的所有表的所有权限revoke all on db1.* from 'chao'@"%";  取消来自远程服务器的chao用户所有数据库的所有的表的权限revoke all privileges on *.* from 'chao'@'%';</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　ps:在公司中，一般情况下是DBA工程师来做这些授权工作。给你一个用户名和密码，你来连接就可以了。</p><p>　　</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQl创建用户和授权</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>MySQL之存储引擎</p><p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9953550.html#part_1">一 存储引擎解释</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9953550.html#part_2">二 MySQL存储引擎分类</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9953550.html#part_3">三 不同存储引擎的使用</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9953550.html#part_4"> </a></li></ul><h3 id="一-存储引擎解释"><a href="#一-存储引擎解释" class="headerlink" title="一 存储引擎解释"></a>一 存储引擎解释</h3><p>　　首先确定一点，存储引擎的概念是MySQL里面才有的，不是所有的关系型数据库都有存储引擎这个概念，后面我们还会说，但是现在要确定这一点。　　</p><p>　　在讲清楚什么是存储引擎之前，我们先来个比喻，我们都知道录制一个视频文件，可以转换成不同的格式，例如mp4，avi，wmv等，而存在我们电脑的磁盘上也会存在于不同类型的文件系统中如windows里常见的ntfs、fat32，存在于linux里常见的ext3，ext4，xfs，但是，给我们或者用户看懂实际视频内容都是一样的。直观区别是，占用系统的空间大小与清晰程度可能不一样。<br>那么数据库表里的数据存储在数据库里及磁盘上和上述的视频格式及存储磁盘文件的系统格式特征类似，也有很多种存储方式。<br>　　但是对于用户和应用程序来说同样一张表的数据，无论用什么引擎来存储，用户能够看到的数据是一样的。不同储引擎存取，引擎功能，占用空间大小，读取性能等可能有区别。说白了，存储引擎就是在如何存储数据、提取数据、更新数据等技术方法的实现上，底层的实现方式不同，那么就会呈现出不同存储引擎有着一些自己独有的特点和功能，对应着不同的存取机制。<br>　　因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型(即：对表的存储、操作等的实现方法不同)，表是什么，表本质上就是磁盘上的文件。</p><p>　　其实MySQL支持多种存储引擎，每种引擎有着一些自己独特的功能，用户在使用的时候，可以根据自己的业务场景来使用不同的存储引擎，其中MySQL最常用的存储引擎为：MyISAM和InnoDB。<br>在详细介绍这些存储引擎之前，我们先来看看MySQL的整个工作流程，看一下存储引擎在哪里，MySQL都做了哪些事情。</p><p>　　看下图：这是我在MySQL官方手册上拿下来的(手册你如果能够玩好，将来你就能做一个NB的DBA<del>~</del>)</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113174617661-1844607042.png" alt="img"></p><p>　　英文版的看着很难受啊超哥，好好好，给你来个中文的，看下图：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113174704948-1194459622.png" alt="img"></p><p>　　来，看每个部分的解释，看下图：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113182706498-379601585.png" alt="img"></p><p>　　搞明白整个过程之后，我们来细说一下这些存储引擎，看下一节<del>~</del></p><p>　　　　</p><h3 id="二-MySQL存储引擎分类"><a href="#二-MySQL存储引擎分类" class="headerlink" title="二 MySQL存储引擎分类"></a>二 MySQL存储引擎分类</h3><p>　　前面我们对MySQL进行操作的时候并没有指定存储引擎，为什么还能用呢，没有指定还能用，说明什么，说明MySQL默认有一个存储引擎，我记得MySQL5.5之前，默认的存储引擎是MyISAM，之后都改为InnoDB了，我们的重点就是这个InnoDB，也是公司中最常用的、最好用的引擎，但是还是一些公司在用MyISAM引擎，除了历史原因之外，还有MyISAM的效率比InnoDB高一点，InnoDB在这方面做了很多优化，效率已经和MyISAM差不多了，但是InnoDB引擎还有好多其他的NB的功能，下面我们就介绍几种存储引擎。</p><p>　　首先看一下咱们的默认存储引擎：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113183450654-1661588333.png" alt="img"></p><p>　　</p><p>　　不同的引擎代表着不同的存取机制，那么有哪些引擎呢，连接进入mysql之后，查看MySQL支持的所有存储引擎：</p><p>　　　　1、show engines；#查看MySQL所有的引擎，</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113184807373-247683719.png" alt="img"></p><p>　　　　2、show variables like “storage_engine%”;查看当前正在使用的引擎</p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113184606683-2116012923.png" alt="img"></p><p>　　　　注意：在存储大文件的时候，可以存到数据库，但是尽量别直接存到数据库里面，会影响数据库的效率，我们就存文件的路径、地址，用户想要这个大文件，我们可以到对应的路径下取读取这个文件给用户。</p><p> 　　</p><p> 　　<strong>几种常用引擎介绍</strong></p><p>　　　　　　<strong>1. MyISAM引擎</strong>　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>MyISAM引擎特点：        1.不支持事务            事务是指逻辑上的一组操作，组成这组操作的各个单元，要么全成功要么全失败。        2.表级锁定            数据更新时锁定整个表：其锁定机制是表级锁定，也就是对表中的一个数据进行操作都会将这个表锁定，其他人不能操作这个表，这虽然可以让锁定的实现成本很小但是也同时大大降低了其并发性能。        3.读写互相阻塞            不仅会在写入的时候阻塞读取，MyISAM还会再读取的时候阻塞写入，但读本身并不会阻塞另外的读。        4.只会缓存索引            MyISAM可以通过key_buffer_size的值来提高缓存索引，以大大提高访问性能减少磁盘IO，但是这个缓存区只会缓存索引，而不会缓存数据。        5.读取速度较快            占用资源相对较少        6.不支持外键约束，但只是全文索引        7.MyISAM引擎是MySQL5.5版本之前的默认引擎，是对最初的ISAM引擎优化的产物。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>MyISAM引擎适用的生产业务场景        1.不需要事务支持的业务(例如转账就不行，充值也不行)        2.一般为读数据比较多的应用，读写都频繁场景不适合，读多或者写多的都适合。        3.读写并发访问都相对较低的业务(纯读纯写高并发也可以)(锁定机制问题)        4.数据修改相对较少的业务(阻塞问题)        5.以读为主的业务，例如：www.blog,图片信息数据库，用户数据库，商品库等业务        6.对数据一致性要求不是很高的业务。        7.中小型的网站部分业务会用。        小结：单一对数据库的操作都可以示用MyISAM，所谓单一就是尽量纯读，或纯写(insert,update,delete)等。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>MyISAM引擎调优精要        1.设置合适的索引(缓存机制)(where、join后面的列建立索引，重复值比较少的建索引等)        2.调整读写优先级，根据实际需求确保重要操作更优先执行，读写的时候可以通过参数设置优先级。        3.启用延迟插入改善大批量写入性能(降低写入频率，尽可能多条数据一次性写入)。        4.尽量顺序操作让insert数据都写入到尾部，较少阻塞。        5.分解大的操作，降低单个操作的阻塞时间，就像操作系统控制cpu分片一样。        6.降低并发数(减少对MySQL访问)，某些高并发场景通过应用进行排队队列机制Q队列。        7.对于相对静态(更改不频繁)的数据库数据，充分利用Query Cache(可以通过配置文件配置)或memcached缓存服务可以极大的提高访问频率。        8.MyISAM的Count只有在全表扫描的时候特别高效，带有其他条件的count都需要进行实际的数据访问。        9.可以把主从同步的主库使用innodb，从库使用MyISAM引擎。主库写，从库读可以(不推荐，有些麻烦的地方，市场上有人这么用)。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><pre><code>不支持事务、表锁设计、支持全文索引,主要面向一些 OLAP 数 据库应用,在 MySQL 5.5.8 版本之前是默认的存储引擎(除 Windows 版本外)。数据库系统 与文件系统一个很大的不同在于对事务的支持,MyISAM 存储引擎是不支持事务的。究其根 本,这也并不难理解。用户在所有的应用中是否都需要事务呢?在数据仓库中,如果没有 ETL 这些操作,只是简单地通过报表查询还需要事务的支持吗?此外,MyISAM 存储引擎的 另一个与众不同的地方是,它的缓冲池只缓存(cache)索引文件,而不缓存数据文件,这与 大多数的数据库都不相同。</code></pre><p>　　　　　　<strong>2. InnoDB引擎</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>InnoDB引擎        介绍：InnoDB引擎是MySQL数据库的另一个重要的存储引擎，正称为目前MySQL AB所发行新版的标准，被包含在所有二进制安装包里。和其他的存储引擎相比，InnoDB引擎的优点是支持兼容ACID的事务(类似于PostGreSQL)，以及参数完整性(即对外键的支持)。Oracle公司与2005年10月收购了Innobase。Innobase采用双认证授权。它使用GNU发行，也允许其他想将InnoDB结合到商业软件的团体获得授权。InnoDB引擎特点：        1.支持事务：支持4个事务隔离界别，支持多版本读。        2.行级锁定(更新时一般是锁定当前行)：通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响。        3.读写阻塞与事务隔离级别相关(有多个级别，这就不介绍啦~)。        4.具体非常高效的缓存特性：能缓存索引，也能缓存数据。        5.整个表和主键与Cluster方式存储，组成一颗平衡树。(了解)        6.所有SecondaryIndex都会保存主键信息。(了解)        7.支持分区，表空间，类似oracle数据库。        8.支持外键约束，不支持全文索引(5.5之前)，以后的都支持了。        9.和MyISAM引擎比较，InnoDB对硬件资源要求还是比较高的。        小结：三个重要功能：Supports transactions，row-level locking，and foreign keys</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>InnoDB引擎适用的生产业务场景        1.需要事务支持(具有较好的事务特性，例银行业务)        2.行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成。        3.数据更新较为频繁的场景，如：BBS(论坛)、SNS(社交平台)、微博等        4.数据一致性要求较高的业务，例如：充值转账，银行卡转账。        5.硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽可能减少磁盘IO，可以通过一些参数来设置，这个就不细讲啦~~~        6.相比MyISAM引擎，Innodb引擎更消耗资源，速度没有MyISAM引擎快</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>InnoDB引擎调优精要        1.主键尽可能小，避免给Secondery index带来过大的空间负担。        2.避免全表扫描，因为会使用表锁。        3.尽可能缓存所有的索引和数据，提高响应速度，较少磁盘IO消耗。        4.在大批量小插入的时候，尽量自己控制事务而不要使用autocommit自动提交，有开关可以控制提交方式。        5合理设置innodb_flush_log_at_trx_commit参数值，不要过度追求安全性。        如果innodb_flush_log_at_trx_commit的值为0，log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作。        6.避免主键更新，因为这会带来大量的数据移动。        可以看一看InnoDB的重要参数学习一下。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>InnoDB 存储引擎将数据放在一个逻辑的表空间中,这个表空间就像黑盒一样由 InnoDB 存储引擎自身来管理。从 MySQL 4.1(包括 4.1)版本开始,可以将每个 InnoDB 存储引擎的 表单独存放到一个独立的 ibd 文件中。此外,InnoDB 存储引擎支持将裸设备(row disk)用 于建立其表空间。InnoDB 通过使用多版本并发控制(MVCC)来获得高并发性,并且实现了 SQL 标准 的 4 种隔离级别,默认为 REPEATABLE 级别,同时使用一种称为 netx-key locking 的策略来 避免幻读(phantom)现象的产生。除此之外,InnoDB 存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead) 等高性能和高可用的功能。对于表中数据的存储,InnoDB 存储引擎采用了聚集(clustered)的方式,每张表都是按 主键的顺序进行存储的,如果没有显式地在表定义时指定主键,InnoDB 存储引擎会为每一 行生成一个 6 字节的 ROWID,并以此作为主键。InnoDB 存储引擎是 MySQL 数据库最为常用的一种引擎,Facebook、Google、Yahoo 等 公司的成功应用已经证明了 InnoDB 存储引擎具备高可用性、高性能以及高可扩展性。对其 底层实现的掌握和理解也需要时间和技术的积累。如果想深入了解 InnoDB 存储引擎的工作 原理、实现和应用,可以参考《MySQL 技术内幕:InnoDB 存储引擎》一书。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　　　<strong>总说事务，到底啥事事务？我们看看解释：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>事务介绍：        简单地说，事务就是指逻辑上的一组SQL语句操作，组成这组操作的各个SQL语句，执行时要么全成功要么全失败。        例如：你给我转账5块钱，流程如下            a.从你银行卡取出5块钱，剩余计算money-5            b.把上面5块钱打入我的账户上，我收到5块，剩余计算money+5.        上述转账的过程，对应的sql语句为：                update 你_account set money=money-5 where name='你'；                update 我_account set money=money+5 where name='我'；        上述的两条SQL操作，在事务中的操作就是要么都执行，要么都不执行，不然钱就对不上了。        这就是事务的原子性(Atomicity)。    事务的四大特性：        1.原子性(Atomicity)            事务是一个不可分割的单位，事务中的所有SQL等操作要么都发生，要么都不发生。        2.一致性(Consistency)            事务发生前和发生后，数据的完整性必须保持一致。        3.隔离性(Isolation)            当并发访问数据库时，一个正在执行的事务在执行完毕前，对于其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。也就是其他人的操作在这个事务的执行过程中是看不到这个事务的执行结果的，也就是他们拿到的是这个事务执行之前的内容，等这个事务执行完才能拿到新的数据。        4.持久性(Durability)            一个事务一旦被提交，它对数据库中的数据改变就是永久性的。如果出了错误，事务也不允撤销，只能通过'补偿性事务'。    事务的开启：        数据库默认事务是自动提交的，也就是发一条sql他就执行一条。如果想多条sql放在一个事务中执行，则需要使用事务进行处理。当我们开启一个事务，并且没有提交，mysql会自动回滚事务。或者我们使用rollback命令手动回滚事务。        数据库开启事务的命令，我们后面会讲到~~~</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　 </p><p>　　　　　　<strong>在介绍上面两个引擎中涉及的两个概念(OLTP和OLAP)的介绍</strong></p><p>　　　　　　参考文章：<a href="https://blog.csdn.net/zhangzheng0413/article/details/8271322/">https://blog.csdn.net/zhangzheng0413/article/details/8271322/</a></p><p>　　　　　　　　</p><p> 　　　　　　<strong>3.其他引擎的介绍</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#NDB 存储引擎2003 年,MySQL AB 公司从 Sony Ericsson 公司收购了 NDB 存储引擎。 NDB 存储引擎是一个集群存储引擎,类似于 Oracle 的 RAC 集群,不过与 Oracle RAC 的 share everything 结构不同的是,其结构是 share nothing 的集群架构,因此能提供更高级别的 高可用性。NDB 存储引擎的特点是数据全部放在内存中(从 5.1 版本开始,可以将非索引数 据放在磁盘上),因此主键查找(primary key lookups)的速度极快,并且能够在线添加 NDB 数据存储节点(data node)以便线性地提高数据库性能。由此可见,NDB 存储引擎是高可用、 高性能、高可扩展性的数据库集群系统,其面向的也是 OLTP 的数据库应用类型。#Memory 存储引擎正如其名,Memory 存储引擎中的数据都存放在内存中,数据库重 启或发生崩溃,表中的数据都将消失。它非常适合于存储 OLTP 数据库应用中临时数据的临时表,也可以作为 OLAP 数据库应用中数据仓库的维度表。Memory 存储引擎默认使用哈希 索引,而不是通常熟悉的 B+ 树索引。#Infobright 存储引擎第三方的存储引擎。其特点是存储是按照列而非行的,因此非常 适合 OLAP 的数据库应用。其官方网站是 http://www.infobright.org/,上面有不少成功的数据 仓库案例可供分析。#NTSE 存储引擎网易公司开发的面向其内部使用的存储引擎。目前的版本不支持事务, 但提供压缩、行级缓存等特性,不久的将来会实现面向内存的事务支持。#BLACKHOLE黑洞存储引擎，可以应用于主备复制中的分发主库。MySQL 数据库还有很多其他存储引擎,上述只是列举了最为常用的一些引擎。如果 你喜欢,完全可以编写专属于自己的引擎,这就是开源赋予我们的能力,也是开源的魅 力所在。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="三-存储引擎的使用"><a href="#三-存储引擎的使用" class="headerlink" title="三 存储引擎的使用"></a>三 存储引擎的使用</h3><p>　　1、创建表时指定引擎</p><pre><code>create table innodb_t2(id int)engine=innodb;</code></pre><p>　　2、在配置文件中指定默认的存储引擎</p><pre><code>linux:vim /etc/my.cnf   windows:my.ini文件[mysqld]default-storage-engine=INNODB  #配置默认引擎，现在用的mysql默认基本都是InnoDB，所以其实都可以不用配置了innodb_file_per_table=1  #表示独立表空间存储，可以不写</code></pre><p> 　　3、不同引擎在创建表的时候生成文件的不同</p><p>　　　　创建四个表，分别使用innodb，myisam，memory，blackhole存储引擎，进行插入数据测试</p><pre><code>#下面是使用四个不同的引擎来创建的表create table t1(id int)engine=innodb;create table t2(id int)engine=myisam;create table t3(id int)engine=memory;create table t4(id int)engine=blackhole;</code></pre><p> 　　　　通过四种引擎来创建的表，我们对照着其生成的文件来看一下区别，看下图：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181114114754297-1522063600.png" alt="img"></p><p>　　　　关于上面的文件作用介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>1.db.opt文件：用来记录该库的默认字符集编码和字符集排序规则用的。也就是说如果你创建数据库指定默认字符集和排序规则，那么后续创建的表如果没有指定字符集和排序规则，那么该新建的表将采用db.opt文件中指定的属性。2.后缀名为.frm的文件：这个文件主要是用来描述数据表结构(id,name字段等)和字段长度等信息3.后缀名为.ibd的文件：这个文件主要储存的是采用独立表储存模式时储存数据库的数据信息和索引信息；4.后缀名为.MYD（MYData）的文件：从名字可以看出，这个是存储数据库数据信息的文件，主要是存储采用独立表储存模式时存储的数据信息；5.后缀名为.MYI的文件：这个文件主要储存的是数据库的索引信息；6.ibdata1文件:主要作用也是储存数据信息和索引信息，这个文件在mysql安装目录的data文件夹下。    从上面可以看出，.ibd储存的是数据信息和索引信息，ibdata1文件也是存储数据信息和索引信息，.MYD和.MYI也是分别储存数据信息和索引信息，那他们之间有什么区别呢？     主要区别是再于数据库的存储引擎不一样，如果储存引擎采用的是MyISAM，则生成的数据文件为表名.frm、表名.MYD、表名的MYI;而储存引擎如果是innoDB，开启了innodb_file_per_table＝1,也就是采用独立储存的模式，生成的文件是表名.frm、表名.ibd，如果采用共存储模式的，数据信息和索引信息都存储在ibdata1(在里面进行分类，从外面看是一个文件)中;     在进行数据恢复的时候，如果用的是MYISAM数据引擎，那么数据很好恢复，只要将相应.frm, .MYD, .MYI文件拷贝过去即可。但是如果是innodb的话，则每一个数据表都是一个单独的文件，只将相应的.frm和.ibd文件拷贝过去是不够的，必须在你的ibd文件的tablespace id和ibdata1文件中的元信息的tablespace id一致才可以。msyql人家设定的规则就是这样存储表的，使用人家的系统，就要理解人家的规则。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><p>　　在Oracle 和SQL Server等所有数据存储管理机制都是一样的。而MySql数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。</p><p>　　Oracle中不存在引擎的概念，数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p><p>关于MySQL的存储引擎大概就说这么多吧<del>有兴趣或者有基础的同学，可以多去学一下MySQL官方手册</del>收获会有很多<del>那么我们就继续回到我们的数据表操作去学习吧</del></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的sql_mode模式说明及设置</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9A%84sql_mode%E6%A8%A1%E5%BC%8F%E8%AF%B4%E6%98%8E%E5%8F%8A%E8%AE%BE%E7%BD%AE/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9A%84sql_mode%E6%A8%A1%E5%BC%8F%E8%AF%B4%E6%98%8E%E5%8F%8A%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>MySQL的sql_mode合理设置</strong></p><p>​    sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.</p><p>​    </p><p><strong>sql model 常用来解决下面几类问题</strong></p><p>　　(1) 通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。</p><p>　　(2) 通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。</p><p>　　(3) 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。</p><p>​    </p><p><strong>sql_mode常用值如下:</strong> </p><p>​    ONLY_FULL_GROUP_BY:</p><p>​    对于GROUP BY聚合操作,如果在SELECT中的列,没有在GROUP BY中出现,那么这个SQL是不合法的,因为列不在GROUP BY从句中</p><p>​    NO_AUTO_VALUE_ON_ZERO:</p><p>​    该值影响自增长列的插入。默认设置下,插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0,而该列又是自增长的,那么这个选项就有用了。</p><p>​    STRICT_TRANS_TABLES:</p><p>​    在该模式下,如果一个值不能插入到一个事务表中,则中断当前的操作,对非事务表不做限制</p><p>​    NO_ZERO_IN_DATE:</p><p>​    在严格模式下,不允许日期和月份为零</p><p>​    NO_ZERO_DATE:</p><p>​    设置该值,mysql数据库不允许插入零日期,插入零日期会抛出错误而不是警告。</p><p>​    ERROR_FOR_DIVISION_BY_ZERO:</p><p>​    在INSERT或UPDATE过程中,如果数据被零除,则产生错误而非警告。如 果未给出该模式,那么数据被零除时MySQL返回NULL</p><p>​    NO_AUTO_CREATE_USER:</p><p>​    禁止GRANT创建密码为空的用户</p><p>​    NO_ENGINE_SUBSTITUTION:</p><p>​    如果需要的存储引擎被禁用或未编译,那么抛出错误。不设置此值时,用默认的存储引擎替代,并抛出一个异常</p><p>​    PIPES_AS_CONCAT:</p><p>​    将”||”视为字符串的连接操作符而非或运算符,这和Oracle数据库是一样的,也和字符串的拼接函数Concat相类似</p><p>​    ANSI_QUOTES:</p><p>​    启用ANSI_QUOTES后,不能用双引号来引用字符串,因为它被解释为识别符</p><p>​    ORACLE的sql_mode设置等同:PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, NO_KEY_OPTIONS, NO_TABLE_OPTIONS, NO_FIELD_OPTIONS, NO_AUTO_CREATE_USER.</p><p>​     </p><p>​    如果使用mysql,为了继续保留大家使用oracle的习惯,可以对mysql的sql_mode设置如下:</p><p>​     </p><p>​    在my.cnf添加如下配置</p><p>​    [mysqld]</p><p>​    sql_mode=’ONLY_FULL_GROUP_BY,NO_AUTO_VALUE_ON_ZERO,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,</p><p>​    ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,PIPES_AS_CONCAT,ANSI_QUOTES’</p><p>​      </p><p>​      </p><p><strong>注意：</strong>MySQL5.6和MySQL5.7默认的sql_mode模式参数是不一样的,5.6的mode是NO_ENGINE_SUBSTITUTION，其实表示的是一个空值，相当于没有什么模式设置，可以理解为宽松模式。5.7的mode是STRICT_TRANS_TABLES，也就是严格模式。</p><p>​    <strong>如果设置的是宽松模式，那么我们在插入数据的时候，即便是给了一个错误的数据，也可能会被接受，并且不报错，例如：我在创建一个表时，该表中有一个字段为name，给name设置的字段类型时char(10)，如果我在插入数据的时候，其中name这个字段对应的有一条数据的长度超过了10，例如’1234567890abc’，超过了设定的字段长度10，那么不会报错，并且取前十个字符存上，也就是说你这个数据被存为了’1234567890’,而’abc’就没有了，但是我们知道，我们给的这条数据是错误的，因为超过了字段长度，但是并没有报错，并且mysql自行处理并接受了，这就是宽松模式的效果，其实在开发、测试、生产等环境中，我们应该采用的是严格模式，出现这种错误，应该报错才对，所以MySQL5.7版本就将sql_mode默认值改为了严格模式，并且我们即便是用的MySQL5.6，也应该自行将其改为严格模式，而你记着，MySQL等等的这些数据库，都是想把关于数据的所有操作都自己包揽下来，包括数据的校验，其实好多时候，我们应该在自己开发的项目程序级别将这些校验给做了，虽然写项目的时候麻烦了一些步骤，但是这样做之后，我们在进行数据库迁移或者在项目的迁移时，就会方便很多，这个看你们自行来衡量。mysql除了数据校验之外，你慢慢的学习过程中会发现，它能够做的事情还有很多很多，将你程序中做的好多事情都包揽了。</strong></p><p><strong>改为严格模式后可能会存在的问题：</strong></p><p>​    若设置模式中包含了NO_ZERO_DATE，那么MySQL数据库不允许插入零日期，插入零日期会抛出错误而不是警告。例如表中含字段TIMESTAMP列（如果未声明为NULL或显示DEFAULT子句）将自动分配DEFAULT ‘0000-00-00 00:00:00’（零时间戳），也或者是本测试的表day列默认允许插入零日期 ‘0000-00-00’ COMMENT ‘日期’；这些显然是不满足sql_mode中的NO_ZERO_DATE而报错。</p><p><strong>模式设置和修改(以解决上述问题为例)：</strong></p><p>​    <strong>方式一</strong>：先执行select @@sql_mode,复制查询出来的值并将其中的NO_ZERO_IN_DATE,NO_ZERO_DATE删除，然后执行set sql_mode = ‘修改后的值’或者set session sql_mode=’修改后的值’;，例如：set session sql_mode=’STRICT_TRANS_TABLES’;改为严格模式</p><p>​        此方法只在当前会话中生效，关闭当前会话就不生效了。</p><p>​    <strong>方式二</strong>：先执行select @@global.sql_mode,复制查询出来的值并将其中的NO_ZERO_IN_DATE,NO_ZERO_DATE删除，然后执行set global sql_mode = ‘修改后的值’。</p><p>​        此方法在当前服务中生效，重新MySQL服务后失效</p><p>​    <strong>方法三</strong>：在mysql的安装目录下，或my.cnf文件(windows系统是my.ini文件)，新增 sql_mode = ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION，</p><p>​        添加my.cnf如下：</p><p>​        [mysqld]</p><p>​        sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER</p><p>​        然后重启mysql。</p><p>​    此方法永久生效.当然生产环境上是禁止重启MySQL服务的，所以采用方式二加方式三来解决线上的问题，那么即便是有一天真的重启了MySQL服务，也会永久生效了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的sql语言分类DML、DQL、DDL、DCL</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9A%84sql%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BBDML%E3%80%81DQL%E3%80%81DDL%E3%80%81DCL/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9A%84sql%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BBDML%E3%80%81DQL%E3%80%81DDL%E3%80%81DCL/</url>
      
        <content type="html"><![CDATA[<p>SQL语言一共分为4大类：数据定义语言DDL，数据操纵语言DML，数据查询语言DQL，数据控制语言DCL  </p><p>1.数据定义语言DDL(Data Definition Language)</p><p>　　对象： 数据库和表</p><p>　　关键词： create alter drop truncate(删除当前表再新建一个一模一样的表结构)</p><p>　　创建数据库：create database school;</p><p>　　删除数据库：drop database school;</p><p>　　切换数据库：use school;</p><p>　　创建表：create table student(</p><p>　　　　　　id int(4) primary key auto_increment,</p><p>　　　　　　name varchar(20),</p><p>　　　　　　score int(3)</p><p>　　　　);</p><p>　　查看数据库里存在的表：show tables;</p><p>　　注意：</p><p>　　　　varchar类型的长度是可变的，创建表时指定了最大长度，定义时，其最大值可以取0-65535之间的任意值，但记录在这个范围内，使用多少分配多少，</p><p>varchar类型实际占用空间为字符串的实际长度加1。这样，可有效节约系统空间。varchar是mysql的特有的数据类型。</p><p>　　　　char类型的长度是固定的，在创建表时就指定了，其长度可以是0-255之间的任意值。虽然char占用的空间比较大，但它的处理速度快。</p><p>　　修改表：alter table student rename (to) teacher;</p><p>　　　　　　alter table student add password varchar(20);</p><p>　　　　　　alter table student change password pwd varchar(20);</p><p>　　　　　　alter table student modify pwd int;</p><p>　　　　　　alter table student drop pwd;</p><p>　　删除表：drop table student;</p><p>　　查看生成表的sql语句：show create table student;</p><p>　　查看表结构：desc student;</p><p>2.数据操纵语言DML(Data Manipulation Language)　　　</p><p>　　对象：纪录(行)</p><p>　　关键词：insert update delete</p><p>　　插入：insert into student values(01,’tonbby’,99); (插入所有的字段)</p><p>　　　　　insert into student(id,name) values(01,’tonbby’); (插入指定的字段)</p><p>　　更新：update student set name = ‘tonbby’,score = ‘99’ where id = 01;</p><p>　　删除：delete from tonbby where id = 01;</p><p>　　注意：</p><p>　　　　　开发中很少使用delete,删除有物理删除和逻辑删除，其中逻辑删除可以通过给表添加一个字段(isDel)，若值为1，代表删除；若值为0，代表没有删除。</p><p>　　　　　此时，对数据的删除操作就变成了update操作了。</p><p>　　truncate和delete的区别：</p><p>　　　　truncate是删除表，再重新创建这个表。属于DDL，delete是一条一条删除表中的数据，属于DML。</p><p>3.数据查询语言DQL(Data Query Language)</p><p>　　select … from student where 条件 group by 分组字段 having 条件 order by 排序字段</p><p>　　执行顺序：from-&gt;where-&gt;group by-&gt;having-&gt;order by-&gt;select</p><p>　　注意：group by 通常和聚合函数(avg(),count()…)一起使用 ,经常先使用group by关键字进行分组，然后再进行集合运算。</p><p>　　　　　group by与having 一起使用，可以限制输出的结果，只有满足条件表达式的结果才会显示。</p><p>　　having和where的区别：</p><p>　　　　两者起作用的地方不一样，where作用于表或视图，是表和视图的查询条件。having作用于分组后的记录，用于选择满足条件的组。</p><p>4.数据控制语言DCL(Data Control Language)  </p><p>　　数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视，用户，权限，事务等。</p><p>　　grant：授权，rollback：回滚。commit：提交。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的库、表的详细操作</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9A%84%E5%BA%93%E3%80%81%E8%A1%A8%E7%9A%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9A%84%E5%BA%93%E3%80%81%E8%A1%A8%E7%9A%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; describe t1; #查看表结构，可简写为：desc 表名+-------+-----------------------+------+-----+---------+-------+| Field | Type                  | Null | Key | Default | Extra |+-------+-----------------------+------+-----+---------+-------+| id    | int(11)               | YES  |     | NULL    |       || name  | varchar(50)           | YES  |     | NULL    |       || sex   | enum('male','female') | YES  |     | NULL    |       || age   | int(3)                | YES  |     | NULL    |       |+-------+-----------------------+------+-----+---------+-------+mysql&gt; show create table t1\G; #查看表详细结构，可加\G</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　<strong>5、MySQL的基础数据类型</strong></p><p> 　　　　关于数据类型，看我这篇博客：<a href="https://www.cnblogs.com/clschao/articles/9959559.html">https://www.cnblogs.com/clschao/articles/9959559.html</a></p><p> 　　<strong>6、表的完整性约束</strong></p><p> 　　　　关于表的完整性约束，看我这篇博客：<a href="https://www.cnblogs.com/clschao/articles/9968396.html">https://www.cnblogs.com/clschao/articles/9968396.html</a></p><p>　　　　 </p><p>　　 <strong>7、修改表 alter table</strong></p><p>　　　　下面的内容就不带着大家演示了，简单带大家看一下，都是固定的语法格式，按照这个写就行了，毫无逻辑可言，所以不做太多的演示，大家自己回去练一下：</p><p>　　　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>语法：1. 修改表名      ALTER TABLE 表名                           RENAME 新表名;2. 增加字段      ALTER TABLE 表名                          ADD 字段名  数据类型 [完整性约束条件…], #注意这里可以通过逗号来分割，一下添加多个约束条件                          ADD 字段名  数据类型 [完整性约束条件…];      ALTER TABLE 表名                          ADD 字段名  数据类型 [完整性约束条件…]  FIRST; #添加这个字段的时候，把它放到第一个字段位置去。      ALTER TABLE 表名                          ADD 字段名  数据类型 [完整性约束条件…]  AFTER 字段名;#after是放到后的这个字段的后面去了，我们通过一个first和一个after就可以将新添加的字段放到表的任意字段位置了。3. 删除字段      ALTER TABLE 表名                           DROP 字段名;4. 修改字段      ALTER TABLE 表名                           MODIFY  字段名 数据类型 [完整性约束条件…];      ALTER TABLE 表名                           CHANGE 旧字段名 新字段名 旧数据类型 [完整性约束条件…];  #change比modify还多了个改名字的功能，这一句是只改了一个字段名      ALTER TABLE 表名                           CHANGE 旧字段名 新字段名 新数据类型 [完整性约束条件…];#这一句除了改了字段名，还改了数据类型、完整性约束等等的内容</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　给一个字段添加外键属性的语句：alter table 表2名 add foreign key(表2的一个字段) references 表1名(表1的一个字段);</p><p>　　　　注意一点：在mysql里面表名是不区分大小写的，如果你将一个名为t1的(小写的t1)改名为一个T1（大写的T1），是完全没用的，因为在数据库里面表名都是小写的。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>示例：1. 修改存储引擎mysql&gt; alter table service     -&gt; engine=innodb;2. 添加字段mysql&gt; alter table student10    -&gt; add name varchar(20) not null,    -&gt; add age int(3) not null default 22;mysql&gt; alter table student10    -&gt; add stu_num varchar(10) not null after name;                //添加name字段之后mysql&gt; alter table student10                            -&gt; add sex enum('male','female') default 'male' first;          //添加到最前面3. 删除字段mysql&gt; alter table student10    -&gt; drop sex;mysql&gt; alter table service    -&gt; drop mac;4. 修改字段类型modifymysql&gt; alter table student10    -&gt; modify age int(3);mysql&gt; alter table student10    -&gt; modify id int(11) not null primary key auto_increment;    //修改为主键5. 增加约束（针对已有的主键增加auto_increment）mysql&gt; alter table student10 modify id int(11) not null primary key auto_increment;ERROR 1068 (42000): Multiple primary key definedmysql&gt; alter table student10 modify id int(11) not null auto_increment;Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 06. 对已经存在的表增加复合主键mysql&gt; alter table service2    -&gt; add primary key(host_ip,port);        7. 增加主键mysql&gt; alter table student1    -&gt; modify name varchar(10) not null primary key;8. 增加主键和自动增长mysql&gt; alter table student1    -&gt; modify id int not null primary key auto_increment;9. 删除主键a. 删除自增约束mysql&gt; alter table student10 modify id int(11) not null; b. 删除主键mysql&gt; alter table student10                                     -&gt; drop primary key;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120205153137-615200525.png" alt="img"></p><p> 　　 <strong>8、复制表</strong></p><p> 　　　　</p><p>　　　　我们通过select查询出来的结果既有表结构又有表记录(数据)，我们在重新创建一个和它一样的表的时候，之前用create还需要自己将表结构写好，然后把那些数据插入到新建的表中，很麻烦，那么我们就可以直接使用mysql提供的复制表的功能：（复制表用的很少昂，了解一下就行了）</p><p>　　　　语法：复制表结构＋记录 （key不会复制: 主键、外键和索引）<br>　　　　mysql&gt; create table new_service select * from service;#这句话的意思是你从service表里面查询出来的数据不要在屏幕上打印了，你直接给我的新表new_service</p><p>　　　　我们自己写个例子：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120210011714-355486838.png" alt="img"></p><p> 　　　　　　虽然我们不能复制key，但是我们可以给他加回去啊：alter table xxx</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120210238280-1001004050.png" alt="img"></p><p>　　　　只复制表结构，不要数据<br>　　　　mysql&gt; select * from service where 1=2; //条件为假，查不到任何记录，所以我们可以通过它来只复制表结构，看下面一句<br>　　　　Empty set (0.00 sec)<br>　　　　mysql&gt; create table new1_service select * from service where 1=2;  #筛选数据的条件为假，那么只拿到了结构，并没有查询出任何的数据，所以做到了只复制表结构<br>　　　　Query OK, 0 rows affected (0.00 sec)<br>　　　　Records: 0 Duplicates: 0 Warnings: 0</p><p>　　　　mysql&gt; create table t4 like employees; #获取用like可以达到这个效果</p><p>再有时间，大家可以预习一下我后面的博客，关于行（数据行\记录）的操作。博客是： </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的逻辑查询语句的执行顺序</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9A%84%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9A%84%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9995517.html#_label1">一 SELECT语句关键字的定义顺序</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9995517.html#_label2">二 SELECT语句关键字的执行顺序</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9995517.html#_label3">三 准备表和数据</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9995517.html#_label4">四 准备SQL逻辑查询测试语句</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9995517.html#_label5">五 执行顺序分析</a></li></ul><h3 id="一-SELECT语句关键字的定义顺序"><a href="#一-SELECT语句关键字的定义顺序" class="headerlink" title="一 SELECT语句关键字的定义顺序"></a>一 SELECT语句关键字的定义顺序</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>SELECT DISTINCT &lt;select_list&gt;FROM &lt;left_table&gt;&lt;join_type&gt; JOIN &lt;right_table&gt;ON &lt;join_condition&gt;WHERE &lt;where_condition&gt;GROUP BY &lt;group_by_list&gt;HAVING &lt;having_condition&gt;ORDER BY &lt;order_by_condition&gt;LIMIT &lt;limit_number&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="二-SELECT语句关键字的执行顺序"><a href="#二-SELECT语句关键字的执行顺序" class="headerlink" title="二 SELECT语句关键字的执行顺序"></a>二 SELECT语句关键字的执行顺序</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>(7)     SELECT (8)     DISTINCT &lt;select_list&gt;(1)     FROM &lt;left_table&gt;(3)     &lt;join_type&gt; JOIN &lt;right_table&gt;(2)     ON &lt;join_condition&gt;(4)     WHERE &lt;where_condition&gt;(5)     GROUP BY &lt;group_by_list&gt;(6)     HAVING &lt;having_condition&gt;(9)     ORDER BY &lt;order_by_condition&gt;(10)    LIMIT &lt;limit_number&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="三-准备表和数据"><a href="#三-准备表和数据" class="headerlink" title="三 准备表和数据"></a>三 准备表和数据</h3><p>\1. 新建一个测试数据库TestDB；</p><pre><code>create database TestDB;</code></pre><p>2.创建测试表table1和table2；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>CREATE TABLE table1 (     customer_id VARCHAR(10) NOT NULL,     city VARCHAR(10) NOT NULL,     PRIMARY KEY(customer_id) )ENGINE=INNODB DEFAULT CHARSET=UTF8; CREATE TABLE table2 (     order_id INT NOT NULL auto_increment,     customer_id VARCHAR(10),     PRIMARY KEY(order_id) )ENGINE=INNODB DEFAULT CHARSET=UTF8;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>3.插入测试数据；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code> INSERT INTO table1(customer_id,city) VALUES('163','hangzhou'); INSERT INTO table1(customer_id,city) VALUES('9you','shanghai'); INSERT INTO table1(customer_id,city) VALUES('tx','hangzhou'); INSERT INTO table1(customer_id,city) VALUES('baidu','hangzhou'); INSERT INTO table2(customer_id) VALUES('163'); INSERT INTO table2(customer_id) VALUES('163'); INSERT INTO table2(customer_id) VALUES('9you'); INSERT INTO table2(customer_id) VALUES('9you'); INSERT INTO table2(customer_id) VALUES('9you'); INSERT INTO table2(customer_id) VALUES('tx'); INSERT INTO table2(customer_id) VALUES(NULL);</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>准备工作做完以后，table1和table2看起来应该像下面这样：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>mysql&gt; select * from table1; +-------------+----------+ | customer_id | city     | +-------------+----------+ | 163         | hangzhou | | 9you        | shanghai | | baidu       | hangzhou | | tx          | hangzhou | +-------------+----------+ 4 rows in set (0.00 sec) mysql&gt; select * from table2; +----------+-------------+ | order_id | customer_id | +----------+-------------+ |        1 | 163         | |        2 | 163         | |        3 | 9you        | |        4 | 9you        | |        5 | 9you        | |        6 | tx          | |        7 | NULL        | +----------+-------------+ 7 rows in set (0.00 sec)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="四-准备SQL逻辑查询测试语句"><a href="#四-准备SQL逻辑查询测试语句" class="headerlink" title="四 准备SQL逻辑查询测试语句"></a>四 准备SQL逻辑查询测试语句</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>#查询来自杭州，并且订单数少于2的客户。 SELECT a.customer_id, COUNT(b.order_id) as total_orders FROM table1 AS a LEFT JOIN table2 AS b ON a.customer_id = b.customer_id WHERE a.city = 'hangzhou' GROUP BY a.customer_id HAVING count(b.order_id) &lt; 2 ORDER BY total_orders DESC;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="五-执行顺序分析"><a href="#五-执行顺序分析" class="headerlink" title="五 执行顺序分析"></a>五 执行顺序分析</h3><p>在这些SQL语句的执行过程中，都会产生一个虚拟表，用来保存SQL语句的执行结果（这是重点），我现在就来跟踪这个虚拟表的变化，得到最终的查询结果的过程，来分析整个SQL逻辑查询的执行顺序和过程。</p><p><strong>执行FROM语句</strong></p><p><em>第一步，执行FROM语句。我们首先需要知道最开始从哪个表开始的，这就是FROM告诉我们的。现在有了<left_table>和<right_table>两个表，我们到底从哪个表开始，还是从两个表进行某种联系以后再开始呢？它们之间如何产生联系呢？——笛卡尔积</right_table></left_table></em></p><p><em>关于什么是笛卡尔积，请自行Google补脑。经过FROM语句对两个表执行笛卡尔积，会得到一个虚拟表，暂且叫VT1（vitual table 1），内容如下：</em></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>+-------------+----------+----------+-------------+| customer_id | city     | order_id | customer_id |+-------------+----------+----------+-------------+| 163         | hangzhou |        1 | 163         || 9you        | shanghai |        1 | 163         || baidu       | hangzhou |        1 | 163         || tx          | hangzhou |        1 | 163         || 163         | hangzhou |        2 | 163         || 9you        | shanghai |        2 | 163         || baidu       | hangzhou |        2 | 163         || tx          | hangzhou |        2 | 163         || 163         | hangzhou |        3 | 9you        || 9you        | shanghai |        3 | 9you        || baidu       | hangzhou |        3 | 9you        || tx          | hangzhou |        3 | 9you        || 163         | hangzhou |        4 | 9you        || 9you        | shanghai |        4 | 9you        || baidu       | hangzhou |        4 | 9you        || tx          | hangzhou |        4 | 9you        || 163         | hangzhou |        5 | 9you        || 9you        | shanghai |        5 | 9you        || baidu       | hangzhou |        5 | 9you        || tx          | hangzhou |        5 | 9you        || 163         | hangzhou |        6 | tx          || 9you        | shanghai |        6 | tx          || baidu       | hangzhou |        6 | tx          || tx          | hangzhou |        6 | tx          || 163         | hangzhou |        7 | NULL        || 9you        | shanghai |        7 | NULL        || baidu       | hangzhou |        7 | NULL        || tx          | hangzhou |        7 | NULL        |+-------------+----------+----------+-------------+</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><em>总共有28（table1的记录条数 \</em> table2的记录条数）条记录。这就是VT1的结果，接下来的操作就在VT1的基础上进行。*</p><p><strong>执行ON过滤</strong></p><p><em>执行完笛卡尔积以后，接着就进行ON a.customer_id = b.customer_id条件过滤，根据ON中指定的条件，去掉那些不符合条件的数据，得到VT2表，内容如下：</em></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>+-------------+----------+----------+-------------+| customer_id | city     | order_id | customer_id |+-------------+----------+----------+-------------+| 163         | hangzhou |        1 | 163         || 163         | hangzhou |        2 | 163         || 9you        | shanghai |        3 | 9you        || 9you        | shanghai |        4 | 9you        || 9you        | shanghai |        5 | 9you        || tx          | hangzhou |        6 | tx          |+-------------+----------+----------+-------------+</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><em>VT2就是经过ON条件筛选以后得到的有用数据，而接下来的操作将在VT2的基础上继续进行。</em></p><p><strong>添加外部行</strong></p><p><em>这一步只有在连接类型为OUTER JOIN时才发生，如LEFT OUTER JOIN、RIGHT OUTER JOIN和FULL OUTER JOIN。在大多数的时候，我们都是会省略掉OUTER关键字的，但OUTER表示的就是外部行的概念。</em></p><p><em>LEFT OUTER JOIN把左表记为保留表，得到的结果为：</em></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>+-------------+----------+----------+-------------+| customer_id | city     | order_id | customer_id |+-------------+----------+----------+-------------+| 163         | hangzhou |        1 | 163         || 163         | hangzhou |        2 | 163         || 9you        | shanghai |        3 | 9you        || 9you        | shanghai |        4 | 9you        || 9you        | shanghai |        5 | 9you        || tx          | hangzhou |        6 | tx          || baidu       | hangzhou |     NULL | NULL        |+-------------+----------+----------+-------------+</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><em>RIGHT OUTER JOIN把右表记为保留表，得到的结果为：</em></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>+-------------+----------+----------+-------------+| customer_id | city     | order_id | customer_id |+-------------+----------+----------+-------------+| 163         | hangzhou |        1 | 163         || 163         | hangzhou |        2 | 163         || 9you        | shanghai |        3 | 9you        || 9you        | shanghai |        4 | 9you        || 9you        | shanghai |        5 | 9you        || tx          | hangzhou |        6 | tx          || NULL        | NULL     |        7 | NULL        |+-------------+----------+----------+-------------+</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><em>FULL OUTER JOIN把左右表都作为保留表，得到的结果为：</em></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>+-------------+----------+----------+-------------+| customer_id | city     | order_id | customer_id |+-------------+----------+----------+-------------+| 163         | hangzhou |        1 | 163         || 163         | hangzhou |        2 | 163         || 9you        | shanghai |        3 | 9you        || 9you        | shanghai |        4 | 9you        || 9you        | shanghai |        5 | 9you        || tx          | hangzhou |        6 | tx          || baidu       | hangzhou |     NULL | NULL        || NULL        | NULL     |        7 | NULL        |+-------------+----------+----------+-------------+</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><em>添加外部行的工作就是在VT2表的基础上添加保留表中被过滤条件过滤掉的数据，非保留表中的数据被赋予NULL值，最后生成虚拟表VT3。</em></p><p><em>由于我在准备的测试SQL查询逻辑语句中使用的是LEFT JOIN，过滤掉了以下这条数据：</em></p><pre><code>| baidu       | hangzhou |     NULL | NULL        |</code></pre><p>现在就把这条数据添加到VT2表中，得到的VT3表如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>+-------------+----------+----------+-------------+| customer_id | city     | order_id | customer_id |+-------------+----------+----------+-------------+| 163         | hangzhou |        1 | 163         || 163         | hangzhou |        2 | 163         || 9you        | shanghai |        3 | 9you        || 9you        | shanghai |        4 | 9you        || 9you        | shanghai |        5 | 9you        || tx          | hangzhou |        6 | tx          || baidu       | hangzhou |     NULL | NULL        |+-------------+----------+----------+-------------+</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><em>接下来的操作都会在该VT3表上进行。</em></p><p><strong>执行WHERE过滤</strong></p><p><em>对添加外部行得到的VT3进行WHERE过滤，只有符合<where_condition>的记录才会输出到虚拟表VT4中。当我们执行WHERE a.city = ‘hangzhou’的时候，就会得到以下内容，并存在虚拟表VT4中：</where_condition></em></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>+-------------+----------+----------+-------------+| customer_id | city     | order_id | customer_id |+-------------+----------+----------+-------------+| 163         | hangzhou |        1 | 163         || 163         | hangzhou |        2 | 163         || tx          | hangzhou |        6 | tx          || baidu       | hangzhou |     NULL | NULL        |+-------------+----------+----------+-------------+</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>但是在使用WHERE子句时，需要注意以下两点：</p><ol><li>由于数据还没有分组，因此现在还不能在WHERE过滤器中使用<code>where_condition=MIN(col)</code>这类对分组统计的过滤；</li><li>由于还没有进行列的选取操作，因此在SELECT中使用列的别名也是不被允许的，如：<code>SELECT city as c FROM t WHERE c='shanghai';</code>是不允许出现的。</li></ol><p><strong>执行GROUP BY分组</strong></p><p><em>GROU BY子句主要是对使用WHERE子句得到的虚拟表进行分组操作。我们执行测试语句中的GROUP BY a.customer_id，就会得到以下内容(默认只显示组内第一条)：</em></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>+-------------+----------+----------+-------------+| customer_id | city     | order_id | customer_id |+-------------+----------+----------+-------------+| 163         | hangzhou |        1 | 163         || baidu       | hangzhou |     NULL | NULL        || tx          | hangzhou |        6 | tx          |+-------------+----------+----------+-------------+</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><em>得到的内容会存入虚拟表VT5中，此时，我们就得到了一个VT5虚拟表，接下来的操作都会在该表上完成。</em></p><p><strong>执行HAVING过滤</strong></p><p><em>HAVING子句主要和GROUP BY子句配合使用，对分组得到的VT5虚拟表进行条件过滤。当我执行测试语句中的HAVING count(b.order_id) &lt; 2时，将得到以下内容：</em></p><pre><code>+-------------+----------+----------+-------------+| customer_id | city     | order_id | customer_id |+-------------+----------+----------+-------------+| baidu       | hangzhou |     NULL | NULL        || tx          | hangzhou |        6 | tx          |+-------------+----------+----------+-------------+</code></pre><p><em>这就是虚拟表VT6。</em></p><p><strong>SELECT列表</strong></p><p><em>现在才会执行到SELECT子句，不要以为SELECT子句被写在第一行，就是第一个被执行的。</em></p><p><em>我们执行测试语句中的SELECT a.customer_id, COUNT(b.order_id) as total_orders，从虚拟表VT6中选择出我们需要的内容。我们将得到以下内容：</em></p><pre><code>+-------------+--------------+| customer_id | total_orders |+-------------+--------------+| baidu       |            0 || tx          |            1 |+-------------+--------------+</code></pre><p><em>还没有完，这只是虚拟表VT7。</em></p><p><strong>执行DISTINCT子句</strong></p><p><em>如果在查询中指定了DISTINCT子句，则会创建一张内存临时表（如果内存放不下，就需要存放在硬盘了）。这张临时表的表结构和上一步产生的虚拟表VT7是一样的，不同的是对进行DISTINCT操作的列增加了一个唯一索引，以此来除重复数据。</em></p><p><em>由于我的测试SQL语句中并没有使用DISTINCT，所以，在该查询中，这一步不会生成一个虚拟表。</em></p><p><strong>执行ORDER BY子句</strong></p><p><em>对虚拟表中的内容按照指定的列进行排序，然后返回一个新的虚拟表，我们执行测试SQL语句中的ORDER BY total_orders DESC，就会得到以下内容：</em></p><pre><code>+-------------+--------------+| customer_id | total_orders |+-------------+--------------+| tx          |            1 || baidu       |            0 |+-------------+--------------+</code></pre><p><em>可以看到这是对total_orders列进行降序排列的。上述结果会存储在VT8中。</em></p><p><strong>执行LIMIT子句</strong></p><p><em>LIMIT子句从上一步得到的VT8虚拟表中选出从指定位置开始的指定行数据。对于没有应用ORDER BY的LIMIT子句，得到的结果同样是无序的，所以，很多时候，我们都会看到LIMIT子句会和ORDER BY子句一起使用。</em></p><p><em>MySQL数据库的LIMIT支持如下形式的选择：</em></p><pre><code>LIMIT n, m</code></pre><p><em>表示从第n条记录开始选择m条记录。而很多开发人员喜欢使用该语句来解决分页问题。对于小数据，使用LIMIT子句没有任何问题，当数据量非常大的时候，使用LIMIT n, m是非常低效的。因为LIMIT的机制是每次都是从头开始扫描，如果需要从第60万行开始，读取3条数据，就需要先扫描定位到60万行，然后再进行读取，而扫描的过程是一个非常低效的过程。所以，对于大数据处理时，是非常有必要在应用层建立一定的缓存机制（现在的大数据处理，大都使用缓存）</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL行(记录)的详细操作</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E8%A1%8C(%E8%AE%B0%E5%BD%95)%E7%9A%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E8%A1%8C(%E8%AE%B0%E5%BD%95)%E7%9A%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9991911.html#_label1">一 介绍</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9991911.html#_label2">二 插入数据INSERT</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9991911.html#_label3">三 更新数据UPDATE</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9991911.html#_label4">四 删除数据DELETE</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9991911.html#_label5">五 查询数据SELECT</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9991911.html#_label6">六 权限管理</a></li></ul><h1 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一 介绍"></a>一 介绍</h1><p>　　MySQL数据操作： DML</p><p>　　========================================================</p><p>　　在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括</p><ol><li><em>使用INSERT实现数据的插入</em></li><li><em>UPDATE实现数据的更新</em></li><li><em>使用DELETE实现数据的删除</em></li><li><em>使用SELECT查询数据以及。</em></li></ol><p>　　<em>========================================================</em></p><p>　　本节内容包括：</p><p>　　　　插入数据<br>　　　　更新数据<br>　　　　删除数据<br>　　　　查询数据</p><h1 id="二-插入（增加）数据INSERT"><a href="#二-插入（增加）数据INSERT" class="headerlink" title="二 插入（增加）数据INSERT"></a>二 插入（增加）数据INSERT</h1><p>　　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>1. 插入完整数据（顺序插入）    语法一：    INSERT INTO 表名(字段1,字段2,字段3…字段n) VALUES(值1,值2,值3…值n); #指定字段来插入数据，插入的值要和你前面的字段相匹配    语法二：    INSERT INTO 表名 VALUES (值1,值2,值3…值n); #不指定字段的话，就按照默认的几个字段来插入数据2. 指定字段插入数据    语法：    INSERT INTO 表名(字段1,字段2,字段3…) VALUES (值1,值2,值3…);3. 插入多条记录    语法：#插入多条记录用逗号来分隔    INSERT INTO 表名 VALUES        (值1,值2,值3…值n),        (值1,值2,值3…值n),        (值1,值2,值3…值n);4. 插入查询结果    语法：    INSERT INTO 表名(字段1,字段2,字段3…字段n)                     SELECT (字段1,字段2,字段3…字段n) FROM 表2                    WHERE …; #将从表2里面查询出来的结果来插入到我们的表中，但是注意查询出来的数据要和我们前面指定的字段要对应好</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="三-更新（修改）数据UPDATE"><a href="#三-更新（修改）数据UPDATE" class="headerlink" title="三 更新（修改）数据UPDATE"></a>三 更新（修改）数据UPDATE</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>语法：    UPDATE 表名 SET         字段1=值1,  #注意语法，可以同时来修改多个值，用逗号分隔        字段2=值2,        WHERE CONDITION; #更改哪些数据，通过where条件来定位到符合条件的数据示例：    UPDATE mysql.user SET password=password(‘123’)         where user=’root’ and host=’localhost’; #这句话是对myslq这个库中的user表中的user字段为'root'并且host字段为'localhost'的这条记录的password字段的数据进行修改，将passord字段的那个数据改为password('123')这个方法对123加工后的密码数据，password()这个方法是mysql提供的密码进行加密用的方法。        定位到某个记录，并把这个记录中的某项内容更改掉</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="四-删除数据DELETE"><a href="#四-删除数据DELETE" class="headerlink" title="四 删除数据DELETE"></a>四 删除数据DELETE</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>语法：    DELETE FROM 表名         WHERE CONITION; #删除符合条件的一些记录    DELETE FROM 表名；如果不加where条件，意思是将表里面所有的内容都删掉，但是清空所有的内容，一般我们用truncate ，能够将id置为零，delete不能将id置零，再插入数据的时候，会按照之前的数据记录的id数继续递增示例：    DELETE FROM mysql.user         WHERE password=’123’;练习：    更新MySQL root用户密码为mysql123    删除除从本地登录的root用户以外的所有用户</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="五-查询数据SELECT（重点）"><a href="#五-查询数据SELECT（重点）" class="headerlink" title="五 查询数据SELECT（重点）"></a>五 查询数据SELECT（重点）</h1><p>　　我们在工作中，多数的场景都是对数据的增删改操作少，读数据的操作多，所以我们的重点就在读取数据这里了。</p><p>　　之前我们说，我们是不是将数据分到多个表中进行保存，而不是将所有的数据都放到一个表里面，例如我们前面所说的部门表和员工表，员工的信息放到一个表里面，部门的信息放到一个部门表里面。</p><p>　　虽然我们把数据分到了不同的表里面，但是这些数据是不是属于我们同一个项目的，也就是说，你将来查询数据的时候，可能不单单的从一张表里面来查询数据，可能涉及到一下查询出来多个表中的数据，也就是多表关联查询，对不对，那么我们先来把单表查询学习一下，再来进行多表查询的学习，看下面两个博客：</p><p>​     <strong>单表查询：<a href="https://www.cnblogs.com/clschao/articles/9995531.html">https://www.cnblogs.com/clschao/articles/9995531.html</a></strong></p><p>​     <strong>多表查询：<a href="https://www.cnblogs.com/clschao/articles/9995815.html">https://www.cnblogs.com/clschao/articles/9995815.html</a></strong></p><h3 id="六-权限管理"><a href="#六-权限管理" class="headerlink" title="六 权限管理"></a>六 权限管理</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20171124164857437-1802110131.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>#授权表user #该表放行的权限，针对：所有数据，所有库下所有表，以及表下的所有字段db #该表放行的权限，针对：某一数据库，该数据库下的所有表，以及表下的所有字段tables_priv #该表放行的权限。针对：某一张表，以及该表下的所有字段columns_priv #该表放行的权限，针对：某一个字段#按图解释：user：放行db1，db2及其包含的所有db：放行db1，及其db1包含的所有tables_priv:放行db1.table1，及其该表包含的所有columns_prive:放行db1.table1.column1，只放行该字段</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>#创建用户create user 'egon'@'1.1.1.1' identified by '123';create user 'egon'@'192.168.1.%' identified by '123';create user 'egon'@'%' identified by '123';#授权：对文件夹，对文件，对文件某一字段的权限查看帮助：help grant常用权限有：select,update,alter,deleteall可以代表除了grant之外的所有权限#针对所有库的授权:*.*grant select on *.* to 'egon1'@'localhost' identified by '123'; #只在user表中可以查到egon1用户的select权限被设置为Y#针对某一数据库：db1.*grant select on db1.* to 'egon2'@'%' identified by '123'; #只在db表中可以查到egon2用户的select权限被设置为Y#针对某一个表：db1.t1grant select on db1.t1 to 'egon3'@'%' identified by '123';  #只在tables_priv表中可以查到egon3用户的select权限#针对某一个字段：mysql&gt; select * from t3;+------+-------+------+| id   | name  | age  |+------+-------+------+|    1 | egon1 |   18 ||    2 | egon2 |   19 ||    3 | egon3 |   29 |+------+-------+------+grant select (id,name),update (age) on db1.t3 to 'egon4'@'localhost' identified by '123'; #可以在tables_priv和columns_priv中看到相应的权限mysql&gt; select * from tables_priv where user='egon4'\G*************************** 1. row ***************************       Host: localhost         Db: db1       User: egon4 Table_name: t3    Grantor: root@localhost  Timestamp: 0000-00-00 00:00:00 Table_priv:Column_priv: Select,Updaterow in set (0.00 sec)mysql&gt; select * from columns_priv where user='egon4'\G*************************** 1. row ***************************       Host: localhost         Db: db1       User: egon4 Table_name: t3Column_name: id  Timestamp: 0000-00-00 00:00:00Column_priv: Select*************************** 2. row ***************************       Host: localhost         Db: db1       User: egon4 Table_name: t3Column_name: name  Timestamp: 0000-00-00 00:00:00Column_priv: Select*************************** 3. row ***************************       Host: localhost         Db: db1       User: egon4 Table_name: t3Column_name: age  Timestamp: 0000-00-00 00:00:00Column_priv: Updaterows in set (0.00 sec)#删除权限revoke select on db1.* from 'egon'@'%';</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="https://www.cnblogs.com/clschao/articles/9991911.html#top">回到顶部</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL练习题及答案</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%BB%83%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%BB%83%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9995776.html#_label1">一 题目</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9995776.html#_label2">二 答案</a></li></ul><h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一 题目"></a>一 题目</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>1、查询所有的课程的名称以及对应的任课老师姓名2、查询学生表中男女生各有多少人3、查询物理成绩等于100的学生的姓名4、查询平均成绩大于八十分的同学的姓名和平均成绩5、查询所有学生的学号，姓名，选课数，总成绩6、 查询姓李老师的个数7、 查询没有报李平老师课的学生姓名8、 查询物理课程比生物课程高的学生的学号9、 查询没有同时选修物理课程和体育课程的学生姓名10、查询挂科超过两门(包括两门)的学生姓名和班级、查询选修了所有课程的学生姓名12、查询李平老师教的课程的所有成绩记录13、查询全部学生都选修了的课程号和课程名14、查询每门课程被选修的次数15、查询之选修了一门课程的学生姓名和学号16、查询所有学生考出的成绩并按从高到低排序（成绩去重）17、查询平均成绩大于85的学生姓名和平均成绩18、查询生物成绩不及格的学生姓名和对应生物分数19、查询在所有选修了李平老师课程的学生中，这些课程(李平老师的课程，不是所有课程)平均成绩最高的学生姓名20、查询每门课程成绩最好的前两名学生姓名21、查询不同课程但成绩相同的学号，课程号，成绩22、查询没学过“叶平”老师课程的学生姓名以及选修的课程名称；23、查询所有选修了学号为1的同学选修过的一门或者多门课程的同学学号和姓名；24、任课最多的老师中学生单科成绩最高的学生姓名</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="二-答案"><a href="#二-答案" class="headerlink" title="二 答案"></a>二 答案</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>#1、查询所有的课程的名称以及对应的任课老师姓名SELECT    course.cname,    teacher.tnameFROM    courseINNER JOIN teacher ON course.teacher_id = teacher.tid;#2、查询学生表中男女生各有多少人SELECT    gender 性别,    count(1) 人数FROM    studentGROUP BY    gender;#3、查询物理成绩等于100的学生的姓名SELECT    student.snameFROM    studentWHERE    sid IN (        SELECT            student_id        FROM            score        INNER JOIN course ON score.course_id = course.cid        WHERE            course.cname = '物理'        AND score.num = 100    );#4、查询平均成绩大于八十分的同学的姓名和平均成绩SELECT    student.sname,    t1.avg_numFROM    studentINNER JOIN (    SELECT        student_id,        avg(num) AS avg_num    FROM        score    GROUP BY        student_id    HAVING        avg(num) &gt; 80) AS t1 ON student.sid = t1.student_id;#5、查询所有学生的学号，姓名，选课数，总成绩(注意：对于那些没有选修任何课程的学生也算在内)SELECT    student.sid,    student.sname,    t1.course_num,    t1.total_numFROM    studentLEFT JOIN (    SELECT        student_id,        COUNT(course_id) course_num,        sum(num) total_num    FROM        score    GROUP BY        student_id) AS t1 ON student.sid = t1.student_id;#6、 查询姓李老师的个数SELECT    count(tid)FROM    teacherWHERE    tname LIKE '李%';#7、 查询没有报李平老师课的学生姓名(找出报名李平老师课程的学生，然后取反就可以)SELECT    student.snameFROM    studentWHERE    sid NOT IN (        SELECT DISTINCT            student_id        FROM            score        WHERE            course_id IN (                SELECT                    course.cid                FROM                    course                INNER JOIN teacher ON course.teacher_id = teacher.tid                WHERE                    teacher.tname = '李平老师'            )    );#8、 查询物理课程比生物课程高的学生的学号(分别得到物理成绩表与生物成绩表，然后连表即可)SELECT    t1.student_idFROM    (        SELECT            student_id,            num        FROM            score        WHERE            course_id = (                SELECT                    cid                FROM                    course                WHERE                    cname = '物理'            )    ) AS t1INNER JOIN (    SELECT        student_id,        num    FROM        score    WHERE        course_id = (            SELECT                cid            FROM                course            WHERE                cname = '生物'        )) AS t2 ON t1.student_id = t2.student_idWHERE    t1.num &gt; t2.num;#9、 查询没有同时选修物理课程和体育课程的学生姓名(没有同时选修指的是选修了一门的，思路是得到物理+体育课程的学生信息表，然后基于学生分组，统计count(课程)=1)SELECT    student.snameFROM    studentWHERE    sid IN (        SELECT            student_id        FROM            score        WHERE            course_id IN (                SELECT                    cid                FROM                    course                WHERE                    cname = '物理'                OR cname = '体育'            )        GROUP BY            student_id        HAVING            COUNT(course_id) = 1    );#10、查询挂科超过两门(包括两门)的学生姓名和班级(求出&lt;60的表，然后对学生进行分组，统计课程数目&gt;=2)SELECT    student.sname,    class.captionFROM    studentINNER JOIN (    SELECT        student_id    FROM        score    WHERE        num &lt; 60    GROUP BY        student_id    HAVING        count(course_id) &gt;= 2) AS t1INNER JOIN class ON student.sid = t1.student_idAND student.class_id = class.cid;#11、查询选修了所有课程的学生姓名(先从course表统计课程的总数，然后基于score表按照student_id分组，统计课程数据等于课程总数即可)SELECT    student.snameFROM    studentWHERE    sid IN (        SELECT            student_id        FROM            score        GROUP BY            student_id        HAVING            COUNT(course_id) = (SELECT count(cid) FROM course)    );#12、查询李平老师教的课程的所有成绩记录SELECT    *FROM    scoreWHERE    course_id IN (        SELECT            cid        FROM            course        INNER JOIN teacher ON course.teacher_id = teacher.tid        WHERE            teacher.tname = '李平老师'    );#13、查询全部学生都选修了的课程号和课程名(取所有学生数，然后基于score表的课程分组，找出count(student_id)等于学生数即可)SELECT    cid,    cnameFROM    courseWHERE    cid IN (        SELECT            course_id        FROM            score        GROUP BY            course_id        HAVING            COUNT(student_id) = (                SELECT                    COUNT(sid)                FROM                    student            )    );#14、查询每门课程被选修的次数SELECT    course_id,    COUNT(student_id)FROM    scoreGROUP BY    course_id;#15、查询之选修了一门课程的学生姓名和学号SELECT    sid,    snameFROM    studentWHERE    sid IN (        SELECT            student_id        FROM            score        GROUP BY            student_id        HAVING            COUNT(course_id) = 1    );#16、查询所有学生考出的成绩并按从高到低排序（成绩去重）SELECT DISTINCT    numFROM    scoreORDER BY    num DESC;#17、查询平均成绩大于85的学生姓名和平均成绩SELECT    sname,    t1.avg_numFROM    studentINNER JOIN (    SELECT        student_id,        avg(num) avg_num    FROM        score    GROUP BY        student_id    HAVING        AVG(num) &gt; 85) t1 ON student.sid = t1.student_id;#18、查询生物成绩不及格的学生姓名和对应生物分数SELECT    sname 姓名,    num 生物成绩FROM    scoreLEFT JOIN course ON score.course_id = course.cidLEFT JOIN student ON score.student_id = student.sidWHERE    course.cname = '生物'AND score.num &lt; 60;#19、查询在所有选修了李平老师课程的学生中，这些课程(李平老师的课程，不是所有课程)平均成绩最高的学生姓名SELECT    snameFROM    studentWHERE    sid = (        SELECT            student_id        FROM            score        WHERE            course_id IN (                SELECT                    course.cid                FROM                    course                INNER JOIN teacher ON course.teacher_id = teacher.tid                WHERE                    teacher.tname = '李平老师'            )        GROUP BY            student_id        ORDER BY            AVG(num) DESC        LIMIT 1    );#20、查询每门课程成绩最好的前两名学生姓名#查看每门课程按照分数排序的信息，为下列查找正确与否提供依据SELECT    *FROM    scoreORDER BY    course_id,    num DESC;#表1：求出每门课程的课程course_id,与最高分数first_numSELECT    course_id,    max(num) first_numFROM    scoreGROUP BY    course_id;#表2：去掉最高分，再按照课程分组，取得的最高分，就是第二高的分数second_numSELECT    score.course_id,    max(num) second_numFROM    scoreINNER JOIN (    SELECT        course_id,        max(num) first_num    FROM        score    GROUP BY        course_id) AS t ON score.course_id = t.course_idWHERE    score.num &lt; t.first_numGROUP BY    course_id;#将表1和表2联合到一起，得到一张表t3，包含课程course_id与该们课程的first_num与second_numSELECT    t1.course_id,    t1.first_num,    t2.second_numFROM    (        SELECT            course_id,            max(num) first_num        FROM            score        GROUP BY            course_id    ) AS t1INNER JOIN (    SELECT        score.course_id,        max(num) second_num    FROM        score    INNER JOIN (        SELECT            course_id,            max(num) first_num        FROM            score        GROUP BY            course_id    ) AS t ON score.course_id = t.course_id    WHERE        score.num &lt; t.first_num    GROUP BY        course_id) AS t2 ON t1.course_id = t2.course_id;#查询前两名的学生（有可能出现并列第一或者并列第二的情况）SELECT    score.student_id,    t3.course_id,    t3.first_num,    t3.second_numFROM    scoreINNER JOIN (    SELECT        t1.course_id,        t1.first_num,        t2.second_num    FROM        (            SELECT                course_id,                max(num) first_num            FROM                score            GROUP BY                course_id        ) AS t1    INNER JOIN (        SELECT            score.course_id,            max(num) second_num        FROM            score        INNER JOIN (            SELECT                course_id,                max(num) first_num            FROM                score            GROUP BY                course_id        ) AS t ON score.course_id = t.course_id        WHERE            score.num &lt; t.first_num        GROUP BY            course_id    ) AS t2 ON t1.course_id = t2.course_id) AS t3 ON score.course_id = t3.course_idWHERE    score.num &gt;= t3.second_numAND score.num &lt;= t3.first_num;#排序后可以看的明显点SELECT    score.student_id,    t3.course_id,    t3.first_num,    t3.second_numFROM    scoreINNER JOIN (    SELECT        t1.course_id,        t1.first_num,        t2.second_num    FROM        (            SELECT                course_id,                max(num) first_num            FROM                score            GROUP BY                course_id        ) AS t1    INNER JOIN (        SELECT            score.course_id,            max(num) second_num        FROM            score        INNER JOIN (            SELECT                course_id,                max(num) first_num            FROM                score            GROUP BY                course_id        ) AS t ON score.course_id = t.course_id        WHERE            score.num &lt; t.first_num        GROUP BY            course_id    ) AS t2 ON t1.course_id = t2.course_id) AS t3 ON score.course_id = t3.course_idWHERE    score.num &gt;= t3.second_numAND score.num &lt;= t3.first_numORDER BY    course_id;#可以用以下命令验证上述查询的正确性SELECT    *FROM    scoreORDER BY    course_id,    num DESC;-- 21、查询不同课程但成绩相同的学号，课程号，成绩-- 22、查询没学过“叶平”老师课程的学生姓名以及选修的课程名称；-- 23、查询所有选修了学号为1的同学选修过的一门或者多门课程的同学学号和姓名；-- 24、任课最多的老师中学生单科成绩最高的学生姓名</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="https://www.cnblogs.com/clschao/articles/9995768.html">更多练习以及参考答案：https://www.cnblogs.com/clschao/articles/9995768.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据备份与还原(mysqldump)</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F(mysqldump)%20/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F(mysqldump)%20/</url>
      
        <content type="html"><![CDATA[<h2 id="一-mysqldump指令实现数据备份、mysql指令实现数据还原"><a href="#一-mysqldump指令实现数据备份、mysql指令实现数据还原" class="headerlink" title="一 mysqldump指令实现数据备份、mysql指令实现数据还原"></a>一 mysqldump指令实现数据备份、mysql指令实现数据还原</h2><p>　　经常有朋友问我，DBA到底是做什么的，百科上说：数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。DBA的核心目标是保证数据库管理系统的稳定性、安全性、完整性和高性能。 </p><p>　　百科出来的内容总是那么的专业，让人看完之后的感觉是很解释的很好，但是我没有看懂或者似懂非懂的模糊感。。哈哈，其实我认为，DBA主要做三件事情：1.保证公司的数据不丢失不损坏 2.提高数据库管理系统的工作性能</p><p>　　对于现在的公司来讲，数据变得尤为重要，可以说最重要，你的网站可以无法访问，服务器可以宕机，但是数据绝对不能丢，所以我们本节内容就冲着如果保护好数据而来的。本篇博客的内容并不是很深入，毕竟不是专业的DBA，只是作为超哥的讲课内容，让大家学一些数据备份的基本操作，入门级别咱们只讲一下mysqldump指令，至于如果做主从复制，双机热备，数据库高可用，数据库集群，大家可以去看我其他的博客，博客写完了，目前还在整理，整理好之后我就发出来供大家批评指正，共同学习<del>，因为毕竟咱们学的是开发，本篇内容就当作是拓展自己的知识领域吧，对你来讲都是很有好处的</del>大家加油吧</p><p>　　那么我们就来学一下mysqldump指令。</p><p>　　1.首先我们先创建一个名为crm2的库</p><p>　　　　mysql&gt; create database crm2;<br>　　　　mysql&gt; show create database crm2;<br>　　2.切换到crm2库下<br>　　　　mysql&gt; use crm2;<br>　　3.创建两张表，student表和class表<br>　　　　mysql&gt; create table tb1(id int primary key,name char(8) not null,age int,class_id int not null);<br>　　　　Query OK, 0 rows affected (0.63 sec)</p><p>　　　　mysql&gt; create table class(id int primary key,cname char(20) not null);<br>　　　　Query OK, 0 rows affected (0.34 sec)</p><p>　　4.给两张表插入一些数据</p><p>　　　　mysql&gt; insert into class values(1,’一班’),(2,’二班’);<br>　　　　mysql&gt; insert into student values(1,’Jaden’,18,1),(2,’太白’,45,1),(3,’彦涛’,30,2);</p><p>　　5.查看一下两个表的数据<br>　　　　mysql&gt; select * from student;<br>　　　　+—-+——–+——+———-+<br>　　　　| id | name | age | class_id |<br>　　　　+—-+——–+——+———-+<br>　　　　| 1 | Jaden | 18 | 1 |<br>　　　　| 2 | 太白 | 45 | 1 |<br>　　　　| 3 | 彦涛 | 30 | 2 |<br>　　　　+—-+——–+——+———-+<br>　　　　3 rows in set (0.00 sec)</p><p>　　　　mysql&gt; select * from class;<br>　　　　+—-+——–+<br>　　　　| id | cname |<br>　　　　+—-+——–+<br>　　　　| 1 | 一班 |<br>　　　　| 2 | 二班 |<br>　　　　+—-+——–+<br>　　　　2 rows in set (0.00 sec)</p><p>　　　　好，前期工作准备完毕，下面我们来通过mysqldump指令进行备份，在cmd窗口下执行下面的指令，注意不是进入mysql里面输入的，是在外面面。</p><p>　　　　C:\WINDOWS\system32&gt;mysqldump -h 127.0.0.1 -u root -p666 crm2 &gt; f:\数据库备份练习\crm2.sql<br>　　　　Warning: Using a password on the command line interface can be insecure. (这个提示是因为我把密码显示出来了，自己在自己电脑上测试的时候，这个警告可以忽略)</p><p>　　　　然后我们就会发现在这个’f:\数据库备份练习'路径下面就有了crm2.sql文件<br>　　　　然后我们通过nodepad++(随便一个文本编辑器都可以)，打开看看里面的内容：</p><p>　　　　– MySQL dump 10.13 Distrib 5.6.42, for Win64 (x86_64)<br>　　　　–<br>　　　　– Host: 127.0.0.1 Database: crm2<br>　　　　– ——————————————————<br>　　　　– Server version    5.6.42</p><p>　　　　/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT <em>/;<br>　　　　/</em>!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS <em>/;<br>　　　　/</em>!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION <em>/;<br>　　　　/</em>!40101 SET NAMES utf8 <em>/;<br>　　　　/</em>!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE <em>/;<br>　　　　/</em>!40103 SET TIME_ZONE=’+00:00’ <em>/;<br>　　　　/</em>!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 <em>/;<br>　　　　/</em>!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 <em>/;<br>　　　　/</em>!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=’NO_AUTO_VALUE_ON_ZERO’ <em>/;<br>　　　　/</em>!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</p><p>　　　　–<br>　　　　– Table structure for table <code>class</code><br>　　　　–</p><p>　　　　DROP TABLE IF EXISTS <code>class</code>; –如果之前存在class表，就将之前的class表删除<br>　　　　/*!40101 SET @saved_cs_client = @@character_set_client <em>/;<br>　　　　/</em>!40101 SET character_set_client = utf8 <em>/;<br>　　　　CREATE TABLE <code>class</code> ( –创建表<br>　　　　<code>id</code> int(11) NOT NULL,<br>　　　　<code>cname</code> char(20) NOT NULL,<br>　　　　PRIMARY KEY (<code>id</code>)<br>　　　　) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>　　　　/</em>!40101 SET character_set_client = @saved_cs_client */;</p><p>　　　　–<br>　　　　– Dumping data for table <code>class</code><br>　　　　–</p><p>　　　　LOCK TABLES <code>class</code> WRITE; –锁表<br>　　　　/*!40000 ALTER TABLE <code>class</code> DISABLE KEYS <em>/;<br>　　　　INSERT INTO <code>class</code> VALUES (1,’一班’),(2,’二班’); –插入数据<br>　　　　/</em>!40000 ALTER TABLE <code>class</code> ENABLE KEYS */;<br>　　　　UNLOCK TABLES; –解锁<br>　　　　……<br>　　　　等等大致内容(如果你插入的数据有中文，这里显示的确实乱码的同学，往回看看我的关于修改mysql字符集编码的博客，将编码改为统一的，然后重新操作一遍就可以了)</p><p>　　　　上面的这个指令的意思就是将crm2这个库，备份到这个’f:\数据库备份练习'路径下，并且命名为crm2.sql文件。</p><p>　　执行备份语句的时候，其中可以加上很多的参数，用来添加一些备份的时候的特殊要求的，其中有一个-B参数，执行备份语句时，如果加上了-B参数，那么将来再执行数据还原的时候，就不需要自己到数据库里面去先创建一个crm2这个库了，并且执行数据还原语句的时候就不需要指定crm2这个库了，如果没有加-B参数，就需要自行到数据库中先创建一个crm2这个库，并且执行语句是要指定将数据恢复到这个crm2库里面，看对比：<br>　　首先上面我们执行的语句中没有加上-B参数，那么恢复数据的时候，怎么恢复呢，看下面的语句<br>　　　　1.连接到数据库中，并创建crm2这个库<br>　　　　　　mysql -u root -p666<br>　　　　　　mysql&gt; create database crm2;<br>　　　　2.退出mysql或者重新启动一个cmd窗口，然后执行<br>　　　　　　mysql -uroot -p 库名 &lt; mysqldump出来的那个sql文件的路径<br>　　　　例如：mysql -uroot -p crm2&lt; f:\数据库备份练习\crm2.sql<br>　　　　3.这样就恢复好了，我们连接上数据库并查看里面的内容：<br>　　　　　　mysql -u root -p666<br>　　　　　　use crm2;<br>　　　　　　mysql&gt; show tables;<br>　　　　　　+—————-+<br>　　　　　　| Tables_in_crm2 |<br>　　　　　　+—————-+<br>　　　　　　| class |<br>　　　　　　| student |<br>　　　　　　+—————-+<br>　　　　　　2 rows in set (0.00 sec)</p><p>　　　　　　mysql&gt; select * from student;<br>　　　　　　+—-+——–+——+———-+<br>　　　　　　| id | name | age | class_id |<br>　　　　　　+—-+——–+——+———-+<br>　　　　　　| 1 | Jaden | 18 | 1 |<br>　　　　　　| 2 | 太白 | 45 | 1 |<br>　　　　　　| 3 | 彦涛 | 30 | 2 |<br>　　　　　　+—-+——–+——+———-+<br>　　　　　　3 rows in set (0.00 sec)</p><p>　　　　　　mysql&gt; desc student;<br>　　　　　　+———-+———+——+—–+———+——-+<br>　　　　　　| Field | Type | Null | Key | Default | Extra |<br>　　　　　　+———-+———+——+—–+———+——-+<br>　　　　　　| id | int(11) | NO | PRI | NULL | |<br>　　　　　　| name | char(8) | NO | | NULL | |<br>　　　　　　| age | int(11) | YES | | NULL | |<br>　　　　　　| class_id | int(11) | NO | | NULL | |<br>　　　　　　+———-+———+——+—–+———+——-+<br>　　　　　　4 rows in set (0.02 sec)</p><p>　　　　就这么简单我们就将数据库恢复了，表中的数据和表结构都恢复了。</p><p>　　　　执行mysqldump的时候加上了-B参数，那么恢复数据的时候，就不需要指定是恢复那个库里面的数据了，也不需要提前到数据库中创建一个crm2库了，因为-B参数导出的文件中自带创建数据库和连接数据库的功能：(使用-B参数备份出来的内容自带create database 库名和use 库名的功能)</p><p>　　　　1.mysqldump -uroot -p -B crm2&gt; f:\数据库备份练习\crm2.sql</p><p>　　　　2.在cmd窗口下执行：mysql -uroot -p &lt; f:\数据库备份练习\crm2.sql<br>　　　　3.查看一下是否恢复了：<br>　　　　　　mysql&gt; show databases;<br>　　　　　　+——————–+<br>　　　　　　| Database |<br>　　　　　　+——————–+<br>　　　　　　| information_schema |<br>　　　　　　| crm2 |<br>　　　　　　| d1 |<br>　　　　　　| mysql |<br>　　　　　　| performance_schema |<br>　　　　　　| test |<br>　　　　　　+——————–+<br>　　　　　　mysql&gt; use crm2;<br>　　　　　　Database changed<br>　　　　　　mysql&gt; show tables;<br>　　　　　　+—————-+<br>　　　　　　| Tables_in_crm2 |<br>　　　　　　+—————-+<br>　　　　　　| class |<br>　　　　　　| student |<br>　　　　　　+—————-+<br>　　　　　　2 rows in set (0.00 sec)<br>　　　　　　mysql&gt; select * from class;<br>　　　　　　+—-+——–+<br>　　　　　　| id | cname |<br>　　　　　　+—-+——–+<br>　　　　　　| 1 | 一班 |<br>　　　　　　| 2 | 二班 |<br>　　　　　　+—-+——–+<br>　　　　　　2 rows in set (0.00 sec)</p><p>　　　　　　mysql&gt; desc student;<br>　　　　　　+———-+———+——+—–+———+——-+<br>　　　　　　| Field | Type | Null | Key | Default | Extra |<br>　　　　　　+———-+———+——+—–+———+——-+<br>　　　　　　| id | int(11) | NO | PRI | NULL | |<br>　　　　　　| name | char(8) | NO | | NULL | |<br>　　　　　　| age | int(11) | YES | | NULL | |<br>　　　　　　| class_id | int(11) | NO | | NULL | |<br>　　　　　　+———-+———+——+—–+———+——-+<br>　　　　　　4 rows in set (0.02 sec)</p><p>　　　　上面我们就完成了一个简单数据库备份和恢复的过程(在linux下面还可以在导出的时候压缩文件内容，减小空间占用mysqldump -uroot -p -B crm2|gzip&gt; f:\数据库备份练习\crm2.sql.gz，windows好像是没有自带的zip压缩指令，大家有兴趣的可以去查一下，作为了解吧)</p><p>　　　　原理：其实很简单，就是把数据从mysql库里面以逻辑的sql语句的形式直接输出或者生成备份文件的过程。</p><p>　　　　上面我们说完了单库备份，下面来看看多个库怎么备份呀<br>　　　　　　C:\WINDOWS\system32&gt;mysqldump -uroot -p -B crm2 mysql&gt; f:\数据库备份练习\crm2mysql.sql<br>　　　　　　Enter password: ***<br>　　　　就是多个库名用空格分开，这样备份出来的sql文件还是一个，也就是这两个库都备份到一个文件里面了。一般作备份的时候的文件名字都是库名.sql，多个库一般就是库名_库名_库名.sql。</p><p>　　　　那如果我们将很多的库都是一起备份的，但是我们只想恢复其中一个库怎么办，这样搞是不是就不太合适了(因为一个文件算是一个备份，在进行恢复的时候，一下就将文件里面的所有的库都还原了，效率低不说，还麻烦)，那就需要分库备份了，也就是将每个库分开来进行备份，自己备份自己的，一个一个来</p><p>　　　　其实就是执行多个单库备份的语句<br>　　　　　　mysqldump -uroot -p -B crm2&gt; f:\数据库备份练习\crm2.sql<br>　　　　　　mysqldump -uroot -p -B mysql&gt; f:\数据库备份练习\crm2.sql<br>　　　　　　…<br>　　　　但是如果库比较多(企业的数据库里一般都会有多个库)，这么写就比较麻烦了，所以需要获取所有数据库的库名，然后根据库名来循环执行上面的单库备份的语句，并将库名作为变量放到语句里面进行循环。需要写脚本(就是一堆系统指令组成的程序)来做这件事情了，具体怎么做，咱们就不说啦，目前知道一下就可以了(写一个.sh文件，然后sh+文件来执行这个文件，文件里面写个for循环就行了，等你学会写shell脚本就会了)</p><p>　　　　备份表：<br>　　　　　　上面我们说的是如何备份库，现在我们来看看如果备份其中的某个表：<br>　　　　　　语法：mysqldump -u 用户名 -p 库名 表名&gt; (路径)备份的文件名<br>　　　　　　　　mysqldump -uroot -p crm2 student&gt; f:\数据库备份练习\crm2_table_student.sql</p><p>　　　　单纯进行表备份的时候，就不用写-B参数了，因为库crm2后面就是student表了，也就是说你的crm2库还在呢</p><p>　　　　备份多个表：<br>　　　　　　语法：mysqldump -u 用户名 -p 库名 表名1 表名2&gt; (路径)备份的文件名</p><p>　　　　和多个库一起备份有一个同样的问题，就是如果我只需要恢复某一张表怎么办，上面的多表备份是不是也不太合适啊，所以又要进行分表备份<br>　　　　又是同样的套路，获取所有的表名，写一个循环脚本，执行单表备份的指令。<br>　　　　分库分表备份有些缺点：文件多，很碎，数据量非常大的时候，效率低<br>　　　　　　1.做一个完整的全备，再做一个分库分表的备份<br>　　　　　　2.脚本批量恢复多个sql文件。　　　　</p><p>　　备份数据库表结构：<br>　　　　利用mysqldump -d参数只备份表的结果，例如：备份crm2库的所有表的结构：</p><p>　　　　C:\WINDOWS\system32&gt;mysqldump -uroot -p -B -d crm2&gt; f:\数据库备份练习\crm2stru.sql<br>　　　　Enter password: ***</p><p>　　备份出来的文件打开一看，就没有了插入数据的部分</p><p>　　mysqldump的关键参数说明：<br>　　　　　　1.-B指定多个库，增加建库语句和use 语句<br>　　　　　　2.–compact 去掉注释，适合调试输出，生产上不用<br>　　　　　　3.-A或者–all-databases<br>　　　　　　　　例如：C:\WINDOWS\system32&gt;mysqldump -uroot -p -B -A&gt; f:\数据库备份练习\all.sql<br>　　　　　　　　Enter password: ***</p><p>　　　　　　4.-F刷新binlog日志(binlog具体是什么，后面咱们再解释)<br>　　　　　　5.–master-data 增加binlog日志文件名及对应的为支点。<br>　　　　　　6.-x，–lock-all-tables 将所有的表锁住，一般mysql引擎都是锁表，全部都不能使用了，所有不太友好</p><p>　　　　　　7.–add-locks这个选项会在INSERT语句中捆上一个LOCK TABLE和UNLOCK TABLE语句。这就防止在这些记录被再次导入数据库时其他用户对表进行的操作(mysql默认是加上的)<br>　　　　　　8.-l，–lock-tables Lock all tables for read<br>　　　　　　9.-d 只备份表结构<br>　　　　　　10.-t 只备份数据<br>　　　　　　11. –single-transaction 开启事务，适合innodb事务数据库备份<br>　　　　　　　　InnoDB表在备份时，通常启用选项–single-transaction来保证备份的一致性，实际上他的工作原理时设定本次会话的隔离界别为：REPEATABLE READ，以确保本次会话(dump)时，不会看到其他会话已经提交了数据。</p><p>　　　　　　　　MyISAM全库备份指令推荐：(gzip是压缩文件为zip类型的)<br>　　　　　　　　mysqldump -uroot -p666 -A -B –master-data=2 -x|gzip&gt;f:\数据库备份练习\all.sql.gz<br>　　　　　　　　InnoDB全库备份指令推荐：<br>　　　　　　　　mysqldump -uroot -p666 -A -B –master-data=2 –single-transaction|gzip&gt;f:\数据库备份练习\all.sql.gz</p><p>　　　　数据恢复：</p><p>　　一、通过source命令恢复数据库<br>　　　　进入mysql数据库控制台，mysql -uroot -p666登陆后<br>　　　　mysql&gt;use 数据库;<br>　　　　然后使用source命令，后面参数为脚本文件(如这里用到的是.sql文件，如果你备份的是.txt文件，那这里写.txt文件)</p><p>　　　　mysql&gt;source crm2.sql #这个文件是系统路径下的，默认是登陆mysql前的系统路径，在mysql中查看系统路径的方法是通过system+系统命令来搞的<br>　　　　mysql&gt;system ls<br>　　二、利用mysql命名恢复(标准)<br>　　　　mysql -root -p666 -e “use crm2;drop table student;show tables;” 必须是双引号<br>　　　　mysql -uroot -p666 crm2&lt;f:\数据库备份练习\crm2.sql<br>　　　　mysql -uroot -p666 -e “use crm2;show tables;”</p><p>　　　　注：如果sql文件里面没有use db这样的字样时，在导入时就要指定数据库名了。</p><p>　　　　mysql -uroot -p666 crm2&lt;.sql文件</p><p>　　　　建议备份数据库时都指定上-B参数，效果好</p><p>　　　　说明：mysql不光可以恢复mysqldump的备份，只要文件中是sql语句，都可以通过mysql命令执行到数据库中</p><p>　　　　mysql 带-e参数实现非交互式对话，就是不需要到mysql里面去，在外面执行里面的指令的方法,例如：mysql -uroot -p666 -e “use crm2;show tables;”，但是语句必须是双引号包裹。</p><p>　　　　批量恢复库：找到所有的数据库名，然后通过库名去循环恢复<br>　　　　<br>　　　　关于binlog，等我整理好在给大家吧<del>~</del></p><p>#下面的这些内容是我之前整理的，大家不要看了，我会改版的，等新版出来之后在发出来给大家，下面的太晦涩难懂了<del>~</del></p><h1 id="二-MySQL数据备份"><a href="#二-MySQL数据备份" class="headerlink" title="二 MySQL数据备份"></a>二 MySQL数据备份</h1><pre><code>#1. 物理备份： 直接复制数据库文件，适用于大型数据库环境。但不能恢复到异构系统中如Windows。#2. 逻辑备份： 备份的是建表、建库、插入等操作所执行SQL语句，适用于中小型数据库，效率相对较低。#3. 导出表： 将表导入到文本文件中。 </code></pre><p>　　<strong>一、使用mysqldump实现逻辑备份</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#语法：# mysqldump -h 服务器 -u用户名 -p密码 数据库名 &gt; 备份文件.sql#示例：#单库备份mysqldump -uroot -p123 db1 &gt; db1.sqlmysqldump -uroot -p123 db1 table1 table2 &gt; db1-table1-table2.sql#多库备份mysqldump -uroot -p123 --databases db1 db2 mysql db3 &gt; db1_db2_mysql_db3.sql#备份所有库mysqldump -uroot -p123 --all-databases &gt; all.sql </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong>二、恢复逻辑备份</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#方法一：[root@localhost backup]# mysql -uroot -p123 &lt; /backup/all.sql#方法二：mysql&gt; use db1;mysql&gt; SET SQL_LOG_BIN=0;mysql&gt; source /root/db1.sql#注：如果备份/恢复单个库时，可以修改sql文件DROP database if exists school;create database school;use school; </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>三、备份/恢复案例</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#数据库备份/恢复实验一：数据库损坏备份：1. # mysqldump -uroot -p123 --all-databases &gt; /backup/`date +%F`_all.sql2. # mysql -uroot -p123 -e 'flush logs' //截断并产生新的binlog3. 插入数据 //模拟服务器正常运行4. mysql&gt; set sql_log_bin=0; //模拟服务器损坏mysql&gt; drop database db;恢复：1. # mysqlbinlog 最后一个binlog &gt; /backup/last_bin.log2. mysql&gt; set sql_log_bin=0; mysql&gt; source /backup/2014-02-13_all.sql //恢复最近一次完全备份 mysql&gt; source /backup/last_bin.log //恢复最后个binlog文件#数据库备份/恢复实验二：如果有误删除备份：1. mysqldump -uroot -p123 --all-databases &gt; /backup/`date +%F`_all.sql2. mysql -uroot -p123 -e 'flush logs' //截断并产生新的binlog3. 插入数据 //模拟服务器正常运行4. drop table db1.t1 //模拟误删除5. 插入数据 //模拟服务器正常运行恢复：1. # mysqlbinlog 最后一个binlog --stop-position=260 &gt; /tmp/1.sql # mysqlbinlog 最后一个binlog --start-position=900 &gt; /tmp/2.sql 2. mysql&gt; set sql_log_bin=0; mysql&gt; source /backup/2014-02-13_all.sql //恢复最近一次完全备份mysql&gt; source /tmp/1.log //恢复最后个binlog文件mysql&gt; source /tmp/2.log //恢复最后个binlog文件注意事项：1. 完全恢复到一个干净的环境（例如新的数据库或删除原有的数据库）2. 恢复期间所有SQL语句不应该记录到binlog中</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>四、实现自动化备份</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>备份计划：1. 什么时间 2:002. 对哪些数据库备份3. 备份文件放的位置备份脚本：[root@localhost~]# vim /mysql_back.sql#!/bin/bashback_dir=/backupback_file=`date +%F`_all.sqluser=rootpass=123if [ ! -d /backup ];thenmkdir -p /backupfi# 备份并截断日志mysqldump -u${user} -p${pass} --events --all-databases &gt; ${back_dir}/${back_file}mysql -u${user} -p${pass} -e 'flush logs'# 只保留最近一周的备份cd $back_dirfind . -mtime +7 -exec rm -rf {} \;手动测试：[root@localhost ~]# chmod a+x /mysql_back.sql [root@localhost ~]# chattr +i /mysql_back.sql[root@localhost ~]# /mysql_back.sql配置cron：[root@localhost ~]# crontab -l2 * * * /mysql_back.sql</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>五、表的导出和导入</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>SELECT... INTO OUTFILE 导出文本文件示例：mysql&gt; SELECT * FROM school.student1INTO OUTFILE 'student1.txt'FIELDS TERMINATED BY ',' //定义字段分隔符OPTIONALLY ENCLOSED BY '”' //定义字符串使用什么符号括起来LINES TERMINATED BY '\n' ; //定义换行符mysql 命令导出文本文件示例:# mysql -u root -p123 -e 'select * from student1.school' &gt; /tmp/student1.txt# mysql -u root -p123 --xml -e 'select * from student1.school' &gt; /tmp/student1.xml# mysql -u root -p123 --html -e 'select * from student1.school' &gt; /tmp/student1.htmlLOAD DATA INFILE 导入文本文件mysql&gt; DELETE FROM student1;mysql&gt; LOAD DATA INFILE '/tmp/student1.txt'INTO TABLE school.student1FIELDS TERMINATED BY ','OPTIONALLY ENCLOSED BY '”'LINES TERMINATED BY '\n';</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#可能会报错mysql&gt; select * from db1.emp into outfile 'C:\\db1.emp.txt' fields terminated by ',' lines terminated by '\r\n';ERROR 1238 (HY000): Variable 'secure_file_priv' is a read only variable#数据库最关键的是数据，一旦数据库权限泄露，那么通过上述语句就可以轻松将数据导出到文件中然后下载拿走，因而mysql对此作了限制，只能将文件导出到指定目录在配置文件中[mysqld]secure_file_priv='C:\\' #只能将数据导出到C:\\下重启mysql重新执行上述语句</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>六、数据库迁移</strong></p><pre><code>务必保证在相同版本之间迁移# mysqldump -h 源IP -uroot -p123 --databases db1 | mysql -h 目标IP -uroot -p456</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础数据类型</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>有符号和无符号tinyint    1.tinyint默认为有符号        mysql&gt; create table t1(x tinyint); #默认为有符号，即数字前有正负号        mysql&gt; desc t1;        mysql&gt; insert into t1 values            -&gt; (-129),            -&gt; (-128),            -&gt; (127),            -&gt; (128);        mysql&gt; select * from t1;        +------+        | x    |        +------+        | -128 | #-129存成了-128        | -128 | #有符号，最小值为-128        |  127 | #有符号，最大值127        |  127 | #128存成了127        +------+    2.设置无符号tinyint        mysql&gt; create table t2(x tinyint unsigned);        mysql&gt; insert into t2 values            -&gt; (-1),            -&gt; (0),            -&gt; (255),            -&gt; (256);        mysql&gt; select * from t2;        +------+        | x    |        +------+        |    0 | -1存成了0        |    0 | #无符号，最小值为0        |  255 | #无符号，最大值为255        |  255 | #256存成了255        +------+有符号和无符号int    1.int默认为有符号        mysql&gt; create table t3(x int); #默认为有符号整数        mysql&gt; insert into t3 values            -&gt; (-2147483649),            -&gt; (-2147483648),            -&gt; (2147483647),            -&gt; (2147483648);        mysql&gt; select * from t3;        +-------------+        | x           |        +-------------+        | -2147483648 | #-2147483649存成了-2147483648        | -2147483648 | #有符号，最小值为-2147483648        |  2147483647 | #有符号，最大值为2147483647        |  2147483647 | #2147483648存成了2147483647        +-------------+    2.设置无符号int        mysql&gt; create table t4(x int unsigned);        mysql&gt; insert into t4 values            -&gt; (-1),            -&gt; (0),            -&gt; (4294967295),            -&gt; (4294967296);        mysql&gt; select * from t4;        +------------+        | x          |        +------------+        |          0 | #-1存成了0        |          0 | #无符号，最小值为0        | 4294967295 | #无符号，最大值为4294967295        | 4294967295 | #4294967296存成了4294967295        +------------+有符号和无符号bigint    1.有符号bigint        mysql&gt; create table t6(x bigint);        mysql&gt; insert into t5 values              -&gt; (-9223372036854775809),            -&gt; (-9223372036854775808),            -&gt; (9223372036854775807),            -&gt; (9223372036854775808);        mysql&gt; select * from t5;        +----------------------+        | x                    |        +----------------------+        | -9223372036854775808 |        | -9223372036854775808 |        |  9223372036854775807 |        |  9223372036854775807 |        +----------------------+    2.无符号bigint        mysql&gt; create table t6(x bigint unsigned);        mysql&gt; insert into t6 values              -&gt; (-1),            -&gt; (0),            -&gt; (18446744073709551615),            -&gt; (18446744073709551616);        mysql&gt; select * from t6;        +----------------------+        | x                    |        +----------------------+        |                    0 |        |                    0 |        | 18446744073709551615 |        | 18446744073709551615 |        +----------------------+用zerofill测试整数类型的显示宽度    mysql&gt; create table t7(x int(3) zerofill);    mysql&gt; insert into t7 values        -&gt; (1),        -&gt; (11),        -&gt; (111),        -&gt; (1111);    mysql&gt; select * from t7;    +------+    | x    |    +------+    |  001 |    |  011 |    |  111 |    | 1111 | #超过宽度限制仍然可以存    +------+</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　注意：对于整型来说，数据类型后面的宽度并不是存储长度限制，而是显示限制，假如：int(8)，那么显示时不够8位则用0来填充，够8位则正常显示，通过zerofill来测试，存储长度还是int的4个字节长度。默认的显示宽度就是能够存储的最大的数据的长度，比如：int无符号类型，那么默认的显示宽度就是int(10)，有符号的就是int(11)，因为多了一个符号，所以我们没有必要指定整数类型的数据，没必要指定宽度，因为默认的就能够将你存的原始数据完全显示</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170801181433755-146301178.png" alt="img"></p><p>　　　　int的存储宽度是4个Bytes，即32个bit，即2**32　　</p><p>　　　　无符号最大值为：4294967296-1</p><p>　　　　有符号最大值：2147483648-1</p><p>　　　　有符号和无符号的最大数字需要的显示宽度均为10，而针对有符号的最小值则需要11位才能显示完全，所以int类型默认的显示宽度为11是非常合理的</p><p>　　　　最后：整形类型，其实没有必要指定显示宽度，使用默认的就ok</p><p>说到这里我想提一下MySQL的mode设置，看我这篇博客：<a href="https://www.cnblogs.com/clschao/articles/9962347.html%EF%BC%8C%E7%9C%8B%E5%AE%8C%E5%8D%9A%E5%AE%A2%E5%BA%94%E8%AF%A5%E5%B0%B1%E8%83%BD%E7%90%86%E8%A7%A3MySQL%E7%9A%84mode%E4%BA%86%E3%80%82">https://www.cnblogs.com/clschao/articles/9962347.html，看完博客应该就能理解MySQL的mode了。</a></p><p>　　<strong>2、浮点型</strong></p><p>　　　　定点数类型  DEC，等同于DECIMAL　　</p><p>　　　　浮点类型：FLOAT DOUBLE</p><p>　　　　作用：存储薪资、身高、温度、体重、体质参数等</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>1.FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]    定义：            单精度浮点数（非准确小数值），m是整数部分+小数部分的总个数，d是小数点后个数。m最大值为255，d最大值为30，例如：float(255,30)    有符号：               -3.402823466E+38 to -1.175494351E-38,               1.175494351E-38 to 3.402823466E+38    无符号：               1.175494351E-38 to 3.402823466E+38    精确度：                **** 随着小数的增多，精度变得不准确 ****2.DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]    定义：               双精度浮点数（非准确小数值），m是整数部分+小数部分的总个数，d是小数点后个数。m最大值也为255，d最大值也为30    有符号：               -1.7976931348623157E+308 to -2.2250738585072014E-308               2.2250738585072014E-308 to 1.7976931348623157E+308    无符号：               2.2250738585072014E-308 to 1.7976931348623157E+308    精确度：               ****随着小数的增多，精度比float要高，但也会变得不准确 ****3.decimal[(m[,d])] [unsigned] [zerofill]    定义：              准确的小数值，m是整数部分+小数部分的总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。比float和double的整数个数少，但是小数位数都是30位    精确度：               **** 随着小数的增多，精度始终准确 ****               对于精确数值计算时需要用此类型               decimal能够存储精确值的原因在于其内部按照字符串存储。精度从高到低：decimal、double、float    decimal精度高，但是整数位数少    float和double精度低，但是整数位数多float已经满足绝大多数的场景了，但是什么导弹、航线等要求精度非常高，所以还是需要按照业务场景自行选择，如果又要精度高又要整数位数多，那么你可以直接用字符串来存。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; create table t1(x float(256,31));ERROR 1425 (42000): Too big scale 31 specified for column 'x'. Maximum is 30.mysql&gt; create table t1(x float(256,30));ERROR 1439 (42000): Display width out of range for column 'x' (max = 255)mysql&gt; create table t1(x float(255,30)); #建表成功Query OK, 0 rows affected (0.02 sec)mysql&gt; create table t2(x double(255,30)); #建表成功Query OK, 0 rows affected (0.02 sec)mysql&gt; create table t3(x decimal(66,31));ERROR 1425 (42000): Too big scale 31 specified for column 'x'. Maximum is 30.mysql&gt; create table t3(x decimal(66,30));ERROR 1426 (42000): Too-big precision 66 specified for 'x'. Maximum is 65.mysql&gt; create table t3(x decimal(65,30)); #建表成功Query OK, 0 rows affected (0.02 sec)mysql&gt; show tables;+---------------+| Tables_in_db1 |+---------------+| t1            || t2            || t3            |+---------------+3 rows in set (0.00 sec)mysql&gt; insert into t1 values(1.1111111111111111111111111111111); #小数点后31个1Query OK, 1 row affected (0.01 sec)mysql&gt; insert into t2 values(1.1111111111111111111111111111111);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into t3 values(1.1111111111111111111111111111111);Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; select * from t1; #随着小数的增多，精度开始不准确+----------------------------------+| x                                |+----------------------------------+| 1.111111164093017600000000000000 |+----------------------------------+1 row in set (0.00 sec)mysql&gt; select * from t2; #精度比float要准确点，但随着小数的增多，同样变得不准确+----------------------------------+| x                                |+----------------------------------+| 1.111111111111111200000000000000 |+----------------------------------+1 row in set (0.00 sec)mysql&gt; select * from t3; #精度始终准确,d为30，于是只留了30位小数+----------------------------------+| x                                |+----------------------------------+| 1.111111111111111111111111111111 |+----------------------------------+1 row in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>3、位类型（了解，不讲~~）</strong></p><p>　　　　BIT(M)可以用来存放多位二进制数，M范围从1~64，如果不写默认为1位。<br>　　　　注意：对于位字段需要使用函数读取<br>    　　　　bin()显示为二进制<br>    　　　　hex()显示为十六进制</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; create table t9(id bit);mysql&gt; desc t9; #bit默认宽度为1+-------+--------+------+-----+---------+-------+| Field | Type   | Null | Key | Default | Extra |+-------+--------+------+-----+---------+-------+| id    | bit(1) | YES  |     | NULL    |       |+-------+--------+------+-----+---------+-------+mysql&gt; insert into t9 values(8);mysql&gt; select * from t9; #直接查看是无法显示二进制位的+------+| id   |+------+|     |+------+mysql&gt; select bin(id),hex(id) from t9; #需要转换才能看到+---------+---------+| bin(id) | hex(id) |+---------+---------+| 1       | 1       |+---------+---------+mysql&gt; alter table t9 modify id bit(5);mysql&gt; insert into t9 values(8);mysql&gt; select bin(id),hex(id) from t9;+---------+---------+| bin(id) | hex(id) |+---------+---------+| 1       | 1       || 1000    | 8       |+---------+---------+</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="三-日期类型"><a href="#三-日期类型" class="headerlink" title="三 日期类型"></a>三 日期类型</h1><p>　　类型：DATE，TIME，DATETIME ，IMESTAMP，YEAR </p><p>　　作用：存储用户注册时间，文章发布时间，员工入职时间，出生时间，过期时间等</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>        YEAR            YYYY（范围：1901/2155）2018        DATE            YYYY-MM-DD（范围：1000-01-01/9999-12-31）例：2018-01-01         TIME            HH:MM:SS（范围：'-838:59:59'/'838:59:59'）例：12:09:32        DATETIME            YYYY-MM-DD HH:MM:SS（范围：1000-01-01 00:00:00/9999-12-31 23:59:59    Y）例： 2018-01-01 12:09:32        TIMESTAMP            YYYYMMDD HHMMSS（范围：1970-01-01 00:00:00/2037 年某时）</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>year：    mysql&gt; create table t10(born_year year); #无论year指定何种宽度，最后都默认是year(4)    mysql&gt; insert into t10 values          -&gt; (1900),        -&gt; (1901),        -&gt; (2155),        -&gt; (2156);    mysql&gt; select * from t10;    +-----------+    | born_year |    +-----------+    |      0000 |    |      1901 |    |      2155 |    |      0000 |    +-----------+date,time,datetime:    mysql&gt; create table t11(d date,t time,dt datetime);    mysql&gt; desc t11;    +-------+----------+------+-----+---------+-------+    | Field | Type     | Null | Key | Default | Extra |    +-------+----------+------+-----+---------+-------+    | d     | date     | YES  |     | NULL    |       |    | t     | time     | YES  |     | NULL    |       |    | dt    | datetime | YES  |     | NULL    |       |    +-------+----------+------+-----+---------+-------+    mysql&gt; insert into t11 values(now(),now(),now());    mysql&gt; select * from t11;    +------------+----------+---------------------+    | d          | t        | dt                  |    +------------+----------+---------------------+    | 2017-07-25 | 16:26:54 | 2017-07-25 16:26:54 |    +------------+----------+---------------------+timestamp：    mysql&gt; create table t12(time timestamp);    mysql&gt; insert into t12 values();    mysql&gt; insert into t12 values(null);    mysql&gt; select * from t12;    +---------------------+    | time                |    +---------------------+    | 2017-07-25 16:29:17 |    | 2017-07-25 16:30:01 |    +---------------------+============注意啦，注意啦，注意啦===========    1. 单独插入时间时，需要以字符串的形式，按照对应的格式插入    2. 插入年份时，尽量使用4位值    3. 插入两位年份时，&lt;=69，以20开头，比如50,  结果2050                          &gt;=70，以19开头，比如71，结果1971    mysql&gt; create table t12(y year);    mysql&gt; insert into t12 values          -&gt; (50),        -&gt; (71);    mysql&gt; select * from t12;    +------+    | y    |    +------+    | 2050 |    | 1971 |    +------+============综合练习===========    mysql&gt; create table student(        -&gt; id int,        -&gt; name varchar(20),        -&gt; born_year year,        -&gt; birth date,        -&gt; class_time time,        -&gt; reg_time datetime);    mysql&gt; insert into student values        -&gt; (1,'sb1',"1995","1995-11-11","11:11:11","2017-11-11 11:11:11"),        -&gt; (2,'sb2',"1997","1997-12-12","12:12:12","2017-12-12 12:12:12"),        -&gt; (3,'sb3',"1998","1998-01-01","13:13:13","2017-01-01 13:13:13");      mysql&gt; select * from student;    +------+------+-----------+------------+------------+---------------------+    | id   | name | born_year | birth      | class_time | reg_time            |    +------+------+-----------+------------+------------+---------------------+    |    1 | sb1 |      1995 | 1995-11-11 | 11:11:11   | 2017-11-11 11:11:11 |    |    2 | sb2 |      1997 | 1997-12-12 | 12:12:12   | 2017-12-12 12:12:12 |    |    3 | sb3 |      1998 | 1998-01-01 | 13:13:13   | 2017-01-01 13:13:13 |    +------+------+-----------+------------+------------+---------------------+</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　mysql的日期格式对字符串采用的是’放松’政策，可以以字符串的形式插入。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>在实际应用的很多场景中，MySQL的这两种日期类型都能够满足我们的需要，存储精度都为秒，但在某些情况下，会展现出他们各自的优劣。下面就来总结一下两种日期类型的区别。1.DATETIME的日期范围是1001——9999年，TIMESTAMP的时间范围是1970——2038年。2.DATETIME存储时间与时区无关，TIMESTAMP存储时间与时区有关，显示的值也依赖于时区。在mysql服务器，操作系统以及客户端连接都有时区的设置。3.DATETIME使用8字节的存储空间，TIMESTAMP的存储空间为4字节。因此，TIMESTAMP比DATETIME的空间利用率更高。4.DATETIME的默认值为null；TIMESTAMP的字段默认不为空（not null）,默认值为当前时间（CURRENT_TIMESTAMP），如果不做特殊处理，并且update语句中没有指定该列的更新值，则默认更新为当前时间。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　工作中一般都用datetime就可以了。　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; create table t1(x datetime not null default now()); # 需要指定传入空值时默认取当前时间Query OK, 0 rows affected (0.01 sec)mysql&gt; create table t2(x timestamp); # 无需任何设置，在传空值的情况下自动传入当前时间Query OK, 0 rows affected (0.02 sec)mysql&gt; insert into t1 values();Query OK, 1 row affected (0.00 sec)mysql&gt; insert into t2 values();Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1;+---------------------+| x                   |+---------------------+| 2018-07-07 01:26:14 |+---------------------+1 row in set (0.00 sec)mysql&gt; select * from t2;+---------------------+| x                   |+---------------------+| 2018-07-07 01:26:17 |+---------------------+1 row in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="四-字符串类型"><a href="#四-字符串类型" class="headerlink" title="四 字符串类型"></a>四 字符串类型</h1><p>　　类型：char，varchar</p><p>　　作用：名字，信息等等</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#官网：https://dev.mysql.com/doc/refman/5.7/en/char.html#注意：char和varchar括号内的参数指的都是字符的长度#char类型：定长，简单粗暴，浪费空间，存取速度快    字符长度范围：0-255（一个中文是一个字符，是utf8编码的3个字节）    存储：        存储char类型的值时，会往右填充空格来满足长度        例如：指定长度为10，存&gt;10个字符则报错(严格模式下)，存&lt;10个字符则用空格填充直到凑够10个字符存储    检索：        在检索或者说查询时，查出的结果会自动删除尾部的空格，如果你想看到它补全空格之后的内容，除非我们打开pad_char_to_full_length SQL模式（SET sql_mode = 'strict_trans_tables,PAD_CHAR_TO_FULL_LENGTH';）#varchar类型：变长，精准，节省空间，存取速度慢    字符长度范围：0-65535（如果大于21845会提示用其他类型 。mysql行最大限制为65535字节，字符编码为utf-8：https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html）    存储：        varchar类型存储数据的真实内容，不会用空格填充，如果'ab  ',尾部的空格也会被存起来        强调：varchar类型会在真实数据前加1-2Bytes的前缀，该前缀用来表示真实数据的bytes字节数（1-2Bytes最大表示65535个数字，正好符合mysql对row的最大字节限制，即已经足够使用）        如果真实的数据&lt;255bytes则需要1Bytes的前缀（1Bytes=8bit 2**8最大表示的数字为255）        如果真实的数据&gt;255bytes则需要2Bytes的前缀（2Bytes=16bit 2**16最大表示的数字为65535）    检索：        尾部有空格会保存下来，在检索或者说查询时，也会正常显示包含空格在内的内容</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　下面我们来进行一些测试，在测试之前，我们需要学一下mysql给我们提供的两个方法：</p><p>　　　　length(字段)：查看该字段数据的字节长度</p><p>　　　　char_length(字段)：查看该字段数据的字符长度</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>创建一个t1表，包含一个char类型的字段create table t1(id int,name char(4));            超过长度：                严格模式下(报错)：                    mysql&gt; insert into t1 values('xiaoshabi');                    ERROR 1406 (22001): Data too long for column 'name' at row 1                非严格模式下(警告)：                    mysql&gt; set sql_mode='NO_ENGINE_SUBSTITUTION';                    Query OK, 0 rows affected (0.00 sec)                    mysql&gt; create table t1(id int,name char(4));                    Query OK, 0 rows affected (0.40 sec)                    mysql&gt; insert into t2 values('xiaoshabi');                    Query OK, 1 row affected, 1 warning (0.11 sec)                    查看一下结果：                    mysql&gt; select * from t1;                    +------+------+                    | id   | name |                    +------+------+                    |    1 | xiao | #只有一个xiao                    +------+------+                    1 row in set (0.00 sec)                varchar类型和上面的效果是一样的，严格模式下也会报错。            如果没有超过长度，那么char类型时mysql会使用空格来补全自己规定的char(4)的4个字符，varchar不会，我们来做个对比            例如：                #再创建一个含有varchar类型的表t2                然后插入几条和t1里面相同的数据                mysql&gt;insert into t1 values(2,'a'),(3,'bb'),(4,'ccc'),(5,'d');                mysql&gt;create table t2(id int,name varchar(4));                mysql&gt; insert into t2 values(1,'xiao'),(2,'a'),(3,'bb'),(4,'ccc'),(5,'d');                查看一下t1表和t2表的内容                mysql&gt; select * from t1;                +------+------+                | id   | name |                +------+------+                |    1 | xiao |                |    2 | a    |                |    3 | bb   |                |    4 | ccc  |                |    5 | d    |                +------+------+                5 rows in set (0.00 sec)                mysql&gt; select * from t2;                +------+------+                | id   | name |                +------+------+                |    1 | xiao |                |    2 | a    |                |    3 | bb   |                |    4 | ccc  |                |    5 | d    |                +------+------+                5 rows in set (0.00 sec)            好，两个表里面数据是一样的，每一项的数据长度也是一样的，那么我们来验证一下char的自动空格在后面补全的存储方式和varchar的不同            通过mysql提供的一个char_length()方法来查看一下所有数据的长度            mysql&gt; select char_length(name) from t1;            +-------------------+            | char_length(name) |            +-------------------+            |                 4 |            |                 1 |            |                 2 |            |                 3 |            |                 1 |            +-------------------+            5 rows in set (0.00 sec)            mysql&gt; select char_length(name) from t2;            +-------------------+            | char_length(name) |            +-------------------+            |                 4 |            |                 1 |            |                 2 |            |                 3 |            |                 1 |            +-------------------+            5 rows in set (0.00 sec)            通过查看结果可以看到，两者显示的数据长度是一样的，不是说好的char会补全吗，我设置的字段是char(4)，那么长度应该都是4才对啊？这是因为mysql在你查询的时候自动帮你把结果里面的空格去掉了，如果我们想看到它存储数据的真实长度，需要设置mysql的模式，通过一个叫做PAD_CHAR_TO_FULL_LENGTH的模式，就可以看到了，所以我们把这个模式加到sql_mode里面：                mysql&gt; set sql_mode='PAD_CHAR_TO_FULL_LENGTH';                Query OK, 0 rows affected (0.00 sec)                然后我们在查看一下t1和t2数据的长度：                mysql&gt; select char_length(name) from t1;                +-------------------+                | char_length(name) |                +-------------------+                |                 4 |                |                 4 |                |                 4 |                |                 4 |                |                 4 |                +-------------------+                5 rows in set (0.00 sec)                mysql&gt; select char_length(name) from t2;                +-------------------+                | char_length(name) |                +-------------------+                |                 4 |                |                 1 |                |                 2 |                |                 3 |                |                 1 |                +-------------------+                5 rows in set (0.00 sec)                通过结果可以看到，char类型的数据长度都是4，这下看到了两者的不同了吧，至于为什么mysql会这样搞，我们后面有解释的，先看现象就可以啦。            现在我们再来看一个问题，就是当你设置的类型为char的时候，我们通过where条件来查询的时候会有一个什么现象：                mysql&gt; select * from t1 where name='a';                +------+------+                | id   | name |                +------+------+                |    2 | a    |                +------+------+                1 row in set (0.00 sec)            ok，结果没问题，我们在where后面的a后面加一下空格再来试试：                mysql&gt; select * from t1 where name='a ';                +------+------+                | id   | name |                +------+------+                |    2 | a    |                +------+------+                1 row in set (0.00 sec)            ok，能查到，再多加一些空格试试，加6个空格，超过了设置的char(4)的4：                mysql&gt; select * from t1 where name='a      ';                +------+------+                | id   | name |                +------+------+                |    2 | a    |                +------+------+                1 row in set (0.00 sec)            ok，也是没问题的            总结：通过&gt;,=,&gt;=,&lt;,&lt;=作为where的查询条件的时候，char类型字段的查询是没问题的。            但是，当我们将where后面的比较符号改为like的时候，(like是模糊匹配的意思，我们前面见过，show variables like '%char%';来查看mysql字符集的时候用过)                其中%的意思是匹配任意字符(0到多个字符都可以匹配到)，还有一个符号是_(匹配1个字符)，这两个字符其实就像我们学的正则匹配里面的通配符，那么我们通过这些符号进行一下模糊查询，看一下，char类型进行模糊匹配的时候，是否还能行，看例子：                mysql&gt; select * from t1 where name like 'a';                Empty set (0.00 sec)                发现啥也没查到，因为char存储的数据是4个字符长度的，不满4个是以空格来补全的，你在like后面就只写了一个'a'，是无法查到的。                我们试一下上面的通配符来查询：                mysql&gt; select * from t1 where name like 'a%';                +------+------+                | id   | name |                +------+------+                |    2 | a    |                +------+------+                1 row in set (0.00 sec)                这样就能看到查询结果了                试一下_是不是匹配1个字符：                mysql&gt; select * from t1 where name like 'a_';                Empty set (0.00 sec)                发现一个_果然不行，我们试试三个_。                mysql&gt; select * from t1 where name like 'a___';                +------+------+                | id   | name |                +------+------+                |    2 | a    |                +------+------+                1 row in set (0.00 sec)                发现果然能行，一个_最多匹配1个任意字符。                如果多写了几个_呢？                mysql&gt; select * from t1 where name like 'a_____';                Empty set (0.00 sec)                查不到结果，说明_匹配的是1个字符，但不是0-1个字符。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>测试结果总结：</strong><br>　　针对char类型，mysql在存储的时候会将不足规定长度的数据使用后面(右边补全)补充空格的形式进行补全，然后存放到硬盘中，但是在读取或者使用的时候会自动去掉它给你补全的空格内容，因为这些空格并不是我们自己存储的数据，所以对我们使用者来说是无用的。</p><p>　　<strong>char和varchar性能对比：</strong><br>　　　　以char(5)和varchar(5)来比较，加入我要存三个人名：sb，ssb1，ssbb2<br>　　　　<strong>char：</strong><br>　　　　　　优点：简单粗暴，不管你是多长的数据，我就按照规定的长度来存，5个5个的存，三个人名就会类似这种存储：sb ssb1 ssbb2，中间是空格补全，取数据的时候5个5个的取，简单粗暴速度快<br>　　　　　　缺点：貌似浪费空间，并且我们将来存储的数据的长度可能会参差不齐</p><p>　　　　<strong>varchar：</strong><br>　　　　　　varchar类型不定长存储数据，更为精简和节省空间<br>　　　　　　例如存上面三个人名的时候类似于是这样的：sbssb1ssbb2，连着的，如果这样存，请问这三个人名你还怎么取出来，你知道取多长能取出第一个吗？(超哥，我能看出来啊，那我只想说：滚犊子！)<br>　　　　　　不知道从哪开始从哪结束，遇到这样的问题，你会想到怎么解决呢？还记的吗？想想？socket？tcp？struct？把数据长度作为消息头。</p><p>　　　　　　<br>　　　　　　所以，varchar在存数据的时候，会在每个数据前面加上一个头，这个头是1-2个bytes的数据，这个数据指的是后面跟着的这个数据的长度，1bytes能表示2<strong>8=256，两个bytes表示2</strong>16=65536，能表示0-65535的数字，所以varchar在存储的时候是这样的：1bytes+sb+1bytes+ssb1+1bytes+ssbb2，所以存的时候会比较麻烦，导致效率比char慢，取的时候也慢，先拿长度，再取数据。</p><p>　　　　　　优点：节省了一些硬盘空间，一个acsii码的字符用一个bytes长度就能表示，但是也并不一定比char省，看一下官网给出的一个表格对比数据，当你存的数据正好是你规定的字段长度的时候，varchar反而占用的空间比char要多。</p><table><thead><tr><th>Value</th><th><code>CHAR(4)</code></th><th>Storage Required</th><th><code>VARCHAR(4)</code></th><th>Storage Required</th></tr></thead><tbody><tr><td><code>''</code></td><td><code>'    '</code></td><td>4 bytes</td><td><code>''</code></td><td>1 byte</td></tr><tr><td><code>'ab'</code></td><td><code>'ab  '</code></td><td>4 bytes</td><td><code>'ab'</code></td><td>3 bytes</td></tr><tr><td><code>'abcd'</code></td><td><code>'abcd'</code></td><td>4 bytes</td><td><code>'abcd'</code></td><td>5 bytes</td></tr><tr><td><code>'abcdefgh'</code></td><td><code>'abcd'</code></td><td>4 bytes</td><td><code>'abcd'</code></td><td>5 bytes</td></tr></tbody></table><p>　　　　　　　　<br>　　　　　　缺点：存取速度都慢</p><p>　　<strong>总结：</strong><br>　　　　所以需要根据业务需求来选择用哪种类型来存<br>　　　　其实在多数的用户量少的工作场景中char和varchar效率差别不是很大，最起码给用户的感知不是很大，并且其实软件级别的慢远比不上硬件级别的慢，所以你们公司的运维发现项目慢的时候会加内存、换nb的硬盘，项目的效率提升的会很多，但是我们作为专业人士，我们应该提出来这样的技术点来提高效率。</p><p>　　　　但是对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。</p><p>　　　　所以啊，两个选哪个都可以，如果是大型并发项目，追求高性能的时候，需要结合你们服务器的硬件环境来进行测试，看一下char和varchar哪个更好，这也能算一个优化的点吧<del>~</del></p><p>　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#官网：https://dev.mysql.com/doc/refman/5.7/en/char.htmlCHAR 和 VARCHAR 是最常使用的两种字符串类型。一般来说CHAR(N)用来保存固定长度的字符串，对于 CHAR 类型,N 的范围 为 0 ~ 255VARCHAR(N)用来保存变长字符类型，对于 VARCHAR 类型,N 的范围为 0 ~ 65 535CHAR(N)和 VARCHAR(N) 中的 N 都代表字符长度,而非字节长度。ps：对于 MySQL 4.1 之前的版本,如 MySQL 3.23 和 MySQL 4.0,CHAR(N)和 VARCHAR (N)中的 N 代表字节长度。#CHAR类型对于 CHAR 类型的字符串,MySQL 数据库会自动对存储列的右边进行填充(Right Padded)操作,直到字符串达到指定的长度 N。而在读取该列时,MySQL 数据库会自动将 填充的字符删除。有一种情况例外,那就是显式地将 SQL_MODE 设置为 PAD_CHAR_TO_ FULL_LENGTH,例如:mysql&gt; CREATE TABLE t ( a CHAR(10));      Query OK, 0 rows affected (0.03 sec)mysql&gt; INSERT INTO t SELECT 'abc';      Query OK, 1 row affected (0.03 sec)      Records: 1  Duplicates: 0  Warnings: 0mysql&gt; SELECT a,HEX(a),LENGTH(a) FROM t\G;      *************************** 1. row ***************************              a: abc         HEX(a): 616263      LENGTH (a): 3      1 row in set (0.00 sec)      mysql&gt; SET SQL_MODE='PAD_CHAR_TO_FULL_LENGTH';      Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT a,HEX(a),LENGTH(a) FROM t\G;      *************************** 1. row ***************************              a: abc         HEX(a): 61626320202020202020      LENGTH (a): 10      1 row in set (0.00 sec)在上述这个例子中,先创建了一张表 t,a 列的类型为 CHAR(10)。然后通过 INSERT语句插入值“abc”,因为 a 列的类型为 CHAR 型,所以会自动在后面填充空字符串,使其长 度为 10。接下来在通过 SELECT 语句取出数据时会将 a 列右填充的空字符移除,从而得到 值“abc”。通过 LENGTH 函数看到 a 列的字符长度为 3 而非 10。接着我们将 SQL_MODE 显式地设置为 PAD_CHAR_TO_FULL_LENGTH。这时再通过 SELECT 语句进行查询时,得到的结果是“abc ”,abc 右边有 7 个填充字符 0x20,并通 过 HEX 函数得到了验证。这次 LENGTH 函数返回的长度为 10。需要注意的是,LENGTH 函数返回的是字节长度,而不是字符长度。对于多字节字符集,CHAR(N)长度的列最多 可占用的字节数为该字符集单字符最大占用字节数 *N。例如,对于 utf8 下,CHAR(10)最 多可能占用 30 个字节。通过对多字节字符串使用 CHAR_LENGTH 函数和 LENGTH 函数, 可以发现两者的不同,示例如下:mysql&gt; SET NAMES gbk;     Query OK, 0 rows affected (0.03 sec)mysql&gt; SELECT @a:='MySQL 技术内幕 '; Query OK, 0 rows affected (0.03 sec)mysql&gt; SELECT @a,HEX(@a),LENGTH(@a),CHAR_LENGTH(@a)\G; ***************************** 1. row **************************** a: MySQL 技术内幕HEX(a): 4D7953514CBCBCCAF5C4DAC4BBLENGTH (a): 13CHAR_LENGTH(a): 91 row in set (0.00 sec)变 量 @ a 是 g b k 字 符 集 的 字 符 串 类 型 , 值 为 “ M y S Q L 技 术 内 幕 ”, 十 六 进 制 为 0x4D7953514CBCBCCAF5C4DAC4BB,LENGTH 函数返回 13,即该字符串占用 13 字节, 因为 gbk 字符集中的中文字符占用两个字节,因此一共占用 13 字节。CHAR_LENGTH 函数 返回 9,很显然该字符长度为 9。#VARCHAR类型VARCHAR 类型存储变长字段的字符类型,与 CHAR 类型不同的是,其存储时需要在 前缀长度列表加上实际存储的字符,该字符占用 1 ~ 2 字节的空间。当存储的字符串长度小 于 255 字节时,其需要 1 字节的空间,当大于 255 字节时,需要 2 字节的空间。所以,对 于单字节的 latin1 来说,CHAR(10)和 VARCHAR(10)最大占用的存储空间是不同的, CHAR(10)占用 10 个字节这是毫无疑问的,而 VARCHAR(10)的最大占用空间数是 11 字节,因为其需要 1 字节来存放字符长度。-------------------------------------------------注意 对于有些多字节的字符集类型,其 CHAR 和 VARCHAR 在存储方法上是一样的,同样 需要为长度列表加上字符串的值。对于 GBK 和 UTF-8 这些字符类型,其有些字符是以 1 字节 存放的,有些字符是按 2 或 3 字节存放的,因此同样需要 1 ~ 2 字节的空间来存储字符的长 度。-------------------------------------------------虽然 CHAR 和 VARCHAR 的存储方式不太相同,但是对于两个字符串的比较,都只比 较其值,忽略 CHAR 值存在的右填充,即使将 SQL _MODE 设置为 PAD_CHAR_TO_FULL_ LENGTH 也一样,例如:mysql&gt; CREATE TABLE t ( a CHAR(10), b VARCHAR(10));    Query OK, 0 rows affected (0.01 sec)mysql&gt; INSERT INTO t SELECT 'a','a';    Query OK, 1 row affected (0.00 sec)    Records: 1  Duplicates: 0  Warnings: 0mysql&gt; SELECT a=b FROM t\G;    *************************** 1. row ***************************    a=b: 1    1 row in set (0.00 sec)    mysql&gt; SET SQL_MODE='PAD_CHAR_TO_FULL_LENGTH';    Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT a=b FROM t\G;    *************************** 1. row ***************************    a=b: 1    1 row in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>其他的字符串类型：BINARY、VARBINARY、BLOB、TEXT</strong></p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181115180030793-1819767308.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。BLOB：     1._BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。     2._BLOB存储的数据只能整体读出。     3._TEXT可以指定字符集，_BLO不用指定字符集。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="五-枚举类型与集合类型"><a href="#五-枚举类型与集合类型" class="headerlink" title="五 枚举类型与集合类型"></a>五 枚举类型与集合类型</h1><p>　　字段的值只能在给定范围中选择，如单选框，多选框，如果你在应用程序或者前端不做选项限制，在MySQL的字段里面也能做限制<br>　　enum 单选    只能在给定的范围内选一个值，如性别 sex 男male/女female<br>　　set 多选 在给定的范围内可以选择一个或一个以上的值（爱好1,爱好2,爱好3…）</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>          枚举类型（enum）            An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.)            示例：                CREATE TABLE shirts (                    name VARCHAR(40),                    size ENUM('x-small', 'small', 'medium', 'large', 'x-large')                );                INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),('polo shirt','small');          集合类型（set）            A SET column can have a maximum of 64 distinct members.            示例：                CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));                INSERT INTO myset (col) VALUES ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>    mysql&gt; create table consumer(     -&gt; name varchar(50),    -&gt; sex enum('male','female'),    -&gt; level enum('vip1','vip2','vip3','vip4','vip5'), #在指定范围内，多选一    -&gt; hobby set('play','music','read','study') #在指定范围内，多选多    -&gt; );    mysql&gt; insert into consumer values          -&gt; ('xiaogui','male','vip5','read,study'),        -&gt; ('taibai','female','vip1','girl');    mysql&gt; select * from consumer;    +------+--------+-------+------------+    | name | sex    | level | hobby      |    +------+--------+-------+------------+    | xiaogui | male   | vip5  | read,study |    | taibai | female | vip1  |            |    +------+--------+-------+------------+</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MMySQL完整性约束</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9968396.html#_label1">一 介绍</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9968396.html#_label2">二 not null与default</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9968396.html#_label3">三 unique</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9968396.html#_label4">四 primary key</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9968396.html#_label5">五 auto_increment</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9968396.html#_label6">六 foreign key</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9968396.html#_label7">七 作业</a></li></ul><h1 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一 介绍"></a>一 介绍</h1><p>　　约束条件与数据类型的宽度一样，都是可选参数</p><p>　　作用：用于保证数据的完整性和一致性<br>　　主要分为：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>PRIMARY KEY (PK)    标识该字段为该表的主键，可以唯一的标识记录FOREIGN KEY (FK)    标识该字段为该表的外键NOT NULL    标识该字段不能为空UNIQUE KEY (UK)    标识该字段的值是唯一的AUTO_INCREMENT    标识该字段的值自动增长（整数类型，而且为主键）DEFAULT    为该字段设置默认值UNSIGNED 无符号ZEROFILL 使用0填充</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　说明：</p><p>　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>1. 是否允许为空，默认NULL，可设置NOT NULL，字段不允许为空，必须赋值2. 字段是否有默认值，缺省的默认值是NULL，如果插入记录时不给字段赋值，此字段使用默认值sex enum('male','female') not null default 'male'age int unsigned NOT NULL default 20 必须为正值（无符号） 不允许为空 默认是203. 是否是key主键 primary key外键 foreign key索引 (index,unique...)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="二-not-null与default"><a href="#二-not-null与default" class="headerlink" title="二 not null与default"></a>二 not null与default</h1><p>　　是否可空，null表示空，非字符串<br>　　not null - 不可空<br>　　null - 可空</p><p>　　</p><p>　　默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值<br>　　create table tb1(<br>　　　　nid int not null defalut 2,<br>　　　　num int not null<br>　　)；</p><p>　　先说一点：在我们插入数据的时候，可以这么写insert into tb1(nid，num) values（1，‘chao’）；就是在插入输入的时候，指定字段插入数据，如果我在只给num插入值，可以这样写insert into tb1(num) values(‘chao’);还可以插入数据的时候，指定插入数据字段的顺序：把nid和num换个位置，但是对应插入的值也要换位置。注意：即便是你只给一个字段传值了，<strong>那么也是生成一整条记录</strong>，这条记录的其他字段的值如果可以为空，那么他们就都是null空值，如果不能为空，就会报错。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>==================not null====================mysql&gt; create table t1(id int); #id字段默认可以插入空mysql&gt; desc t1;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id    | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+mysql&gt; insert into t1 values(); #可以插入空mysql&gt; create table t2(id int not null); #设置字段id不为空mysql&gt; desc t2;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id    | int(11) | NO   |     | NULL    |       |+-------+---------+------+-----+---------+-------+mysql&gt; insert into t2 values(); #不能插入空ERROR 1364 (HY000): Field 'id' doesn't have a default value==================default====================#设置id字段有默认值后，则无论id字段是null还是not null，都可以插入空，插入空默认填入default指定的默认值mysql&gt; create table t3(id int default 1);mysql&gt; alter table t3 modify id int not null default 1;==================综合练习====================mysql&gt; create table student(    -&gt; name varchar(20) not null,    -&gt; age int(3) unsigned not null default 18,    -&gt; sex enum('male','female') default 'male',    -&gt; hobby set('play','study','read','music') default 'play,music'    -&gt; );mysql&gt; desc student;+-------+------------------------------------+------+-----+------------+-------+| Field | Type                               | Null | Key | Default    | Extra |+-------+------------------------------------+------+-----+------------+-------+| name  | varchar(20)                        | NO   |     | NULL       |       || age   | int(3) unsigned                    | NO   |     | 18         |       || sex   | enum('male','female')              | YES  |     | male       |       || hobby | set('play','study','read','music') | YES  |     | play,music |       |+-------+------------------------------------+------+-----+------------+-------+mysql&gt; insert into student(name) values('chao');mysql&gt; select * from student;+------+-----+------+------------+| name | age | sex  | hobby      |+------+-----+------+------------+| chao|  18 | male | play,music |+------+-----+------+------------+</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　<strong>注意一点：如果是非严格模式，int类型不传值的话会默认为0，因为null不是int类型的，字段是int类型，所以他会自动将null变为0</strong></p><h1 id="三-unique"><a href="#三-unique" class="headerlink" title="三 unique"></a>三 unique</h1><p>　　独一无二，唯一属性：id，身份证号等</p><p>　　是一种key，唯一键，是在数据类型之外的附加属性，其实还有加速查询的作用，后面再讲这个。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>============设置唯一约束 UNIQUE===============方法一：create table department1(id int,name varchar(20) unique,comment varchar(100));方法二：create table department2(id int,name varchar(20),comment varchar(100),constraint uk_name unique(name));mysql&gt; insert into department1 values(1,'IT','技术');Query OK, 1 row affected (0.00 sec)mysql&gt; insert into department1 values(1,'IT','技术');ERROR 1062 (23000): Duplicate entry 'IT' for key 'name'</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>create table service(id int primary key auto_increment,name varchar(20),host varchar(15) not null,port int not null,unique(host,port) #联合唯一);mysql&gt; insert into service values    -&gt; (1,'nginx','192.168.0.10',80),    -&gt; (2,'haproxy','192.168.0.20',80),    -&gt; (3,'mysql','192.168.0.30',3306)    -&gt; ;Query OK, 3 rows affected (0.01 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; insert into service(name,host,port) values('nginx','192.168.0.10',80);ERROR 1062 (23000): Duplicate entry '192.168.0.10-80' for key 'host'</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="四-primary-key"><a href="#四-primary-key" class="headerlink" title="四 primary key"></a>四 primary key</h1><p>　　从约束角度看primary key字段的值不为空且唯一，那我们直接使用not null+unique不就可以了吗，要它干什么？</p><p>　　主键primary key是innodb存储引擎组织数据的依据，innodb称之为索引组织表，一张表中必须有且只有一个主键。</p><p>　　</p><p>　　一个表中可以：</p><p>　　　　单列做主键<br>　　　　多列做主键（复合主键或者叫做联合主键）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>unique key和primary key都是MySQL的特殊类型，不仅仅是个字段约束条件，还称为索引，可以加快查询速度，这个索引功能我们后面再讲，现在只讲一下这些key作为约束条件的效果。    关于主键的强调内容：        1.一张表中必须有，并且只能由一个主键字段：innodb引擎下存储表数据的时候，会通过你的主键字段的数据来组织管理所有的数据，将数据做成一种树形结构的数据结构，帮你较少IO次数，提高获取定位数据、获取数据的速度，优化查询。            解释：如果我们在一张表中没有设置primary key，那么mysql在创建表的时候，会按照顺序从上到下遍历你设置的字段，直到找到一个not null unique的字段，自动识别成主键pri，通过desc可以看到，这样是不是不好啊，所以我们在创建表的时候，要给他一个主键，让他优化的时候用，如果没有pri也没有not null unique字段，那么innodb引擎下的mysql被逼无奈，你没有设置主键字段，主键又有不为空且唯一的约束，又不能擅自给你的字段加上这些约束，那么没办法，它只能给你添加一个隐藏字段来帮你组织数据，如果是这样，你想想，主键是不是帮我们做优化查询用的啊，这个优化是我们可以通过主键来查询数据：例如：如果我们将id设置为主键，当我们查一个id为30的数据的时候，也就是select * from tb1 where id=30；这个查询语句的速度非常快，不需要遍历前面三十条数据，就好像我们使用的字典似的，找一个字，不需要一页一页的翻书，可以首先看目录，然后看在哪一节，然后看在哪一页，一步步的范围，然后很快就找到了，这就像我们说的mysql的索引(主键、唯一键)的工作方式，一步一步的缩小范围来查找，几步就搞定了，所以通过主键你能够快速的查询到你所需要的数据，所以，如果你的主键是mysql帮你加的隐藏的字段，你查询数据的时候，就不能将这个隐藏字段作为条件来查询数据了，就不能享受到优化后的查询速度了，对么        2.一张表里面，通常都应该有一个id字段，而且通常把这个id字段作为主键，当然你非要让其他的字段作为主键也是可以的，看你自己的设计，创建表的时候，一般都会写create table t1(id int primary key);id int primary key这个东西在建表的时候直接就写上</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; create table t1(id int not null unique);Query OK, 0 rows affected (0.02 sec)mysql&gt; desc t1;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id    | int(11) | NO   | PRI | NULL    |       |+-------+---------+------+-----+---------+-------+1 row in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>============单列做主键===============#方法一：not null+uniquecreate table department1(id int not null unique, #主键name varchar(20) not null unique,comment varchar(100));mysql&gt; desc department1;+---------+--------------+------+-----+---------+-------+| Field   | Type         | Null | Key | Default | Extra |+---------+--------------+------+-----+---------+-------+| id      | int(11)      | NO   | PRI | NULL    |       || name    | varchar(20)  | NO   | UNI | NULL    |       || comment | varchar(100) | YES  |     | NULL    |       |+---------+--------------+------+-----+---------+-------+rows in set (0.01 sec)#方法二：在某一个字段后用primary keycreate table department2(id int primary key, #主键name varchar(20),comment varchar(100));mysql&gt; desc department2;+---------+--------------+------+-----+---------+-------+| Field   | Type         | Null | Key | Default | Extra |+---------+--------------+------+-----+---------+-------+| id      | int(11)      | NO   | PRI | NULL    |       || name    | varchar(20)  | YES  |     | NULL    |       || comment | varchar(100) | YES  |     | NULL    |       |+---------+--------------+------+-----+---------+-------+rows in set (0.00 sec)#方法三：在所有字段后单独定义primary keycreate table department3(id int,name varchar(20),comment varchar(100),constraint pk_name primary key(id); #创建主键并为其命名pk_namemysql&gt; desc department3;+---------+--------------+------+-----+---------+-------+| Field   | Type         | Null | Key | Default | Extra |+---------+--------------+------+-----+---------+-------+| id      | int(11)      | NO   | PRI | NULL    |       || name    | varchar(20)  | YES  |     | NULL    |       || comment | varchar(100) | YES  |     | NULL    |       |+---------+--------------+------+-----+---------+-------+rows in set (0.01 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>联合主键        和联合唯一是类似的，        mysql&gt; create table t10(            -&gt;id int,            -&gt;port int,            -&gt;primary key(id,port)            -&gt; );        Query OK, 0 rows affected (0.45 sec)        mysql&gt; desc t10;        +-------+---------+------+-----+---------+-------+        | Field | Type    | Null | Key | Default | Extra |        +-------+---------+------+-----+---------+-------+        | id    | int(11) | NO   | PRI | 0       |       |         | port  | int(11) | NO   | PRI | 0       |       |        +-------+---------+------+-----+---------+-------+        2 rows in set (0.10 sec)        看key，两个都写的是pri，两个联合起来作为主键，他们两个作为一个主键，不能再有其他的主键了，也就是在创建表的时候，只能出现一次primary key方法。        有同学说，老师，我不写primary key行不，只写一个not null unique字段，当然行，但是我们应该这样做吗，是不是不应该啊，所以以后设置主键的时候，就使用primary key来指定</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>==================多列做主键================create table service(ip varchar(15),port char(5),service_name varchar(10) not null,primary key(ip,port));mysql&gt; desc service;+--------------+-------------+------+-----+---------+-------+| Field        | Type        | Null | Key | Default | Extra |+--------------+-------------+------+-----+---------+-------+| ip           | varchar(15) | NO   | PRI | NULL    |       || port         | char(5)     | NO   | PRI | NULL    |       || service_name | varchar(10) | NO   |     | NULL    |       |+--------------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)mysql&gt; insert into service values    -&gt; ('172.16.45.10','3306','mysqld'),    -&gt; ('172.16.45.11','3306','mariadb')    -&gt; ;Query OK, 2 rows affected (0.00 sec)Records: 2  Duplicates: 0  Warnings: 0mysql&gt; insert into service values ('172.16.45.10','3306','nginx');ERROR 1062 (23000): Duplicate entry '172.16.45.10-3306' for key 'PRIMARY'</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="五-auto-increment"><a href="#五-auto-increment" class="headerlink" title="五 auto_increment"></a>五 auto_increment</h1><p>　　之前我们插入数据的时候，id也需要自己来写，是不是很麻烦啊，我们是不是想，只要有一条记录就直接插入进去啊，不需要考虑说，你现在存储到第多少条数据了，对不对，所以出现了一个叫做auto_increment的属性</p><p>　　约束字段为自动增长，被约束的字段必须同时被key约束，也就是说只能给约束成key的字段加自增属性，默认起始位置为1，步长也为1.</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#不指定id，则自动增长create table student(id int primary key auto_increment,name varchar(20),sex enum('male','female') default 'male');mysql&gt; desc student;+-------+-----------------------+------+-----+---------+----------------+| Field | Type                  | Null | Key | Default | Extra          |+-------+-----------------------+------+-----+---------+----------------+| id    | int(11)               | NO   | PRI | NULL    | auto_increment || name  | varchar(20)           | YES  |     | NULL    |                || sex   | enum('male','female') | YES  |     | male    |                |+-------+-----------------------+------+-----+---------+----------------+mysql&gt; insert into student(name) values    -&gt; ('egon'),    -&gt; ('alex')    -&gt; ;mysql&gt; select * from student;+----+------+------+| id | name | sex  |+----+------+------+|  1 | egon | male ||  2 | alex | male |+----+------+------+#也可以指定idmysql&gt; insert into student values(4,'asb','female');Query OK, 1 row affected (0.00 sec)mysql&gt; insert into student values(7,'wsb','female');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from student;+----+------+--------+| id | name | sex    |+----+------+--------+|  1 | egon | male   ||  2 | alex | male   ||  4 | asb  | female ||  7 | wsb  | female |+----+------+--------+#对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长mysql&gt; delete from student;Query OK, 4 rows affected (0.00 sec)mysql&gt; select * from student;Empty set (0.00 sec)mysql&gt; insert into student(name) values('ysb');mysql&gt; select * from student;+----+------+------+| id | name | sex  |+----+------+------+|  8 | ysb  | male |+----+------+------+#应该用truncate清空表，比起delete一条一条地删除记录，truncate是直接清空表，在删除大表时用它mysql&gt; truncate student;Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into student(name) values('egon');Query OK, 1 row affected (0.01 sec)mysql&gt; select * from student;+----+------+------+| id | name | sex  |+----+------+------+|  1 | egon | male |+----+------+------+1 row in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#在创建完表后，修改自增字段的起始值mysql&gt; create table student(    -&gt; id int primary key auto_increment,    -&gt; name varchar(20),    -&gt; sex enum('male','female') default 'male'    -&gt; );mysql&gt; alter table student auto_increment=3;mysql&gt; show create table student;.......ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mysql&gt; insert into student(name) values('egon');Query OK, 1 row affected (0.01 sec)mysql&gt; select * from student;+----+------+------+| id | name | sex  |+----+------+------+|  3 | egon | male |+----+------+------+row in set (0.00 sec)mysql&gt; show create table student;.......ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8#也可以创建表时指定auto_increment的初始值，注意初始值的设置为表选项，应该放到括号外create table student(id int primary key auto_increment,name varchar(20),sex enum('male','female') default 'male')auto_increment=3;#设置步长sqlserver：自增步长    基于表级别    create table t1（        id int。。。    ）engine=innodb,auto_increment=2 步长=2 default charset=utf8mysql自增的步长：    show session variables like 'auto_inc%';    #基于会话级别    set session auth_increment_increment=2 #修改会话级别的步长    #基于全局级别的    set global auth_increment_increment=2 #修改全局级别的步长（所有会话都生效）#！！！注意了注意了注意了！！！If the value of auto_increment_offset is greater than that of auto_increment_increment, the value of auto_increment_offset is ignored. 翻译：如果auto_increment_offset的值大于auto_increment_increment的值，则auto_increment_offset的值会被忽略 ，这相当于第一步步子就迈大了，扯着了蛋比如：设置auto_increment_offset=3，auto_increment_increment=2mysql&gt; set global auto_increment_increment=5;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global auto_increment_offset=3;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like 'auto_incre%'; #需要退出重新登录+--------------------------+-------+| Variable_name            | Value |+--------------------------+-------+| auto_increment_increment | 1     || auto_increment_offset    | 1     |+--------------------------+-------+create table student(id int primary key auto_increment,name varchar(20),sex enum('male','female') default 'male');mysql&gt; insert into student(name) values('egon1'),('egon2'),('egon3');mysql&gt; select * from student;+----+-------+------+| id | name  | sex  |+----+-------+------+|  3 | egon1 | male ||  8 | egon2 | male || 13 | egon3 | male |+----+-------+------+</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="六-foreign-key"><a href="#六-foreign-key" class="headerlink" title="六 foreign key"></a>六 foreign key</h1><p>　　<strong>一 快速理解foreign key（外键其实就是标明表和表之间的关系，表和表之间如果有关系的话就三种：一对一，多对一，多对多，我们挨个看看~）</strong></p><p>　　　　员工信息表有三个字段：工号  姓名  部门</p><p>　　　　公司有3个部门，但是有1个亿的员工，那意味着部门这个字段需要重复存储，部门名字越长，越浪费</p><p>　　　　那这就体现出来了三个缺点：</p><p>　　　　　　1.表的组织结构不清晰：员工的信息、部门的信息等等都掺在一张表里面。</p><p>　　　　　　2.浪费空间，每一条信息都包含员工和部门，多个员工从属一个部门，也需要每个员工的信息里都包含着部门的信息，浪费硬盘空间。</p><p>　　　　　　3.扩展性极差：如果想修改一个部门的信息，比如修改部门名称，那么这个包含员工和部门信息的表中的所有的包含这个部门信息的数据都需要进行修改，那么修改起来就非常麻烦，这是非常致命的缺点。</p><p>　　　　解决方法：（画一个excel表格来表示一下效果~~）</p><p>　　　　　　我们完全可以定义一个部门表，解耦和</p><p>　　　　　　我们虽然将部门表提出来了，但是员工表本身是和部门有联系的，你光把部门信息提出来还是不够的，还需要建立关联</p><p>　　　　　　然后让员工信息表关联该表，如何关联，即foreign key　</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120134926941-1019804865.png" alt="img"></p><p> 　　　　在解释一下：数据要拆到不同表里面存着，你要站在两个表的角度来看两者之间的关系，你站在部门表的角度看，一个部门包含多个员工，站在员工表看，多个员工属于一个部门，以我们上课来举个例子看：现在的多个老师可以讲一个课程python，那么老师对于课程表来说就是多对一个关系，那这是不是就是最终关系呢，我们还需要站在课程表的角度来看，多个课程能不能被一个老师教啊，这个看业务场景，你看咱们学校就不行，讲python的只能讲python，但是我们上的小学，初中，高中是不是多个课程可以被一个老师教啊，所以从老男孩的业务来看，课程表对老师表是一对一的，即便是你多个老师可以讲这一门课程，但是这一门可能对应的那几个老师只能讲这一门，不能讲其他的课程，所以他们只是单纯的多对一的关系，多个老师对应一门课程，但是小学、初中、高中的业务，多个老师可以教一门课程，同样这多个老师每个老师又可以教多门课程，那么从课程表角度来看，多个课程也能从属一个老师，所以是多对多的关系：看下图</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120140818625-1670827769.png" alt="img"></p><p>　　<strong>二 一对多的关系</strong>　　</p><p>　　　　我们在看看员工和部门这个多对一的关系表：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120144851634-1641860170.png" alt="img"></p><p>　　　　如果我们没有做强制的约束关系，那么在员工表里面那个部门id可以随便写，即便是部门表里面没有这个id号，它也是可以写的，但是这样写就错了，因为业务不允许，并且这个数据完全没用，根本就不存在这个部门，哪里来的这个部门的员工呢，对不对，所以要做一个硬性的关系，你员工里面的部门id一定要来自于部门表的id字段。怎么来做这个硬性关系呢，通过外键foreign key，怎么叫外键，就是跟外部的一个表进行关联，建立这种硬性的关系，就叫做外键，就像我们上面这两个表似的，左边的员工表有一个字段(部门id字段)来自于右边的部门表，那么我们就可以通过数据库在员工表的部门id字段加上一个foreign key，外键关联到右边部门表的id字段，这样就建立了这种硬性的关系了，之前我们是看着两张表之间有关系，但是没有做强制约束，还是两张普通的表，操作其中任何一个，另外一个也没问题，但是加上了这种强制关系之后，他们两个的操作也就都关联起来了，具体操作看下面的代码：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120151602446-643961969.png" alt="img"></p><p>　　　　部门表是被关联的表，员工表是关联表，也就是员工表要关联部门表，对吧，如果我们先创建员工表，在创建员工表的时候加外键关系，就会报错，看效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120152533625-1565302510.png" alt="img"></p><p>　　　　所以我们应该先建立部门表，也就是被关联的表，因为关联表中的字段的数据是来根据被关联表的被关联字段的数据而来的。</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120152712430-25536712.png" alt="img"></p><p>　　　　然后看一下表结构：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120152905752-1329526259.png" alt="img"></p><p>　　　　表创建好了，如果我们直接给员工表插入几条数据，那么会报错，因为，你的部门还没有呢，你的员工表里面的那个dep_id外键字段的数据从何而来啊？看效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120153111250-1169885498.png" alt="img"></p><p>　　　　然后我们先插入部门的数据，然后再插入员工的数据：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120153240961-1689722900.png" alt="img"></p><p>　　　　然后查看一下数据：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120153315045-1186082443.png" alt="img"></p><p>　　　　数据没问题了，但是你有没有发现一个问题，就是员工表的id从6开始的，因为我们前面插入了5条数据，失败了，虽然失败了，但是id自动增长了。</p><p>　　　　所以有引出一个问题，如果想让id从头开始，我们可以把这些数据删掉，用delete的删除是没用的，需要用truncate来删除，这是清空表的意思。</p><p>　　　　看一下delete：</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120153554703-1406210070.png" alt="img"></p><p>　　　　delete不是用来清空表的，是用来删除一些你想删除的符合某些条件的数据，一般用在delete from tb1 where id&gt;20；这样的，如果要清空表，让id置零，使用truncate</p><p>　　　　再看一下truncate：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120154024721-179214293.png" alt="img"></p><p>　　　　然后查看一下数据看看：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120154051601-284934776.png" alt="img"></p><p>　　　　ok，大家练习一下吧<del>~</del></p><p> 　　</p><p>　　　　我们来看一下，如果对关联的表进行修改的话会有什么效果，首先我们先修改一下部门表的id字段中的某个数据，将id的值改一下</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120154500902-1514552894.png" alt="img"></p><p>　　　　报错了，那我们改一改员工表里面的外键字段dep_id，改它的值来试试：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120154652114-761405114.png" alt="img"></p><p>　　　　还是报错了！我靠，那我试试删除一下试试，解散一个部门，删除他的数据：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120154736474-1820083889.png" alt="img"></p><p>　　　　报错了！不让你删除，因为你删除之后，员工表里面的之前属于这个部门的记录找不到对应的部门id了，就报错了</p><p>　　　　那我删除一下员工表里面关于这个要被解散的部门的员工数据，按理说是不是应该没问题啊，来看看效果：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120155057295-1099231759.png" alt="img"></p><p>　　　　删除成功了，完全没问题啊，那么关于这个部门的所有员工数据都被删除了，也就是说，你这个部门下面没有任何员工了，没有了限制了相当于，所以我们尝试一下看看现在能不能删除部门表里面的这个部门了</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120155259498-1676374078.png" alt="img"></p><p>　　　　ok~可以删除了</p><p>　　　　虽然我们修改部门表或者员工表里面的部门id，但是我们可以删除，但是删除这个被关联表部门表的数据的时候由于有关联关系的存在，所以删除的时候也很麻烦，要先将关联数据删除，才能删除被关联的表的数据。</p><p>　　　　刚才我们删除了教学部这个部门，当我们想解散这个部门的时候，首先想到的是什么，是不是我们的部门表，想直接操作部门表进行删除，对吧，想修改部门的id号，是不是首先想到的也是操作部门表进行修改，把部门的id修改了，但是我们由于关联关系的存在，不得不考虑关联表中的数据，对不对，所以操作就变得很麻烦了，有没有简单的方法呢？我们想做的是不是说，我想删除一个部门，直接删除部门表里面的数据就行了，是不是达到这个效果，删除一个部门的时候，与这个部门关联的所有的员工表的那些数据都跟着删除，或者我更新部门表中一个部门的id号，那么关联的员工表中的关联字段的部门id号跟着自动更新了，</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120160841065-272740197.png" alt="img"></p><p>　　</p><p>　　　　看一下解决办法：</p><p>　　　　首先我们把之前的两个表删除了，能先删除部门表吗？如果删了部门表，你的员工表是不是找不到对应关系了，你说会不会报错啊，所以先删除员工表：</p><p>　　　　　　1.先删除关联表，再删除被关联表，然后我们重新建立两个表，然后建表的时候说一下咱们的解决方案。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120161230284-1451777591.png" alt="img"></p><p>　　　　　　2.重建表，我们现在要解决的问题是：我们要达到一个在做某个表(被关联表)更新或者删除操作的时候，关联表的数据同步的进行更新和删除的效果，所以我们在建表的时候，可以加上两个功能：同步更新和同步删除：看看如何实现：在建立关联关系的时候，加上这两句： on delete cascade和 on update cascade</p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120162027140-391143965.png" alt="img"></p><p>　　　　　　然后把我们之间的表和数据都插入进去：然后再进行更新删除操作：</p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120162127654-2145260854.png" alt="img"></p><p>　　　　　　然后我们再直接删除部门表里面的数据的时候，你看看结果：</p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120162232053-2012516333.png" alt="img"></p><p>　　　　　　成功了，并且员工表里面关联部门表id的数据也都删除了，是不是达到了我们刚才想要实现的效果呀</p><p>　　　　　　下面我们来看一下更新操作，我们之前说更新一个部门的id号，注意一个问题昂，我更新部门的名称，你说有影响吗？肯定没有啊，因为我员工表并不是关联的部门的名称字段，而是关联的部门的id字段，你改部门名称没关系，我通过你的id照样找到你，但是你如果改了id号，那么我员工表里面的id号和你不匹配了，我就没法找到你，所有当你直接更新部门的id的时候，我就给你报错了，大哥，你想改的是关联字段啊，考虑一下关联表的数据们的感受行不行。我们来看一下加上 on update cascade之后的效果：</p><p> 　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120162743120-1025924790.png" alt="img"></p><p>　　　　　　将部门id为2的部门的id改成了200，完全ok，员工表里面之前关联id为2的部门的数据都改成了关联id为200的数据了。说明同步更新也是没问题的。</p><p> 　　<strong>我们总结一下foreign key的下面几个约束作用：</strong></p><p>　　　　1、先要建立被关联的表才能建立关联表</p><p>　　　　2、在插入数据记录的时候，要先想被关联表中插入数据，才能往关联表里面插入数据</p><p>　　　　3、更新或者删除数据的时候，都需要考虑关联表和被关联表的关系</p><p>　　　　　　解决方案：</p><p>　　　　　　　　a.删除表的时候，先删除关联表，再删除被关联表</p><p>　　　　　　　　b.重建表的时候，在加外键关联的时候加上这两句：on delete cascade 和 on update cascade</p><p> 　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ContractedBlock.gif" alt="img"> 简单测试</p><p>　　一对多的内容大致就说完了，我们看一下多对多的关系</p><p>　　<strong>三 多对多关系</strong></p><p> 　　　　我们上面大致提了一下多对多的关系，下面我们通过一个例子来细讲一下，这个例子就用–&gt;书和出版社的关系来看吧：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120171740684-1420625094.png" alt="img"></p><p>　　　　上面是一对多没问题，我们再来看看书和作者的关系：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120171943958-248866141.png" alt="img"></p><p>　　　　一本书可以有多个作者，一个作者可不可以写多本书，两者之间是不是站在谁的角度去看都是一个一对多的关系啊，那这就是多对多的关系，那我们创建表的时候，需要将两个表都加一个foreign key的字段，但是你添加字段的时候，你想想，能直接给两个表都这一个foreign key字段吗，两个谁先创建，谁后创建，是不是都不行啊，两个表的创建是不是都依赖着另外一张表啊，所以我们之前的加外键字段的方式对于这种多对多的关系是不是就不好用啦，怎么办，我们需要通过第三张表来缓和一下两者的关系，通过第三张表来创建双方的关系</p><p>　　　　我们先创建书表和作者表，然后创建第三张表，第三张表就需要有一个字段外键关联书表，还有一个字段外键关联作者表</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120172905486-41616144.png" alt="img"></p><p>　　　　然后我们如果想查一下alex出了哪些书，你可以怎么查，想一下，首先在author作者表里面找一个alex的id是多少，alex的id为2，然后找一个第三张表里面author_id为2的数据中book的id，然后拿着这些book的id去book表里面找对应的book名称，你就能够知道alex这个作者出了哪几本书了，对不对，这就是一个多表查询的一个思路</p><p>　　　　来我们创建一下试试看（学了foreign key，这个东西是不是很简单啊，两个foreign key嘛~~）</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120173957460-1521536555.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120174227313-2029106582.png" alt="img"></p><p>　　　　建立前两张表，插入数据，建立第三张表</p><p>　　　　然后给第三张表插入一些数据：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120174348982-440298530.png" alt="img"></p><p>　　　　查看一下数据：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120174408928-1564991357.png" alt="img"></p><p>　　　　数据就创建好了，多对多就讲完了<del>~</del></p><p>　　</p><p>　　<strong>四 一对一关系</strong></p><p>　　　　我们来以咱们学校的学生来举例：</p><p>　　　　最开始你只是一个客户，可能还处于咨询考虑的阶段，还没有转化为学生，也有的客户已经转换为学生了，说白了就是你交钱了，哈哈</p><p>　　　　那我们来建两个表：客户表和学生表</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120190209104-630390523.png" alt="img"></p><p>　　　　客户表里面存着客户的信息，学生表里面存着客户转换为学生之后的学生信息，那么这两个表是什么关系呢？你想一下，学生是不是从客户转换过来的，那么一个学生能对应多个用户的信息吗？当然是不能的，那么一个客户能对应多个学生的信息吗，当然也是不能的，那么他们两个就是一对一的关系，那这个关系该怎么建立呢？我们知道通过外键可以建立关系，如果在客户表里面加外键关联学生表的话，那说明你的学生表必须先被创建出来，这样肯定是不对的，因为你的客户表先有的，才能转换为学生，那如果在学生表加外键关联客户表的话，貌似是可以的，不过一个学生只对应一个客户，那么这个关系怎么加呢，外键我们知道是一对多的，那怎么搞？我们可以把这个关联字段设置成唯一的，不就可以了吗，我既和你有关联，我还不能重复，那就做到了我和你一对一的关联关系。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181120191244240-594088333.png" alt="img"></p><p>　　　　</p><p>　　<strong>表关系的总结</strong>　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>分析步骤：#1、先站在左表的角度去找是否左表的多条记录可以对应右表的一条记录，如果是，则证明左表的一个字段foreign key 右表一个字段（通常是id）#2、再站在右表的角度去找是否右表的多条记录可以对应左表的一条记录，如果是，则证明右表的一个字段foreign key 左表一个字段（通常是id）#3、总结：#多对一：如果只有步骤1成立，则是左表多对一右表如果只有步骤2成立，则是右表多对一左表#多对多如果步骤1和2同时成立，则证明这两张表时一个双向的多对一，即多对多,需要定义一个这两张表的关系表来专门存放二者的关系#一对一:如果1和2都不成立，而是左表的一条记录唯一对应右表的一条记录，反之亦然。这种情况很简单，就是在左表foreign key右表的基础上，将左表的外键字段设置成unique即可</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><pre><code>#一对多或称为多对一三张表：出版社，作者信息，书一对多（或多对一）：一个出版社可以出版多本书关联方式：foreign key</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>=====================多对一=====================create table press(id int primary key auto_increment,name varchar(20));create table book(id int primary key auto_increment,name varchar(20),press_id int not null,foreign key(press_id) references press(id)on delete cascadeon update cascade);insert into press(name) values('北京工业地雷出版社'),('人民音乐不好听出版社'),('知识产权没有用出版社');insert into book(name,press_id) values('九阳神功',1),('九阴真经',2),('九阴白骨爪',2),('独孤九剑',3),('降龙十巴掌',2),('葵花宝典',3)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><pre><code>#多对多三张表：出版社，作者信息，书多对多：一个作者可以写多本书，一本书也可以有多个作者，双向的一对多，即多对多　　关联方式：foreign key+一张新的表</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>=====================多对多=====================create table author(id int primary key auto_increment,name varchar(20));#这张表就存放作者表与书表的关系，即查询二者的关系查这表就可以了create table author2book(id int not null unique auto_increment,author_id int not null,book_id int not null,constraint fk_author foreign key(author_id) references author(id)on delete cascadeon update cascade,constraint fk_book foreign key(book_id) references book(id)on delete cascadeon update cascade,primary key(author_id,book_id));#插入四个作者，id依次排开insert into author(name) values('egon'),('alex'),('yuanhao'),('wpq');#每个作者与自己的代表作如下1 egon:       1 九阳神功      2 九阴真经      3 九阴白骨爪      4 独孤九剑      5 降龙十巴掌      6 葵花宝典2 alex:       1 九阳神功      6 葵花宝典3 yuanhao:      4 独孤九剑      5 降龙十巴掌      6 葵花宝典4 wpq:      1 九阳神功insert into author2book(author_id,book_id) values(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,6),(3,4),(3,5),(3,6),(4,1);</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　中间那一张存放关系的表，对外关联的字段可以联合唯一</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><pre><code>#一对一两张表：学生表和客户表一对一：一个学生是一个客户，一个客户有可能变成一个学校，即一对一的关系关联方式：foreign key+unique</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#一定是student来foreign key表customer，这样就保证了：#1 学生一定是一个客户，#2 客户不一定是学生，但有可能成为一个学生create table customer(id int primary key auto_increment,name varchar(20) not null,qq varchar(10) not null,phone char(16) not null);create table student(id int primary key auto_increment,class_name varchar(20) not null,customer_id int unique, #该字段一定要是唯一的foreign key(customer_id) references customer(id) #外键的字段一定要保证uniqueon delete cascadeon update cascade);#增加客户insert into customer(name,qq,phone) values('李飞机','31811231',13811341220),('王大炮','123123123',15213146809),('守榴弹','283818181',1867141331),('吴坦克','283818181',1851143312),('赢火箭','888818181',1861243314),('战地雷','112312312',18811431230);#增加学生insert into student(class_name,customer_id) values('脱产3班',3),('周末19期',4),('周末19期',5);</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>例一：一个用户只有一个博客    用户表：    id  name    1    egon    2    alex    3    wupeiqi    博客表              fk+unique    id url name_id    1  xxxx   1    2  yyyy   3    3  zzz    2例二：一个管理员唯一对应一个用户    用户表：    id user  password    1  egon    xxxx    2  alex    yyyy    管理员表：       fk+unique    id user_id password    1   1      xxxxx    2   2      yyyyy</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　了解：将来你们接触某一些大型项目的时候，尽量不要给表建立外键关系，因为外键直接在数据库级别就变成耦合的了，那么我们要拓展或者删除或者更改某些数据库或者数据表的时候，拓展起来就比较难，我们可以自己从自己的程序代码的逻辑层面上将这些关联关系建立好，有很多公司就是这么做的，利于拓展，如果我们加了很多的foreign key ，那么当你想删除一个表的时候，可能会牵一发而动全身，了解一下就可以了</p><p> 　　查看所有外键的名称的方法： select REFERENCED_TABLE_SCHEMA,REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME,table_name,CONSTRAINT_NAME from information_schema.key_column_usage;  #包含我们创建外键的时候，mysql帮我们自动生成的外键名称。</p><p>　　外键这个key的名称我们可以通过constraint来指定：</p><p>　　删除外键关联，添加外键字段并添加外键关联：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; desc e3;+-------+----------+------+-----+---------+----------------+| Field | Type     | Null | Key | Default | Extra          |+-------+----------+------+-----+---------+----------------+| id    | int(11)  | NO   | PRI | NULL    | auto_increment || xx    | char(11) | YES  |     | NULL    |                || ee_id | int(11)  | YES  | MUL | NULL    |                |+-------+----------+------+-----+---------+----------------+3 rows in set (0.10 sec)mysql&gt; alter table e3 drop ee_id;  #直接删除外键字段是不可以的ERROR 1553 (HY000): Cannot drop index 'ee_id': needed in a foreign key constraintmysql&gt; alter table e3 drop foreign key e3_ibfk_1; #通过上面的方法找到这个表的外键字段，然后先解除外键字段的关系，才能删除外键字段Query OK, 0 rows affected (0.11 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc e3;+-------+----------+------+-----+---------+----------------+| Field | Type     | Null | Key | Default | Extra          |+-------+----------+------+-----+---------+----------------+| id    | int(11)  | NO   | PRI | NULL    | auto_increment || xx    | char(11) | YES  |     | NULL    |                || ee_id | int(11)  | YES  | MUL | NULL    |                |+-------+----------+------+-----+---------+----------------+3 rows in set (0.10 sec)#解除了外键关系之后，是可以随意插入数据的，就没有了外键的约束#但是表结构的key那一项里面还是显示MUL，不过没关系，已经没有外键约束的效果了，大家可以插入一条原来那个关联表的字段中不存在的数据来试一试，肯定是没问题的，我没有保存下来，就不给大家演示啦，然后然后我们就可以删除这个外键字段了mysql&gt; alter table e3 drop ee_id;Query OK, 0 rows affected (0.65 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc e3;+-------+----------+------+-----+---------+----------------+| Field | Type     | Null | Key | Default | Extra          |+-------+----------+------+-----+---------+----------------+| id    | int(11)  | NO   | PRI | NULL    | auto_increment || xx    | char(11) | YES  |     | NULL    |                |+-------+----------+------+-----+---------+----------------+2 rows in set (0.10 sec)#看添加外键字段和外键关联：首先创建一个e2表，包含一个id字段，别忘了id字段最少也要是unique属性，primary key当然最好啦</code></pre><p>  mysql&gt; alter table e3 add ee_id int;<br>  Query OK, 0 rows affected (0.64 sec)<br>  Records: 0 Duplicates: 0 Warnings: 0</p><p>  mysql&gt; alter table e3 add foreign key(ee_id) references e2(id);<br>  Query OK, 0 rows affected (0.83 sec)<br>  Records: 0 Duplicates: 0 Warnings: 0</p><p>  #添加关联删除和关联更新的操作：当删除主表数据的时候，从表中有关的数据都跟着删除，当主表的关系字段修改的时候，从表对应的关系字段的值也更着更新。</p><p>　　alter table 从表 add foreign key(从表字段) references 主表(主表字段) on delete cascade on update cascade;</p><p>  #另外，能够作为主表(也就是多对一关系的那个一表的被关联的那个字段)的关系字段的约束最少要是唯一的unique属性。</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　</p><p>　　　　<strong>外键约束有三种约束模式（都是针对父表的约束）：</strong></p><p>　　　　<strong>模式一： district 严格约束（默认的 ），父表不能删除或者更新已经被子表数据引用的记录</strong></p><p>　　　　<strong>模式二：cascade 级联模式：父表的操作，对应的子表关联的数据也跟着操作 。</strong></p><p>　　　　<strong>模式三：set null：置空模式，父表操作之后，子表对应的数据（外键字段）也跟着被置空。</strong></p><p>　　　　<strong>通常的一个合理的约束模式是：删除的时候子表置空；更新的时候子表级联。</strong></p><p>　　　　<strong>指定模式的语法：foreign key(外键字段)references 父表(主键字段)on delete 模式 on update 模式;</strong></p><p>　　　　<strong>注意：删除置空的前提条件是 外键字段允许为空，不然外键会创建失败。</strong></p><p>　　　　<strong>外键虽然很强大，能够进行各种约束，但是外键的约束降低了数据的可控性和可拓展性。通常在实际开发时，很少使用外键来约束。</strong></p><h1 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h1><p>　　　　将下面的角色关系在数据库中创建好，并且插入一些数据进去，自行看看该如何设计，其实下面感觉已经给你写出来了都。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170906003405866-1307219644.png" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库初识 - cls超 - 博客园</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E8%AF%86%20/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E8%AF%86%20/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#1、下载：MySQL Community Server 5.7.16http://dev.mysql.com/downloads/mysql/#2、解压如果想要让MySQL安装在指定目录，那么就将解压后的文件夹移动到指定目录，如：C:\mysql-5.7.16-winx64#3、添加环境变量【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --&gt; 【将MySQL的bin目录路径追加到变值值中，用 ； 分割】#4、初始化mysqld --initialize-insecure#5、启动MySQL服务mysqld # 启动MySQL服务#6、启动MySQL客户端并连接MySQL服务mysql -u root -p # 连接MySQL服务器#7、将mysql添加系统服务    注意：--install前，必须用mysql启动命令的绝对路径    # 制作MySQL的Windows服务，在终端执行此命令：    "c:\mysql-5.7.16-winx64\bin\mysqld" --install    # 移除MySQL的Windows服务，在终端执行此命令：    "c:\mysql-5.7.16-winx64\bin\mysqld" --remove    注册成服务之后，以后再启动和关闭MySQL服务时，仅需执行如下命令：    # 启动MySQL服务    net start mysql    # 关闭MySQL服务    net stop mysql</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>1.解压tar包cd /software   #cd到一个自己创建的文件夹中tar -xzvf mysql-5.6.21-linux-glibc2.5-x86_64.tar.gz  #解压下载下来的mysql文件，如果没在这个文件夹中，记得把文件移动到这个文件夹中，通过mv指令mv mysql-5.6.21-linux-glibc2.5-x86_64 mysql-5.6.21 #通过mv指令给这个解压出来的文件改了个名字2.添加用户与组groupadd mysql        #添加用户组useradd -r -g mysql mysql  #创建mysql用户，并添加到mysql用户组chown -R mysql:mysql mysql-5.6.21  #这是mysql用户和mysql用户组的归属chmod +x -Rf /usr/local/mysql    #赐予可执行权限3.安装数据库su mysqlcd mysql-5.6.21/scripts./mysql_install_db --user=mysql --basedir=/software/mysql-5.6.21 --datadir=/software/mysql-5.6.21/data  #使用mysql用户来将我们下载并解压的那个mysql文件，安装到/software/mysql-5.6.21/data这个目录里面4.配置文件cd /software/mysql-5.6.21/support-files  #配置文件在这个目录下cp my-default.cnf /etc/my.cnf  #copy一份my-default.cnf文件到etc目录下，并起名为my.cnf文件cp mysql.server /etc/init.d/mysql  #copy一份mysql.server文件，到etc的init.d的mysql文件夹中，启动加载的初始配置文件会有一部分在这个目录里面读取vim /etc/init.d/mysql   #若mysql的安装目录是/usr/local/mysql,则可省略此步修改文件中的两个变更值basedir=/software/mysql-5.6.21  #基础目录datadir=/software/mysql-5.6.21/data  #数据目录5.配置环境变量vim /etc/profile  #环境变量的配置文件 ，添加下面两行export MYSQL_HOME="/software/mysql-5.6.21"export PATH="$PATH:$MYSQL_HOME/bin"#使配置生效，通过source指令source /etc/profile6.添加自启动服务chkconfig --add mysqlchkconfig mysql on7.启动mysqlservice mysql start8.登录mysql及改密码与配置远程访问mysqladmin -u root password 'your_password'     #修改root用户密码mysql -u root -p     #登录mysql,需要输入密码mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'your_password' WITH GRANT OPTION;     #允许root用户远程访问（默认远程连接是不能使用root用户来连接的）mysql&gt;FLUSH PRIVILEGES;     #刷新权限9. 一些必要的初始配置（除了下面这些，将来玩mysql的时候还有很多很多的配置）1）修改字符集为UTF8vi /etc/my.cnf在[client]下面添加 default-character-set = utf8在[mysqld]下面添加 character_set_server = utf82）增加错误日志vi /etc/my.cnf在[mysqld]下面添加：log-error = /usr/local/mysql/log/error.loggeneral-log-file = /usr/local/mysql/log/mysql.log3) 设置为不区分大小写，linux下默认会区分大小写。vi /etc/my.cnf在[mysqld]下面添加：lower_case_table_name=1修改完重启：#service  mysql  restart</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　</p><p>　　　　在linux上使用mysql的时候，一定要注意的就是权限问题，linux恶心的地方就是权限问题。</p><p>　　<strong>2.mysql的简单使用演示</strong></p><p>　　　　这里只是给大家演示一下mysql是个什么样子，具体怎么管理数据，后面我们会学，这里只做演示用，因为演示一下之后，你对这个东西就有了一些简单的认识和了解，再进行后面的学的时候，你就不会摸着黑听理论了，所谓的瞎听了，哈哈。注意，我们下面会输入一些指令进行操作数据库，数据库里面的指令必须要用；分号结尾，然后才能执行，切记。<br>　　　　　　1.开启服务端，mysqld\ net start mysql<br>　　　　　　2.使用mysql自带的客户端进行连接，cmd下输入mysql -u root -p，然后回车，会提示你输入密码，此时初始的root用户还没有密码，所以还是直接回车就可以连接上了<br>　　　　　　3.show databases；先不讲里面的内容，说一下这是几个库，每个项目可以有自己单独的一个库，里面放这个项目的所有数据表<br>　　　　　　4.创建一个库：create database CRM；然后show databases；查看一下就有了这个crm库，不分大小写，统一会变成小写，对照着我们mysql安装目录下的data文件夹里面的内容看一下，库就是对应的文件夹。<br>　　　　　　5.我们目前在所有数据库之上，想在我们自己项目的库里面操作数据，就需要切换到我们自己这个crm项目的库里面进行数据的操作，切换数据库使用use + 库名，例如：use crm；就提示你切换成功了。<br>　　　　　　6.我们说过，库里面维护的数据就像一张一张的数据表，类似excel，对不对，那我们创建一张表看一下，命令：<br>　　　　　　create table student(<br>　　　　　　　　id int,<br>　　　　　　　　name char(10),<br>　　　　　　　　age int<br>　　　　　　);<br>　　　　　　7.再执行show tables;就可以看到有了一个student表<br>　　　　　　8.查看一下这个表里的数据select * from student；发现什么数据也没有<br>　　　　　　9.插入几条数据,写几条数据：insert into student values(1,’d’,18),(2,’x’,11),(3,’d’,10),(4,’k’,9);然后回车，就执行了这条指令，然后我们再查看一下这个表里面有没有数据了，执行上一条指令，select * from student；发现里面就有数据了：<br>　　　　　　　　结果：<br>　　　　　　　　mysql&gt; select * from student;<br>　　　　　　　　+——+——+——+<br>　　　　　　　　| id | name | age |<br>　　　　　　　　+——+——+——+<br>　　　　　　　　| 1 | d | 18 |<br>　　　　　　　　| 2 | x | 11 |<br>　　　　　　　　| 3 | d | 10 |<br>　　　　　　　　| 4 | k | 9 |<br>　　　　　　　　+——+——+——+<br>　　　　　　　　4 rows in set (0.00 sec)</p><p>　　　　分析一下：上面这些就是mysql数据帮我们保存的数据，以表格的外貌展示，第一行为表头，从第二行开始都是对应的数据，每列都是自己这一列规定的内容，比如id这一列是你插入的这几条数据的id，我们这个insert就是插入数据，select就是查看数据，这就是我们通过MySQL自带的客户端来操作的MySQL服务端来进行数据的操作。MySQL服务端和操作系统及硬盘打交道，快速的帮你实现数据的操作，其他的语言开发的客户端就是通过这种形式来操作数据库里面的数据的，将来我们使用python操作数据库的时候，会使用一个叫做pymysql的工具来搞，到时候会给你们讲，他就是一个咱们MySQL服务器的客户端，连接上服务端就可以操作服务端的保存的你的项目的数据了。例如用户要查看自己的信息，就通过你写的程序接受到客户的请求，通过自己的mysql客户端去MySQL服务端查看对应的信息，然后mysql服务端将这些信息发送给你的py程序客户端，你通过程序再将数据返回给你的用户，你的用户就看到了自己的信息，就是这么个过程，大家理解了吗。<br>　　　　真正的数据库维护优化等高级数据库的技术一般都是由公司的DBA来做，或者由比较懂数据库的运维来做，一般不会让开发来搞，除非你开发人员的数据库能力很强，这些NB的技术包括：数据库优化，数据库BUG解决，数据库备份（冷备、热备），保证数据不丢失，集群，高可用等等保证项目的稳定性和可用性及高并发用（很多的用户都来操作数据，你要并发），数据库各项配置参数的调优，慢sql语句的提炼和调优，数据库开发、数据库更新，数据迁移，数据恢复，分库分表等等，这些是数据库的高端技术，而针对开发人员，一般你需要学习这些：基本的开发环境使用的数据库搭建，然后增删改查就差不多了。当然如果想提升自己的能力和水平（还有薪资水平），数据库是你必须要学好的内容，但是那是你做开发之后的事情了，而且有好多同学目前已经在数据库或者运维方面很NB了，但是开发还不行啊，对不对，哈哈，好好学python，数据库不是你学习python的重点，但是必须要会一些基本的内容，懂得越多越好，ok吗，同志们<del>~</del>　　　　</p><p> 　　<strong>3.MySQL安装目录介绍</strong></p><p>　　　　看图：</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181109102923996-996317799.png" alt="img"></p><p>　　　　其中，我们重点看一下data文件夹：如果你找不到自己建立的库或者表的文件，可能不在这个data文件夹下面，连接上mysql之后，输入<code>show global variables like ``"%datadir%"``;来查看数据文件存储路径，找到路径之后，到对应路径下如果找不到这个文件夹，那么可能是隐藏的，把隐藏的文件显示一下就行了。</code></p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181109103137038-1513129894.png" alt="img"></p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181109103158055-428480257.png" alt="img"></p><p>　　　　　　</p><p>　　　　关于数据库中的这4个初始的库的详细介绍，有兴趣的同学可以来看看我的这篇文章（目前作为了解用）：<a href="https://www.cnblogs.com/clschao/articles/9928223.html">https://www.cnblogs.com/clschao/articles/9928223.html</a></p><p>　　　　其中mysql这个库我需要提一下：</p><p>　　　　　　mysql：这个是mysql整个服务的核心数据库，类似于sql server中的master表，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。</p><p>　　<strong>总结：其实这些库就是我们电脑上对应的文件夹，在mysql中显示为对应的库，来方便我们管理数据，而文件或者文件夹这种与硬盘打交道的事情就交给mysql了，我们只需要对mysql库中的数据进行操作就可以了，你可以看到，我们刚才简单使用的时候创建的一个crm库，也就是在data目录下的生成了一个crm文件夹。</strong></p><p>　　说到这里，大家对数据库有个基本的了解了呢。那么我们返回去看一下mysql的一些其他知识（提高逼格的内容<del>），回到数据库分类及mysql介绍</del></p><h3 id="四-root用户密码设置及忘记密码的解决方法"><a href="#四-root用户密码设置及忘记密码的解决方法" class="headerlink" title="四 root用户密码设置及忘记密码的解决方法"></a>四 root用户密码设置及忘记密码的解决方法</h3><p>　　再怎么说我们的root用户密码也不能为空啊对不对，所以需要设置一个密码，看下面设置密码的方法，我给了三种方法：</p><p>　　<strong>方法1： 用SET PASSWORD命令</strong><br>　　　　首先登录MySQL，使用mysql自带的那个客户端连接上mysql。<br>　　　　格式：mysql&gt; set password for 用户名@localhost = password(‘新密码’);<br>　　　　例子：mysql&gt; set password for root@localhost = password(‘123’); </p><p>　　<strong>方法2：用mysqladmin</strong>  （因为我们将bin已经添加到环境变量了，这个mysqladmin也在bin目录下，所以可以直接使用这个mysqladmin功能，使用它来修改密码）</p><p>　　　　关于mysqladmin的介绍：是一个执行管理操作的客户端程序。它可以用来检查服务器的配置和当前状态、创建和删除数据库、修改用户密码等等的功能，虽然mysqladmin的很多功能通过使用MySQL自带的mysql客户端可以搞定，但是有时候使用mysqladmin操作会比较简单。<br>　　　　格式：mysqladmin -u用户名 -p旧密码 password 新密码<br>　　　　例子：mysqladmin -uroot -p123456 password 123 </p><p>　　　　只用mysqladmin的时候，会出现一个warning警告信息：Warning: Using a password on the command line interface can be insecure.，这个没关系，是提示你，你直接在cmd下使用明文设置密码的时候，是不安全的，因为别人可以通过翻看你输入指令的历史记录来查看到你设置的密码，所以提示你一下，不信你按上下键，可以看到自己之前输入的命令，或者输入下面这个指令也可以看到：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181107144630827-1405279649.png" alt="img"></p><p>　　　　所以我们最好连接进入到mysql里面之后，在进行密码的修改和设置。<br>　　<strong>方法3：用UPDATE直接编辑那个自动的mysql库中的user表</strong><br>　　　　首先登录MySQL，连接上mysql服务端。<br>　　　　mysql&gt; use mysql;   use mysql的意思是切换到mysql这个库，这个库是所有的用户表和权限相关的表都在这个库里面，我们进入到这个库才能修改这个库里面的表。<br>　　　　mysql&gt; update user set password=password(‘123’) where user=’root’ and host=’localhost’;   其中password=password(‘123’) 前面的password是变量，后面的password是mysql提供的给密码加密用的，我们最好不要明文的存密码，对吧，其中user是一个表，存着所有的mysql用户的信息。</p><p>　　　　mysql&gt; flush privileges;  刷新权限，让其生效，否则不生效，修改不成功。</p><p>　　<strong>在忘记root密码的时候，可以这样（注意：root密码最好不要忘记，找地方记录下来，不然如果是工作中你们使用的数据库（不管是测试的还是线上的，都是比较麻烦的事情，数据库轻易不会让你重启的，不过作为一个开发来讲，你应该是无法用root用户的<del>~</del>））</strong><br>　　<strong>以windows为例：</strong><br>　　　　1. 关闭正在运行的MySQL服务，net stop mysql（这个mysql是你添加的mysqld到系统服务时的服务名）。<br>　　　　2. 打开DOS窗口，转到mysql\bin目录。<br>　　　　3. 输入mysqld –skip-grant-tables 回车。–skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证，因为之所以mysql启动之后，客户端连接的时候需要登陆认证，输入密码什么的，是因为mysql服务端启动的时候，加载了自己内部的一些权限相关信息的授权表、权限认证表什么的，这样就要求客户端必须有认证，如果启动的时没有加载这些表和设置，那么我们客户端再进行登陆的时候，就不需要认证了，那么就可以登陆上了，登陆之后，我们到mysql这个存有所有用户信息的表中去修改root用户或者别的用户的密码了，还是比较6的，但是这样搞需要关闭服务端，在实际工作中想关闭mysql服务？？你觉得可能吗？？记住这个问题，我后面给大家解决。 </p><p>　　　　　　注意一个问题，如果我们直接使用的上面这个指令，也即是mysqld –skip-grant-tables，也就是直接通过mysqld启动的mysql服务的话，我们就不能通过net stop mysql的方式来关闭mysql服务了。但是可以通过别的方式来关闭，我在安装mysql的那篇博客里面写到了，杀进程的方式，知道你肯定忘记了，再给你写一下（win10）：tasklist |findstr mysqld找到这个mysqld服务的端口号，然后taskkill /F /PID 端口号来杀死这个mysql服务的进行，以后就可以使用net start/stop mysql的方式来启动和关闭了。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181107160548009-1854647099.png" alt="img"></p><p>　　　　4. 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\bin目录。<br>　　　　5. 输入mysql回车，如果成功，将出现MySQL提示符 &gt;。<br>　　　　6. 连接权限数据库： use mysql; 。<br>　　　　6. 改密码：update user set password=password(“123”) where user=”root”;（别忘了最后加分号） 。<br>　　　　7. 刷新权限（必须步骤）：flush privileges;　。凡是涉及到密码修改或者后面我们会学到的权限修改，修改完之后全部要再执行一下这一句。<br>　　　　8. 退出 quit。<br>　　　　9. 注销系统，再进入，使用用户名root和刚才设置的新密码123登录。</p><p> 　　注意：我们在使用cmd的时候，经常需要使用管理员身份来运行cmd窗口，每次都需要自己右键选择管理员身份运行，很麻烦，所有有永久解决的方法，看我下面的操作：</p><p>　　　　1、去”C:/Windows/System32”目录找到”cmd.exe”:<br>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/026872b1f02315e603647ac94458bdfa.jpg" alt="&quot;net start mysql&quot;启动MySQL服务报错,提示发生系统错误5解决方法_MySQL"></p><p>　　　　2、右击属性,选择“以管理员身份运行”:<br>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/e84c571f5d91ecb199c4f58b81ee1d65.jpg" alt="&quot;net start mysql&quot;启动MySQL服务报错,提示发生系统错误5解决方法_MySQL"></p><p>　　　　</p><p>　　　　<strong>永久解决办法：</strong></p><p>　　　　　　1、创建“cmd.exe”快捷方式:<br>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181107150805096-1146419434.png" alt="img"></p><p>　　　　　　2、右击选择“属性”,选择“快捷方式”,再选择“高级”,在选择“以管理员身份运行”,再单击“确定”。<br>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181107150942170-1295251735.png" alt="img"></p><p>　　　　　　以后只要打开快捷方式就可以以管理员的身份运行cmd了!</p><p>*<strong><em>总结一下**</em></strong>，到目前为止，我们已经大致了解mysql了，并且知道怎么使用自带的mysql客户端来连接mysql服务端，还知道怎么修改密码什么的了，那后面的我们是不是就应该实战了呢，哈哈，实战之前，本来想带着大家使用xshell这个客户端工具来操作一下mysql，不过学它需要一些后面的知识，后面再学吧<del>不过还需要做一件事情，那就是数据库的编码问题，我们知道自己写socket简单对话程序的时候还需要双方规定好编码方式，是gbk啊还是utf-8啊等问题，不然容易报错或者乱码，对吧，mysql也存在这个问题，这个问题搞不清楚，将来你们学习、甚至工作中都会非常头疼</del>来，我们就学一下怎么把mysql的编码调好<del>~</del></p><h3 id="五-修改字符集编码"><a href="#五-修改字符集编码" class="headerlink" title="五 修改字符集编码"></a>五 修改字符集编码</h3><p>　　</p><p>　　使用数据库的时候要注意的字符集编码，其实主要的是中文乱码的问题，大家应该对编码比较熟悉了，双方沟通需要编码相同不然容易报错或者出现乱码的问题，在使用数据库的时候也会存在这样的问题，所以我们需要解决这个问题：<br>　　　　先来模拟一下这个问题：<br>　　　　我们将刚才的student数据表删除，我们再来创建一个student表，然后往这个表里面插入几条含有中文的数据来看一下效果：<br>　　　　　　1.create table student(id int,name char(10),age int);<br>　　　　　　2.insert into student value(1,’呵呵’,11),(2,’老刁’,12),(3,’dsb’,10),(4,’你好’,9);<br>　　　　　　3.select * from student;<br>　　　　　　+——+——+——+<br>　　　　　　| id | name | age |<br>　　　　　　+——+——+——+<br>　　　　　　| 1 | ?? | 11 |<br>　　　　　　| 2 | ?? | 12 |<br>　　　　　　| 3 | dsb | 10 |<br>　　　　　　| 4 | ?? | 9 |<br>　　　　　　+——+——+——+<br>　　　　　　4 rows in set (0.00 sec)<br>　　　　发现什么问题，插入的中文怎么成了??号了，乱码了。。。<br>　　　　什么原因呢？我们先来看看我们创建这个crm库的时候，是怎么创建的，输入查看库创建的是时候mysql内部实际执行的创建语句的指令（咱们自己写了个指令，但是mysql在执行的时候会按照自己的方式来执行这个执行，现在就看看它实际执行的时候是个什么语句）：show database crm\G；然后看结果：<br>　　　　　　mysql&gt; show create database crm\G<br>　　　　　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>* 1. row *</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>　　　　　　Database: crm<br>　　　　　　Create Database: CREATE DATABASE <code>crm</code> /<em>!40100 DEFAULT CHARACTER SET latin1 <em>/<br>　　　　　　1 row in set (0.04 sec)<br>　　　　可以看到，我们创建这个库的时候，mysql默认帮我们指定了一个字符集：latin1，就是上面的后面半句DEFAULT CHARACTER SET latin1，创建库的时候默认指定了latin1的意思是，在这个库里面我们创建的数据表，只要没有给表指定字符集，那么这个库里面的所有表都将是latin1字符集的(除了库创建的时候可以指定字符集之外，创建表的时候也可以指定字符集)，来看一下创建表的时候，查看表创建语句的指令(此时我们并没有在创建表的时候指定字符集对吧)：show create table student\G;看结果：<br>　　　　　　mysql&gt; show create table student\G;<br>　　　　　　<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em><br>　　　　　　Table: student<br>　　　　　　Create Table: CREATE TABLE <code>student</code> (<br>　　　　　　　　<code>id</code> int(11) DEFAULT NULL,<br>　　　　　　　　<code>name</code> char(10) DEFAULT NULL,<br>　　　　　　　　<code>age</code> int(11) DEFAULT NULL<br>　　　　　　) ENGINE=InnoDB DEFAULT CHARSET=latin1<br>　　　　　　1 row in set (0.00 sec)</p><p>　　　　发现创建表的时候，mysql也默认给我们指定了一个字符集，也是latin1，因为库就是latin1的。<br>　　　　下面我们来看一下MySQL的一些初始信息：通过指令(\s)来查看，注意只需要看里面的有关characterset的部分<br>　　　　　　mysql&gt; \s<br>　　　　　　————–<br>　　　　　　mysql Ver 14.14 Distrib 5.6.42, for Win64 (x86_64)</p><p>　　　　　　Connection id: 12<br>　　　　　　Current database: crm<br>　　　　　　Current user: root@localhost<br>　　　　　　SSL: Not in use<br>　　　　　　Using delimiter: ;<br>　　　　　　Server version: 5.6.42 MySQL Community Server (GPL)<br>　　　　　　Protocol version: 10<br>　　　　　　Connection: localhost via TCP/IP<br>　　　　　　Server characterset: latin1 #服务端是latin1<br>　　　　　　Db characterset: latin1 #数据库默认是latin1<br>　　　　　　Client characterset: gbk #我们现在用的客户端是gbk<br>　　　　　　Conn. characterset: gbk #双方连接也是gbk编码的，这个不用管<br>　　　　　　TCP port: 3306<br>　　　　　　Uptime: 4 days 18 hours 52 min 50 sec</p><p>　　　　　　Threads: 1 Questions: 88 Slow queries: 0 Opens: 70 Flush tables: 1 Open tables: 61 Queries per second avg: 0.000<br>　　　　　　————–</p><p>　　　　上面看的不够清晰，那么我们再看一下各个角色的编码（客户端、服务端，数据库等等）：<br>　　　　在mysql中执行指令：show variables like ‘%char%’；看结果：<br>　　　　　　mysql&gt; show variables like “%char%”;<br>　　　　　　+————————–+——————————————-+<br>　　　　　　| Variable_name | Value |<br>　　　　　　+————————–+——————————————-+<br>　　　　　　| character_set_client | gbk |<br>　　　　　　| character_set_connection | gbk |<br>　　　　　　| character_set_database | latin1 |<br>　　　　　　| character_set_filesystem | binary |<br>　　　　　　| character_set_results | gbk |<br>　　　　　　| character_set_server | latin1 |<br>　　　　　　| character_set_system | utf8 |<br>　　　　　　| character_sets_dir | F:\jj\mysql-5.6.42-winx64\share\charsets\ |<br>　　　　　　+————————–+——————————————-+<br>　　　　　　8 rows in set (0.00 sec)</p><p>　　　　关于上面这些编码的详细解释，看我的博客：<a href="https://www.cnblogs.com/clschao/articles/9946174.html%EF%BC%8C%E6%88%91%E5%B0%B1%E4%B8%8D%E7%BB%99%E5%A4%A7%E5%AE%B6%E8%AF%A6%E7%BB%86%E8%AF%B4%E5%95%A6%E3%80%82">https://www.cnblogs.com/clschao/articles/9946174.html，我就不给大家详细说啦。</a></p><p>　　　　那为什么出现乱码问题呢？又如何解决乱码问题呢？<br>　　　　　　原因：因为客户端mysql的字符集和服务端的字符集不一样，注意一下其中的character_set_client、character_set_connection、character_set_results这三项，我们在这里可以简单称为客户端三炮，就是因为这三炮和服务端的编码不一致导致的，所以我们需要将这三项改为和服务端一致的字符集就可以了。<br>　　　　　　解决方案：<br>　　　　　　　　<strong>一.在插入数据之前，先执行一条指令：set names latin1；</strong>临时修改客户端三炮的字符集，让客户端插入数据的时候按照服务端的字符集编码来插入数据，然后我们再插入一条数据，然后看效果：<br>　　　　　　　　　　　　mysql&gt; set names latin1;<br>　　　　　　　　　　　　Query OK, 0 rows affected (0.14 sec)<br>　　　　　　　　　　然后我们再查看一下编码：<br>　　　　　　　　　　　　mysql&gt; show variables like “%char%”;<br>　　　　　　　　　　　　+————————–+——————————————-+<br>　　　　　　　　　　　　| Variable_name | Value |<br>　　　　　　　　　　　　+————————–+——————————————-+<br>　　　　　　　　　　　　| character_set_client | latin1 |<br>　　　　　　　　　　　　| character_set_connection | latin1 |<br>　　　　　　　　　　　　| character_set_database | latin1 |<br>　　　　　　　　　　　　| character_set_filesystem | binary |<br>　　　　　　　　　　　　| character_set_results | latin1 |<br>　　　　　　　　　　　　| character_set_server | latin1 |<br>　　　　　　　　　　　　| character_set_system | utf8 |<br>　　　　　　　　　　　　| character_sets_dir | F:\jj\mysql-5.6.42-winx64\share\charsets\ |<br>　　　　　　　　　　　　+————————–+——————————————-+<br>　　　　　　　　　　　　8 rows in set (0.00 sec)<br>　　　　　　　　　　发现客户端三炮都改为和服务端一致的latin1了，按照我们刚才说的，按理说再插入数据应该就不会乱码了。来插入一条数据试试看：</p><p>　　　　　　　　　　　　mysql&gt; insert into student value(5,’不乱了吧’,111);<br>　　　　　　　　　　　　Query OK, 1 row affected (0.09 sec)</p><p>　　　　　　　　　　　　mysql&gt; select * from student;<br>　　　　　　　　　　　　+——+———-+——+<br>　　　　　　　　　　　　| id | name | age |<br>　　　　　　　　　　　　+——+———-+——+<br>　　　　　　　　　　　　| 1 | ?? | 11 |<br>　　　　　　　　　　　　| 2 | ?? | 12 |<br>　　　　　　　　　　　　| 3 | dsb | 10 |<br>　　　　　　　　　　　　| 4 | ?? | 9 |<br>　　　　　　　　　　　　| 5 | 不乱了吧 | 111 | #再次插入的数据就不乱吗了，但是之前乱码的内容还是乱码的内容<br>　　　　　　　　　　　　+——+———-+——+<br>　　　　　　　　　　　　5 rows in set (0.00 sec)<br>　　　　　　　　　　总结：在进行DQL和DML语句(关于DQL和DML的解释我们后面会讲的，你就理解为一些sql语句)之前，先执行set names latin1；<br>但是我们如果断开连接，退出数据库之后，在连接进来以后，插入数据时如果不执行set names latin1，还是会乱码，说明这句指令没有让字符集永久生效。<br>　　　　　　　　　　不信，我们退出一下，然后再连接进来看看：<br>　　　　　　　　　　　　mysql&gt; quit<br>　　　　　　　　　　　　Bye</p><p>　　　　　　　　　　　　C:\Users\chao&gt;mysql -uroot -p #连接进来</p><p>　　　　　　　　　　　　mysql&gt; use crm; #切换库<br>　　　　　　　　　　　　Database changed<br>　　　　　　　　　　　　mysql&gt; select * from student; #查看crm库中的student表中的数据<br>　　　　　　　　　　　　+——+———–+——+<br>　　　　　　　　　　　　| id | name | age |<br>　　　　　　　　　　　　+——+———–+——+<br>　　　　　　　　　　　　| 1 | ?? | 11 |<br>　　　　　　　　　　　　| 2 | ?? | 12 |<br>　　　　　　　　　　　　| 3 | dsb | 10 |<br>　　　　　　　　　　　　| 4 | ?? | 9 |<br>　　　　　　　　　　　　| 5 | ??????°? | 111 |<br>　　　　　　　　　　　　+——+———–+——+<br>　　　　　　　　　　　　5 rows in set (0.00 sec)</p><p>　　　　　　　　　　发现还是tm的乱码，真恶心啊，果然没有永久生效，我们在使用一下set names latin1；然后再查看一下表中的数据<br>　　　　　　　　　　　　mysql&gt; set names latin1;<br>　　　　　　　　　　　　Query OK, 0 rows affected (0.00 sec)</p><p>　　　　　　　　　　　　mysql&gt; select * from student;<br>　　　　　　　　　　　　+——+———-+——+<br>　　　　　　　　　　　　| id | name | age |<br>　　　　　　　　　　　　+——+———-+——+<br>　　　　　　　　　　　　| 1 | ?? | 11 |<br>　　　　　　　　　　　　| 2 | ?? | 12 |<br>　　　　　　　　　　　　| 3 | dsb | 10 |<br>　　　　　　　　　　　　| 4 | ?? | 9 |<br>　　　　　　　　　　　　| 5 | 不乱了吧 | 111 |<br>　　　　　　　　　　　　+——+———-+——+<br>　　　　　　　　　　　　5 rows in set (0.00 sec)<br>　　　　　　　　　　发现第五条数据，也就是我们之前使用latin1插入的数据，在查看之前使用set names latin1；还是可以看到对应的不乱码的数据的，因为我们就是以latin1的字符集插入的，只是查看的时候客户端三炮还是之前的gbk的编码，所以直接查看结果的时候还是乱码的。<br>　　　　　　　　　　这样虽然可以解决乱码问题，但是没办法永久解决乱码问题，所以每次在进行sql语句输入之前都要先执行一下set names latin1；(latin1这里代指的是服务端的字符集，不一定就是latin1)，所以我们还有其他的方法来解决，修改配置文件，看第二种方法！<br>　　　　　　　　　　注意一点：如果想把之前已经乱码的数据改为不乱码，在工作中，我们需要将数据全部导出来，然后重新建库建表，再把数据导进来。</p><p>　　　　　　　　<strong>二.在配置文件里面修改客户端和服务端参数，可以实现set names latin1；的效果，并且永久生效</strong><br>　　　　　　　　　　首先回答一个问题：至于为什么MySQL中的编码是latin1，是因为这是人家mysql规定好的，并写在自己的运行程序中的，只要mysql启动的时候，我们没有给人家指定一个字符集，那么它就会按照自己程序中写好的这个字符集来运行。<br>　　　　　　　　　　所以，我们如果想永久的更改mysql的字符集(不管是客户端还是服务端的)，就需要在mysql服务端启动之前给人家指定好，具体怎么指定呢，就需要看一下mysql启动的时候加载自己程序文件的过程(在并发编程的时候我们说过，任何程序运行都是通过加载自己的程序文件运行起来的)，看看加载了哪些文件，并且哪些文件是关于mysql字符集的，我们只需要将这个关于字符集的文件里面的内容修改一下，就相当于间接的告诉mysql运行加载的时候需要使用的字符集格式。那么我们就可以做到永久修改mysql的字符集了，对不对。好，针对这个思路，我们研究了一下发现，这个包含字符集配置的配置文件叫做my.ini文件(win10，unix叫做my.cnf)，这个文件是mysql启动的时候加载的一些用户自定制配置的文件，那么我们可以通过这个配置文件来改一改字符集，除了能填写字符集的配置项之外，还能填写一些你自己想要定制的其他的内容(需要研究mysql官方手册了~~)。<br>　　　　　　　　　　如果你的安装目录里面没有这个文件并且没有在其他地方设置，那么mysql就会按照自己默认的配置参数来运行，我们可以通过写一个my.ini文件来指定，mysql运行起来时会读取这个my.ini文件中的一些配置，其中就可以配置指定字符集。</p><p>　　　　　　　　　　我们知道这个文件叫做my.ini文件了，但是这个文件写在哪里呢？这里我们再说一个问题：有的人的博客上说mysql在启动的时候使用的配置文件在这个目录下(以win10举例)：<br>　　　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181112184932705-1774146235.png" alt="img"></p><p>　　　　　　　　　　</p><p>　　　　　　　　　　但是我查看了一下mysql启动的时候对my.ini文件的加载顺序：</p><p>　　　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181112185003097-695587448.png" alt="img"></p><p>　　　　　　　　　　发现并没有加载上面这个文件夹中的my.ini文件，并且我测试了一下，将上面文件夹中my.ini文件中的mysqld下面的默认端口号3306改为了3307，然后我启动了mysql服务，然后我查了一下端口号，发现3307这个端口并没有被使用：<br>　　　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181112185054865-1909124370.png" alt="img"></p><p>　　　　　　　　　　所以验证出上面的这个文件夹中的文件并没有被加载生效。所以我确定，上面这个文件夹中的配置文件只是一个参考用的，我称它为伪配置文件。并不是有些博客里面的mysql中加载的那个my.ini文件。　　　　　　　　　　　　　　　　　　　　</p><p>　　　　　　　　　　并且我们通过上面的查看my.ini文件的加载顺序中看到，我们自己mysql的安装目录中的my.ini文件就是其中一个加载顺序的结果，所以，看样子我们自己在自己的mysql的安装目录下写一个my.ini文件就应该能行了，来就按照这个思路搞一搞(和大家确定说一下，这样肯定是可以的<del>~</del>)</p><p>　　　　　　　　　　首先在安装目录下创建一个my.ini文件(copy一份my-default.ini文件，改名为my.ini文件)，使用Notepad++打开，里面写上下面的内容，来看看是不是会生效</p><p>　　　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113091334372-1865787999.png" alt="img"></p><p>　　　　　　　　　　之前我们连接mysql服务端的时候的指令是 mysql -uroot -p回车，其实我们直接输入mysql然后回车就能连接上mysql服务端，但是用户并不是root，而是mysql给我们创建一个用户，没啥用，可以忽略，工作中这个用户肯定是要被删除了，我们先来看一下这个用户，通过select user()来查看，并不是我们的root用户，root用户连接的时候是需要填密码的。</p><p>　　　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113091415088-131853398.png" alt="img"></p><p>　　　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181112190019806-1899256596.png" alt="img"></p><p>　　　　　　　　　　之前我们用root用户连接输入库的命令是这样的：　　　　　　</p><p>　　　　　　　　　　　　C:\Users\chao&gt;mysql -uroot -p<br>　　　　　　　　　　　　Enter password: ***</p><p> 　　　　　　　　　　我们在我们创建的my.ini文件中写上下面几行，然后保存：　　　　　　　</p><p>　　　　　　　　　　　　[mysql]   #配置客户端连接的时候，指定一下用户名和密码，那么我们在进行mysql客户端连接的时候，直接输入mysql然后回车就可以了，并且用户是我们下面指定的root用户<br>　　　　　　　　　　　　user=root<br>　　　　　　　　　　　　password=666</p><p>　　　　　　　　　　重启mysql服务（一般修改配置文件，让其生效，需要重启服务，但是我测试了一下，这个用户名和密码的指定，貌似不需要重启服务就可以的）：</p><p>　　　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181112190410935-596003229.png" alt="img"></p><p>　　　　　　　　　　然后再起一个cmd客户端，直接输入mysql然后回车，再查看一下用户：</p><p>　　　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181112190538108-1335314654.png" alt="img"></p><p>　　　　　　　　　　改为root用户了<del>配置文件生效</del></p><p>　　　　　　　　　　　　<br>　　　　　　　　　　通过上面的实验，我们知道，我们可以通过my.ini文件中的配置项，来更改mysql系统的一些服务，实现一些自定制配置，其实能够完成的配置非常多，将来深入学习mysql的时候，这个配置文件很关键，不过对于现在只做开发的你，就不必去研究那么多了，如果想看一下都可以进行哪些配置，可以参考一下我的那个centos7.1下安装mysql的博客最后面的内容，有关于其中的很多配置及解释，还可以参考上面我们提到的那个伪配置文件里面的内容来搞，但是记住一点，你写的这些配置必须是mysql能够认识的，也就是要按照人家规定的变量名称来配置，比如上面我们配置的用户名和密码，就叫做user和password，不能是username什么的，这个记住啦。</p><p>　　　　　　　　　　下面我们通过配置文件来搞一搞编码，终于到了这一步了(windows和linux都是这个配置)<br>　　　　　　　　　　在配置之前我们看一下各个角色的编码，还记得查看指令吗：<br>　　　　　　　　　　　　mysql&gt; show variables like “%char%”;<br>　　　　　　　　　　　　+————————–+——————————————-+<br>　　　　　　　　　　　　| Variable_name | Value |<br>　　　　　　　　　　　　+————————–+——————————————-+<br>　　　　　　　　　　　　| character_set_client | gbk |<br>　　　　　　　　　　　　| character_set_connection | gbk |<br>　　　　　　　　　　　　| character_set_database | latin1 |<br>　　　　　　　　　　　　| character_set_filesystem | binary |<br>　　　　　　　　　　　　| character_set_results | gbk |<br>　　　　　　　　　　　　| character_set_server | latin1 |<br>　　　　　　　　　　　　| character_set_system | utf8 |<br>　　　　　　　　　　　　| character_sets_dir | F:\jj\mysql-5.6.42-winx64\share\charsets\ |<br>　　　　　　　　　　　　+————————–+——————————————-+<br>　　　　　　　　　　　　8 rows in set (0.00 sec)<br>　　　　　　　　　　好，我们来改一改my.ini配置文件，文件中的内容写法，写完之后保存，然后重启mysql系统服务：<br>　　　　　　　　　　　　#强调：配置文件中的注释可以有中文，但是配置项中不能出现中文<br>　　　　　　　　　　　　#在mysql的解压目录下，新建my.ini,然后配置<br>　　　　　　　　　　　　#1. 在执行mysqld命令时，下列配置会生效，即mysql服务启动时生效<br>　　　　　　　　　　　　[mysqld]</p><p>　　　　　　　　　　　　character_set_server=utf8<br>　　　　　　　　　　　　collation-server=utf8_general_ci  #就是一个校对规则，一般默认都是这个，如果不是就改成这个就可以了，所以直接写上就行了，这个规则后面我们会讲的<del>~</del></p><p>　　　　　　　　　　　　还可以配置好多内容，比如下面的端口号，基准路径，数据文件路径：</p><p>　　　　　　　　　　　　　　port=3306 # mysql服务端默认监听(listen on)的TCP/IP端口</p><p>　　　　　　　　　　　　　　basedir=”C:/Program Files/MySQL/MySQL Server 5.5/“ # 基准路径，其他路径都相对于这个路径</p><p>　　　　　　　　　　　　　　datadir=”C:/Program Files/MySQL/MySQL Server 5.5/Data” # mysql数据库文件所在目录</p><p>　　　　　　　　　　　　#2. 针对客户端命令的全局配置，当mysql客户端命令执行时，下列配置生效<br>　　　　　　　　　　　　[client]<br>　　　　　　　　　　　　default-character-set=utf8</p><p>　　　　　　　　　　　　#3. 只针对mysql这个客户端的配置，2中的是全局配置，而此处的则是只针对mysql这个命令的局部配置<br>　　　　　　　　　　　　[mysql]<br>　　　　　　　　　　　　user=root<br>　　　　　　　　　　　　password=666<br>　　　　　　　　　　　　default-character-set=utf8</p><p>　　　　　　　　　　　　#如果没有[mysql],则用户在使用mysql系统自带的mysql客户端来执行mysql命令时的配置以[client]为准</p><p>　　　　　　　　　　重启mysql服务，让配置文件生效：<br>　　　　　　　　　　　　C:\WINDOWS\system32&gt;net stop mysql<br>　　　　　　　　　　　　MySQL 服务正在停止..<br>　　　　　　　　　　　　MySQL 服务已成功停止。</p><p>　　　　　　　　　　　　C:\WINDOWS\system32&gt;net start mysql<br>　　　　　　　　　　　　MySQL 服务正在启动 .<br>　　　　　　　　　　　　MySQL 服务已经启动成功。</p><p>　　　　　　　　　　然后连接进入mysql，再次查看编码：<br>　　　　　　　　　　　　C:\Users\chao&gt;mysql -uroot -p<br>　　　　　　　　　　　　Enter password: ***<br>　　　　　　　　　　　　mysql&gt; show variables like “%char%”;<br>　　　　　　　　　　　　+————————–+——————————————-+<br>　　　　　　　　　　　　| Variable_name | Value |<br>　　　　　　　　　　　　+————————–+——————————————-+<br>　　　　　　　　　　　　| character_set_client | utf8 |<br>　　　　　　　　　　　　| character_set_connection | utf8 |<br>　　　　　　　　　　　　| character_set_database | utf8 |<br>　　　　　　　　　　　　| character_set_filesystem | binary |<br>　　　　　　　　　　　　| character_set_results | utf8 |<br>　　　　　　　　　　　　| character_set_server | utf8 |<br>　　　　　　　　　　　　| character_set_system | utf8 |<br>　　　　　　　　　　　　| character_sets_dir | F:\jj\mysql-5.6.42-winx64\share\charsets\ |<br>　　　　　　　　　　　　+————————–+——————————————-+<br>　　　　　　　　　　　　8 rows in set (0.00 sec)</p><p>　　　　　　　　　　编码都编程utf8了，verygood，编码统一了，我们再来插入一条数据看看：<br>　　　　　　　　　　　　首先我们将之前的crm库删除，然后再重新创建一个crm库，并在crm库里面重新创建一个student表，为什么删除呢？因为前面我们说了，之前的数据是乱码的，没办法改，所以我们先删除吧，然后重新创建一个，之前创建的crm库是Latin1的字符集的，所以为了简单演示，我们就删除重新创建吧，这里注意，如果将来你们公司使用的数据库的编码确实有问题，并且和你们现在要使用的编码不一致，那么就需要使用第一种临时修改字符集的方式来插入和查询数据，没办法，要不然就要重塑数据库，将编码调节好。<br>　　　　　　　　　　　　来操作一下看看效果：<br>　　　　　　　　　　　　首先看一下之前的crm库的创建语句：<br>　　　　　　　　　　　　　　mysql&gt; show create database crm\G<br>　　　　　　　　　　　　　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>* 1. row *</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>　　　　　　　　　　　　　　Database: crm<br>　　　　　　　　　　　　　　Create Database: CREATE DATABASE <code>crm</code> /*!40100 DEFAULT CHARACTER SET latin1 */<br>　　　　　　　　　　　　　　1 row in set (0.08 sec)<br>　　　　　　　　　　　　　　还是latin1的字符集</p><p>　　　　　　　　　　　　　　mysql&gt; drop database crm; #删除之前的crm库<br>　　　　　　　　　　　　　　Query OK, 1 row affected (0.41 sec)</p><p>　　　　　　　　　　　　　　mysql&gt; show databases; #查看一下，crm库没有了<br>　　　　　　　　　　　　　　+——————–+<br>　　　　　　　　　　　　　　| Database |<br>　　　　　　　　　　　　　　+——————–+<br>　　　　　　　　　　　　　　| information_schema |<br>　　　　　　　　　　　　　　| mysql |<br>　　　　　　　　　　　　　　| performance_schema |<br>　　　　　　　　　　　　　　| test |<br>　　　　　　　　　　　　　　+——————–+<br>　　　　　　　　　　　　　　4 rows in set (0.01 sec)</p><p>　　　　　　　　　　　　　　mysql&gt; create database crm; #重新创建<br>　　　　　　　　　　　　　　Query OK, 1 row affected (0.00 sec)</p><p>　　　　　　　　　　　　　　mysql&gt; show databases;<br>　　　　　　　　　　　　　　+——————–+<br>　　　　　　　　　　　　　　| Database |<br>　　　　　　　　　　　　　　+——————–+<br>　　　　　　　　　　　　　　| information_schema |<br>　　　　　　　　　　　　　　| crm |<br>　　　　　　　　　　　　　　| mysql |<br>　　　　　　　　　　　　　　| performance_schema |<br>　　　　　　　　　　　　　　| test |<br>　　　　　　　　　　　　　　+——————–+<br>　　　　　　　　　　　　　　5 rows in set (0.00 sec)</p><p>　　　　　　　　　　　　查看创建时的语句：<br>　　　　　　　　　　　　　　mysql&gt; show create database crm\G<br>　　　　　　　　　　　　　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>* 1. row *</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>　　　　　　　　　　　　　　Database: crm<br>　　　　　　　　　　　　　　Create Database: CREATE DATABASE <code>crm</code> /*!40100 DEFAULT CHARACTER SET utf8 */<br>　　　　　　　　　　　　　　1 row in set (0.00 sec)<br>　　　　　　　　　　　　已经改为了utf8的字符集<br>　　　　　　　　　　　　然后我们插入数据，查看数据，看一下效果：<br>　　　　　　　　　　　　　　mysql&gt; use crm;<br>　　　　　　　　　　　　　　Database changed<br>　　　　　　　　　　　　　　mysql&gt; create table student(id int,name char(10),age int);<br>　　　　　　　　　　　　　　Query OK, 0 rows affected (0.47 sec)</p><p>　　　　　　　　　　　　　　mysql&gt; insert into student value(1,’呵呵’,11),(2,’老刁’,12),(3,’dsb’,10),(4,’你好’,9);<br>　　　　　　　　　　　　　　Query OK, 4 rows affected (0.10 sec)<br>　　　　　　　　　　　　　　Records: 4 Duplicates: 0 Warnings: 0</p><p>　　　　　　　　　　　　　　mysql&gt; select * from student;<br>　　　　　　　　　　　　　　+——+——–+——+<br>　　　　　　　　　　　　　　| id | name | age |<br>　　　　　　　　　　　　　　+——+——–+——+<br>　　　　　　　　　　　　　　| 1 | 呵呵 | 11 |<br>　　　　　　　　　　　　　　| 2 | 老刁 | 12 |<br>　　　　　　　　　　　　　　| 3 | dsb | 10 |<br>　　　　　　　　　　　　　　| 4 | 你好 | 9 |<br>　　　　　　　　　　　　　　+——+——–+——+</p><p>　　　　　　　　　　　　good，完全没有乱码了<del>~</del>这就是解决方案</p><p>　　　　　　　　总结：不乱码的思想：系统的编码、客户端、服务端、库、表、列，这几项的编码都要统一才不会出现乱码的情况。</p><p>　　　　　　　　附赠：<br>　　　　　　　　　　windows系统查看系统默认编码的指令：<br>　　　　　　　　　　cmd窗口情况下：windows下cmd默认的编码是GBK<br>　　　　　　　　　　想在windows下查看sqlite的utf-8中文需要先 执行chcp 65001把当前页换为utf-8编码<br>　　　　　　　　　　　　chcp 命令:<br>　　　　　　　　　　　　chcp 65001 就是换成UTF-8代码页，在命令行标题栏上点击右键，选择”属性”-&gt;”字体”，将字体修改为True Type字体”Lucida Console”，然后点击确定将属性应用到当前窗口<br>　　　　　　　　　　　　chcp 936 可以换回默认的GBK<br>　　　　　　　　　　　　chcp 437 是美国英语<br>　　　　　　　　　　linux系统查看系统默认编码的指令：<br>　　　　　　　　　　执行指令：cat sysconfig i18n<br>　　　　　　　　　　　　结果中有一条是：LANG=”zh_CN.utf8”</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113093735072-2013878217.png" alt="img"></p><h3 id="六-初识sql语句"><a href="#六-初识sql语句" class="headerlink" title="六 初识sql语句"></a>六 初识sql语句</h3><p>　　有了mysql这个数据库软件，就可以将程序员从对数据的管理中解脱出来，专注于对程序逻辑的编写。</p><p>　　mysql服务端软件即mysqld帮我们管理好文件夹以及文件，前提是作为使用者的我们，需要下载mysql的客户端，或者其他模块来连接到mysqld，然后使用mysql软件规定的语法格式去提交自己命令，实现对文件夹或文件的管理。该命令的语法即sql（Structured Query Language 即结构化查询语言），sql语句又分为几类，具体看我的博客：<a href="https://www.cnblogs.com/clschao/articles/9930802.html%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA4%E4%B8%AD%EF%BC%8CDDL%E3%80%81DQL%E3%80%81DML%E3%80%81DCL%E3%80%82">https://www.cnblogs.com/clschao/articles/9930802.html，主要分为4中，DDL、DQL、DML、DCL。</a></p><p>　　SQL语句主要是针对数据库里面三个角色进行操作，对象是：库、表、行，操作包括：增删改查。</p><p>　　　　1、库（data文件夹中的文件夹，每创建一个库，这个库的名称就是文件夹的名称，文件夹里面保存着一些这个库相关的初始信息）</p><p>　　　　　　增：create database db1 charset utf8; #创建一个库，可以指定字符集 　　　　　　</p><p>　　　　　　查：show databases; #查看数据库中所有的库<br>　　　　　　　　show create database db1; #查看单独某个库db1的信息 　　　　　　</p><p>　　　　　　改：alter database db1 charset latin1; #修改库的字符集，注意语句的格式（其他语句也是这么个格式），alter（修改） database（修改数据库） db1（哪个数据库） charset（字符集） latin1（改成哪个字符集） 　　　　　　</p><p>　　　　　　删除: drop database db1; #删除数据库</p><p> 　　　　2、表（操作文件，表是上面库文件夹里面的文件）</p><p>　　　　　　先切换库：use db1； #要操作表文件，要先切换到对应的库下才能操作表</p><p>　　　　　　　　　　   查看当前所在的是哪个库：select database();</p><p>　　　　　　增：create table t1(id int,name char(10) );  #创建表的时候，和excel一样，需要有字段啊，每个字段还需要只能一下这个字段数据的格式，这里指定的是两个字段列，id和name列，id和name是列名(字段名)，id 后面的int的意思说id这一列中的数据只能是int类型的，name后面的char的意思是，name这一列中的数据只能是char类型的(char表示定长字符串类型)，char里面的10是说这个字段的长度最长为10个字符，如果不指定这个长度，默认长度是1，注意是字符而不是字节，这些字段的内容我们后面会详解，这里知道一下就好啦。</p><p>　　　　　　　　#在创建表的时候，我们去看一下mysql安装目录里面的data文件夹里面的db1文件夹里面的文件，然后我们执行创建表的指令，看看db1文件夹里面的变化，多了两个文件，分别是：db1.frm，db1.ibd文件，创建了一张表为什么会多了两个文件呢，这两个文件都是啥呢？看解释（里面涉及到存储引擎，关于存储引擎我们后面会讲的~~）：　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>1.后缀名为.frm的文件：这个文件主要是用来描述数据表结构(id,name字段等)和字段长度等信息2.后缀名为.ibd的文件：这个文件主要储存的是采用独立表储存模式时储存数据库的数据信息和索引信息；3.后缀名为.MYD（MYData）的文件：从名字可以看出，这个是存储数据库数据信息的文件，主要是存储采用独立表储存模式时存储的数据信息；4.后缀名为.MYI的文件：这个文件主要储存的是数据库的索引信息；5.ibdata1文件:主要作用也是储存数据信息和索引信息，这个文件在mysql安装目录的data文件夹下。    从上面可以看出，.ibd储存的是数据信息和索引信息，ibdata1文件也是存储数据信息和索引信息，.MYD和.MYI也是分别储存数据信息和索引信息，那他们之间有什么区别呢？     主要区别是再于数据库的存储引擎不一样，如果储存引擎采用的是MyISAM，则生成的数据文件为表名.frm、表名.MYD、表名的MYI;而储存引擎如果是innoDB，开启了innodb_file_per_table＝1,也就是采用独立储存的模式，生成的文件是表名.frm、表名.ibd，如果采用共存储模式的，数据信息和索引信息都存储在ibdata1中;     在进行数据恢复的时候，如果用的是MYISAM数据引擎，那么数据很好恢复，只要将相应.frm, .MYD, .MYI文件拷贝过去即可。但是如果是innodb的话，则每一个数据表都是一个单独的文件，只将相应的.frm和.ibd文件拷贝过去是不够的，必须在你的ibd文件的tablespace id和ibdata1文件中的元信息的tablespace id一致才可以。msyql人家设定的规则就是这样存储表的，使用人家的系统，就要理解人家的规则。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　查：show tables；  #查看当前库中所有的表</p><p>　　　　　　　　show create table t1; #查看单表的创建信息</p><p>　　　　　　　　#还可以通过下面两句来查看表信息，以表格的形式展示结果：</p><p>　　　　　　　　desc t1；</p><p>　　　　　　　　describe t1；#上下这两句是一样的结果</p><p>　　　　　　改：alter table t1 modify name char(3);  #修改字段属性的，将name字段的char长度改为3，改完之后我们在用上面的show create table t1；desc t1；describe t1；来查看一下修改结果。</p><p>　　　　　　　　alter table t1 change name name1 char(2);</p><p>　　　　　　删：drop table t1;</p><p> 　　　　</p><p>　　　　3. 行（操作文件（表）中的内容/记录）（*****将来的重中之重）</p><p>　　　　　　增：insert into t1 values(1,’dsb1’),(2,’dsb2’),(3,’dsb3’); #往t1表中插入三行数据，注意你插入的每行内容都要和你创建表的时候的字段个数和字段属性对应好，注意每行数据以逗号分隔。</p><p>　　　　　　　　insert后面的into可以不用写。</p><p>　　　　　　查：select * from t1; #查看t1表中所有字段的数据，select 字段 from 表。</p><p>　　　　　　　　select id,name from t1;#查看t1表中的id和name列的数据，其他的不看，注意格式，每个字段逗号分隔，在cmd窗口下只是展示给我们看，将来我们通过程序获取查询数据的时候，就可以这么获取，查询字段的顺序也是可以颠倒的，name,id这样也是可以的。</p><p>　　　　　　　　注意还有一个问题，看下图：当你写sql语句的时候，可能会出现下面这种情况，由于少写了一个引号，导致怎么也结束不了</p><p>　　　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181113110646061-1046207598.png" alt="img"></p><p>　　　　　　改：update t1 set name=’sb’ where id=2; #把id为2的行（记录）中的name字段的数据改为sb；id&gt;1;id&lt;=1;等等都可以。后面会细讲的<del>~</del></p><p>　　　　　　　　update t1 set name=’sb’,id=88 where id&gt;2; #对两个字段进行修改</p><p>　　　　　　　　update t1 set name=’sb’;#如果不指定where，那么会name字段的所有数据都改成sb。</p><p>　　　　　　删：delete from t1 where id=1; #删除id为1的行</p><p>　　　　　　清空表：</p><p>　　　　　　　　delete from t1; #如果有自增id，新增的数据，仍然是以删除前的最后一样作为起始。</p><p>　　　　　　　　truncate table t1;数据量大，删除速度比上一条快，且直接从零开始，</p><p>　　　　　　　　auto_increment 表示：自增</p><p>　　　　　　　　primary key 表示：约束（不能重复且不能为空）；加速查找</p><p> 　　至此，我们大家认识了一下简单的SQL语句，下来大家练一练吧<del>~</del>明天我们针对库、表、行的操作来一些详细的讲解，其实库的内容不多，主要是表和行，最主要是行。</p><p> 　　</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL校对规则</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%A0%A1%E5%AF%B9%E8%A7%84%E5%88%99/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%A0%A1%E5%AF%B9%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p><strong>一、前言</strong></p><p>有时候遇到这种情况，你用一个like语句查询，查到的结果中有一些并没有包含你查询的关键词的纪录；<br>有时候遇到这种情况，你的数据库自作聪明的大小写不敏感，让你在更新时把大小写不同的两条记录都更新了；<br>有时候遇到这种情况，你的查询语句一切正常，查询却失败了，报告Illegal mix of collations错误；</p><p>你很困惑，在想数据库是不是坏了。。。其实 ，这些都和数据库字符集的校对规则有关；了解了校对规则，你就知道怎样处理这些问题。</p><p>那么，校对规则是怎么回事呢？它是一组规则，负责决定某一字符集下的字符进行比较和排序的结果。</p><p>比如说，有latin1字符集中的字母A和a，我们需要它们在比较的时候相等，那么，我们可以使用字符集校对规则 latin1_general_ci；这种校对规则在比较和排序的时候不区分大小写；如果我们需要他们在比较的时候不等呢？也很简单，我们可以使用字符集校对规则latin1_bin;这种校对规则会以二进制的方式对字符进行比较，很明显，a和A的二进制编码不同，比较的结果就是不等。</p><p>上面的场景说明了校对规则在最简单情况下起的作用；实际情况与此并没有太多不同，只不过稍微有些复杂而已。</p><p><strong>二、校对规则总览</strong></p><p>我们可以使用 SHOW COLLATION 指令来查看数据库支持的校对规则</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/26132809-e4466af4777a40e18cd676aa33ff0a3e.png" alt="img"></p><p>在图中，我们列出了数据库支持的latin1字符集的校对规则。为什么一种字符集竟然有这么多种的校对规则呢？因为在不同的情况下，对比较的结果有不同的期待，所以就有了不同的校对规则。前面说的大小写敏感（latin1_general_cs）和不敏感（latin1_general_ci）是两种校对规则，根据二进制方式进行比较（latin1_bin）也是一种校对规则，德国人（latin1_german1_ci）和西班牙人（latin1_spanish_ci）使用的某些不同的拉丁字符在某些情况下是等价的，所以有了两种新的校对规则。</p><p>举个例子，在latin1_german1_ci中，如下字符是等价的，而他们，具有不同的外形和编码。当然，它们的编码不同，所以在latin1_bin校对规则下，他们又是不等价的了。<br>A,a,À,Á,Â,Ã,Ä,Å,Æ,à,á,â,ã,ä,å,æ</p><p><strong>三、校对规则导致的问题</strong></p><p><strong>1、混合校对规则比较</strong></p><p>两个字符串比较，要求两者必须有相同的校对规则，或者两者的校对规则是相容的——所谓相容是指，两种校对规则优先级不同，比较的时候两者使用高优先级的校对规则进行比较，比如latin1_bin的优先级相对较高。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>CREATE TABLE `tbl` (  `col_a` int(11) default NULL,  `col_b` char(20) character set latin1 collate latin1_general_ci default NULL,  `col_c` char(20) character set latin1 collate latin1_german1_ci default NULL,  `col_d` char(20) character set latin1 collate latin1_bin default NULL,  KEY `col_a` (`col_a`),  KEY `col_b` (`col_b`)) ENGINE=MyISAM DEFAULT CHARSET=latin1</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>在这个表中，col_b、col_c、col_d的校对规则各不同；其中，latin1_general_ci和latin1_german1_ci 校对规则同级，不能进行比较；如果强行比较的话，就会报错，如下：</p><pre><code>mysql&gt; select * from tbl where col_b = col_c;ERROR 1267 (HY000): Illegal mix of collations (latin1_general_ci,IMPLICIT) and (latin1_german1_ci,IMPLICIT) for operation '='</code></pre><p>而latin1_general_ci和latin1_bin的优先级不同，latin1_bin高于latin1_general,因此比较的时候，会按照latin1_bin的规则进行比较。</p><pre><code>mysql&gt; select * from tbl where binary col_b = col_d;Empty set (0.00 sec)</code></pre><p>当然，可以在sql语句中强制指定校对规则进行比较，下面这个例子就说明了这一点：</p><pre><code>mysql&gt; select * from tbl where col_b COLLATE latin1_danish_ci = col_c COLLATE latin1_danish_ci;Empty set (0.00 sec)</code></pre><p><strong>2、校对规则导致的问题——SELECT出错误的记录</strong></p><p> 在上面的基础上，我们要演示一个常见的问题；我们需要对该数据表进行一定的处理：</p><pre><code>alter table tbl modify col_b collate latin1_swedish_ci default null;insert into tbl (col_b) values ('hao123');</code></pre><p>然后进行下面的查询</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/26133427-7bf9d15008414e0facf3f020ff1fd63c.png" alt="img"></p><p>我们希望查询的是包含“刘”的记录，hao123这个和“刘”没有任何关系的条目被选了出来，看起来很奇怪。<br>不过这不是数据库出了问题，而是校对规则的使用上存在问题：<br>下面是我们使用ultraedit察看字符串的二进制编码的结果，在gbk编码下，hao123的编码为68 61 6f 31 32 33，而刘的编码位C1 F5。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/26133506-31dda18d4e71492689fe28c390748efe.png" alt="img"></p><p>在前面的latin1_swedish_ci 校对规则中可以看到：</p><p>61和C1都与41等价</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/26133617-e59a2c13992e4047964f56aa1ed257a9.png" alt="img"></p><p>6F和F5都与4F等价</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/26133638-8c5e6313a58f45b09fbbad8e90620604.png" alt="img"></p><p>这就是ao = 刘的原因。</p><p>解决办法有两个：<br>1）修改该字段的字符集和校对规则，改成gbk，这该问题不在存在。这是完美的解决方案，不过有些时候你没有权限对数据库进行这样的改动。</p><pre><code>mysql&gt; alter table tbl modify col_b char(20) charset gbk default null;Query OK, 1 row affected (0.01 sec)Records: 1  Duplicates: 0  Warnings: 0mysql&gt; select * from tbl where binary col_b like like '%刘%';Empty set (0.00 sec)</code></pre><p>2）查询的时候声明校对规则为latin1_bin 。这样可以在一定程度上缓解这个问题；不过如果col_b中只要含有c1 f5,就会被选出来——而c1 f5可能恰好是另外两个字符的前半截和后半截，或者干脆就是 Á õ ….</p><pre><code>mysql&gt; select * from tbl where binary col_b like '%刘%';Empty set (0.00 sec)</code></pre><p>转载：<a href="http://hi.baidu.com/cuttinger/item/e23013e372ee62adce2d4fda">http://hi.baidu.com/cuttinger/item/e23013e372ee62adce2d4fda</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之多表查询</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9995815.html#_label1">一 介绍</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9995815.html#_label2">二 多表连接查询</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9995815.html#_label3">三 符合条件连接查询</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9995815.html#_label4">四 子查询</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9995815.html#_label5">五 综合练习</a></li></ul><h1 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一 介绍"></a>一 介绍</h1><p>　　本节主题</p><ul><li>多表连接查询</li><li>复合条件连接查询</li><li>子查询</li></ul><p>　　首先说一下，我们写项目一般都会建一个数据库，那数据库里面是不是存了好多张表啊，不可能把所有的数据都放到一张表里面，肯定要分表来存数据，这样节省空间，数据的组织结构更清晰，解耦和程度更高，但是这些表本质上是不是还是一个整体啊，是一个项目所有的数据，那既然分表存了，就要涉及到多个表连接查询了，比如说员工信息一张表，部门信息一张表，那如果我想让你帮我查一下技术部门有哪些员工的姓名，你怎么办，单独找员工表能实现吗，不能，单独找部门表也无法实现，因为部门表里面没有员工的信息，对不对，所以就涉及到部门表和员工表来关联到一起进行查询了，好，那我们来建立这么两张表：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#建表#部门表create table department(id int,name varchar(20) );#员工表，之前我们学过foreign key，强行加上约束关联，但是我下面这个表并没有直接加foreign key，这两个表我只是让它们在逻辑意义上有关系，并没有加foreign key来强制两表建立关系，为什么要这样搞，是有些效果要给大家演示一下#所以，这两个表是不是先建立哪个表都行啊，如果有foreign key的话，是不是就需要注意表建立的顺序了。那我们来建表。create table employee(id int primary key auto_increment,name varchar(20),sex enum('male','female') not null default 'male',age int,dep_id int);#给两个表插入一些数据insert into department values(200,'技术'),(201,'人力资源'),(202,'销售'),(203,'运营'); #注意这一条数据，在下面的员工表里面没有对应这个部门的数据insert into employee(name,sex,age,dep_id) values('egon','male',18,200),('alex','female',48,201),('wupeiqi','male',38,201),('yuanhao','female',28,202),('liwenzhou','male',18,200),('jingliyang','female',18,204) #注意这条数据的dep_id字段的值，这个204，在上面的部门表里面也没有对应的部门id。所以两者都含有一条双方没有涉及到的数据，这都是为了演示一下效果设计的昂;#查看表结构和数据mysql&gt; desc department;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+mysql&gt; desc employee;+--------+-----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+-----------------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | | NULL | || sex | enum('male','female') | NO | | male | || age | int(11) | YES | | NULL | || dep_id | int(11) | YES | | NULL | |+--------+-----------------------+------+-----+---------+----------------+mysql&gt; select * from department;+------+--------------+| id | name |+------+--------------+| 200 | 技术 || 201 | 人力资源 || 202 | 销售 || 203 | 运营 |+------+--------------+mysql&gt; select * from employee;+----+------------+--------+------+--------+| id | name | sex | age | dep_id |+----+------------+--------+------+--------+| 1 | egon | male | 18 | 200 || 2 | alex | female | 48 | 201 || 3 | wupeiqi | male | 38 | 201 || 4 | yuanhao | female | 28 | 202 || 5 | liwenzhou | male | 18 | 200 || 6 | jingliyang | female | 18 | 204 |+----+------------+--------+------+--------+</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="二-多表连接查询"><a href="#二-多表连接查询" class="headerlink" title="二 多表连接查询"></a>二 多表连接查询</h1><pre><code>#重点：外链接语法SELECT 字段列表    FROM 表1 INNER|LEFT|RIGHT JOIN 表2    ON 表1.字段 = 表2.字段;</code></pre><p>　　<strong>1、交叉连接：不适用任何匹配条件。生成笛卡尔积</strong></p><p>　　</p><p>　　补充一点：select 查询表的时候，后面可以跟多张表一起查询：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; select * from department,employee; #表用逗号分隔，看我查询时表的顺序，先department后employee，所以你看结果表的这些字段，是不是就是我们两个表字段并且哪个表在前面，哪个表的字段就在前面+------+--------------+----+------------+--------+------+--------+| id   | name         | id | name       | sex    | age  | dep_id |+------+--------------+----+------------+--------+------+--------+|  200 | 技术         |  1 | egon       | male   |   18 |    200 ||  201 | 人力资源     |  1 | egon       | male   |   18 |    200 ||  202 | 销售         |  1 | egon       | male   |   18 |    200 ||  203 | 运营         |  1 | egon       | male   |   18 |    200 ||  200 | 技术         |  2 | alex       | female |   48 |    201 ||  201 | 人力资源     |  2 | alex       | female |   48 |    201 ||  202 | 销售         |  2 | alex       | female |   48 |    201 ||  203 | 运营         |  2 | alex       | female |   48 |    201 ||  200 | 技术         |  3 | wupeiqi    | male   |   38 |    201 ||  201 | 人力资源     |  3 | wupeiqi    | male   |   38 |    201 ||  202 | 销售         |  3 | wupeiqi    | male   |   38 |    201 ||  203 | 运营         |  3 | wupeiqi    | male   |   38 |    201 ||  200 | 技术         |  4 | yuanhao    | female |   28 |    202 ||  201 | 人力资源     |  4 | yuanhao    | female |   28 |    202 ||  202 | 销售         |  4 | yuanhao    | female |   28 |    202 ||  203 | 运营         |  4 | yuanhao    | female |   28 |    202 ||  200 | 技术         |  5 | liwenzhou  | male   |   18 |    200 ||  201 | 人力资源     |  5 | liwenzhou  | male   |   18 |    200 ||  202 | 销售         |  5 | liwenzhou  | male   |   18 |    200 ||  203 | 运营         |  5 | liwenzhou  | male   |   18 |    200 ||  200 | 技术         |  6 | jingliyang | female |   18 |    204 ||  201 | 人力资源     |  6 | jingliyang | female |   18 |    204 ||  202 | 销售         |  6 | jingliyang | female |   18 |    204 ||  203 | 运营         |  6 | jingliyang | female |   18 |    204 |+------+--------------+----+------------+--------+------+--------+24 rows in set (0.12 sec)我们让employee表在前面看看结果，注意看结果表的字段</code></pre><p>mysql&gt; select * from employee,department;<br>+—-+————+——–+——+——–+——+————–+<br>| id | name | sex | age | dep_id | id | name |<br>+—-+————+——–+——+——–+——+————–+<br>| 1 | egon | male | 18 | 200 | 200 | 技术 |<br>| 1 | egon | male | 18 | 200 | 201 | 人力资源 |<br>| 1 | egon | male | 18 | 200 | 202 | 销售 |<br>| 1 | egon | male | 18 | 200 | 203 | 运营 |<br>| 2 | alex | female | 48 | 201 | 200 | 技术 |<br>| 2 | alex | female | 48 | 201 | 201 | 人力资源 |<br>| 2 | alex | female | 48 | 201 | 202 | 销售 |<br>| 2 | alex | female | 48 | 201 | 203 | 运营 |<br>| 3 | wupeiqi | male | 38 | 201 | 200 | 技术 |<br>| 3 | wupeiqi | male | 38 | 201 | 201 | 人力资源 |<br>| 3 | wupeiqi | male | 38 | 201 | 202 | 销售 |<br>| 3 | wupeiqi | male | 38 | 201 | 203 | 运营 |<br>| 4 | yuanhao | female | 28 | 202 | 200 | 技术 |<br>| 4 | yuanhao | female | 28 | 202 | 201 | 人力资源 |<br>| 4 | yuanhao | female | 28 | 202 | 202 | 销售 |<br>| 4 | yuanhao | female | 28 | 202 | 203 | 运营 |<br>| 5 | liwenzhou | male | 18 | 200 | 200 | 技术 |<br>| 5 | liwenzhou | male | 18 | 200 | 201 | 人力资源 |<br>| 5 | liwenzhou | male | 18 | 200 | 202 | 销售 |<br>| 5 | liwenzhou | male | 18 | 200 | 203 | 运营 |<br>| 6 | jingliyang | female | 18 | 204 | 200 | 技术 |<br>| 6 | jingliyang | female | 18 | 204 | 201 | 人力资源 |<br>| 6 | jingliyang | female | 18 | 204 | 202 | 销售 |<br>| 6 | jingliyang | female | 18 | 204 | 203 | 运营 |<br>+—-+————+——–+——+——–+——+————–+<br>24 rows in set (0.00 sec)</p><pre><code>关于笛卡儿积：我们看一下上面的这些数据，有什么发现，首先看到这些字段都显示出来了，并且数据变得很多，我们来看一下，这么多条数据都是怎么来的，为什么会出现这么条数据，笛卡儿积这是一个数据名词，你可以去研究研究~~　　因为我们要进行连表查询，那么mysql并不知道你想要如何连接两个表的关系进行查询，那么mysql会将你两个表数据的所有组合关系都给你拼接成一条数据来显示，这样你就可以想查哪个关联关系的数据就查哪个了，如果还是不太理解看一下下面的图：</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　关于笛卡儿积现象的解释图：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181123165130845-264296897.png" alt="img"></p><p>　　</p><p>　　　　<strong>咱们为了更好的管理数据，为了节省空间，为了数据组织结构更清晰，将数据拆分到了不同表里面，但是本质上是不是还是一份数据，一份重复内容很多的很大的数据，所以我们即便是分表了，但是咱们是不是还需要找到一个方案把两个本来分开的表能够合并到一起来进行查询，那你是不是就可以根据部门找员工，根据员工找部门了，对不对，但是我们合并两个表的时候，如何合并，根据什么来合并，通过笛卡儿积这种合并有没有浪费，我们其实想做的是不是说我们的员工表中dep_id这个字段中的数据和部门表里面的id能够对应上就可以了，因为我们知道我们设计表的时候，是通过这两个字段来给两个表建立关系的，对不对，看下图：</strong></p><p>　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181123170733686-1528734466.png" alt="img"></strong></p><p>　　　　我们的目标就是将两个分散出去的表，按照两者之间有关系的字段，能对应上的字段，把两者合并成一张表，这就是多表查询的一个本质。那么笛卡儿积干了什么事儿，就是简单粗暴的将两个表的数据全部对应了一遍，用处就是什么呢，它肯定就能保证有一条是对应准的，你需要做的事情就是在笛卡儿积的基础上只过滤出我们需要的那些数据就行了，笛卡儿积不是咱们最终要得到的结果，只是给你提供了一个基础，它不管对应的对不对，全部给你对应一遍，然后你自己去筛选就可以了，然后基于笛卡儿积我们来找一下对应的数据，看看能不能找到：</p><p>　　<strong>2、内连接：只连接匹配的行</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#我们要找的数据就是员工表里面dep_id字段的值和部门表里面id字段的值能对应上的那些数据啊，所以你看下面的写法：mysql&gt; select * from employee,department where employee.dep_id=department.id;+----+-----------+--------+------+--------+------+--------------+| id | name      | sex    | age  | dep_id | id   | name         |+----+-----------+--------+------+--------+------+--------------+|  1 | egon      | male   |   18 |    200 |  200 | 技术         ||  2 | alex      | female |   48 |    201 |  201 | 人力资源     ||  3 | wupeiqi   | male   |   38 |    201 |  201 | 人力资源     ||  4 | yuanhao   | female |   28 |    202 |  202 | 销售         ||  5 | liwenzhou | male   |   18 |    200 |  200 | 技术         |+----+-----------+--------+------+--------+------+--------------+5 rows in set (0.14 sec)拿到了我们想要的结果。但是你看，我们左表employee表中的dep_id为204的那个数据没有了，右表department表的id为203的数据没有了，因为我们现在要的就是两表能对应上的数据一起查出来，那个204和203双方对应不上。#再看一个需求，我要查出技术部的员工的名字mysql&gt; select name from employee,department where employee.dep_id=department.id and department.name='技术';ERROR 1052 (23000): Column 'name' in field list is ambiguous#上面直接就报错了，因为select后面直接写的name，在两个表合并起来的表中，是有两个name字段的，直接写name是不行的，要加上表名，再看：mysql&gt; select employee.name from employee,department where employee.dep_id=department.id and department.name='技术';+-----------+| name      |+-----------+| egon      || liwenzhou |+-----------+2 rows in set (0.09 sec)结果就没问题了</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　但是你看上面的代码有没有什么不太好的地方，虽然我们能够完成我们的事情，但是代码可读性不好，所以以后不要这么写，但是看图：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181123180131254-1636098034.png" alt="img"></p><p>　　　　所以mysql为我们提供了一些专门做连表操作的方法，这些方法语义更加的明确，你一看就知道那些代码是连表的，那些代码是查询的，其实上面的连表也是个查询操作，但是我们为了区分明确，连表专门用连表的方法，查询就专门用查询的方法。那这些专门的方法都是什么呢，看后面的内容：</p><p>　　<strong>3 、外链接之左连接：优先显示左表全部记录</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#以左表为准，即找出所有员工信息，当然包括没有部门的员工#本质就是：在内连接的基础上增加左边有右边没有的结果  #注意语法：mysql&gt; select employee.id,employee.name,department.name as depart_name from employee left join department on employee.dep_id=department.id;+----+------------+--------------+| id | name       | depart_name  |+----+------------+--------------+|  1 | egon       | 技术         ||  5 | liwenzhou  | 技术         ||  2 | alex       | 人力资源     ||  3 | wupeiqi    | 人力资源     ||  4 | yuanhao    | 销售         ||  6 | jingliyang | NULL         |+----+------------+--------------+</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>4 、外链接之右连接：优先显示右表全部记录</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#以右表为准，即找出所有部门信息，包括没有员工的部门#本质就是：在内连接的基础上增加右边有左边没有的结果mysql&gt; select employee.id,employee.name,department.name as depart_name from employee right join department on employee.dep_id=department.id;+------+-----------+--------------+| id   | name      | depart_name  |+------+-----------+--------------+|    1 | egon      | 技术         ||    2 | alex      | 人力资源     ||    3 | wupeiqi   | 人力资源     ||    4 | yuanhao   | 销售         ||    5 | liwenzhou | 技术         || NULL | NULL      | 运营         |+------+-----------+--------------+</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>5 、全外连接：显示左右两个表全部记录</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果#注意：mysql不支持全外连接 full JOIN#强调：mysql可以使用此种方式间接实现全外连接select * from employee left join department on employee.dep_id = department.idunionselect * from employee right join department on employee.dep_id = department.id;#查看结果+------+------------+--------+------+--------+------+--------------+| id   | name       | sex    | age  | dep_id | id   | name         |+------+------------+--------+------+--------+------+--------------+|    1 | egon       | male   |   18 |    200 |  200 | 技术         ||    5 | liwenzhou  | male   |   18 |    200 |  200 | 技术         ||    2 | alex       | female |   48 |    201 |  201 | 人力资源     ||    3 | wupeiqi    | male   |   38 |    201 |  201 | 人力资源     ||    4 | yuanhao    | female |   28 |    202 |  202 | 销售         ||    6 | jingliyang | female |   18 |    204 | NULL | NULL         || NULL | NULL       | NULL   | NULL |   NULL |  203 | 运营         |+------+------------+--------+------+--------+------+--------------+#注意 union与union all的区别：union会去掉相同的纪录，因为union all是left join 和right join合并，所以有重复的记录，通过union就将重复的记录去重了。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="三-符合条件连接查询"><a href="#三-符合条件连接查询" class="headerlink" title="三 符合条件连接查询"></a>三 符合条件连接查询</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#示例1：以内连接的方式查询employee和department表，并且employee表中的age字段值必须大于25,即找出年龄大于25岁的员工以及员工所在的部门select employee.name,department.name from employee inner join department    on employee.dep_id = department.id    where age &gt; 25;#示例2：以内连接的方式查询employee和department表，并且以age字段的升序方式显示select employee.id,employee.name,employee.age,department.name from employee,department    where employee.dep_id = department.id    and age &gt; 25    order by age asc;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="四-子查询"><a href="#四-子查询" class="headerlink" title="四 子查询"></a>四 子查询</h1><p>　　子查询其实就是将你的一个查询结果用括号括起来，这个结果也是一张表，就可以将它交给另外一个sql语句，作为它的一个查询依据来进行操作。</p><p>　　来，我们简单来个需求：技术部都有哪些员工的姓名，都显示出来：　1、看一下和哪个表有关，然后from找到两个表  2、进行一个连表操作　3、基于连表的结果来一个过滤就可以了</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#我们之前的做法是：先连表mysql&gt; select * from employee inner join department on employee.dep_id = department.id; +----+-----------+--------+------+--------+------+--------------+| id | name      | sex    | age  | dep_id | id   | name         |+----+-----------+--------+------+--------+------+--------------+|  1 | egon      | male   |   18 |    200 |  200 | 技术         ||  2 | alex      | female |   48 |    201 |  201 | 人力资源     ||  3 | wupeiqi   | male   |   38 |    201 |  201 | 人力资源     ||  4 | yuanhao   | female |   28 |    202 |  202 | 销售         ||  5 | liwenzhou | male   |   18 |    200 |  200 | 技术         |+----+-----------+--------+------+--------+------+--------------+5 rows in set (0.10 sec)#然后根据连表的结果进行where过滤，将select*改为select employee.namemysql&gt; select employee.name from employee inner join department on employee.dep_id = department.id where department.name='技术';</code></pre><p>  +———–+<br>  | name |<br>  +———–+<br>  | egon |<br>  | liwenzhou |<br>  +———–+<br>  2 rows in set (0.09 sec)</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　然后看一下子查询这种方式的写法：它的做法就是解决完一个问题，再解决下一个问题，针对我们上面的需求，你想，我们的需求是不是说找技术部门下面有哪些员工对不对，如果你直接找员工表，你能确定哪个dep_id的数值表示的是技术部门吗，不能，所以咱们是不是应该先确定一个技术部门对应的id号是多少，然后根据部门的id号，再去员工表里面查询一下dep_id为技术部门对应的部门表的那个id号的所有的员工表里面的记录：好，那我们看一下下面的操作</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#首先从部门表里面找到技术部门对应的idmysql&gt; select id from department where name='技术';+------+| id   |+------+|  200 |+------+1 row in set (0.00 sec)#那我们把上面的查询结果用括号括起来，它就表示一条id=200的数据，然后我们通过员工表来查询dep_id=这条数据作为条件来查询员工的namemysql&gt; select name from employee where dep_id = (select id from department where name='技术');+-----------+| name      |+-----------+| egon      || liwenzhou |+-----------+2 rows in set (0.00 sec)上面这些就是子查询的一个思路，解决一个问题，再解决另外一个问题，你子查询里面可不可以是多个表的查询结果，当然可以，然后再通过这个结果作为依据来进行过滤，然后我们学一下子查询里面其他的内容，往下学。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>子查询：#1：子查询是将一个查询语句嵌套在另一个查询语句中。#2：内层查询语句的查询结果，可以为外层查询语句提供查询条件。#3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字#4：还可以包含比较运算符：= 、 !=、&gt; 、&lt;等</code></pre><p>　　<strong>1、带IN关键字的子查询</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#查询员工平均年龄在25岁以上的部门名，可以用连表，也可以用子查询，我们用子查询来搞一下select id,name from department    where id in         (select dep_id from employee group by dep_id having avg(age) &gt; 25);#连表来搞一下上面这个需求select department.name from department inner join employee on department.id=employee.dep_id     group by department.name     having avg(age)&gt;25;总结：子查询的思路和解决问题一样，先解决一个然后拿着这个的结果再去解决另外一个问题，连表的思路是先将两个表关联在一起，然后在进行group by啊过滤啊等等操作，两者的思路是不一样的#查看技术部员工姓名select name from employee    where dep_id in         (select id from department where name='技术');#查看不足1人的部门名(子查询得到的是有人的部门id)select name from department where id not in (select distinct dep_id from employee);</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>2、带比较运算符的子查询</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#比较运算符：=、!=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;#查询大于所有人平均年龄的员工名与年龄mysql&gt; select name,age from emp where age &gt; (select avg(age) from emp);+---------+------+| name | age |+---------+------+| alex | 48 || wupeiqi | 38 |+---------+------+2 rows in set (0.00 sec)#查询大于部门内平均年龄的员工名、年龄select t1.name,t1.age from emp t1inner join (select dep_id,avg(age) avg_age from emp group by dep_id) t2on t1.dep_id = t2.dep_idwhere t1.age &gt; t2.avg_age; </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><p>　　<strong>3、带EXISTS关键字的子查询</strong></p><p>　　　　EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。而是返回一个真假值。True或False<br>　　　　当返回True时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询。还可以写not exists，和exists的效果就是反的</p><p>　　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#department表中存在dept_id=203，Turemysql&gt; select * from employee    -&gt;     where exists      -&gt;         (select id from department where id=200); +----+------------+--------+------+--------+| id | name       | sex    | age  | dep_id |+----+------------+--------+------+--------+|  1 | egon       | male   |   18 |    200 ||  2 | alex       | female |   48 |    201 ||  3 | wupeiqi    | male   |   38 |    201 ||  4 | yuanhao    | female |   28 |    202 ||  5 | liwenzhou  | male   |   18 |    200 ||  6 | jingliyang | female |   18 |    204 |+----+------------+--------+------+--------+#department表中存在dept_id=205，Falsemysql&gt; select * from employee    -&gt;     where exists    -&gt;         (select id from department where id=204);Empty set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>练习：通过连表的方式来查询每个部门最新入职的那位员工</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>company.employee    员工id      id                  int                 姓名        emp_name            varchar    性别        sex                 enum    年龄        age                 int    入职日期     hire_date           date    岗位        post                varchar    职位描述     post_comment        varchar    薪水        salary              double    办公室       office              int    部门编号     depart_id           int#创建表，只需要创建这一张表create table employee(id int not null unique auto_increment,name varchar(20) not null,sex enum('male','female') not null default 'male', #大部分是男的age int(3) unsigned not null default 28,hire_date date not null,post varchar(50),post_comment varchar(100),salary double(15,2),office int, #一个部门一个屋子depart_id int);#查看表结构mysql&gt; desc employee;+--------------+-----------------------+------+-----+---------+----------------+| Field        | Type                  | Null | Key | Default | Extra          |+--------------+-----------------------+------+-----+---------+----------------+| id           | int(11)               | NO   | PRI | NULL    | auto_increment || name         | varchar(20)           | NO   |     | NULL    |                || sex          | enum('male','female') | NO   |     | male    |                || age          | int(3) unsigned       | NO   |     | 28      |                || hire_date    | date                  | NO   |     | NULL    |                || post         | varchar(50)           | YES  |     | NULL    |                || post_comment | varchar(100)          | YES  |     | NULL    |                || salary       | double(15,2)          | YES  |     | NULL    |                || office       | int(11)               | YES  |     | NULL    |                || depart_id    | int(11)               | YES  |     | NULL    |                |+--------------+-----------------------+------+-----+---------+----------------+#插入记录#三个部门：教学，销售，运营insert into employee(name,sex,age,hire_date,post,salary,office,depart_id) values('egon','male',18,'20170301','老男孩驻沙河办事处外交大使',7300.33,401,1), #以下是教学部('alex','male',78,'20150302','teacher',1000000.31,401,1),('wupeiqi','male',81,'20130305','teacher',8300,401,1),('yuanhao','male',73,'20140701','teacher',3500,401,1),('liwenzhou','male',28,'20121101','teacher',2100,401,1),('jingliyang','female',18,'20110211','teacher',9000,401,1),('jinxin','male',18,'19000301','teacher',30000,401,1),('成龙','male',48,'20101111','teacher',10000,401,1),('歪歪','female',48,'20150311','sale',3000.13,402,2),#以下是销售部门('丫丫','female',38,'20101101','sale',2000.35,402,2),('丁丁','female',18,'20110312','sale',1000.37,402,2),('星星','female',18,'20160513','sale',3000.29,402,2),('格格','female',28,'20170127','sale',4000.33,402,2),('张野','male',28,'20160311','operation',10000.13,403,3), #以下是运营部门('程咬金','male',18,'19970312','operation',20000,403,3),('程咬银','female',18,'20130311','operation',19000,403,3),('程咬铜','male',18,'20150411','operation',18000,403,3),('程咬铁','female',18,'20140512','operation',17000,403,3);#ps：如果在windows系统中，插入中文字符，select的结果为空白，可以将所有字符编码统一设置成gbk</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　答案：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>SELECT    *FROM    emp AS t1INNER JOIN (   #和虚拟表进行连表    SELECT        post,        max(hire_date) as max_date  #给这个最大的日期取个别名叫做max_date，先将每个部门最近入职的最大的日期的信息筛选出来，通过这个表来和我们上面的总表进行关联    FROM        emp    GROUP BY        post) AS t2 ON t1.post = t2.post  #给虚拟表取个别名叫做t2WHERE    t1.hire_date = t2.max_date;  #然后再通过where来过滤出，入职日期和最大日期相等的记录，就是我们要的内容</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="五-综合练习"><a href="#五-综合练习" class="headerlink" title="五 综合练习　"></a>五 综合练习　</h1><p>　　表结构为</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20180211190041138-168655281.png" alt="img"></p><p>　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#创建表及插入记录CREATE TABLE class (  cid int(11) NOT NULL AUTO_INCREMENT,  caption varchar(32) NOT NULL,  PRIMARY KEY (cid)) ENGINE=InnoDB CHARSET=utf8;INSERT INTO class VALUES(1, '三年二班'), (2, '三年三班'), (3, '一年二班'), (4, '二年九班');CREATE TABLE course(  cid int(11) NOT NULL AUTO_INCREMENT,  cname varchar(32) NOT NULL,  teacher_id int(11) NOT NULL,  PRIMARY KEY (cid),  KEY fk_course_teacher (teacher_id),  CONSTRAINT fk_course_teacher FOREIGN KEY (teacher_id) REFERENCES teacher (tid)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO course VALUES(1, '生物', 1), (2, '物理', 2), (3, '体育', 3), (4, '美术', 2);CREATE TABLE score (  sid int(11) NOT NULL AUTO_INCREMENT,  student_id int(11) NOT NULL,  course_id int(11) NOT NULL,  num int(11) NOT NULL,  PRIMARY KEY (sid),  KEY fk_score_student (student_id),  KEY fk_score_course (course_id),  CONSTRAINT fk_score_course FOREIGN KEY (course_id) REFERENCES course (cid),  CONSTRAINT fk_score_student FOREIGN KEY (student_id) REFERENCES student(sid)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO score VALUES(1, 1, 1, 10),(2, 1, 2, 9),(5, 1, 4, 66),(6, 2, 1, 8),(8, 2, 3, 68),(9, 2, 4, 99),(10, 3, 1, 77),(11, 3, 2, 66),(12, 3, 3, 87),(13, 3, 4, 99),(14, 4, 1, 79),(15, 4, 2, 11),(16, 4, 3, 67),(17, 4, 4, 100),(18, 5, 1, 79),(19, 5, 2, 11),(20, 5, 3, 67),(21, 5, 4, 100),(22, 6, 1, 9),(23, 6, 2, 100),(24, 6, 3, 67),(25, 6, 4, 100),(26, 7, 1, 9),(27, 7, 2, 100),(28, 7, 3, 67),(29, 7, 4, 88),(30, 8, 1, 9),(31, 8, 2, 100),(32, 8, 3, 67),(33, 8, 4, 88),(34, 9, 1, 91),(35, 9, 2, 88),(36, 9, 3, 67),(37, 9, 4, 22),(38, 10, 1, 90),(39, 10, 2, 77),(40, 10, 3, 43),(41, 10, 4, 87),(42, 11, 1, 90),(43, 11, 2, 77),(44, 11, 3, 43),(45, 11, 4, 87),(46, 12, 1, 90),(47, 12, 2, 77),(48, 12, 3, 43),(49, 12, 4, 87),(52, 13, 3, 87);CREATE TABLE student(  sid int(11) NOT NULL AUTO_INCREMENT,  gender char(1) NOT NULL,  class_id int(11) NOT NULL,  sname varchar(32) NOT NULL,  PRIMARY KEY (sid),  KEY fk_class (class_id),  CONSTRAINT fk_class FOREIGN KEY (class_id) REFERENCES class (cid)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO student VALUES(1, '男', 1, '理解'), (2, '女', 1, '钢蛋'), (3, '男', 1, '张三'), (4, '男', 1, '张一'), (5, '女', 1, '张二'), (6, '男', 1, '张四'), (7, '女', 2, '铁锤'), (8, '男', 2, '李三'), (9, '男', 2, '李一'), (10, '女', 2, '李二'), (11, '男', 2, '李四'), (12, '女', 3, '如花'), (13, '男', 3, '刘三'), (14, '男', 3, '刘一'), (15, '女', 3, '刘二'), (16, '男', 3, '刘四');CREATE TABLE teacher(  tid int(11) NOT NULL AUTO_INCREMENT,  tname varchar(32) NOT NULL,  PRIMARY KEY (tid)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO teacher VALUES(1, '张磊老师'), (2, '李平老师'), (3, '刘海燕老师'), (4, '朱云海老师'), (5, '李杰老师');</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>！！！重中之重：练习之前务必搞清楚sql逻辑查询语句的执行顺序</strong></p><p><a href="https://www.cnblogs.com/clschao/articles/9995517.html">链接：https://www.cnblogs.com/clschao/articles/9995517.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>1、查询所有的课程的名称以及对应的任课老师姓名2、查询学生表中男女生各有多少人3、查询物理成绩等于100的学生的姓名4、查询平均成绩大于八十分的同学的姓名和平均成绩5、查询所有学生的学号，姓名，选课数，总成绩6、 查询姓李老师的个数7、 查询没有报李平老师课的学生姓名8、 查询物理课程比生物课程高的学生的学号9、 查询没有同时选修物理课程和体育课程的学生姓名10、查询挂科超过两门(包括两门)的学生姓名和班级11 、查询选修了所有课程的学生姓名12、查询李平老师教的课程的所有成绩记录13、查询全部学生都选修了的课程号和课程名14、查询每门课程被选修的次数15、查询之选修了一门课程的学生姓名和学号16、查询所有学生考出的成绩并按从高到低排序（成绩去重）17、查询平均成绩大于85的学生姓名和平均成绩18、查询生物成绩不及格的学生姓名和对应生物分数19、查询在所有选修了李平老师课程的学生中，这些课程(李平老师的课程，不是所有课程)平均成绩最高的学生姓名20、查询每门课程成绩最好的前两名学生姓名21、查询不同课程但成绩相同的学号，课程号，成绩22、查询没学过“叶平”老师课程的学生姓名以及选修的课程名称；23、查询所有选修了学号为1的同学选修过的一门或者多门课程的同学学号和姓名；24、任课最多的老师中学生单科成绩最高的学生姓名</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="https://www.cnblogs.com/clschao/articles/9995776.html">参考答案:https://www.cnblogs.com/clschao/articles/9995776.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之单表查询</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="#_label1">一 单表查询的语法</a></li><li><a href="#_label2">二 关键字的执行优先级(重点)</a></li><li><a href="#_label3">三 简单查询</a></li><li><a href="#_label4">四 WHERE约束</a></li><li><a href="#_label5">五 分组查询:GROUP BY</a></li><li><a href="#_label6">六 HAVING过滤</a></li><li><a href="#_label7">七 查询排序:ORDER BY</a></li><li><a href="#_label8">八 限制查询的记录数:LIMIT</a></li><li><a href="#_label9">九 使用正则表达式查询</a></li></ul><h1 id="一-单表查询的语法"><a href="#一-单表查询的语法" class="headerlink" title="一 单表查询的语法"></a>一 单表查询的语法</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#查询数据的本质：mysql会到你本地的硬盘上找到对应的文件，然后打开文件，按照你的查询条件来找出你需要的数据。下面是完整的一个单表查询的语法select * from，这个select * 指的是要查询所有字段的数据。SELECT distinct 字段1,字段2... FROM 库名.表名 #from后面是说从库的某个表中去找数据，mysql会去找到这个库对应的文件夹下去找到你表名对应的那个数据文件，找不到就直接报错了，找到了就继续后面的操作                  WHERE 条件       #从表中找符合条件的数据记录，where后面跟的是你的查询条件                  GROUP BY field（字段）   #分组                  HAVING 筛选      #过滤，过滤之后执行select后面的字段筛选，就是说我要确定一下需要哪个字段的数据，你查询的字段数据进行去重，然后在进行下面的操作                  ORDER BY field（字段）   #将结果按照后面的字段进行排序                  LIMIT 限制条数    #将最后的结果加一个限制条数，就是说我要过滤或者说限制查询出来的数据记录的条数关于上面这些内容，我们在下面一个一个的来详细解释</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="二-关键字的执行优先级-重点"><a href="#二-关键字的执行优先级-重点" class="headerlink" title="二 关键字的执行优先级(重点)"></a>二 关键字的执行优先级(重点)</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>重点中的重点：关键字的执行优先级fromwheregroup byhavingselectdistinctorder bylimit</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>1.找到表:from</strong></p><p>　　<strong>2.拿着where指定的约束条件，去文件/表中取出一条条记录</strong></p><p>　　<strong>3.将取出的一条条记录进行分组group by，如果没有group by，则整体作为一组</strong></p><p>　　<strong>4.将分组的结果进行having过滤</strong></p><p>　　<strong>5.执行select</strong></p><p>　　<strong>6.去重</strong></p><p>　　<strong>7.将结果按条件排序：order by</strong></p><p>　　<strong>8.限制结果的显示条数</strong></p><p>​       <strong>详细见：<a href="https://www.cnblogs.com/clschao/articles/9995517.html">https://www.cnblogs.com/clschao/articles/9995517.html</a></strong></p><h1 id="三-简单查询"><a href="#三-简单查询" class="headerlink" title="三 简单查询"></a>三 简单查询</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#我们来创建一个员工表，然后对员工表进行一个简单的查询，来看一下效果，下面是员工表的字段company.employee    员工id      id                  int                 姓名        emp_name            varchar    性别        sex                 enum    年龄        age                 int    入职日期     hire_date           date    岗位        post                varchar    职位描述     post_comment        varchar    薪水        salary              double    办公室       office              int    部门编号     depart_id           int#创建表create table employee(    id int not null unique auto_increment,    name varchar(20) not null,    sex enum('male','female') not null default 'male', #大部分是男的    age int(3) unsigned not null default 28,    hire_date date not null,    post varchar(50),    post_comment varchar(100),    salary double(15,2),    office int, #一个部门一个屋子    depart_id int);#查看表结构mysql&gt; desc employee;+--------------+-----------------------+------+-----+---------+----------------+| Field        | Type                  | Null | Key | Default | Extra          |+--------------+-----------------------+------+-----+---------+----------------+| id           | int(11)               | NO   | PRI | NULL    | auto_increment || name         | varchar(20)           | NO   |     | NULL    |                || sex          | enum('male','female') | NO   |     | male    |                || age          | int(3) unsigned       | NO   |     | 28      |                || hire_date    | date                  | NO   |     | NULL    |                || post         | varchar(50)           | YES  |     | NULL    |                || post_comment | varchar(100)          | YES  |     | NULL    |                || salary       | double(15,2)          | YES  |     | NULL    |                || office       | int(11)               | YES  |     | NULL    |                || depart_id    | int(11)               | YES  |     | NULL    |                |+--------------+-----------------------+------+-----+---------+----------------+#插入记录#三个部门：教学，销售，运营insert into employee(name,sex,age,hire_date,post,salary,office,depart_id) values('egon','male',18,'20170301','老男孩驻沙河办事处外交大使',7300.33,401,1), #以下是教学部，全都是老师('alex','male',78,'20150302','teacher',1000000.31,401,1),('wupeiqi','male',81,'20130305','teacher',8300,401,1),('yuanhao','male',73,'20140701','teacher',3500,401,1),('liwenzhou','male',28,'20121101','teacher',2100,401,1),('jingliyang','female',18,'20110211','teacher',9000,401,1),('jinxin','male',18,'19000301','teacher',30000,401,1),('成龙','male',48,'20101111','teacher',10000,401,1),('歪歪','female',48,'20150311','sale',3000.13,402,2),#以下是销售部门('丫丫','female',38,'20101101','sale',2000.35,402,2),('丁丁','female',18,'20110312','sale',1000.37,402,2),('星星','female',18,'20160513','sale',3000.29,402,2),('格格','female',28,'20170127','sale',4000.33,402,2),('张野','male',28,'20160311','operation',10000.13,403,3), #以下是运营部门('程咬金','male',18,'19970312','operation',20000,403,3),('程咬银','female',18,'20130311','operation',19000,403,3),('程咬铜','male',18,'20150411','operation',18000,403,3),('程咬铁','female',18,'20140512','operation',17000,403,3);#ps：如果在windows系统中，插入中文字符，select的结果为空白，可以将所有字符编码统一设置成gbk</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　查询操作：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>简单查询    SELECT id,name,sex,age,hire_date,post,post_comment,salary,office,depart_id     FROM employee;    SELECT * FROM employee; #不推荐用* ，查询的时候*的效率低，至于为什么低，后面会讲到，先知道一下就行了    SELECT name,salary FROM employee;#避免重复DISTINCT   SELECT post FROM employee;#直接这样查询我们会看到很多重复的内容，我只想看一下有哪些职位，那么多重复的内容是没用的，所以我们加一个去重的功能，叫做distinct 　　SELECT DISTINCT post FROM employee;  #对查询出来的记录进行去重，如果post职位有重复的，就会被剔除，剩下不重复的内容，注意，因为我们查询出来的记录里面只有一个字段post，才会根据post来进行去重   SELECT DISTINCT post，salary FROM employee；#但是如果这样写，你会发现，貌似没有起到根据post来去重的效果，因为你的去重条件变成了post和salary两个字段的数据，只有他俩合起来是一个重复记录的时候才会去重      　　看一下下面这两句的效果就明白了：注意一点，使用distinct对记录进行去重的时候，distinct必须写在所有查询字段的前面，不然会报错，当然有些特别的用法可以结合着写到字段的中间或者后面，这个后面学到了我们再说   select post，sex from employee；   select distinct post，sex from employee；#通过四则运算查询    SELECT name, salary*12 FROM employee; #查询每个人的年薪，月薪我们有记录，查年薪呢？简单的乘以12就可以了，from 库.表的时候，我们已经通过use 库名；来指定了库了，所以from的时候直接写from 表，就行了    #你会发现，结果是出来了，但是我们的那个薪资的字段名变成了salary*12，是因为我们通过查询语句查询出来的也是一张表，但是这个表是不是内存当中的一个虚拟表，并不是我们硬盘中存的那个完整的表，对吧，虚拟表是不是也有标题和记录啊，既然是一个表，我们是可以指定这个虚拟表的标题的，通过as+新字段名来指定    SELECT name, salary*12 AS Annual_salary FROM employee; #as + 新字段名，就是起一个别名的意思，上面的那个salary*12的字段名也是一个别名，只不过不直观，是mysql自动给你写上的    SELECT name, salary*12 Annual_salary FROM employee;　　#除了乘法以外，加减乘除都是可以的#自定义显示格式，自己规定查询结果的显示格式   CONCAT() 函数用于连接字符串   SELECT CONCAT('姓名: ',name,'  年薪: ', salary*12)  AS Annual_salary  #我想让name这个字段显示的字段名称是中文的姓名，让salary*12显示的是中文的年薪，   FROM employee;#看结果：通过结果你可以看出，这个concat就是帮我们做字符串拼接的，并且拼接之后的结果，都在一个叫做Annual_salary的字段中了</code></pre><p>　　　　+—————————————+<br>　　　　| Annual_salary |<br>　　　　+—————————————+<br>　　　　| 姓名: egon 年薪: 87603.96 |<br>　　　　| 姓名: alex 年薪: 12000003.72 |<br>　　　　| 姓名: wupeiqi 年薪: 99600.00 |<br>　　　　| 姓名: yuanhao 年薪: 42000.00 |</p><p>　　　　…..</p><p>​       +—————————————+</p><pre><code>   SELECT CONCAT('姓名: ',name,'  年薪: ', salary*12)  AS Annual_salary,CONCAT('性别：',sex) from employee;#还可以这样分成两列　　   CONCAT_WS() 第一个参数为分隔符来进行字符串拼接   SELECT CONCAT_WS(':',name,salary*12)  AS Annual_salary  #通过冒号来将name和salary连接起来   FROM employee;   #上面这个效果我们也可以通过concat来实现：SELECT CONCAT(name,':',salary*12)  AS Annual_salary from employee;   结合CASE语句：结合条件来对查询的结果进行一些加工操作   SELECT       (           CASE           WHEN NAME = 'egon' THEN               NAME           WHEN NAME = 'alex' THEN               CONCAT(name,'_BIGSB')           ELSE               concat(NAME, 'SB')           END       ) as new_name,sex   FROM       employee;#看结果:</code></pre><p>　　　　+————–+——–+<br>　　　　| new_name | sex |<br>　　　　+————–+——–+<br>　　　　| egon | male |<br>　　　　| alex_BIGSB | male |<br>　　　　| wupeiqiSB | male |<br>　　　　| yuanhaoSB | male |<br>　　　　| liwenzhouSB | male |<br>　　　　| jingliyangSB | female |<br>　　　　| jinxinSB | male |<br>　　　　| 成龙SB | male |</p><p>　　　　…</p><p>　　　　+————–+</p><pre><code></code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　简单查询就结束了，我们做一下练习，然后继续学习我们上面列举完整查询语句中的其他内容。</p><p>　　小练习：</p><pre><code>1 查出所有员工的名字，薪资,格式为    &lt;名字:egon&gt;    &lt;薪资:3000&gt;2 查出所有的岗位（去掉重复）3 查出所有员工名字，以及他们的年薪,年薪的字段名为annual_year</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><pre><code>select concat('&lt;名字:',name,'&gt;    ','&lt;薪资:',salary,'&gt;') from employee;select distinct depart_id from employee;select name,salary*12 annual_salary from employee;</code></pre><h1 id="四-WHERE约束"><a href="#四-WHERE约束" class="headerlink" title="四 WHERE约束"></a>四 WHERE约束</h1><p>　　where语句中可以使用：</p><p>　　　　之前我们用where 后面跟的语句是不是id=1这种类型的啊，用=号连接的，除了=号外，还能使用其他的，看下面：</p><p>　　1. 比较运算符：&gt; &lt; &gt;= &lt;= &lt;&gt; !=<br>　　2. between 80 and 100 值在80到100之间<br>　　3. in(80,90,100)  值是80或90或100<br>　　4. like ‘egon%’</p><pre><code>　　pattern可以是%或_，　　%表示任意多字符　　_表示一个字符 </code></pre><p>　　5. 逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#1:单条件查询    SELECT name FROM employee        WHERE post='sale';  #注意优先级，我们说where的优先级是不是比select要高啊，所以我们的顺序是先找到这个employee表，然后按照post='sale'的条件，然后去表里面select数据#2:多条件查询    SELECT name,salary FROM employee         WHERE post='teacher' AND salary&gt;10000;#3:关键字BETWEEN AND 写的是一个区间    SELECT name,salary FROM employee         WHERE salary BETWEEN 10000 AND 20000; #就是salary&gt;=10000 and salary&lt;=20000的数据    SELECT name,salary FROM employee         WHERE salary NOT BETWEEN 10000 AND 20000; #加个not，就是不在这个区间内，薪资小于10000的或者薪资大于20000的，注意没有等于，#4:关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS) 判断null只能用is    SELECT name,post_comment FROM employee         WHERE post_comment IS NULL;    SELECT name,post_comment FROM employee         WHERE post_comment IS NOT NULL;    SELECT name,post_comment FROM employee         WHERE post_comment=''; 注意''是空字符串，不是null，两个是不同的东西，null是啥也没有，''是空的字符串的意思，是一种数据类型，null是另外一种数据类型    ps：        执行        update employee set post_comment='' where id=2;        再用上条查看，就会有结果了#5:关键字IN集合查询    SELECT name,salary FROM employee         WHERE salary=3000 OR salary=3500 OR salary=4000 OR salary=9000 ; #这样写是不是太麻烦了，写一大堆的or，下面我们用in这个简单的写法来搞    SELECT name,salary FROM employee         WHERE salary IN (3000,3500,4000,9000) ;    SELECT name,salary FROM employee         WHERE salary NOT IN (3000,3500,4000,9000) ;#6:关键字LIKE模糊查询，模糊匹配，可以结合通配符来使用    通配符’%’  #匹配任意所有字符    SELECT * FROM employee             WHERE name LIKE 'eg%';    通配符’_’  #匹配任意一个字符       SELECT * FROM employee             WHERE name LIKE 'al__'; #注意我这里写的两个_，用1个的话，匹配不到alex，因为al后面还有两个字符ex。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>where条件咱们就说完了，这个where条件到底怎么运作的，我们来说一下：我们以select id,name,age from employee where id&gt;7;这个语句来说一下</p><p>　　首先先找到employee表，找到这个表之后，mysql会拿着where后面的约束条件去表里面找符合条件的数据，然后遍历你表中所有的数据，查看一下id是否大于7，逐条的对比，然后只要发现id比7大的，它就会把这一整条记录给select，但是select说我只拿id、name、age这个三个字段里面的数据，然后就打印了这三个字段的数据，然后where继续往下过滤，看看id是不是还有大于7的，然后发现一个符合条件的就给select一个，然后重复这样的事情，直到把数据全部过滤一遍才会结束。这就是where条件的一个工作方式。</p><p>然后我们可以来做一些小练习：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>1. 查看岗位是teacher的员工姓名、年龄2. 查看岗位是teacher且年龄大于30岁的员工姓名、年龄3. 查看岗位是teacher且薪资在9000-1000范围内的员工姓名、年龄、薪资4. 查看岗位描述不为NULL的员工信息5. 查看岗位是teacher且薪资是10000或9000或30000的员工姓名、年龄、薪资6. 查看岗位是teacher且薪资不是10000或9000或30000的员工姓名、年龄、薪资7. 查看岗位是teacher且名字是jin开头的员工姓名、年薪</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>select name,age from employee where post = 'teacher';select name,age from employee where post='teacher' and age &gt; 30; select name,age,salary from employee where post='teacher' and salary between 9000 and 10000;select * from employee where post_comment is not null;select name,age,salary from employee where post='teacher' and salary in (10000,9000,30000);select name,age,salary from employee where post='teacher' and salary not in (10000,9000,30000);select name,salary*12 from employee where post='teacher' and name like 'jin%';</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="五-分组查询-GROUP-BY"><a href="#五-分组查询-GROUP-BY" class="headerlink" title="五 分组查询:GROUP BY"></a>五 分组查询:GROUP BY</h1><p>　　<strong>1、 什么是分组？为什么要分组？</strong></p><p>　　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#1、首先明确一点：分组发生在where之后，即分组是基于where之后得到的记录而进行的#2、分组指的是：将所有记录按照某个相同字段进行归类，比如针对员工信息表的职位分组，或者按照性别进行分组等#3、为何要分组呢？是因为我们有时候会需要以组为单位来统计一些数据或者进行一些计算的，对不对，比方说下面的几个例子    取每个部门的最高工资      取每个部门的员工数    取男人数和女人数      小窍门：‘每’这个字后面的字段，就是我们分组的依据，只是个小窍门，但是不能表示所有的情况，看上面第三个分组，没有'每'字，这个就需要我们通过语句来自行判断分组依据了    我们能用id进行分组吗，能，但是id是不是重复度很低啊，基本没有重复啊，对不对，这样的字段适合做分组的依据吗？不适合，对不对，依据性别分组行不行，当然行，因为性别我们知道，是不是就两种啊，也可能有三种是吧，这个重复度很高，对不对，分组来查的时候才有更好的意义　　#4、大前提：    可以按照任意字段分组，但是分组完毕后，比如group by post，只能查看post字段，如果想查看组内信息，需要借助于聚合函数#注意一点，在查询语句里面select 字段 from 表，这几项是必须要有的，其他的什么where、group by等等都是可有可无的</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><p>　　来，我们来测试一下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; select * from employee group by post;+----+--------+--------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+| id | name   | sex    | age | hire_date  | post                                    | post_comment | salary     | office | depart_id |+----+--------+--------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+| 14 | 张野   | male   |  28 | 2016-03-11 | operation                               | NULL         |   10000.13 |    403 |         3 ||  9 | 歪歪   | female |  48 | 2015-03-11 | sale                                    | NULL         |    3000.13 |    402 |         2 ||  2 | alex   | male   |  78 | 2015-03-02 | teacher                                 | NULL         | 1000000.31 |    401 |         1 ||  1 | egon   | male   |  18 | 2017-03-01 | 老男孩驻沙河办事处外交大使              | NULL         |    7300.33 |    401 |         1 |+----+--------+--------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+4 rows in set (0.06 sec)通过结果可以看出，如果直接通过post部门字段来进行分组，默认拿到的结果都是每组的第一条数据但是你想，我们分组的意义是什么，是不是说通过分组来统计一下整个组的情况啊，不再是看某个人单独的情况了，对不对，并且将来你在这样进行直接分组查询的时候，可能因为你们公司设置的mysql的环境不同，而查不到数据，我们可以看到，我们现在仍然可以查询出来数据，但是如果我们在sql_mode中添加了下面的only_full_group_by这个mode，那么我们在直接分组查询，就无法得到数据了，只能得到字段名并且设置了sql_mode为only_full_group_by之后，select *，就不行了，会直接报错，只能select post ，post是你分组的那个字段</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>2、 ONLY_FULL_GROUP_BY</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#查看MySQL 5.7默认的sql_mode如下：mysql&gt; select @@global.sql_mode;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION#！！！注意ONLY_FULL_GROUP_BY的语义就是确定select target list中的所有列的值都是明确语义，简单的说来，在ONLY_FULL_GROUP_BY模式下，target list中的值要么是来自于聚集函数的结果，要么是来自于group by list中的表达式的值。#设置sql_mole如下操作(我们可以去掉ONLY_FULL_GROUP_BY模式)：mysql&gt; set global sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　看一下测试：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; select @@global.sql_mode;+-------------------+| @@global.sql_mode |+-------------------+|                   |+-------------------+1 row in set (0.00 sec)mysql&gt; select * from emp group by post; +----+------+--------+-----+------------+----------------------------+--------------+------------+--------+-----------+| id | name | sex    | age | hire_date  | post                       | post_comment | salary     | office | depart_id |+----+------+--------+-----+------------+----------------------------+--------------+------------+--------+-----------+| 14 | 张野 | male   |  28 | 2016-03-11 | operation                  | NULL         |   10000.13 |    403 |         3 ||  9 | 歪歪 | female |  48 | 2015-03-11 | sale                       | NULL         |    3000.13 |    402 |         2 ||  2 | alex | male   |  78 | 2015-03-02 | teacher                    | NULL         | 1000000.31 |    401 |         1 ||  1 | egon | male   |  18 | 2017-03-01 | 老男孩驻沙河办事处外交大使 | NULL         |    7300.33 |    401 |         1 |+----+------+--------+-----+------------+----------------------------+--------------+------------+--------+-----------+4 rows in set (0.00 sec)#由于没有设置ONLY_FULL_GROUP_BY,于是也可以有结果，默认都是组内的第一条记录，但其实这是没有意义的mysql&gt; set global sql_mode='ONLY_FULL_GROUP_BY';Query OK, 0 rows affected (0.00 sec)mysql&gt; quit #设置成功后，一定要退出，然后重新登录方可生效Byemysql&gt; use db1;Database changedmysql&gt; select * from emp group by post; #报错ERROR 1055 (42000): 'db1.emp.id' isn't in GROUP BY  #意思是告诉你，你select后面取的字段必须在你的group by后面的字段里面才行mysql&gt; select post,count(id) from emp group by post; #只能查看分组依据和使用聚合函数+----------------------------+-----------+| post                       | count(id) |+----------------------------+-----------+| operation                  |         5 || sale                       |         5 || teacher                    |         7 || 老男孩驻沙河办事处外交大使 |         1 |+----------------------------+-----------+4 rows in set (0.00 sec)因为一般分组之后，我们再考虑其中一条数据就没有什么意义了，所以一般我们都会在这种模式下进行分组，下面我们在看看group by，下面的内容</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>3、 GROUP BY</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>单独使用GROUP BY关键字分组    SELECT post FROM employee GROUP BY post;    注意：我们按照post字段分组，那么select查询的字段只能是post，想要获取组内的其他相关信息，需要借助函数GROUP BY关键字和GROUP_CONCAT()函数一起使用,比如说我想按部门分组，每个组有哪些员工，都显示出来，怎么搞    SELECT post,GROUP_CONCAT(name) FROM employee GROUP BY post;#按照岗位分组，并查看组内所有成员名，通过逗号拼接在一起    SELECT post,GROUP_CONCAT(name,':',salary) as emp_members FROM employee GROUP BY post;GROUP BY一般都会与聚合函数一起使用，聚合是什么意思：聚合就是将分组的数据聚集到一起，合并起来搞事情，拿到一个最后的结果    select post,count(id) as count from employee group by post;#按照岗位分组，并查看每个组有多少人，每个人都有唯一的id号，我count是计算一下分组之后每组有多少的id记录，通过这个id记录我就知道每个组有多少人了关于集合函数，mysql提供了以下几种聚合函数：count、max、min、avg、sum等，上面的group_concat也算是一个聚合函数了，做字符串拼接的操作</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong>强调：</strong></p><pre><code>如果我们用设置了unique约束的字段作为分组的依据，则每一条记录自成一组，这种分组没有意义多条记录之间的某个字段值相同，该字段通常用来作为分组的依据</code></pre><p>　　<strong>4、 聚合函数</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#强调：聚合函数聚合的是组的内容，若是没有分组，则默认一组示例：    SELECT COUNT(*) FROM employee;  #count是统计个数用的    SELECT COUNT(*) FROM employee WHERE depart_id=1;  #后面跟where条件的意思是统计一下满足depart_id=1这个的所有记录的个数    SELECT MAX(salary) FROM employee;  #max（）统计分组后每组的最大值，这里没有写group by，那么就是统计整个表中所有记录中薪资最大的，薪资的值    SELECT MIN(salary) FROM employee;    SELECT AVG(salary) FROM employee;    SELECT SUM(salary) FROM employee;    SELECT SUM(salary) FROM employee WHERE depart_id=3;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>5、 小练习：</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>1. 查询岗位名以及岗位包含的所有员工名字#通过上面的需求来整理逻辑：a、先看一下和哪个表有关系：所有的信息都在employee这个表里面，所以先写from employee，找到表了#                      b、看有没有什么过滤条件，大于小于啊什么的，没有吧，所以是不是不需要写where条件啊#                      c、看看有没有分组的内容，也就是看看上面的需求里面有没有分类的概念，发现是不是有啊，按照岗位来分组，对不对，所以该写什么了：from employee group by post；#                      d、然后再看需要查什么字段出来，发现是不是要看岗位名和所有员工的名字啊，所以怎么写：select post,group_concat(name) from employee group by post;这就是完整语句了，不信你试试下面的题都按照上面这个逻辑来搞一搞：2. 查询岗位名以及各岗位内包含的员工个数3. 查询公司内男员工和女员工的个数4. 查询岗位名以及各岗位的平均薪资5. 查询岗位名以及各岗位的最高薪资6. 查询岗位名以及各岗位的最低薪资7. 查询男员工与男员工的平均薪资，女员工与女员工的平均薪资。 #这道题我们自己提炼一下分组依据，是不是就是性别啊#总结：先from打开文件，然后按照where后面的条件，将硬盘的数据读到内存，内存中的到一张虚拟表，然后按照虚拟表来进行group by分组。group by 必须写在where条件之后，写在where之前会报错，语法规定的#我们说聚合函数是跟着分组来的，你看这样一句话：select max(salary) from employee;直接也是可以使用聚合函数的，因为没有where，那么默认是表中所有的数据，没有group by，默认整个表是一组8.统计各部门年龄在30岁及以上的员工平均薪资#想一下怎么写，1、from 表  2、where age&gt;=30得到一张虚拟表 3、对虚拟表按部门group by  4、select 部门和聚合函数avg#答案：select post,avg(salary) from employee where age&gt;=30 group by post;#看结果：</code></pre><p>​    mysql&gt; select post,avg(salary) from employee where age&gt;=30 group by post;#因为有的部门里面的员工没有大于30岁的，所以没有显示出所有的部门<br>​    +———+—————+<br>​    | post | avg(salary) |<br>​    +———+—————+<br>​    | sale | 2500.240000 |<br>​    | teacher | 255450.077500 |<br>​    +———+—————+<br>​    2 rows in set (0.09 sec)</p><p>到这里我们的group by就讲完了，看一下我们完整查询语句里面还有什么</p><pre><code>SELECT distinct 字段1,字段2... FROM 库名.表名                   WHERE 条件                         GROUP BY field（字段）                     HAVING 筛选      #过滤，过滤之后执行select后面的字段筛选，就是说我要确定一下需要哪个字段的数据，你查询的字段数据进行去重，然后在进行下面的操作                  ORDER BY field（字段）   #将结果按照后面的字段进行排序                  LIMIT 限制条数 注意：虽然语法里面我们先写的select，但是并不是先执行的select，按照mysql自己的规范来执行的下面关键字的优先级　　from　　where　　group by　　having　　select　　distinct　　order by　　limit</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#题1：分组mysql&gt; select post,group_concat(name) from employee group by post;+-----------------------------------------+---------------------------------------------------------+| post                                    | group_concat(name)                                      |+-----------------------------------------+---------------------------------------------------------+| operation                               | 张野,程咬金,程咬银,程咬铜,程咬铁                        || sale                                    | 歪歪,丫丫,丁丁,星星,格格                                || teacher                                 | alex,wupeiqi,yuanhao,liwenzhou,jingliyang,jinxin,成龙   || 老男孩驻沙河办事处外交大使              | egon                                                    |+-----------------------------------------+---------------------------------------------------------+#题目2：mysql&gt; select post,count(id) from employee group by post;+-----------------------------------------+-----------+| post                                    | count(id) |+-----------------------------------------+-----------+| operation                               |         5 || sale                                    |         5 || teacher                                 |         7 || 老男孩驻沙河办事处外交大使              |         1 |+-----------------------------------------+-----------+#题目3：mysql&gt; select sex,count(id) from employee group by sex;+--------+-----------+| sex    | count(id) |+--------+-----------+| male   |        10 || female |         8 |+--------+-----------+#题目4：mysql&gt; select post,avg(salary) from employee group by post;+-----------------------------------------+---------------+| post                                    | avg(salary)   |+-----------------------------------------+---------------+| operation                               |  16800.026000 || sale                                    |   2600.294000 || teacher                                 | 151842.901429 || 老男孩驻沙河办事处外交大使              |   7300.330000 |+-----------------------------------------+---------------+#题目5mysql&gt; select post,max(salary) from employee group by post;+-----------------------------------------+-------------+| post                                    | max(salary) |+-----------------------------------------+-------------+| operation                               |    20000.00 || sale                                    |     4000.33 || teacher                                 |  1000000.31 || 老男孩驻沙河办事处外交大使              |     7300.33 |+-----------------------------------------+-------------+#题目6mysql&gt; select post,min(salary) from employee group by post;+-----------------------------------------+-------------+| post                                    | min(salary) |+-----------------------------------------+-------------+| operation                               |    10000.13 || sale                                    |     1000.37 || teacher                                 |     2100.00 || 老男孩驻沙河办事处外交大使              |     7300.33 |+-----------------------------------------+-------------+#题目七mysql&gt; select sex,avg(salary) from employee group by sex;+--------+---------------+| sex    | avg(salary)   |+--------+---------------+| male   | 110920.077000 || female |   7250.183750 |+--------+---------------+</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="六-HAVING过滤"><a href="#六-HAVING过滤" class="headerlink" title="六 HAVING过滤"></a>六 HAVING过滤</h1><p>　　<strong>讲having之前，我们补充一个点：之前我们写的查询语句是这样的：select id,name from employee;实际上我们在select每个字段的时候，省略了一个表名，有的人可能会这样写，select employee.id,employee.name from employee;你会发现查询出来的结果是一样的，但是如果你要将查询出来的结果表，起一个新表名的话，带着表名这样写就错了</strong></p><p>　　<strong>select employee.id,employee.name from employee as tb1;这样执行会下面的报错：</strong></p><p>　　　　mysql&gt; select employee.id,employee.name from employee as tb1;<br>　　　　ERROR 1054 (42S22): Unknown column ‘employee.id’ in ‘field list’</p><p>　　<strong>因为这个语句先执行的是谁啊，是不是我们的from啊，那么后面的as也是比select要先执行的，所以你先将表employee起了个新名字叫做tb1，然后在tb1里面取查询数据，那么tb1里面找不到employee.id这个字段，就会报错，如果我们查询的时候不带表名，你as来起一个新的表名也是没问题的，简单提一下这个内容，知道就好了</strong></p><p>　　</p><p><strong>HAVING与WHERE不一样的地方在于!!!!!!</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>having的语法格式和where是一模一样的，只不过having是在分组之后进行的进一步的过滤，where不能使用聚合函数，having是可以使用聚合函数的#！！！执行优先级从高到低：where &gt; group by &gt; having #1. Where 发生在分组group by之前，因而Where中可以有任意字段，但是绝对不能使用聚合函数。#2. Having发生在分组group by之后，因而Having中可以使用分组的字段，无法直接取到其他字段,having是可以使用聚合函数</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　having简单测试：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#来个需求：统计各部门年龄在30岁及以上的员工的平均薪资，并且保留平均工资大于10000的部门答案：select post,avg(salary) as new_sa from employee where age&gt;=30 group by post having avg(salary) &gt; 10000;看结果：</code></pre><p>　　+———+—————+<br>　　| post | new_sa |<br>　　+———+—————+<br>　　| teacher | 255450.077500 |<br>　　+———+—————+<br>　　1 row in set (0.00 sec)</p><pre><code>然后我们看这样一句话：select * from employee having avg(salary) &gt; 10000;只要一运行就会报错：</code></pre><p>　　　　mysql&gt; select * from employee having avg(salary) &gt; 10000;<br>　　　　ERROR 1140 (42000): Mixing of GROUP columns (MIN(),MAX(),COUNT(),…) with no GROUP columns is illegal if there is no GROUP BY clause</p><pre><code>是因为having只能在group by后面运行</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　小练习：</p><pre><code>1. 查询各岗位内包含的员工个数小于2的岗位名、岗位内包含员工名字、个数3. 查询各岗位平均薪资大于10000的岗位名、平均工资4. 查询各岗位平均薪资大于10000且小于20000的岗位名、平均工资</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#题1：mysql&gt; select post,group_concat(name),count(id) from employee group by post having count(id) &lt; 2;+-----------------------------------------+--------------------+-----------+| post                                    | group_concat(name) | count(id) |+-----------------------------------------+--------------------+-----------+| 老男孩驻沙河办事处外交大使              | egon               |         1 |+-----------------------------------------+--------------------+-----------+#题目2：mysql&gt; select post,avg(salary) from employee group by post having avg(salary) &gt; 10000;+-----------+---------------+| post      | avg(salary)   |+-----------+---------------+| operation |  16800.026000 || teacher   | 151842.901429 |+-----------+---------------+#题目3：mysql&gt; select post,avg(salary) from employee group by post having avg(salary) &gt; 10000 and avg(salary) &lt;20000;+-----------+--------------+| post      | avg(salary)  |+-----------+--------------+| operation | 16800.026000 |+-----------+--------------+</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>说一下去重：distinct</strong> </p><p>　　　　将查询的结果进行去重：select distinct post from employee; 注意distinct去重要写在查询字段的前面，不然会报错，关于distinct使用时的其他问题看下面的总结</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>有时需要查询出某个字段不重复的记录，这时可以使用mysql提供的distinct这个关键字来过滤重复的记录，但是实际中我们往往用distinct来返回不重复字段的条数（count(distinct id)）,其原因是distinct只能返回他的目标字段，而无法返回其他字段，distinct 想写在其他字段后面需要配合聚合函数来写。mysql&gt; select id,count(distinct post) from employee;ERROR 1140 (42000): Mixing of GROUP columns (MIN(),MAX(),COUNT(),...) with no GROUP columns is illegal if there is no GROUP BY clause报错了：是因为distinct不能返回其他的字段，只能返回目标字段mysql&gt; select count(distinct post) from employee;+----------------------+| count(distinct post) |+----------------------+|                    4 |+----------------------+1 row in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　说完去重，我们看一下order by，排序</p><h1 id="七-查询排序-ORDER-BY"><a href="#七-查询排序-ORDER-BY" class="headerlink" title="七 查询排序:ORDER BY"></a>七 查询排序:ORDER BY</h1><p>　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>按单列排序    SELECT * FROM employee ORDER BY salary; #默认是升序排列    SELECT * FROM employee ORDER BY salary ASC; #升序    SELECT * FROM employee ORDER BY salary DESC; #降序但是你看，如果我们按照age来排序，你看看是什么效果：mysql&gt; SELECT * FROM employee ORDER BY age;+----+------------+--------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+| id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id |+----+------------+--------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+| 1 | egon | male | 18 | 2017-03-01 | 老男孩驻沙河办事处外交大使 | NULL | 7300.33 | 401 | 1 || 17 | 程咬铜 | male | 18 | 2015-04-11 | operation | NULL | 18000.00 | 403 | 3 || 16 | 程咬银 | female | 18 | 2013-03-11 | operation | NULL | 19000.00 | 403 | 3 || 15 | 程咬金 | male | 18 | 1997-03-12 | operation | NULL | 20000.00 | 403 | 3 || 12 | 星星 | female | 18 | 2016-05-13 | sale | NULL | 3000.29 | 402 | 2 || 11 | 丁丁 | female | 18 | 2011-03-12 | sale | NULL | 1000.37 | 402 | 2 || 18 | 程咬铁 | female | 18 | 2014-05-12 | operation | NULL | 17000.00 | 403 | 3 || 7 | jinxin | male | 18 | 1900-03-01 | teacher | NULL | 30000.00 | 401 | 1 || 6 | jingliyang | female | 18 | 2011-02-11 | teacher | NULL | 9000.00 | 401 | 1 || 13 | 格格 | female | 28 | 2017-01-27 | sale | NULL | 4000.33 | 402 | 2 || 14 | 张野 | male | 28 | 2016-03-11 | operation | NULL | 10000.13 | 403 | 3 || 5 | liwenzhou | male | 28 | 2012-11-01 | teacher | NULL | 2100.00 | 401 | 1 || 10 | 丫丫 | female | 38 | 2010-11-01 | sale | NULL | 2000.35 | 402 | 2 || 9 | 歪歪 | female | 48 | 2015-03-11 | sale | NULL | 3000.13 | 402 | 2 || 8 | 成龙 | male | 48 | 2010-11-11 | teacher | NULL | 10000.00 | 401 | 1 || 4 | yuanhao | male | 73 | 2014-07-01 | teacher | NULL | 3500.00 | 401 | 1 || 2 | alex | male | 78 | 2015-03-02 | teacher | NULL | 1000000.31 | 401 | 1 || 3 | wupeiqi | male | 81 | 2013-03-05 | teacher | NULL | 8300.00 | 401 | 1 |+----+------------+--------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+  发现什么，按照年龄来升序排的，没问题，但是你看年龄相同的那些按什么排的，是不是看着是乱的啊，但是不管它对这种相同数据的内容怎么排序，我们是不是想如果出现相同的数据，那么这些相同的数据也按照一个依据来排列啊：  所以我们可以给相同的这些数据指定一个排序的依据，看下面：按多列排序:先按照age升序，如果年纪相同，则按照薪资降序    SELECT * from employee        ORDER BY age, #注意排序的条件用逗号分隔        salary DESC;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　小练习：</p><pre><code>1. 查询所有员工信息，先按照age升序排序，如果age相同则按照hire_date降序排序2. 查询各岗位平均薪资大于10000的岗位名、平均工资,结果按平均薪资升序排列3. 查询各岗位平均薪资大于10000的岗位名、平均工资,结果按平均薪资降序排列</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#题目1mysql&gt; select * from employee ORDER BY age asc,hire_date desc;#题目2 mysql&gt; select post,avg(salary) from employee group by post having avg(salary) &gt; 10000 order by avg(salary) asc;#注意：查询语句的语法是固定上面这样写的，但是运行顺序是这样的：1、from  2、where  3、group by  4、having  5、select  6、distinct 7、order by  8、limit，我们下面要学的+-----------+---------------+| post      | avg(salary)   |+-----------+---------------+| operation |  16800.026000 || teacher   | 151842.901429 |+-----------+---------------+#题目3mysql&gt; select post,avg(salary) from employee group by post having avg(salary) &gt; 10000 order by avg(salary) desc;+-----------+---------------+| post      | avg(salary)   |+-----------+---------------+| teacher   | 151842.901429 || operation |  16800.026000 |+-----------+---------------+</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="八-限制查询的记录数-LIMIT"><a href="#八-限制查询的记录数-LIMIT" class="headerlink" title="八 限制查询的记录数:LIMIT"></a>八 限制查询的记录数:LIMIT</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>示例：　　#取出工资最高的前三位    SELECT * FROM employee ORDER BY salary DESC         LIMIT 3;                    #默认初始位置为0,从第一条开始顺序取出三条     SELECT * FROM employee ORDER BY salary DESC        LIMIT 0,5; #从第0开始，即先查询出第一条，然后包含这一条在内往后查5条     SELECT * FROM employee ORDER BY salary DESC        LIMIT 5,5; #从第5开始，即先查询出第6条，然后包含这一条在内往后查5条</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　小练习：分页显示，每页显示5条。我们工作中经常会涉及到数据分页显示，因为数据量很大的时候，加入上10w条数据，我们是不是要分开给用户显示啊，要不然页面上都显示不过来，即便是显示过来了，用户看着是不是也很不爽啊，要一直往下面滚轮，对不对，用户体验不好，所以你会发现有好多的网站都可以看到一个分页的功能。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; select * from  employee limit 0,5;+----+-----------+------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+| id | name      | sex  | age | hire_date  | post                                    | post_comment | salary     | office | depart_id |+----+-----------+------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+|  1 | egon      | male |  18 | 2017-03-01 | 老男孩驻沙河办事处外交大使              | NULL         |    7300.33 |    401 |         1 ||  2 | alex      | male |  78 | 2015-03-02 | teacher                                 |              | 1000000.31 |    401 |         1 ||  3 | wupeiqi   | male |  81 | 2013-03-05 | teacher                                 | NULL         |    8300.00 |    401 |         1 ||  4 | yuanhao   | male |  73 | 2014-07-01 | teacher                                 | NULL         |    3500.00 |    401 |         1 ||  5 | liwenzhou | male |  28 | 2012-11-01 | teacher                                 | NULL         |    2100.00 |    401 |         1 |+----+-----------+------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+5 rows in set (0.00 sec)mysql&gt; select * from  employee limit 5,5;+----+------------+--------+-----+------------+---------+--------------+----------+--------+-----------+| id | name       | sex    | age | hire_date  | post    | post_comment | salary   | office | depart_id |+----+------------+--------+-----+------------+---------+--------------+----------+--------+-----------+|  6 | jingliyang | female |  18 | 2011-02-11 | teacher | NULL         |  9000.00 |    401 |         1 ||  7 | jinxin     | male   |  18 | 1900-03-01 | teacher | NULL         | 30000.00 |    401 |         1 ||  8 | 成龙       | male   |  48 | 2010-11-11 | teacher | NULL         | 10000.00 |    401 |         1 ||  9 | 歪歪       | female |  48 | 2015-03-11 | sale    | NULL         |  3000.13 |    402 |         2 || 10 | 丫丫       | female |  38 | 2010-11-01 | sale    | NULL         |  2000.35 |    402 |         2 |+----+------------+--------+-----+------------+---------+--------------+----------+--------+-----------+5 rows in set (0.00 sec)mysql&gt; select * from  employee limit 10,5;+----+-----------+--------+-----+------------+-----------+--------------+----------+--------+-----------+| id | name      | sex    | age | hire_date  | post      | post_comment | salary   | office | depart_id |+----+-----------+--------+-----+------------+-----------+--------------+----------+--------+-----------+| 11 | 丁丁      | female |  18 | 2011-03-12 | sale      | NULL         |  1000.37 |    402 |         2 || 12 | 星星      | female |  18 | 2016-05-13 | sale      | NULL         |  3000.29 |    402 |         2 || 13 | 格格      | female |  28 | 2017-01-27 | sale      | NULL         |  4000.33 |    402 |         2 || 14 | 张野      | male   |  28 | 2016-03-11 | operation | NULL         | 10000.13 |    403 |         3 || 15 | 程咬金    | male   |  18 | 1997-03-12 | operation | NULL         | 20000.00 |    403 |         3 |+----+-----------+--------+-----+------------+-----------+--------------+----------+--------+-----------+5 rows in set (0.00 sec)到最后不够五条了怎么办，完全不影响，接着写</code></pre><p>  mysql&gt; select * from employee limit 15,5;<br>  +—-+———–+——–+—–+————+———–+————–+———-+——–+———–+<br>  | id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id |<br>  +—-+———–+——–+—–+————+———–+————–+———-+——–+———–+<br>  | 16 | 程咬银 | female | 18 | 2013-03-11 | operation | NULL | 19000.00 | 403 | 3 |<br>  | 17 | 程咬铜 | male | 18 | 2015-04-11 | operation | NULL | 18000.00 | 403 | 3 |<br>  | 18 | 程咬铁 | female | 18 | 2014-05-12 | operation | NULL | 17000.00 | 403 | 3 |<br>  +—-+———–+——–+—–+————+———–+————–+———-+——–+———–+<br>  3 rows in set (0.00 sec)</p><p>#到目前为止，单表查询所有的语法都讲完了，语法就是按照我们博客最上面说的语法顺序来写，但是执行的时候，要按照对应的各个方法的优先级去执行。</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="九-使用正则表达式查询"><a href="#九-使用正则表达式查询" class="headerlink" title="九 使用正则表达式查询"></a>九 使用正则表达式查询</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#之前我们用like做模糊匹配，只有%和_，局限性比较强，所以我们说一个正则，之前我们是不是学过正则匹配，你之前学的正则表达式都可以用，正则是通用的SELECT * FROM employee WHERE name REGEXP '^ale';SELECT * FROM employee WHERE name REGEXP 'on$';SELECT * FROM employee WHERE name REGEXP 'm{2}';小结：对字符串匹配的方式WHERE name = 'egon';WHERE name LIKE 'yua%';WHERE name REGEXP 'on$';</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　小练习：</p><pre><code>查看所有员工中名字是jin开头，n或者g结果的员工信息select * from employee where name regexp '^jin.*[g|n]$';</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之视图、触发器、事务、存储过程、函数</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E8%A7%86%E5%9B%BE%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E5%87%BD%E6%95%B0/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E8%A7%86%E5%9B%BE%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10034539.html#_label1">一 视图</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10034539.html#_label2">二 触发器</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10034539.html#_label3">三 事务</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10034539.html#_label4">四 存储过程</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10034539.html#_label5">五 函数</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10034539.html#_label6">六 流程控制</a></li></ul><p>　　MySQL这个软件想将数据处理的所有事情，能够在mysql这个层面上全部都做了，也就是说它想要完成一件事，以后想开发的人，例如想写python程序的人，你就专门的写你自己的python程序，以后凡是关于数据的增删改查，全部都在MySQL里面完成，也就是说它想实现一个数据处理与应用程序的一个完全的解耦和状态，比如说，如果我是个应用程序员，我想要查询数据，我不需要自己写sql语句，只需要调用mysql封装好的一些功能，直接调用这个功能就可以了，之前我们使用sql来进行数据的增删改查，其实sql也可以算作一个开发语言，有专门招数据库开发的岗位，也就是说mysql想做这么一个事儿，以后啊，专门有人写应用程序的开发，专门有人来写sql，来开发sql部分，在数据库层面根据应用层的程序员的要求，把sql语句全部写好，各种复杂的需求全部帮你封装好，封装成一个一个的功能，应用程序开发程序员在根据自己的需求来使用这些功能，直接调用就可以了，这是mysql想要完成的事情，但是咱们以后做开发，一般不会这么搞，一般招聘需求里面都会有一项是要会sql，浅显的说是因为花最少的钱，做最多的事儿，但是往深了说是因为公司里面一般不会用这些内置的功能去sql的工作，至于为什么，咱们学完mysql之后再说吧<del>~</del></p><h1 id="一-视图"><a href="#一-视图" class="headerlink" title="一 视图"></a>一 视图</h1><p>　　视图是一个虚拟表（非真实存在），是跑到内存中的表，真实表是硬盘上的表，怎么就得到了虚拟表，就是你查询的结果，只不过之前我们查询出来的虚拟表，从内存中取出来显示在屏幕上，内存中就没有了这些表的数据，但是下次我要是想用这个虚拟表呢，没办法，只能重新查一次，每次都要重新查。其本质是【根据SQL语句获取动态的数据集，并为其命名】，用户使用时只需使用【名称】即可获取结果集，可以将该结果集当做表来使用。如果我们想查询一些有关联的表，比如我们前面的老师学生班级什么的表，我可能需要几个表联合查询的结果，但是这几张表在硬盘上是单独存的，所以我们需要通过查询的手段，将这些表在内存中拼成一个虚拟表，然后是不是我们再基于虚拟表在进行进一步的查询，然后我们如果以后想重新再查一下这些关系数据，还需要对硬盘上这些表进行再次的重新加载到内容，联合成虚拟表，然后再筛选等等的操作，意味着咱们每次都在写重复的sql语句，那有没有好的方法啊，其实很简单，我们把重复用的这些sql逻辑封装起来，然后下次使用的时候直接调用这个封装好的操作就可以了，这个封装起来的操作就类似我们下面要说的视图</p><p>　　为什么要用视图：使用视图我们可以把查询过程中的临时表摘出来，保存下来，用视图去实现，这样以后再想操作该临时表的数据时就无需重写复杂的sql了，直接去视图中查找即可，但视图有明显地效率问题，并且视图是存放在数据库中的，如果我们程序中使用的sql过分依赖数据库中的视图，即强耦合，那就意味着扩展sql极为不便，因此并不推荐使用</p><p>　　临时表应用举例：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#两张有关系的表mysql&gt; select * from course;+-----+--------+------------+| cid | cname  | teacher_id |+-----+--------+------------+|   1 | 生物   |          1 ||   2 | 物理   |          2 ||   3 | 体育   |          3 ||   4 | 美术   |          2 |+-----+--------+------------+4 rows in set (0.00 sec)mysql&gt; select * from teacher;+-----+-----------------+| tid | tname           |+-----+-----------------+|   1 | 张磊老师        ||   2 | 李平老师        ||   3 | 刘海燕老师      ||   4 | 朱云海老师      ||   5 | 李杰老师        |+-----+-----------------+5 rows in set (0.00 sec)#查询李平老师教授的课程名mysql&gt; select cname from course where teacher_id = (select tid from teacher where tname='李平老师'); #子查询的方式+--------+| cname  |+--------+| 物理   || 美术   |+--------+2 rows in set (0.00 sec)#子查询出临时表，作为teacher_id等判断依据select tid from teacher where tname='李平老师'</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>一 创建视图</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#语法：CREATE VIEW 视图名称 AS  SQL语句create view teacher_view as select tid from teacher where tname='李平老师';</code></pre><p>  mysql&gt; show tables;<br>  +—————+<br>  | Tables_in_crm |<br>  +—————+<br>  | class |<br>  | course |<br>  | score |<br>  | student |<br>  | teacher |<br>  | teacher_view |  #看这里<br>  +—————+</p><pre><code></code></pre><p>  mysql&gt; desc teacher_view;  #有表结构<br>  +——-+———+——+—–+———+——-+<br>  | Field | Type | Null | Key | Default | Extra |<br>  +——-+———+——+—–+———+——-+<br>  | tid | int(11) | NO | | 0 | |<br>  +——-+———+——+—–+———+——-+<br>  1 row in set (0.04 sec)</p><pre><code></code></pre><p>  mysql&gt; select * from teacher_view; #有表数据<br>  +—–+<br>  | tid |<br>  +—–+<br>  | 2 |<br>  +—–+<br>  1 row in set (0.00 sec)</p><pre><code>注意：但是在硬盘上你找到自己的mysql安装目录里面的data文件夹里面的对应的那个库的文件夹，这个文件夹里面存着咱们的表信息，打开之后你会发现，这个视图表，只有表结构的teacher_view.frm文件，没有那个.idb存放数据的文件其实他并没有真实的数据，也没有必要再存一份数据，因为它的数据来源于其他两个表，所以他本质在后台对应的就是一个sql语句而已，所以记住了，视图只有表结构，没有表数据视图的好处是以后我们如果再需要查询或者使用上面的虚拟表，就可以直接使用这个视图了，sql的代码量也会省很多。但是弊端也很致命，看下面注意的内容。#于是查询李平老师教授的课程名的sql可以改写为mysql&gt; select cname from course where teacher_id = (select tid from teacher_view);+--------+| cname  |+--------+| 物理   || 美术   |+--------+2 rows in set (0.00 sec)#！！！注意注意注意：#1. 使用视图以后就无需每次都重写子查询的sql，开发的时候是方便了很多，但是这么效率并不高，还不如我们写子查询的效率高#2. 而且有一个致命的问题：视图是存放到数据库里的，如果我们程序中的sql过分依赖于数据库中存放的视图，那么意味着，一旦sql需要修改且涉及到视图的部分，则必须去数据库中进行修改，然后再到自己的应用程序里面将那个sql语句改一改，需要很多的修改工作，并而对视图的更改通常在一般中型及以上公司中数据库有专门的DBA负责，你要想完成修改，必须付出大量的沟通成本DBA可能才会帮你完成修改，极其地不方便这么多的弊端，为什么mysql还要提供这个东西呢，有一点是因为mysql想把所有数据处理的工作全部接手过来，但其实还有其他的原因，等我们讲完存储过程在和大家说吧。#3 并且注意：视图一般都是用于查询，尽量不要修改(插入、删除等)视图中的数据，虽然有时候可以修改成功，但是尽量不要这样做，因为这个视图可能是多个表联合起来生成的一个结果，如果你修改它，可能会造成很多表里面的数据都跟着被修改了</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>二 使用视图</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#修改视图，原始表也跟着改mysql&gt; select * from course;+-----+--------+------------+| cid | cname  | teacher_id |+-----+--------+------------+|   1 | 生物   |          1 ||   2 | 物理   |          2 ||   3 | 体育   |          3 ||   4 | 美术   |          2 |+-----+--------+------------+4 rows in set (0.00 sec)mysql&gt; create view course_view as select * from course; #创建表course的视图Query OK, 0 rows affected (0.52 sec)mysql&gt; select * from course_view;+-----+--------+------------+| cid | cname  | teacher_id |+-----+--------+------------+|   1 | 生物   |          1 ||   2 | 物理   |          2 ||   3 | 体育   |          3 ||   4 | 美术   |          2 |+-----+--------+------------+4 rows in set (0.00 sec)mysql&gt; update course_view set cname='xxx'; #更新视图中的数据Query OK, 4 rows affected (0.04 sec)Rows matched: 4  Changed: 4  Warnings: 0mysql&gt; insert into course_view values(5,'yyy',2); #往视图中插入数据Query OK, 1 row affected (0.03 sec)mysql&gt; select * from course; #发现原始表的记录也跟着修改了+-----+-------+------------+| cid | cname | teacher_id |+-----+-------+------------+|   1 | xxx   |          1 ||   2 | xxx   |          2 ||   3 | xxx   |          3 ||   4 | xxx   |          2 ||   5 | yyy   |          2 |+-----+-------+------------+5 rows in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　我们不应该修改视图中的记录，而且在涉及多个表的情况下是根本无法修改视图中的记录的，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170918074209806-732383035.png" alt="img"></p><p>　　<strong>三 修改视图</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>语法：ALTER VIEW 视图名称 AS SQL语句，这基本就和删掉视图重新创建一个视图的过程是一样的，修改视图没什么好讲的，这里就简单提一下，就不讲啦~~，还不如我们直接删掉，再重新创建呢mysql&gt; alter view teacher_view as select * from course where cid&gt;3;Query OK, 0 rows affected (0.04 sec)mysql&gt; select * from teacher_view;+-----+-------+------------+| cid | cname | teacher_id |+-----+-------+------------+|   4 | xxx   |          2 ||   5 | yyy   |          2 |+-----+-------+------------+2 rows in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>四 删除视图</strong></p><pre><code>语法：DROP VIEW 视图名称DROP VIEW teacher_view</code></pre><h1 id="二-触发器"><a href="#二-触发器" class="headerlink" title="二 触发器"></a>二 触发器</h1><p>　　使用触发器可以定制用户对某一张表的数据进行【增、删、改】操作时前后的行为，注意：没有查询，在进行增删改操作的时候，触发的某个操作，称为触发器，也就是增删改的行为触发另外的一种行为，触发的行为无非就是sql语句的事情，及自动运行另外一段sql语句。来看一下触发器怎么来创建：</p><p>　　<strong>一 创建触发器</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code># 插入前CREATE TRIGGER tri_before_insert_tb1 BEFORE INSERT ON tb1 FOR EACH ROWBEGIN #begin和end里面写触发器要做的sql事情，注意里面的代码缩进，并且给触发器起名字的时候，名字的格式最好这样写，有表示意义，一看名字就知道要做什么，是给哪个表设置的触发器    ...END# 插入后CREATE TRIGGER tri_after_insert_tb1 AFTER INSERT ON tb1 FOR EACH ROWBEGIN    ...END# 删除前CREATE TRIGGER tri_before_delete_tb1 BEFORE DELETE ON tb1 FOR EACH ROWBEGIN    ...END# 删除后CREATE TRIGGER tri_after_delete_tb1 AFTER DELETE ON tb1 FOR EACH ROWBEGIN    ...END# 更新前CREATE TRIGGER tri_before_update_tb1 BEFORE UPDATE ON tb1 FOR EACH ROWBEGIN    ...END# 更新后CREATE TRIGGER tri_after_update_tb1 AFTER UPDATE ON tb1 FOR EACH ROWBEGIN    ...END</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　插入后触发触发器：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#准备表CREATE TABLE cmd (  #这是一张指令信息表，你在系统里面执行的任何的系统命令都在表里面写一条记录    id INT PRIMARY KEY auto_increment,  #id    USER CHAR (32),  #用户    priv CHAR (10),  #权限              cmd CHAR (64),   #指令    sub_time datetime, #提交时间      success enum ('yes', 'no') #是否执行成功，0代表执行失败);CREATE TABLE errlog ( #指令执行错误的信息统计表，专门提取上面cmd表的错误记录    id INT PRIMARY KEY auto_increment, #id    err_cmd CHAR (64),  #错误指令    err_time datetime   #错误命令的提交时间);#现在的需求是：不管正确或者错误的cmd，都需要往cmd表里面插入，然后，如果是错误的记录，还需要往errlog表里面插入一条记录#若果没有触发器，我们会怎么实现，我们完全可以通过咱们的应用程序来做，根据cmd表里面的success这个字段是哪个值（yes成功，no表示失败），在给cmd插入记录的时候，判断一下这个值是yes或者no，来判断一下成功或者失败，如果失败了，直接给errlog来插入一条记录#但是mysql说，你的应用程序可以省事儿了，你只需要往cmd表里面插入数据就行了，没必要你自己来判断了，可以使用触发器来实现，可以判断你插入的这条记录的success这个字段对应的值，然后自动来触发触发器，进行errlog表的数据插入#创建触发器delimiter //      （或者写$$，其他符号也行，但是不要写mysql不能认识的，知道一下就行了），delimiter 是告诉mysql，遇到这句话的时候，就将sql语句的结束符分号改成delimiter后面的//CREATE TRIGGER tri_after_insert_cmd AFTER INSERT ON cmd FOR EACH ROW               #在你cmd表插入一条记录之后触发的。BEGIN           #每次给cmd插入一条记录的时候，都会被mysql封装成一个对象，叫做NEW，里面的字段都是这个NEW的属性    IF NEW.success = 'no' THEN           #mysql里面是可以写这种判断的，等值判断只有一个等号，然后写then            INSERT INTO errlog(err_cmd, err_time) VALUES(NEW.cmd, NEW.sub_time) ;     #必须加分号，并且注意，我们必须用delimiter来包裹，不然，mysql一看到分号，就认为你的sql结束了，所以会报错      END IF ;       #然后写end if，必须加分号  END//      #只有遇到//这个完成的sql才算结束delimiter ;        #然后将mysql的结束符改回为分号#往表cmd中插入记录，触发触发器，根据IF的条件决定是否插入错误日志INSERT INTO cmd (    USER,    priv,    cmd,    sub_time,    success)VALUES    ('chao','0755','ls -l /etc',NOW(),'yes'),    ('chao','0755','cat /etc/passwd',NOW(),'no'),    ('chao','0755','useradd xxx',NOW(),'no'),    ('chao','0755','ps aux',NOW(),'yes');#查询错误日志，发现有两条mysql&gt; select * from errlog;+----+-----------------+---------------------+| id | err_cmd         | err_time            |+----+-----------------+---------------------+|  1 | cat /etc/passwd | 2017-09-14 22:18:48 ||  2 | useradd xxx     | 2017-09-14 22:18:48 |+----+-----------------+---------------------+2 rows in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>特别的：NEW表示即将插入的数据行，OLD表示即将删除的数据行。</strong></p><p>　　<strong>二 使用触发器</strong></p><p>　　　　触发器无法由用户直接调用，而由对表的【增/删/改】操作被动引发的。</p><p>　　<strong>三 删除触发器</strong></p><pre><code>drop trigger tri_after_insert_cmd;</code></pre><h3 id="三-事务"><a href="#三-事务" class="headerlink" title="　　三 事务"></a>　　三 事务</h3><p>　　　　事务用于将某些操作的多个SQL作为原子性操作，也就是这些sql语句要么同时成功，要么都不成功，事务的其他特性在我第一篇博客关于事务的介绍里面有，这里就不多做介绍啦，一旦有某一个出现错误，即可回滚到原来的状态，从而保证数据库数据完整性。</p><p>　　　　简单来说：我给一个姑娘转账，姑娘那儿收到了200，你的账户上扣了200，这两个操作是不是两个sql语句，这两个sql语句是你的应用程序发给mysql服务端的，并且这两个sql语句都要一起执行，不然数据就错了，你想想是不是。并且如果你通过应用程序发送这两条sql的时候，由于网络问题，你只发送了一个sql过来，那只有一个账户改了数据，另外一个没改，那数据是不是就出错了啊。这就是事务要完成的事情。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>create table user(id int primary key auto_increment,name char(32),balance int);insert into user(name,balance)values('wsb',1000),('chao',1000),('ysb',1000);#原子操作start transaction;update user set balance=900 where name='wsb'; #买支付100元update user set balance=1010 where name='chao'; #中介拿走10元update user set balance=1090 where name='ysb'; #卖家拿到90元commit;  #只要不进行commit操作，就没有保存下来，没有刷到硬盘上#出现异常，回滚到初始状态start transaction;update user set balance=900 where name='wsb'; #买支付100元update user set balance=1010 where name='chao'; #中介拿走10元uppdate user set balance=1090 where name='ysb'; #卖家拿到90元,出现异常没有拿到rollback;  #如果上面三个sql语句出现了异常，就直接rollback，数据就直接回到原来的状态了。但是执行了commit之后，rollback这个操作就没法回滚了#我们要做的是检测这几个sql语句是否异常，没有异常直接commit，有异常就rollback，但是现在单纯的只是开启了事务，但是还没有说如何检测异常，我们先来一个存储过程来捕获异常，等我们学了存储过程，再细说存储过程。commit;#通过存储过程来捕获异常：(shit！，写存储过程的是，注意每一行都不要缩进！！！按照下面的缩进来写，居然让我翻车了！！！我记住你了~~~)，我的代码直接黏贴就能用。</code></pre><p>delimiter //<br>create PROCEDURE p5()<br>BEGIN<br>DECLARE exit handler for sqlexception<br>BEGIN<br>rollback;<br>END;</p><p>START TRANSACTION;<br>update user set balance=900 where name=’wsb’; #买支付100元<br>update user set balance=1010 where name=’chao’; #中介拿走10元<br>#update user2 set balance=1090 where name=’ysb’; #卖家拿到90元<br>update user set balance=1090 where name=’ysb’; #卖家拿到90元<br>COMMIT;</p><p>END //<br>delimiter ;</p><pre><code>mysql&gt; select * from user;+----+------+---------+| id | name | balance |+----+------+---------+|  1 | wsb  |    1000 ||  2 | chao |    1000 ||  3 | ysb  |    1000 |+----+------+---------+3 rows in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="四-存储过程"><a href="#四-存储过程" class="headerlink" title="四 存储过程"></a>四 存储过程</h1><p>　　<strong>一 介绍</strong></p><p>　　　　存储过程包含了一系列可执行的sql语句，存储过程存放于MySQL中，通过调用它的名字可以执行其内部的一堆sql。到目前为止，我们上面学的视图、触发器、事务等为我们简化了应用程序级别写sql语句的复杂程度，让我们在应用程序里面写sql更简单方便了，但是我们在应用程序上还是需要自己写sql的，而我们下面要学的存储过程，它是想让我们的应用程序不需要再写sql语句了，所有的sql语句，全部放到mysql里面，被mysql封装成存储过程，说白了它就是一个功能，这个功能对应着一大堆的sql语句，这些语句里面可以包括我们前面学的视图啊、触发器啊、事务啊、等等的内容，也就是说存储过程其实是什么？是一堆sql的集合体，可以直接用mysql里面提供的一堆功能，有了存储过程以后，它的好处是我项目逻辑中需要的各种查询都可以让DBA或者你自己封装到存储过程里面，以后使用的时候直接调用存储过程名就可以了，在开发应用的时候就简单了，就不要应用程序员进行sql语句的开发了，但是你想如果你真的这么做了，确实很有好处，简单很多，应用程序的开发和数据库sql语句的开发，完全的解耦了，这样，专门的人做专门的事情，专门招一个应用开发的人开发应用程序，招一个开发型DBA，会sql的开发，他把sql写完之后，封装成一个个的存储过程，给应用程序员用就行了，对不对，这个DBA就不单纯的是管理数据库系统了，还需要会写sql语句，那这样你的应用程序开发的效率就高了，运行效率也提高了，你开发应用程序的时候如果写了一堆的sql语句，这些语句是不是要通过网络传输，传输到mysql服务端来执行，然后将结果返回给你的应用程序，那么在传输的时候，你说好多的sql语句和简单的一个存储过程的名字，哪个传输的速度快，哪个发送给服务端的速度快，当然是单纯的一个存储过程的名字更快。</p><p>　　　　所以摆在你面前有两种开发模式：</p><p>　　　　　　第一种是招一个会开发应用程序的并且这个人还要会sql开发，这样的人既写应用程序，还写sql语句，这种情况你可以招两个人，一个是前面说的，还有一个是数据库管理人员，单纯只会管理数据库的而不会sql开发的人，这样好招人，工资也不高。（应用程序员–&gt;只需要开发应用程序的逻辑 。   sql开发人员–&gt;编写存储过程）</p><p>　　　　　　第二种：招一个应用程序开发的，只需要会应用程序级别的开发，再招一个会sql开发的DBA。（应用程序员–&gt;开发应用+写原生sql 。 数据库人员负责维护数据库的正常运行）</p><p>　　　　我们比较一下这两种的开发模式：第二种：解耦和，开发效率高，运行效率也高，所以以后最好采用第一种开发模式，哈哈，是不是神反转，原因是什么呢，钱只是一个方面，主要还是因为以后如果你想扩展，那就很不方便了，为什么呢，因为通常sql开发人员，不如你的应用程序员更懂你的业务逻辑，一旦你要扩展一个功能，还需要跨部门沟通，导致这种工作方式受限的不只是技术层面了，这种方式在技术层面肯定是效率高的，但是要考虑人为因素，还有成本方面的考虑，所以通常咱们以后做开发，不要想着会有人给你写sql，需要你自己写的很熟练。这样，你一个部门就能搞定这两件事情。</p><p>　　　　第二种方式其实也比较麻烦，你开发程序员自己需要写sql，并且写出来的sql还存在效率问题，那么有没有一种方式可以不让开发程序员自己再写sql了，搞一个封装程度更高的东西让你来调用，有没有这种方式呢？有，就是第三种方式</p><p>　　　　　　第三种：应用程序除了开发应用程序的逻辑，不需要编写原生sql，只需要使用别人写好的框架，基于框架来处理数据，框架提供的功能是ORM：对象关系映射，和对象有关系，就是在应用程序里面，只需要定义一堆的类，每个类对应数据库里面的一张表，这个类一实例化，也就是一个类对象对应表里面的一条记录，得到对象以后，这个对象除了有数据之外，还有处理该条信息的方法，增删改查都有了，全都封装成了对象的一个一个的方法了，意味着你以后再想进行查询，就没必要写原生sql了，直接基于面向对象的思想来处理类与对象就行了，但是这种方式本质上还是使用了原生sql，只不过对于应用程序员来说，你不用直接写sql了，别人写好的ORM框架就帮你处理这件事儿了，帮你把你调用的那些接口方法和你传入的参数等等帮你转换为了原生sql，然后再往mysql里面提交。所以这种方式和第二种方式有些类似，但是比第二种方式要好(前提是第二种方式应用程序员的sql水平比较low的情况下，一般会比较low)：</p><p>　　　　　　　　这种方式的优点：应用程序员不需要再写原生的sql了，这意味着开发效率比第二种要高，同时还兼顾了第二种方式扩展性高的好处，因为本质上还是原生sql</p><p>　　　　　　　　缺点是：执行效率还不如第二种方式高，因为你现在再想运行需要做什么事 情，首先你想，你程序里面用的是别人写好的ORM框架或者模块，你的sql要想执行，你需要做什么事儿，你的ORM框架需要把类或者类对象先翻译成原生的sql，再沿着网络发到mysql服务端，中间对了一个转换的过程，所以执行效率其实连方式二都比不上。</p><p>　　　　总结：其实单单从技术层面上看，第一种方式肯定是最好的，开发和执行效率是最高的，扩展性单纯技术层面来看也比较高，所以单单从技术层面来考虑，这种方式肯定是优选的。但是就目前的现状而言，多数还是需要你应用程序员既做应用逻辑的开发，还要会原生sql的开发，所以应该尽可能的不让mysql来做了，所有关于数据的增删改查都交给应用程序级别来做，在应用程序中写原生的sql，这也是第二种方式和第三种方式的一个共性，所有事情基本都交给应用程序级别来做，mysql级别基本不做sql的开发，这样扩展性也好一些，因为所有的事情都交给你应用程序的开发部门来做了，自己部门内部进行扩展还是扩展性不错的，所以咱们一般从后面两种方式来选择，那么后面两种选哪一种呢？第二种执行效率比第三种高，因为比第三种少了一步类对象转换为sql的过程。第三种开发效率高，不要应用程序员再写原生的sql了。所以具体选哪一种，看你们自己公司的情况，需要快速开发，就找第三种，如果自己程序员的sql写的很溜(又快又优)，那么找第二种，一般大公司采用的第一种多一些，部门分工非常的明确，等你们大家学到Django框架，你们就会接触ORM啦<del>~</del>学完MySQL之后，我们在学框架之前，带大家咱们自己开发一个简单的ORM框架，能够在你自己的应用程序中使用的ORM，写这个ORM框架很重要，对你以后的框架和项目的学习很有指导意义，说哆啦，我们继续说存储过程：　　　　</p><p>　　　　使用存储过程的优点：</p><pre><code>#1. 用于替代程序写的SQL语句，实现程序与sql解耦#2. 基于网络传输，传别名的数据量小，而直接传sql数据量大</code></pre><p>　　　　使用存储过程的缺点：</p><pre><code>#1. 程序员扩展功能不方便</code></pre><p>　　　　<strong>上面一大堆话的总结：程序与数据库结合使用的三种方式</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#方式一：    MySQL：存储过程    程序：调用存储过程#方式二：    MySQL：    程序：纯SQL语句#方式三：    MySQL:    程序：类和对象，即ORM（本质还是纯SQL语句）</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>二 创建简单存储过程（无参）</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>delimiter //create procedure p1()BEGIN    select * from blog;    INSERT into blog(name,sub_time) values("xxx",now());END //delimiter ;#在mysql中调用call p1(); #类似于MySQL的函数，但不是函数昂，别搞混了，MySQL的函数(count()\max()\min()等等)都是放在sql语句里面用的，不能单独的使用，存储过程是可以直接调用的  call 名字+括号;#MySQL的视图啊触发器啊if判断啊等等都能在存储过程里面写，这是一大堆的sql的集合体，都可以综合到这里面#在python中基于pymysql调用cursor.callproc('p1') print(cursor.fetchall())</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　另外：存储过程是可以传参数的，看下面的内容</p><p>　　<strong>三 创建存储过程（有参）</strong></p><pre><code>对于存储过程，可以接收参数，其参数有三类：#in          仅用于传入参数用#out        仅用于返回值用#inout     既可以传入又可以当作返回值</code></pre><p>　　　　in:传入参数：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>delimiter //create procedure p2(    in n1 int,  #n1参数是需要传入的，也就是接收外部数据的，并且这个数据必须是int类型    in n2 int)BEGIN    select * from blog where id &gt; n1;  #直接应用变量END //delimiter ;#调用存储过程的两种方式：或者说是两个地方吧　　#在mysql中调用　　call p2(3,2)　　#在python中基于pymysql调用　　cursor.callproc('p2',(3,2))　　print(cursor.fetchall())</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　#通过存储过程的传参来看，也能体现出我们学习的Python的灵活性，传参不需要指定类型，也不需要声明这个参数是传入的还是返回出来的，参数既可以传入，这个参数也可以直接通过return返回。</p><p>　　out：返回值：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#查看存储过程的一些信息：show create procedure p3; #查看视图啊、触发器啊都这么看，还可以用\G，show create procedure p3\G;\G的意思是你直接查看表结构可能横向上显示不完，\G是让表给你竖向显示，一row是一行的字段delimiter //create procedure p3(    in n1 int,    out res int)BEGIN    select * from blog where id &gt; n1;      set res = 1;  #我在这里设置一个res=1，如果上面的所有sql语句全部正常执行了，那么这一句肯定也就执行了，那么此时res=1，如果我最开始传入的时候，给res的值设置的是0，#那么你想，最后我接收到的返回值如果是0，那么说明你中间肯定有一些sql语句执行失败了#注意写法：out的那个参数，可以用set来设置，set设置之后表示这个res可以作为返回值，并且不需要像python一样写一个return，你直接set之后的值，就是这个存储过程的返回值END //delimiter ;#在mysql中调用set @res=0; #这是MySQL中定义变量名的固定写法(set @变量名=值)，可以自己规定好，0代表假（执行失败），1代表真（执行成功），如果这个被改为1了，说明存储过程中的sql语句执行成功了call p3(3,@res);#注意：不要这样写：call p3（3，1），这样out的参数值你写死了，没法确定后面这个1是不是成功了，也就是说随后这个out的值可能改成0了，也就是失败了，但是这样你就判断不了了，你后面查看的这个res就成1了，所以这个参数应该是一个变量名昂，定义变量名就是上一句,如果你直接传一个常量数字，会报错的，写法不对。select @res; #看一下这个结果，就知道这些sql语句是不是执行成功了，大家明白了吗~~~#在python中基于pymysql调用，在python中只需要知道存储过程的名字就行了cursor.callproc('p3',(3,0)) #0相当于set @res=0，为什么这里这个out参数可以写常数0啊，因为你用的pymysql,人家会帮你搞定，pymysql其实会帮你写成这样：第一个参数变量名：@_p3_0=3，第二个：@_p3_1=0，也就是pymysql会自动帮你对应上一个变量名，pymysql只是想让你写的时候更方便#沿着网络将存储过程名和参数发给了mysql服务端，比咱们发一堆的sql语句肯定要快对了，mysql帮你调用存储过程print(cursor.fetchall()) #查询select的查询结果cursor.execute('select @_p3_0,@_p3_1;') #@_p3_0代表第一个参数，@_p3_1代表第二个参数，即返回值print(cursor.fetchall())#别忘了关掉：cursor.close()conn.close()#注意昂：存储过程在哪个库里面建的，就只能在哪个库里面用</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　inout：既可传入又可以返回值:</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>delimiter //create procedure p4(    inout n1 int)BEGIN    select * from blog where id &gt; n1;    set n1 = 1;END //delimiter ;#在mysql中调用set @x=3;call p4(@x);select @x;#在python中基于pymysql调用cursor.callproc('p4',(3,))print(cursor.fetchall()) #查询select的查询结果cursor.execute('select @_p4_0;') print(cursor.fetchall())</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　存储过程结合事务来写：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>delimiter //            create procedure p4(                out status int            )            BEGIN                1. 声明如果出现异常则执行{                    set status = 1;                    rollback;                }                开始事务                    -- 由秦兵账户减去100                    -- 方少伟账户加90                    -- 张根账户加10                    commit;                结束                set status = 2;            END //            delimiter ;#实现delimiter //create PROCEDURE p5(    OUT p_return_code tinyint)BEGIN     DECLARE exit handler for sqlexception   #声明如果一旦出现异常则执行下面的这个begin和end里面的操作    BEGIN         -- ERROR   #--是什么啊，忘了吧，是注释的意思，就告诉你后面是对错误的处理        set p_return_code = 1;  #将out返回值改为1了，这是你自己规定的，1表示出错了        rollback;  #回滚事务    END;     DECLARE exit handler for sqlwarning  #声明了出现警告信息之后你的操作行为    BEGIN         -- WARNING         set p_return_code = 2;         rollback;     END;     START TRANSACTION;  #其实咱们这个存储过程里面就是执行这个事务，并且一直检测着这个事务，一旦出错或者出现警告，就rollback        DELETE from tb1; #事务里面的任何一条sql执行失败或者执行出现警告，都会执行上面我们声明的那些对应的操作，如果没有任何的异常，就会自动执行下面的commit，并执行后面成功的sql        insert into blog(name,sub_time) values('yyy',now());  #拿我的代码进行测试的时候，别忘了改成你自己库里的表，还有表里面对应的字段名要有的，自己测试的时候，可以自己写一个错误的sql来试试看    COMMIT;     -- SUCCESS     set p_return_code = 0; #0代表执行成功END //delimiter ;#在mysql中调用存储过程set @res=123;call p5(@res);select @res;#在python中基于pymysql调用存储过程cursor.callproc('p5',(123,)) #注意后面这个参数是个元祖，别忘了逗号，按照我们上面规定的，上面有三个值0，1，2：0成功、1失败、2警告也是失败。所以我们传给这个out参数的值只要不是这三个值就行了，这里给的是100print(cursor.fetchall()) #查询select的查询结果cursor.execute('select @_p5_0;')print(cursor.fetchall())#执行成功以后，查看一下结果就能看到执行后的值了</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>四 执行存储过程</strong></p><p>　　在MySQL中执行存储过程：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>-- 无参数call proc_name()-- 有参数，全incall proc_name(1,2)-- 有参数，有in，out，inoutset @t1=0;set @t2=3;call proc_name(1,2,@t1,@t2)执行存储过程</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　在python中基于pymysql来执行存储过程：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#!/usr/bin/env python# -*- coding:utf-8 -*-import pymysqlconn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='t1')cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)# 执行存储过程cursor.callproc('p1', args=(1, 22, 3, 4))# 获取执行完存储的参数cursor.execute("select @_p1_0,@_p1_1,@_p1_2,@_p1_3")result = cursor.fetchall()#conn.commit()cursor.close()conn.close()print(result)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>五 删除存储过程</strong></p><pre><code>drop procedure proc_name;</code></pre><h1 id="五-函数"><a href="#五-函数" class="headerlink" title="五 函数"></a>五 函数</h1><p>　　MySQL中提供了许多内置函数，但是注意，这些函数只能在sql语句中使用，不能单独调用昂，例如：其实下面的有些函数我们都已经用过了，其他的如果你们用到了，咱们再过来查吧，好不？</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>一、数学函数    ROUND(x,y)        返回参数x的四舍五入的有y位小数的值    RAND()        返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。二、聚合函数(常用于GROUP BY从句的SELECT查询中)    AVG(col)返回指定列的平均值    COUNT(col)返回指定列中非NULL值的个数    MIN(col)返回指定列的最小值    MAX(col)返回指定列的最大值    SUM(col)返回指定列的所有值之和    GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果    三、字符串函数    CHAR_LENGTH(str)        返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。    CONCAT(str1,str2,...)        字符串拼接        如有任何一个参数为NULL ，则返回值为 NULL。    CONCAT_WS(separator,str1,str2,...)        字符串拼接（自定义连接符）        CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。    CONV(N,from_base,to_base)        进制转换        例如：            SELECT CONV('a',16,2); 表示将 a 由16进制转换为2进制字符串表示    FORMAT(X,D)        将数字X 的格式写为'#,###,###.##',以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若  D 为 0, 则返回结果不带有小数点，或不含小数部分。        例如：            SELECT FORMAT(12332.1,4); 结果为： '12,332.1000'    INSERT(str,pos,len,newstr)        在str的指定位置插入字符串            pos：要替换位置其实位置            len：替换的长度            newstr：新字符串        特别的：            如果pos超过原字符串长度，则返回原字符串            如果len超过原字符串长度，则由新字符串完全替换    INSTR(str,substr)        返回字符串 str 中子字符串的第一个出现位置。    LEFT(str,len)        返回字符串str 从开始的len位置的子序列字符。    LOWER(str)        变小写    UPPER(str)        变大写    REVERSE(str)        返回字符串 str ，顺序和字符顺序相反。    SUBSTRING(str,pos) , SUBSTRING(str FROM pos) SUBSTRING(str,pos,len) , SUBSTRING(str FROM pos FOR len)        不带有len 参数的格式从字符串str返回一个子字符串，起始于位置 pos。带有len参数的格式从字符串str返回一个长度同len字符相同的子字符串，起始于位置 pos。 使用 FROM的格式为标准 SQL 语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。        mysql&gt; SELECT SUBSTRING('Quadratically',5);            -&gt; 'ratically'        mysql&gt; SELECT SUBSTRING('foobarbar' FROM 4);            -&gt; 'barbar'        mysql&gt; SELECT SUBSTRING('Quadratically',5,6);            -&gt; 'ratica'        mysql&gt; SELECT SUBSTRING('Sakila', -3);            -&gt; 'ila'        mysql&gt; SELECT SUBSTRING('Sakila', -5, 3);            -&gt; 'aki'        mysql&gt; SELECT SUBSTRING('Sakila' FROM -4 FOR 2);            -&gt; 'ki'四、日期和时间函数    CURDATE()或CURRENT_DATE() 返回当前的日期    CURTIME()或CURRENT_TIME() 返回当前的时间    DAYOFWEEK(date)   返回date所代表的一星期中的第几天(1~7)    DAYOFMONTH(date)  返回date是一个月的第几天(1~31)    DAYOFYEAR(date)   返回date是一年的第几天(1~366)    DAYNAME(date)   返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE);    FROM_UNIXTIME(ts,fmt)  根据指定的fmt格式，格式化UNIX时间戳ts    HOUR(time)   返回time的小时值(0~23)    MINUTE(time)   返回time的分钟值(0~59)    MONTH(date)   返回date的月份值(1~12)    MONTHNAME(date)   返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE);    NOW()    返回当前的日期和时间    QUARTER(date)   返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE);    WEEK(date)   返回日期date为一年中第几周(0~53)    YEAR(date)   返回日期date的年份(1000~9999)    重点:    DATE_FORMAT(date,format) 根据format字符串格式化date值       mysql&gt; SELECT DATE_FORMAT('2009-10-04 22:23:00', '%W %M %Y');        -&gt; 'Sunday October 2009'       mysql&gt; SELECT DATE_FORMAT('2007-10-04 22:23:00', '%H:%i:%s');        -&gt; '22:23:00'       mysql&gt; SELECT DATE_FORMAT('1900-10-04 22:23:00',        -&gt;                 '%D %y %a %d %m %b %j');        -&gt; '4th 00 Thu 04 10 Oct 277'       mysql&gt; SELECT DATE_FORMAT('1997-10-04 22:23:00',        -&gt;                 '%H %k %I %r %T %S %w');        -&gt; '22 22 10 10:23:00 PM 22:23:00 00 6'       mysql&gt; SELECT DATE_FORMAT('1999-01-01', '%X %V');        -&gt; '1998 52'       mysql&gt; SELECT DATE_FORMAT('2006-06-00', '%d');        -&gt; '00'五、加密函数    MD5()            计算字符串str的MD5校验和    PASSWORD(str)           返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。六、控制流函数                CASE WHEN[test1] THEN [result1]...ELSE [default] END        如果testN是真，则返回resultN，否则返回default    CASE [test] WHEN[val1] THEN [result]...ELSE [default]END          如果test和valN相等，则返回resultN，否则返回default    IF(test,t,f)           如果test是真，返回t；否则返回f    IFNULL(arg1,arg2)         如果arg1不是空，返回arg1，否则返回arg2    NULLIF(arg1,arg2)         如果arg1=arg2返回NULL；否则返回arg1        七、控制流函数小练习#7.1、准备表，将下面这些内容保存为一个.txt文件或者.sql，然后通过navicat的运行sql文件的功能导入到数据库中，还记得吗？/*Navicat MySQL Data TransferSource Server         : localhost_3306Source Server Version : 50720Source Host           : localhost:3306Source Database       : studentTarget Server Type    : MYSQLTarget Server Version : 50720File Encoding         : 65001Date: 2018-01-02 12:05:30*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for course-- ----------------------------DROP TABLE IF EXISTS `course`;CREATE TABLE `course` (  `c_id` int(11) NOT NULL,  `c_name` varchar(255) DEFAULT NULL,  `t_id` int(11) DEFAULT NULL,  PRIMARY KEY (`c_id`),  KEY `t_id` (`t_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of course-- ----------------------------INSERT INTO `course` VALUES ('1', 'python', '1');INSERT INTO `course` VALUES ('2', 'java', '2');INSERT INTO `course` VALUES ('3', 'linux', '3');INSERT INTO `course` VALUES ('4', 'web', '2');-- ------------------------------ Table structure for score-- ----------------------------DROP TABLE IF EXISTS `score`;CREATE TABLE `score` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `s_id` int(10) DEFAULT NULL,  `c_id` int(11) DEFAULT NULL,  `num` double DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;-- ------------------------------ Records of score-- ----------------------------INSERT INTO `score` VALUES ('1', '1', '1', '79');INSERT INTO `score` VALUES ('2', '1', '2', '78');INSERT INTO `score` VALUES ('3', '1', '3', '35');INSERT INTO `score` VALUES ('4', '2', '2', '32');INSERT INTO `score` VALUES ('5', '3', '1', '66');INSERT INTO `score` VALUES ('6', '4', '2', '77');INSERT INTO `score` VALUES ('7', '4', '1', '68');INSERT INTO `score` VALUES ('8', '5', '1', '66');INSERT INTO `score` VALUES ('9', '2', '1', '69');INSERT INTO `score` VALUES ('10', '4', '4', '75');INSERT INTO `score` VALUES ('11', '5', '4', '66.7');-- ------------------------------ Table structure for student-- ----------------------------DROP TABLE IF EXISTS `student`;CREATE TABLE `student` (  `s_id` varchar(20) NOT NULL,  `s_name` varchar(255) DEFAULT NULL,  `s_age` int(10) DEFAULT NULL,  `s_sex` char(1) DEFAULT NULL,  PRIMARY KEY (`s_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of student-- ----------------------------INSERT INTO `student` VALUES ('1', '鲁班', '12', '男');INSERT INTO `student` VALUES ('2', '貂蝉', '20', '女');INSERT INTO `student` VALUES ('3', '刘备', '35', '男');INSERT INTO `student` VALUES ('4', '关羽', '34', '男');INSERT INTO `student` VALUES ('5', '张飞', '33', '女');-- ------------------------------ Table structure for teacher-- ----------------------------DROP TABLE IF EXISTS `teacher`;CREATE TABLE `teacher` (  `t_id` int(10) NOT NULL,  `t_name` varchar(50) DEFAULT NULL,  PRIMARY KEY (`t_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of teacher-- ----------------------------INSERT INTO `teacher` VALUES ('1', '大王');INSERT INTO `teacher` VALUES ('2', 'alex');INSERT INTO `teacher` VALUES ('3', 'chao');INSERT INTO `teacher` VALUES ('4', 'peiqi');#7.2、统计各科各分数段人数.显示格式:课程ID,课程名称,[100-85],[85-70],[70-60],[ &lt;60]select  score.c_id,          course.c_name,       sum(CASE WHEN num BETWEEN 85 and 100 THEN 1 ELSE 0 END) as '[100-85]',      sum(CASE WHEN num BETWEEN 70 and 85 THEN 1 ELSE 0 END) as '[85-70]',      sum(CASE WHEN num BETWEEN 60 and 70 THEN 1 ELSE 0 END) as '[70-60]',      sum(CASE WHEN num &lt; 60 THEN 1 ELSE 0 END) as '[ &lt;60]'from score,course where score.c_id=course.c_id GROUP BY score.c_id;    </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　需要掌握的函数：date_format ：这个我们要讲一讲，将来你可能会用的到的，我们前面没有讲过的一个东西。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#1 基本使用mysql&gt; SELECT DATE_FORMAT('2009-10-04 22:23:00', '%W %M %Y');        -&gt; 'Sunday October 2009'mysql&gt; SELECT DATE_FORMAT('2007-10-04 22:23:00', '%H:%i:%s');        -&gt; '22:23:00'mysql&gt; SELECT DATE_FORMAT('1900-10-04 22:23:00',    -&gt;                 '%D %y %a %d %m %b %j');        -&gt; '4th 00 Thu 04 10 Oct 277'mysql&gt; SELECT DATE_FORMAT('1997-10-04 22:23:00',    -&gt;                 '%H %k %I %r %T %S %w');        -&gt; '22 22 10 10:23:00 PM 22:23:00 00 6'mysql&gt; SELECT DATE_FORMAT('1999-01-01', '%X %V');        -&gt; '1998 52'mysql&gt; SELECT DATE_FORMAT('2006-06-00', '%d');        -&gt; '00'#2 准备表和记录CREATE TABLE blog (    id INT PRIMARY KEY auto_increment,    NAME CHAR (32),    sub_time datetime);INSERT INTO blog (NAME, sub_time)VALUES    ('第1篇','2015-03-01 11:31:21'),    ('第2篇','2015-03-11 16:31:21'),    ('第3篇','2016-07-01 10:21:31'),    ('第4篇','2016-07-22 09:23:21'),    ('第5篇','2016-07-23 10:11:11'),    ('第6篇','2016-07-25 11:21:31'),    ('第7篇','2017-03-01 15:33:21'),    ('第8篇','2017-03-01 17:32:21'),    ('第9篇','2017-03-01 18:31:21');#3. 提取sub_time字段的值，按照格式后的结果即"年月"来分组，统计一下每年每月的博客数量，怎么写呢，按照sub_time分组，但是我们的sub_time是年月日加时间，我想看每年每月，直接按照sub_time来分组是不行的，每篇博客的发表时间基本都是不同的，所以我们需要通过这个date_format来搞了SELECT DATE_FORMAT(sub_time,'%Y-%m'),COUNT(1) FROM blog GROUP BY DATE_FORMAT(sub_time,'%Y-%m');#结果+-------------------------------+----------+| DATE_FORMAT(sub_time,'%Y-%m') | COUNT(1) |+-------------------------------+----------+| 2015-03                       |        2 || 2016-07                       |        4 || 2017-03                       |        3 |+-------------------------------+----------+3 rows in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　更多函数：<a href="http://doc.mysql.cn/mysql5/refman-5.1-zh.html-chapter/functions.html#encryption-functions">中文猛击这里</a> OR <a href="https://dev.mysql.com/doc/refman/5.7/en/functions.html">官方猛击这里</a></p><p>　　<strong>一 自定义函数（自己简单看看吧）</strong></p><pre><code>#！！！注意！！！#函数中不要写sql语句（否则会报错），函数仅仅只是一个功能，是一个在sql中被应用的功能#若要想在begin...end...中写sql，请用存储过程</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>delimiter //create function f1(    i1 int,    i2 int)returns intBEGIN    declare num int;    set num = i1 + i2;    return(num);END //delimiter ;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>delimiter //create function f5(    i int)returns intbegin    declare res int default 0;    if i = 10 then        set res=100;    elseif i = 20 then        set res=200;    elseif i = 30 then        set res=300;    else        set res=400;    end if;    return res;end //delimiter ;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>二 删除函数</strong></p><pre><code>drop function func_name;</code></pre><p>　　<strong>三 执行函数</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code># 获取返回值select UPPER('chao') into @res;SELECT @res;# 在查询中使用select f1(11,nid) ,name from tb2;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　关于查看存储过程，函数，视图，触发器的语法：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>查询数据库中的存储过程和函数       select name from mysql.proc where db = 'xx' and type = 'PROCEDURE'   //查看xx库里面的存储过程       select name from mysql.proc where db = 'xx' and type = 'FUNCTION'   //函数       show procedure status; //存储过程       show function status;     //函数查看存储过程或函数的创建代码　　show create procedure proc_name;　　show create function func_name;查看视图　　SELECT * from information_schema.VIEWS   //视图　　SELECT * from information_schema.TABLES   //表查看触发器　　SHOW TRIGGERS [FROM db_name] [LIKE expr]　　SELECT * FROM triggers T WHERE trigger_name=”mytrigger” \G；其中triggers T就是triggers as T的意思，起别名</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="六-流程控制"><a href="#六-流程控制" class="headerlink" title="六 流程控制"></a>六 流程控制</h1><p>　　<strong>一 条件语句</strong></p><p>　　　　if条件语句：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>delimiter //CREATE PROCEDURE proc_if ()BEGIN    declare i int default 0;    if i = 1 THEN        SELECT 1;    ELSEIF i = 2 THEN        SELECT 2;    ELSE        SELECT 7;    END IF;END //delimiter ;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>二 循环语句</strong></p><p>　　　　while循环：#后面讲索引的时候，咱们会用到while循环，注意语法</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>delimiter //CREATE PROCEDURE proc_while ()BEGIN    DECLARE num INT ;    SET num = 0 ;    WHILE num &lt; 10 DO        SELECT            num ;        SET num = num + 1 ;    END WHILE ;END //delimiter ;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　到这里你会发现，其实sql也是一个开发语言，基本数据类型啊函数啊流程控制啊(if、while等)它都有。下面这两个我们简单看一下用法就行啦<del>~</del></p><p>　　　　repeat循环：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>delimiter //CREATE PROCEDURE proc_repeat ()BEGIN    DECLARE i INT ;    SET i = 0 ;    repeat        select i;        set i = i + 1;        until i &gt;= 5    end repeat;END //delimiter ;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　loop：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>BEGIN    declare i int default 0;    loop_label: loop        set i=i+1;        if i&lt;8 then            iterate loop_label;        end if;        if i&gt;=10 then            leave loop_label;        end if;        select i;    end loop loop_label;END</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　咱们本篇博客的重点是事务和存储过程，这是你将来和mysql打交道的时候会常用的内容。其他的内容是你了解知道的内容。那么MySQL的内容就还剩下索引及慢sql优化的问题了，我们下一篇博客再讲吧<del>~</del></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之索引原理与慢查询优化</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label1">一 介绍</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label2">二 索引的原理</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label3">三 索引的数据结构</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label4">四 聚集索引与辅助索引</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label5">五 MySQL索引管理</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label6">六 测试索引</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label7">七 正确使用索引</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label8">八 联合索引与覆盖索引</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label9">九 查询优化神器-explain</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label10">十 慢查询优化的基本步骤</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10049133.html#_label11">十一 慢日志管理</a></li></ul><h1 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一 介绍"></a>一 介绍</h1><p>　　<strong>为何要有索引?</strong></p><p>　　　　一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。</p><p>　　<strong>什么是索引？</strong></p><p>　　　　索引在MySQL中也叫做“键”或者”key”（primary key，unique key，还有一个index key），是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要，减少io次数，加速查询。（其中primary key和unique key，除了有加速查询的效果之外，还有约束的效果，primary key 不为空且唯一，unique key 唯一，而index key只有加速查询的效果，没有约束效果）<br>　　　　索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。<br>　　　　索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。</p><p>　　　　强调：一旦为表创建了索引，以后的查询最好先查索引，再根据索引定位的结果去找数据</p><p>　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>                      30        10                          40   5         15               35          661    6    11   19          21   39     55    100</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>你是否对索引存在误解？</strong></p><p>　　　　索引是应用程序设计和开发的一个重要方面。若索引太多，应用程序的性能可能会受到影响。而索引太少，对查询性能又会产生影响，要找到一个平衡点，这对应用程序的性能至关重要。一些开发人员总是在事后才想起添加索引—-我一直认为，这源于一种错误的开发模式。如果知道数据的使用，从一开始就应该在需要处添加索引。开发人员往往对数据库的使用停留在应用的层面，比如编写SQL语句、存储过程之类，他们甚至可能不知道索引的存在，或认为事后让相关DBA加上即可。DBA往往不够了解业务的数据流，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需的时间，并且可能会遗漏一部分的索引。当然索引也并不是越多越好，我曾经遇到过这样一个问题：某台MySQL服务器iostat显示磁盘使用率一直处于100%，经过分析后发现是由于开发人员添加了太多的索引，在删除一些不必要的索引之后，磁盘使用率马上下降为20%。可见索引的添加也是非常有技术含量的。</p><h1 id="二-索引的原理"><a href="#二-索引的原理" class="headerlink" title="二 索引的原理"></a><strong>二 索引的原理</strong></h1><p>　　<strong>一 索引原理</strong></p><p>　　　　索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等，下面内容看不懂的同学也没关系，能明白这个目录的道理就行了。 那么你想，书的目录占不占页数，这个页是不是也要存到硬盘里面，也占用硬盘空间。你再想，你在没有数据的情况下先建索引或者说目录快，还是已经存在好多的数据了，然后再去建索引，哪个快，肯定是没有数据的时候快，因为如果已经有了很多数据了，你再去根据这些数据建索引，是不是要将数据全部遍历一遍，然后根据数据建立索引。你再想，索引建立好之后再添加数据快，还是没有索引的时候添加数据快，索引是用来干什么的，是用来加速查询的，那对你写入数据会有什么影响，肯定是慢一些了，因为你但凡加入一些新的数据，都需要把索引或者说书的目录重新做一个，所以索引虽然会加快查询，但是会降低写入的效率。　　</p><p>　　　　<strong>索引的影响</strong></p><p>　　　　　　1、在表中有大量数据的前提下，创建索引速度会很慢</p><p>　　　　　　2、在索引创建完毕后，对表的查询性能会发幅度提升，但是写性能会降低</p><p>　　　　<strong>本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。</strong></p><p>　　　　数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><p>　　<strong>二 磁盘IO与预读</strong></p><p>　　　　前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转/min，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms，也就是半圈的时间（这里有两个时间：平均寻道时间，受限于目前的物理水平，大概是5ms的时间，找到磁道了，还需要找到你数据存在的那个点，寻点时间，这寻点时间的一个平均值就是半圈的时间，这个半圈时间叫做平均延迟时间，那么平均延迟时间加上平均寻道时间就是你找到一个数据所消耗的平均时间，大概9ms，其实机械硬盘慢主要是慢在这两个时间上了，当找到数据然后把数据拷贝到内存的时间是非常短暂的，和光速差不多了）；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的消耗的时间段下cpu可以执行约450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难，所以我们要想办法降低IO次数。下图是计算机硬件延迟的对比图，供大家参考：</p><p>　　　　 <strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170912010954844-413816327.png" alt="img"></strong></p><p>　　　　考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，<strong>当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内</strong>，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p><h1 id="三-索引的数据结构"><a href="#三-索引的数据结构" class="headerlink" title="三 索引的数据结构"></a>三 索引的数据结构</h1><p>　　前面讲了索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，现在我们来看看索引怎么做到减少IO，加速查询的。任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生（B+树是通过二叉查找树，再由平衡二叉树，B树演化而来，等到后面讲算法的时候再将，现在这个阶段，你大概了解一下就行了，别深究~~）。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170912011123500-158121126.png" alt="img"></p><p>　　如上图，是一颗b+树，最上层是树根，中间的是树枝，最下面是叶子节点，关于b+树的定义可以参见<a href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树</a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块或者叫做一个block块，这是操作系统一次IO往内存中读的内容，一个块对应四个扇区，可以看到每个磁盘块包含几个数据项（深蓝色所示，一个磁盘块里面包含多少数据，一个深蓝色的块表示一个数据，其实不是数据，后面有解释）和指针（黄色所示，看最上面一个，p1表示比上面深蓝色的那个17小的数据的位置在哪，看它指针指向的左边那个块，里面的数据都比17小，p2指向的是比17大比35小的磁盘块），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><p>　　###b+树的查找过程<br>　　　　如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。除了叶子节点，其他的树根啊树枝啊保存的就是数据的索引，他们是为你建立这种数据之间的关系而存在的。</p><p>　　###b+树性质<br>　　　　1**.索引字段要尽量的小**：通过上面的分析，我们知道IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p><p>　　　　　　比如：你每个叶子节点只存两个数据的情况下，你如果想多加两个数据，你怎么办</p><p>　　　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181201154920816-458715474.png" alt="img"></p><p>　　　　　　　　所以我们需要将树建的越低越好，因为每个磁盘块的大小是一定的，那么意味着我们单个数据库里面的单个数据的大小越大越好还是越小越好，你想啊，你现在叶子节点的磁盘块，两个数据就沾满了，你数据要是更大的话，你这一个磁盘块就只能放一个数据了亲，这样随着你数据量的增大，你的树就越高啊，我们应该想办法让树的层数低下来，效率才高啊，所以我们应该让每个数据的大小尽可能的小，那就意味着，你每个磁盘块存的数据就越多，你树的层级就越少啊，树就越低啊，对不对。并且数据的数量越大，你需要的磁盘块越多，磁盘块越多，你需要的树的层级就越高，所以我们应该尽可能的用更少的磁盘块来装更多的数据项，这样树的高度才能降下来，怎么才能装更多的数据项啊，当然是你的数据项越小，你的磁盘块盛放的数据量就越多了，所以如果一张表中有很多的字段，我们应该用什么字段来建立索引啊，如果你有id字段、name字段、描述信息字段等等的，你应该用哪个来建立索引啊，当然是id字段了，你想想对不对，因为id是个数字，占用空间最少啊。</p><p>　　　　2.<strong>索引的最左匹配特性</strong>：简单来说就是你的数据来了以后，从数据块的左边开始匹配，在匹配右边的，知道这句话就行啦<del>~</del>，我们继续学下面的内容。当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p><h1 id="四-聚集索引与辅助索引"><a href="#四-聚集索引与辅助索引" class="headerlink" title="四 聚集索引与辅助索引"></a><strong>四 聚集索引与辅助索引</strong></h1><p>　　<strong>聚集索引是什么呢，其实就是我们说的那个主键，之前我们说Innodb存储引擎的表，必须有一个主键，还记得为什么吗，我们说过的…不记得了吧，看下面</strong></p><p>　　　　<strong>还记得MyISAM存储引擎在创建表的时候会在硬盘上生成哪些文件吗，是不是有三个.frm.MYD.MYI结尾的三个文件，frm结尾的是表结构，MYD结尾的是数据文件，MYI结尾的就是索引文件，也就是说索引也是存在硬盘上的，那InnoDB引擎呢，创建一个表，在硬盘上会生成.frm.idb结尾的两个文件，那索引的呢，难道InnoDB就用不了索引吗？怎么可能？之前咱们有没有建立过索引啊，primary key、unique key是不是都叫做索引啊，但是索引那个文件去哪了呢，索引是不可能在表结构.frm（存什么字段什么类型这些东西）的文件中，那就只剩下.idb结尾的数据文件了，索引就在这里面，InnoDB引擎的表，它的索引和数据都在同一个文件里面，所以我一直强调，使用InnoDB存储引擎的时候，每建一个表，就需要给一个主键，是因为这个主键是InnoDB存储引擎的.idb文件来组织存储数据的依据或者说方式，也就是说InnoDB存储引擎在存储数据的时候默认就按照索引的那种树形结构来帮你存。这种索引，我们就称为聚集索引，也就是在聚集数据组织数据的时候，就用这种索引。InnoDB这么做就是为了加速查询效率，因为你经常会遇到基于主键来查询数据的情况，并且通常我们把id字段作为主键，第一点是因为id占用的数据空间不大，第二点是你经常会用到id来查数据。如果你的表有两个字段，一个id一个name，id为主键，当你查询的时候如果where后面的条件是name=多少多少，那么你就没有用到主键给你带来的加速查询的效果（需要主键之外的辅助索引），如果你用where id=多少多少，就会按照我们刚才上面说的哪种树形结构来给你找寻数据了（当然不仅仅有这种树形结构的数据结构类型），能够快速的帮你定位到数据块。这种聚集索引的特点是它会以id字段作为依据，去建立树形结构，但是叶子节点存的是你表中的一条完整记录，一条完整的数据。记住这一点昂，一会将辅助索引的时候，和这个内容有关系，会讲到一个回表的概念。</strong></p><p>　　<strong>在数据库中，B+树的高度一般都在2<del>4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做100次IO，2</del>4次的IO意味着查询时间只需要0.02~0.04秒。</strong></p><p>　　<strong>数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），</strong></p><p>　　<strong>聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。</strong></p><p>　　<strong>聚集索引与辅助索引不同的是：叶子结点存放的是否是一整行的信息</strong></p><p>　　<strong>1、聚集索引</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>#InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。#如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。#如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。#由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多少情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20171125235128734-300879165.png" alt="img"></strong></p><p>　　　　<strong>聚集索引的好处之一：它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录</strong>　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>#参照第六小结测试索引的准备阶段来创建出表s1mysql&gt; desc s1; #最开始没有主键+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id     | int(11)     | NO   |     | NULL    |       || name   | varchar(20) | YES  |     | NULL    |       || gender | char(6)     | YES  |     | NULL    |       || email  | varchar(50) | YES  |     | NULL    |       |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)mysql&gt; explain select * from s1 order by id desc limit 10; #Using filesort，需要二次排序+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2633472 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+1 row in set, 1 warning (0.11 sec)mysql&gt; alter table s1 add primary key(id); #添加主键Query OK, 0 rows affected (13.37 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; explain select * from s1 order by id desc limit 10; #基于主键的聚集索引在创建完毕后就已经完成了排序，无需二次排序+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | index | NULL          | PRIMARY | 4       | NULL |   10 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+1 row in set, 1 warning (0.04 sec)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　</p><p>　　　　<strong>聚集索引的好处之二：范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>mysql&gt; alter table s1 drop primary key;Query OK, 2699998 rows affected (24.23 sec)Records: 2699998  Duplicates: 0  Warnings: 0mysql&gt; desc s1;+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id     | int(11)     | NO   |     | NULL    |       || name   | varchar(20) | YES  |     | NULL    |       || gender | char(6)     | YES  |     | NULL    |       || email  | varchar(50) | YES  |     | NULL    |       |+--------+-------------+------+-----+---------+-------+4 rows in set (0.12 sec)mysql&gt; explain select * from s1 where id &gt; 1 and id &lt; 1000000; #没有聚集索引，预估需要检索的rows数如下，explain就是预估一下你的sql的执行效率+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2690100 |    11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+1 row in set, 1 warning (0.00 sec)mysql&gt; alter table s1 add primary key(id);Query OK, 0 rows affected (16.25 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; explain select * from s1 where id &gt; 1 and id &lt; 1000000; #有聚集索引，预估需要检索的rows数如下+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows    | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+|  1 | SIMPLE      | s1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 1343355 |   100.00 | Using where |+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+1 row in set, 1 warning (0.09 sec)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>2、辅助索引</strong></p><p>　　　　就是我们在查询的时候，where后面需要写id之外的其他字段名称来进行查询，比如说是where name=xx，没法用到主键索引的效率，怎么办，就需要我们添加辅助索引了，给name添加一个辅助索引。</p><p>　　　　表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引）（unique key啊、index key啊），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。</p><p>　　　　叶子节点存放的是对应的那条数据的主键字段的值，除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark），其实这个书签你可以理解为是一个{‘name字段’，name的值，主键id值}的这么一个数据。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。如果我们select 后面要的是name，我们直接就可以在辅助索引的叶子节点找到对应的name值，比如：select name from tb1 where name=’xx’；这个xx值你直接就在辅助索引的叶子节点就能找到，这种我们也可以称为覆盖索引。如果你select后面的字段不是name，例如：select age from tb1 where name=’xx’；也就是说，我通过辅助索引的叶子节点不能直接拿到age的值，需要通过辅助索引的叶子节点中保存的主键id的值再去通过聚集索引来找到完整的一条记录，然后从这个记录里面拿出age的值，这种操作有时候也成为回表操作，就是从头再回去查一遍，这种的查询效率也很高，但是比覆盖索引低一些，再说一下昂，再辅助索引的叶子节点就能找到你想找的数据可称为覆盖索引。再看看下面的解释：</p><p>　　　　由于InnoDB存储引擎是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键或者称为主键的值。如下图</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20171126001518515-1178335624.png" alt="img"></p><p>　　　　辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引，但只能有一个聚集索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得只想主键索引的主键，然后再通过主键索引来找到一个完整的行记录，这种查找的效率也是非常高。</p><p>　　　　举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问才能得到最终的一个数据页。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20171126002330609-628176603.png" alt="img"></p><p>　　概念基本就说完了，下面我们来点实际操作吧，看下面的内容<del>~</del></p><h1 id="五-MySQL索引管理"><a href="#五-MySQL索引管理" class="headerlink" title="五 MySQL索引管理"></a><strong>五 MySQL索引管理</strong></h1><p>　　<strong>一 功能</strong></p><pre><code>#1. 索引的功能就是加速查找#2. mysql中的primary key，unique，联合唯一也都是索引，这些索引除了加速查找以外，还有约束的功能</code></pre><p>　　<strong>二 MySQL常用的索引</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>普通索引INDEX：加速查找唯一索引：    -主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）    -唯一索引UNIQUE:加速查找+约束（不能重复）联合索引：    -PRIMARY KEY(id,name):联合主键索引    -UNIQUE(id,name):联合唯一索引    -INDEX(id,name):联合普通索引</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　各种索引的应用场景：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>举个例子来说，比如你在为某商场做一个会员卡的系统。这个系统有一个会员表有下列字段：会员编号 INT会员姓名 VARCHAR(10)会员身份证号码 VARCHAR(18)会员电话 VARCHAR(10)会员住址 VARCHAR(50)会员备注信息 TEXT那么这个 会员编号，作为主键，使用 PRIMARY会员姓名 如果要建索引的话，那么就是普通的 INDEX会员身份证号码 如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）#除此之外还有全文索引，即FULLTEXT会员备注信息 ， 如果需要建索引的话，可以选择全文搜索。用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。但其实对于全文搜索，我们并不会使用MySQL自带的该索引，而是会选择第三方软件如Sphinx，专门来做全文搜索。#其他的如空间索引SPATIAL，了解即可，几乎不用</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>三 索引的两大类型hash与btree</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#我们可以在创建上述索引的时候，为其指定索引类型，分两类hash类型的索引：查询单条快，范围查询慢btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）#不同的存储引擎支持的索引类型也不一样InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>四 创建/删除索引的语法</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#方法一：创建表时    　　CREATE TABLE 表名 (                字段名1  数据类型 [完整性约束条件…],                字段名2  数据类型 [完整性约束条件…],                [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY                [索引名]  (字段名[(长度)]  [ASC |DESC])                 );#方法二：CREATE在已存在的表上创建索引        CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名                      ON 表名 (字段名[(长度)]  [ASC |DESC]) ;#方法三：ALTER TABLE在已存在的表上创建索引        ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX                             索引名 (字段名[(长度)]  [ASC |DESC]) ;#删除索引：DROP INDEX 索引名 ON 表名字;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　看下面的示范：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#方式一create table t1(    id int,    name char,    age int,    sex enum('male','female'),    unique key uni_id(id),    index ix_name(name) #index没有key);#方式二create index ix_age on t1(age);#方式三alter table t1 add index ix_sex(sex);#查看mysql&gt; show create table t1;| t1    | CREATE TABLE `t1` (  `id` int(11) DEFAULT NULL,  `name` char(1) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `sex` enum('male','female') DEFAULT NULL,  UNIQUE KEY `uni_id` (`id`),  KEY `ix_name` (`name`),  KEY `ix_age` (`age`),  KEY `ix_sex` (`sex`)) ENGINE=InnoDB DEFAULT CHARSET=latin1</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="六-测试索引"><a href="#六-测试索引" class="headerlink" title="六 测试索引"></a><strong>六 测试索引</strong></h1><p>　　<strong>一 准备</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#1. 准备表create table s1(id int,name varchar(20),gender char(6),email varchar(50));#2. 创建存储过程，实现批量插入记录delimiter $$ #声明存储过程的结束符号为$$create procedure auto_insert1()BEGIN    declare i int default 1;    while(i&lt;3000000)do        insert into s1 values(i,'egon','male',concat('egon',i,'@oldboy'));        set i=i+1;    end while;END$$ #$$结束delimiter ; #重新声明分号为结束符号#3. 查看存储过程show create procedure auto_insert1\G #4. 调用存储过程call auto_insert1();</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>二 在没有索引的前提下测试查询速度</strong></p><pre><code>#无索引：mysql根本就不知道到底是否存在id等于333333333的记录，也不知道存在几条id=333333333的记录，只能把数据表从头到尾扫描一遍，此时有多少个磁盘块就需要进行多少IO操作，所以查询速度很慢mysql&gt; select * from s1 where id=333333333;Empty set (0.33 sec)</code></pre><p>　　<strong>三 在表中已经存在大量数据的前提下，为某个字段段建立索引，建立速度会很慢</strong></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913163337125-480382090.png" alt="img"></p><p>　　　　或者用alter table s1 add primary key(id);加主键，建索引很慢的。</p><p>　　<strong>四 在索引建立完毕后，以该字段为查询条件时，查询速度提升明显</strong></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913171928047-457783306.png" alt="img"></p><p>　　　　<strong>PS：</strong></p><p>　　　　<strong>1. mysql先去索引表里根据b+树的搜索原理很快搜索到id等于333333333的记录不存在，IO大大降低，因而速度明显提升</strong></p><p>　　　　<strong>2. 我们可以去mysql的data目录下找到该表，可以看到占用的硬盘空间多了</strong></p><p>　　　　<strong>3. 需要注意，如下图</strong></p><p>　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913163702469-1581818233.png" alt="img"></strong></p><p>　　<strong>五 总结</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#1. 一定是为搜索条件的字段创建索引，比如select * from s1 where id = 333;就需要为id加上索引#2. 在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，建完后查询速度加快比如create index idx on s1(id);会扫描表中所有的数据，然后以id为数据项，创建索引结构，存放于硬盘的表中。建完以后，再查询就会很快了。#3. 需要注意的是：innodb表的索引会存放于s1.ibd文件中，而myisam表的索引则会有单独的索引文件table1.MYIMySAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在innodb中，表数据文件本身就是按照B+Tree（BTree即Balance True）组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此innodb表数据文件本身就是主索引。因为inndob的数据文件要按照主键聚集，所以innodb要求表必须要有主键（Myisam可以没有），如果没有显式定义，则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql会自动为innodb表生成一个隐含字段作为主键，这字段的长度为6个字节，类型为长整型.</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　你想一下，是不是全部加索引就一定好的呢，首先，我们加上索引，查询时快了，但是写入的时候就慢了，还记得吗，每次插入新的记录，你的整个索引结构都会跟着改，所以如果你乱加索引，你会发现，即便是你的网站没有几个人在注册，或者说没有几个写入数据的操作，你的磁盘IO会居高不下，磁盘在疯狂的转，因为你每插入一条数据，我们的索引都需要重新建，重建的索引要写入硬盘里面的，还记得我们给那三百万条数据建索引的时候的速度吗？每次都要把所有的数据取出来，做好一个数据结构，然后再写回硬盘，也就是要经历很多的IO才能实现这个事儿，所以乱加索引的一个弊端就是，你很少的写入都会导致你的磁盘IO非常的高，导致效率很差，所以我们要学一下怎么正确的加索引。</p><h1 id="七-正确使用索引"><a href="#七-正确使用索引" class="headerlink" title="七 正确使用索引"></a>七 正确使用索引</h1><p>　　<strong>一 索引未命中</strong></p><p>　　　　<strong>并不是说我们创建了索引就一定会加快查询速度，**</strong>若想利用索引达到预想的提高查询速度的效果，我们在添加索引时，必须遵循以下问题**</p><p>　　　　<strong>1 范围问题，或者说条件不明确，条件中出现这些符号或关键字：**</strong>&gt;、&gt;=、&lt;、&lt;=、!= 、between…and…、like、**</p><p>　　　　<strong>大于号、小于号</strong></p><p>　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913173142047-877845727.png" alt="img"></strong></p><p>　　　　如果你写where id &gt;1 and id &lt;1000000;你会发现，随着你范围的增大，速度会越来越慢，会成倍的体现出来。</p><p>　　　　不等于！=</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913173317000-2056548532.png" alt="img"></p><p>　　　　between …and…</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913173514032-289009705.png" alt="img"></p><p>　　　　like  #测like的时候，你可以先把id的主键索引去掉，然后测一下like，然后加上index key，再测一下。就知道你忘了，看语句：create index email_index  on s1(email) ，email_index是索引名、on、 s1是表名（字段名），你会发现建索引的时间也是很慢的，desc s1;查看一下索引是不是创建成功了，看那个key字段是不是有个mul，有这个说明创建成功了。</p><p>　　　　like=后面如果没有那些特殊字符，通配符之类的，就跟等于是一个效果，精确匹配。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913174115844-1107691992.png" alt="img"></p><p>　　　　#使用like的时候，通配符写在最前面，也是需要全匹配一遍，然后在比较字符串的第二个字符，最左匹配的规则，还记得吗。</p><p>　　　　<strong>2 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#先把表中的索引都删除，让我们专心研究区分度的问题mysql&gt; desc s1;+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id     | int(11)     | YES  | MUL | NULL    |       || name   | varchar(20) | YES  |     | NULL    |       || gender | char(5)     | YES  |     | NULL    |       || email  | varchar(50) | YES  | MUL | NULL    |       |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)mysql&gt; drop index a on s1;Query OK, 0 rows affected (0.20 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; drop index d on s1;Query OK, 0 rows affected (0.18 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc s1;+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id     | int(11)     | YES  |     | NULL    |       || name   | varchar(20) | YES  |     | NULL    |       || gender | char(5)     | YES  |     | NULL    |       || email  | varchar(50) | YES  |     | NULL    |       |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913180335203-1305806986.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>我们编写存储过程为表s1批量添加记录，name字段的值均为egon，也就是说name这个字段的区分度很低（gender字段也是一样的，我们稍后再搭理它）回忆b+树的结构，查询的速度与树的高度成反比，要想将树的高低控制的很低，需要保证：在某一层内数据项均是按照从左到右，从小到大的顺序依次排开，即左1&lt;左2&lt;左3&lt;...而对于区分度低的字段，无法找到大小关系，因为值都是相等的，毫无疑问，还想要用b+树存放这些等值的数据，只能增加树的高度，字段的区分度越低，则树的高度越高。极端的情况，索引字段的值都一样，那么b+树几乎成了一根棍。本例中就是这种极端的情况，name字段所有的值均为'egon'#现在我们得出一个结论：为区分度低的字段建立索引，索引树的高度会很高，然而这具体会带来什么影响呢？？？#1：如果条件是name='xxxx',那么肯定是可以第一时间判断出'xxxx'是不在索引树中的（因为树中所有的值均为'egon’,看第一条的时候就知道你不在索引树里面了），所以查询速度很快#2：如果条件正好是name='egon',查询时，我们永远无法从树的某个位置得到一个明确的范围，只能往下找，往下找，往下找。。。这与全表扫描的IO次数没有多大区别，所以速度很慢</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong>3 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</strong></p><p>　　　　<strong>4 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)</strong></p><p>　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913181917438-461459737.png" alt="img"></strong></p><p>　　　　把上面的条件写成 where id = 3000/3;你会发现速度变得很快，因为等于号后面的数字，是在比较之前就计算出来了，不需要每次都计算一次每次都计算一次了，跟直接等于一个常数是一样的，所以很快。结论是不要让你的索引字段参与到计算中。</p><p>　　　　<strong>5 and/or</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#1、and与or的逻辑    条件1 and 条件2:所有条件都成立才算成立，但凡要有一个条件不成立则最终结果不成立    条件1 or 条件2:只要有一个条件成立则最终结果就成立#2、and的工作原理    条件：        a = 10 and b = 'xxx' and c &gt; 3 and d =4    索引：        制作联合索引(d,a,b,c)    工作原理:  #如果是你找的话，你会怎么找，是不是从左到右一个一个的比较啊，首先你不能确定a这个字段是不是有索引，即便是有索引，也不一定能确保命中索引了（所谓命中索引，就是应用上了索引），mysql不会这么笨的，看下面mysql是怎么找的：        索引的本质原理就是先不断的把查找范围缩小下来，然后再进行处理，对于连续多个and：mysql会按照联合索引，从左到右的顺序找一个区分度高的索引字段(这样便可以快速锁定很小的范围)，加速查询，即按照d—&gt;a-&gt;b-&gt;c的顺序#3、or的工作原理    条件：        a = 10 or b = 'xxx' or c &gt; 3 or d =4    索引：        制作联合索引(d,a,b,c)    工作原理:        只要一个匹配成功就行，所以对于连续多个or：mysql会按照条件的顺序，从左到右依次判断，即a-&gt;b-&gt;c-&gt;d</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　索引要加在数据区分度高的字段上</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913184346985-350786634.png" alt="img"></p><p>　　　　在左边条件成立但是索引字段的区分度低的情况下（name与gender均属于这种情况），会依次往右找到一个区分度高的索引字段，加速查询</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913184803907-472470203.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913185326453-368396003.png" alt="img"></p><p>　　　　经过分析，在条件为name=’egon’ and gender=’male’ and id&gt;333 and email=’xxx’的情况下，我们完全没必要为前三个条件的字段加索引，因为只能用上email字段的索引，前三个字段的索引反而会降低我们的查询效率</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913185714750-1756875642.png" alt="img"></p><p>　　　　　　　</p><p>　　　　大家还有兴趣的话，可以去研究一下mysql的慢sql查询的日志，学一学如果筛选慢sql等操作和配置等，优化慢sql的方式是可以修改你查询语句的逻辑，还有更有效的方式就是加索引或者联合索引。</p><p>　　　　<strong>6 最左前缀匹配原则（详见第八小节），非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配(指的是范围大了，有索引速度也慢)，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</strong></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170913190827078-212193584.png" alt="img"></p><p>　　　　<strong>7 其他情况</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>- 使用函数    select * from tb1 where reverse(email) = 'egon';- 类型不一致    如果列是字符串类型，传入条件是必须用引号引起来，不然...    select * from tb1 where email = 999;#排序条件为索引，则select字段必须也是索引字段，否则无法命中- order by    select name from s1 order by email desc;    当根据索引排序时候，select查询的字段如果不是索引，则速度仍然很慢    select email from s1 order by email desc;    特别的：如果对主键排序，则还是速度很快：        select * from tb1 order by nid desc;- 组合索引最左前缀    如果组合索引为：(name,email)    name and email       -- 命中索引    name                 -- 命中索引    email                -- 未命中索引- count(1)或count(列)代替count(*)在mysql中没有差别了- create index xxxx  on tb(title(19)) #text类型，必须制定长度</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>二 其他注意事项</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>- 避免使用select *- count(1)或count(列) 代替 count(*)- 创建表时尽量时 char 代替 varchar- 表的字段顺序固定长度的字段优先- 组合索引代替多个单列索引（经常使用多个条件查询时）- 尽量使用短索引- 使用连接（JOIN）来代替子查询(Sub-Queries)- 连表时注意条件类型需一致- 索引散列值（重复少）不适合建索引，例：性别不适合</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="八-联合索引与覆盖索引"><a href="#八-联合索引与覆盖索引" class="headerlink" title="八 联合索引与覆盖索引"></a>八 联合索引与覆盖索引</h1><p>　　<strong>一 联合索引</strong></p><p>　　　　联合索引时指对表上的多个列合起来做一个索引，省的你查询的时候，where后面的条件字段一直再变，你就想给每个字段加索引的尴尬问题。联合索引的创建方法与单个索引的创建方法一样，不同之处在仅在于有多个索引列，如下</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; create table t(    -&gt; a int,    -&gt; b int,    -&gt; primary key(a),    -&gt; key idx_a_b(a,b)    -&gt; );Query OK, 0 rows affected (0.11 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20190115215106080-1756385205.png" alt="img"></p><p>　　　　那么何时需要使用联合索引呢？在讨论这个问题之前，先来看一下联合索引内部的结果。从本质上来说，联合索引就是一棵B+树，不同的是联合索引的键值得数量不是1，而是&gt;=2。接着来讨论两个整型列组成的联合索引，假定两个键值得名称分别为a、b如图</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20171126004856453-1491949427.png" alt="img"></p><p>　　　　可以看到这与我们之前看到的单个键的B+树并没有什么不同，键值都是排序的，通过叶子结点可以逻辑上顺序地读出所有数据，就上面的例子来说，即（1,1），（1,2），（2,1），（2,4），（3,1），（3,2），数据按（a,b）的顺序进行了存放。</p><p>　　　　因此，对于查询select * from table where a=xxx and b=xxx, 显然是可以使用(a,b) 这个联合索引的，对于单个列a的查询select * from table where a=xxx,也是可以使用（a,b）这个索引的。</p><p>　　　　但对于b列的查询select * from table where b=xxx,则不可以使用（a,b） 索引，其实你不难发现原因，叶子节点上b的值为1、2、1、4、1、2显然不是排序的，因此对于b列的查询使用不到(a,b) 索引</p><p>　　　　<strong>注意建立联合索引的一个原则：</strong>索引是有个最左匹配的原则的，所以建联合索引的时候，将区分度高的放在最左边，依次排下来，范围查询的条件尽可能的往后边放。</p><p>　　　　<strong>联合索引的第二个好处是在第一个键相同的情况下，已经对第二个键进行了排序处理</strong>，例如在很多情况下应用程序都需要查询某个用户的购物情况，并按照时间进行排序，最后取出最近三次的购买记录，这时使用联合索引可以帮我们避免多一次的排序操作，因为索引本身在叶子节点已经排序了，如下</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#===========准备表==============create table buy_log(    userid int unsigned not null,    buy_date date);insert into buy_log values(1,'2009-01-01'),(2,'2009-01-01'),(3,'2009-01-01'),(1,'2009-02-01'),(3,'2009-02-01'),(1,'2009-03-01'),(1,'2009-04-01');alter table buy_log add key(userid);alter table buy_log add key(userid,buy_date);#===========验证==============mysql&gt; show create table buy_log;| buy_log | CREATE TABLE `buy_log` (  `userid` int(10) unsigned NOT NULL,  `buy_date` date DEFAULT NULL,  KEY `userid` (`userid`),  KEY `userid_2` (`userid`,`buy_date`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 |#可以看到possible_keys在这里有两个索引可以用，分别是单个索引userid与联合索引userid_2,但是优化器最终选择了使用的key是userid因为该索引的叶子节点包含单个键值，所以理论上一个页能存放的记录应该更多mysql&gt; explain select * from buy_log where userid=2;+----+-------------+---------+------+-----------------+--------+---------+-------+------+-------+| id | select_type | table   | type | possible_keys   | key    | key_len | ref   | rows | Extra |+----+-------------+---------+------+-----------------+--------+---------+-------+------+-------+|  1 | SIMPLE      | buy_log | ref  | userid,userid_2 | userid | 4       | const |    1 |       |+----+-------------+---------+------+-----------------+--------+---------+-------+------+-------+1 row in set (0.00 sec)#接着假定要取出userid为1的最近3次的购买记录，用的就是联合索引userid_2了，因为在这个索引中，在userid=1的情况下，buy_date都已经排序好了mysql&gt; explain select * from buy_log where userid=1 order by buy_date desc limit 3;+----+-------------+---------+------+-----------------+----------+---------+-------+------+--------------------------+| id | select_type | table   | type | possible_keys   | key      | key_len | ref   | rows | Extra                    |+----+-------------+---------+------+-----------------+----------+---------+-------+------+--------------------------+|  1 | SIMPLE      | buy_log | ref  | userid,userid_2 | userid_2 | 4       | const |    4 | Using where; Using index |+----+-------------+---------+------+-----------------+----------+---------+-------+------+--------------------------+1 row in set (0.00 sec)#ps：如果extra的排序显示是Using filesort，则意味着在查出数据后需要二次排序(如下查询语句，没有先用where userid=3先定位范围，于是即便命中索引也没用，需要二次排序)mysql&gt; explain select * from buy_log order by buy_date desc limit 3;+----+-------------+---------+-------+---------------+----------+---------+------+------+-----------------------------+| id | select_type | table   | type  | possible_keys | key      | key_len | ref  | rows | Extra                       |+----+-------------+---------+-------+---------------+----------+---------+------+------+-----------------------------+|  1 | SIMPLE      | buy_log | index | NULL          | userid_2 | 8       | NULL |    7 | Using index; Using filesort |+----+-------------+---------+-------+---------------+----------+---------+------+------+-----------------------------+#对于联合索引（a,b）,下述语句可以直接使用该索引，无需二次排序select ... from table where a=xxx order by b;#然后对于联合索引(a,b,c)来首，下列语句同样可以直接通过索引得到结果select ... from table where a=xxx order by b;select ... from table where a=xxx and b=xxx order by c;#但是对于联合索引(a,b,c)，下列语句不能通过索引直接得到结果，还需要自己执行一次filesort操作，因为索引（a，c)并未排序select ... from table where a=xxx order by c;</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>二 覆盖索引</strong></p><p>　　　　<strong>InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。</strong></p><p>　　　　使用覆盖索引的一个好处是：辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作</p><hr><p>　　　　 注意：覆盖索引技术最早是在InnoDB Plugin中完成并实现，这意味着对于InnoDB版本小于1.0的，或者MySQL数据库版本为5.0以下的，InnoDB存储引擎不支持覆盖索引特性</p><hr><p>　　　　对于InnoDB存储引擎的辅助索引而言，由于其包含了主键信息，因此其叶子节点存放的数据为（primary key1，priamey key2，…,key1，key2，…）。例如</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>select age from s1 where id=123 and name = 'egon'; #id字段有索引，但是name字段没有索引,该sql命中了索引，但未覆盖，需要去聚集索引中再查找详细信息。最牛逼的情况是，索引字段覆盖了所有，那全程通过索引来加速查询以及获取结果就ok了mysql&gt; desc s1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | | NULL | || name | varchar(20) | YES | | NULL | || gender | char(6) | YES | | NULL | || email | varchar(50) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.21 sec)mysql&gt; explain select name from s1 where id=1000; #没有任何索引+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 2688336 | 10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+1 row in set, 1 warning (0.00 sec)mysql&gt; create index idx_id on s1(id); #创建索引Query OK, 0 rows affected (4.16 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select name from s1 where id=1000; #命中辅助索引，但是未覆盖索引，还需要从聚集索引中查找name+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------+| 1 | SIMPLE | s1 | NULL | ref | idx_id | idx_id | 4 | const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.08 sec)mysql&gt; explain select id from s1 where id=1000; #在辅助索引中就找到了全部信息，Using index代表覆盖索引+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------------+| 1 | SIMPLE | s1 | NULL | ref | idx_id | idx_id | 4 | const | 1 | 100.00 | Using index |+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------------+1 row in set, 1 warning (0.03 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong>覆盖索引的另外一个好处是对某些统计问题而言的。基于上一小结创建的表buy_log,查询计划如下</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>mysql&gt; explain select count(*) from buy_log;+----+-------------+---------+-------+---------------+--------+---------+------+------+-------------+| id | select_type | table   | type  | possible_keys | key    | key_len | ref  | rows | Extra       |+----+-------------+---------+-------+---------------+--------+---------+------+------+-------------+|  1 | SIMPLE      | buy_log | index | NULL          | userid | 4       | NULL |    7 | Using index |+----+-------------+---------+-------+---------------+--------+---------+------+------+-------------+1 row in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　innodb存储引擎并不会选择通过查询聚集索引来进行统计。由于buy_log表有辅助索引，而辅助索引远小于聚集索引，选择辅助索引可以减少IO操作，故优化器的选择如上key为userid辅助索引</p><p>　　　　<strong>对于（a,b）形式的联合索引，一般是不可以选择b中所谓的查询条件。但如果是统计操作，并且是覆盖索引，则优化器还是会选择使用该索引，如下</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#联合索引userid_2（userid,buy_date）,一般情况，我们按照buy_date是无法使用该索引的，但特殊情况下：查询语句是统计操作，且是覆盖索引，则按照buy_date当做查询条件时，也可以使用该联合索引mysql&gt; explain select count(*) from buy_log where buy_date &gt;= '2011-01-01' and buy_date &lt; '2011-02-01';+----+-------------+---------+-------+---------------+----------+---------+------+------+--------------------------+| id | select_type | table   | type  | possible_keys | key      | key_len | ref  | rows | Extra                    |+----+-------------+---------+-------+---------------+----------+---------+------+------+--------------------------+|  1 | SIMPLE      | buy_log | index | NULL          | userid_2 | 8       | NULL |    7 | Using where; Using index |+----+-------------+---------+-------+---------------+----------+---------+------+------+--------------------------+1 row in set (0.00 sec)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="九-查询优化神器-explain"><a href="#九-查询优化神器-explain" class="headerlink" title="九 查询优化神器-explain"></a><strong>九 查询优化神器-explain</strong></h1><p>　　<strong>关于explain命令相信大家并不陌生，具体用法和字段含义可以参考官网explain-output，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。</strong></p><p>　　<strong>关于explain，如果大家有兴趣，可以看看这篇博客，他总结的挺好的：<a href="http://www.cnblogs.com/yycc/p/7338894.html">http://www.cnblogs.com/yycc/p/7338894.html</a></strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>执行计划：让mysql预估执行操作(一般正确)    all &lt; index &lt; range &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt; system/const    id,email    慢：        select * from userinfo3 where name='alex'        explain select * from userinfo3 where name='alex'        type: ALL(全表扫描)            select * from userinfo3 limit 1;    快：        select * from userinfo3 where email='alex'        type: const(走索引)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong><a href="http://blog.itpub.net/29773961/viewspace-1767044/">http://blog.itpub.net/29773961/viewspace-1767044/</a></strong></p><h1 id="十-慢查询优化的基本步骤"><a href="#十-慢查询优化的基本步骤" class="headerlink" title="十 慢查询优化的基本步骤"></a><strong>十 慢查询优化的基本步骤</strong></h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）3.order by limit 形式的sql语句让排序的表优先查4.了解业务方使用场景5.加索引时参照建索引的几大原则6.观察结果，不符合预期继续从0分析</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="十一-慢日志管理"><a href="#十一-慢日志管理" class="headerlink" title="十一 慢日志管理"></a>十一 慢日志管理</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>慢日志            - 执行时间 &gt; 10            - 未命中索引            - 日志文件路径        配置：            - 内存                show variables like '%query%';                show variables like '%queries%';                set global 变量名 = 值            - 配置文件                mysqld --defaults-file='E:\wupeiqi\mysql-5.7.16-winx64\mysql-5.7.16-winx64\my-default.ini'                my.conf内容：                    slow_query_log = ON                    slow_query_log_file = D:/....                注意：修改配置文件之后，需要重启服务</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>MySQL日志管理========================================================错误日志: 记录 MySQL 服务器启动、关闭及运行错误等信息二进制日志: 又称binlog日志，以二进制文件的方式记录数据库中除 SELECT 以外的操作查询日志: 记录查询的信息慢查询日志: 记录执行时间超过指定时间的操作中继日志： 备库将主库的二进制日志复制到自己的中继日志中，从而在本地进行重放通用日志： 审计哪个账号、在哪个时段、做了哪些事件事务日志或称redo日志： 记录Innodb事务相关的如事务执行时间、检查点等========================================================一、bin-log1. 启用# vim /etc/my.cnf[mysqld]log-bin[=dir\[filename]]# service mysqld restart2. 暂停//仅当前会话SET SQL_LOG_BIN=0;SET SQL_LOG_BIN=1;3. 查看查看全部：# mysqlbinlog mysql.000002按时间：# mysqlbinlog mysql.000002 --start-datetime="2012-12-05 10:02:56"# mysqlbinlog mysql.000002 --stop-datetime="2012-12-05 11:02:54"# mysqlbinlog mysql.000002 --start-datetime="2012-12-05 10:02:56" --stop-datetime="2012-12-05 11:02:54" 按字节数：# mysqlbinlog mysql.000002 --start-position=260# mysqlbinlog mysql.000002 --stop-position=260# mysqlbinlog mysql.000002 --start-position=260 --stop-position=9304. 截断bin-log（产生新的bin-log文件）a. 重启mysql服务器b. # mysql -uroot -p123 -e 'flush logs'5. 删除bin-log文件# mysql -uroot -p123 -e 'reset master' 二、查询日志启用通用查询日志# vim /etc/my.cnf[mysqld]log[=dir\[filename]]# service mysqld restart三、慢查询日志启用慢查询日志# vim /etc/my.cnf[mysqld]log-slow-queries[=dir\[filename]]long_query_time=n# service mysqld restartMySQL 5.6:slow-query-log=1slow-query-log-file=slow.loglong_query_time=3查看慢查询日志测试:BENCHMARK(count,expr)SELECT BENCHMARK(50000000,2*3);</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL字符集详解</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AF%A6%E8%A7%A3/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL字符集编码简单介绍"><a href="#一、MySQL字符集编码简单介绍" class="headerlink" title="一、MySQL字符集编码简单介绍"></a>一、MySQL字符集编码简单介绍</h2><p>　　在使用MySQL时要注意6个需要编码的地方：系统的编码、客户端、服务端、库、表、列。字符集编码不仅影响数据存储,还影响client程序和数据库之间的交互.在mysql中输入命令show session variables like ‘%char%’能够看到例如以下一些字符集（下面是以win10为例，生产中多数时linux，在linux里面除了latin1之外都是utf8的字符集）:</p><p>　　　　mysql&gt; show variables like “%char%”;<br>　　　　+————————–+——————————————-+<br>　　　　| Variable_name | Value |<br>　　　　+————————–+——————————————-+<br>　　　　| character_set_client | gbk |<br>　　　　| character_set_connection | gbk |<br>　　　　| character_set_database | latin1 |<br>　　　　| character_set_filesystem | binary |<br>　　　　| character_set_results | gbk |<br>　　　　| character_set_server | latin1 |<br>　　　　| character_set_system | utf8 |<br>　　　　| character_sets_dir | F:\jj\mysql-5.6.42-winx64\share\charsets\ |<br>　　　　+————————–+——————————————-+</p><p>　　　　8 rows in set (0.00 sec)</p><p>　　mysql中的字符集都相应着一个默认的校对规则(COLLATION),当然一个字符集也可能相应多个校对规则,可是两个不同的字符集不能相应同一个规则。使用默认的就可以了</p><p>　　以下来看看上面命令列出的字符集相关变量的含义：</p><ul><li>character_set_client:server解析客户端sql语句的字符集.(The character set for statements that arrive from the client. The session value of this variable is set using the character set requested by the client when the client connects to the server).</li><li>character_set_connection:字符串字面值（literal strings）的字符集.</li><li>character_set_results:server返回给客户端的查询结果或者错误提示的字符集编码.(The character set used for returning query results such as result sets or error messages to the client)</li><li>character_set_system:这是mysqlserver用来存储元数据的编码,通常就是utf8,不要去改动它.</li><li>character_sets_dir:这是mysql字符集编码存储文件夹.</li><li>character_set_filesystem:这是文件系统字符集编码,主要用于解析用于文件名称的字符串字面值,如LOAD DATA INFILE和SELECT …INTO OUTFILE等语句以及LOAD_FILE()函数.在打开文件之前,文件名称会从character_set_client转换为character_set_filesystem指定的编码.默认值为binary,也就是说不会进行转换.比如我们设置的character_set_client=GBK,而character_set_filesystem为默认值的话,则采用SELECT…INTO OUTFILE “文件名称”,文件名称为GBK编码.反之,假设我们设置了character_set_filesystem=UTF8,则导出的文件名称为UTF8编码. 比如:linux系统的终端编码是UTF8,系统默认语言和编码为zh_CN.UTF8.我们有一个数据库名为test,test中有个表名为t1,编码为latin1,另外,我们在mysqlclient运行了SET NAMES GBK,假设我们不改动character_set_filesystem的值,运行SELECT * FROM t1 INTO OUTFILE ‘文件1’, 能够发现相应的文件夹以下生成了一个名为”文件1”的文件,那文件名称编码是什么呢?事实上这里有几个地方须要注意,首先,我们的sql语句里面的”文件1”原生编码就是终端编码UTF8,也就是’\xe6\x96\x87\xe4\xbb\xb61’,而导出数据的语句SELECT * FROM t1 INTO OUTFILE ‘文件1’,依照前面的说法,由于character_set_filesystem为binary,因此’\xe6\x96\x87\xe4\xbb\xb61’不会转换,这样终于还是’\xe6\x96\x87\xe4\xbb\xb61’,这样在zh_CN.UTF8的系统中文件名称不会乱码.而假设我们设置了character_set_filesystem=UTF8,则原生的’\xe6\x96\x87\xe4\xbb\xb61’会先依照GBK解码,然后用UTF8编码,最后的结果是”\xe9\x8f\x82\xe5\x9b\xa6\xe6\xac\xa21”,这样文件名称就会乱码了.所以这个变量也最好不要改动,用默认值就OK.</li><li>character_set_server:服务器默认字符集编码,假设创建数据库的时候没有指定编码,则采用character_set_server指定编码.</li><li>character_set_database:默认数据库的字符集编码.假设没有默认数据库,则该变量值与character_set_server同样.事实上这个值代表的就是你当前数据库的编码而已,比方使用”use test”,而test数据库的编码为latin1的话,这个值就是latin1.而你切换的时候”use test2”,则character_set_database的值就是数据库test2的编码.</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="二、MySQL字符集编码层次"><a href="#二、MySQL字符集编码层次" class="headerlink" title="二、MySQL字符集编码层次"></a>二、MySQL字符集编码层次</h2><p>　　第一部分主要是归纳了MySQL文档中关于字符集编码的说明。这部分主要说明下MySQL中字符集编码层次:服务端–&gt;数据库–&gt;表–&gt;字段。</p><p>　　关于系统的编码主要针对的是我们将来在存储文件的时候，有可能会将文件直接存贮在mysql的服务器上，那么，我们在数据库里面存的就是这些文件的路径，实际文件是存在系统里面的，那么文件名称就会受到你系统编码的影响，比如我们mysql设置的utf8编码的格式存储的文件路径，但是系统默认是gbk编码的，那么文件在保存到系统里的时候，文件的名称和你存在mysql里面的文件名称就对应不上了，出现乱码显示的问题，所以也要注意系统的编码。客户端的编码问题，我们在第一节的时候说了一下，大家应该比较了解啦。所以我们下面之说mysql内部设置的这些编码问题。</p><p>　　简单来说,服务器编码就是character_set_server来指定的.当我们创建数据库的时候能够指定编码,假设没有指定,采用的就是character_set_server指定的编码.比如:我们使用”create database t1 character set gbk”,这里我们指定了数据库t1的编码为gbk,所以不会采用character_set_server指定的编码.而假设我们使用”create database t2”,则通过”show create database t2”能够看到t2的编码为character_set_server定的编码.</p><p>　　同理,mysql表也能够有自己独立的编码,在创建表的时候能够指定,假设没有指定,则默认采用数据库的编码.比方我们再之前的数据库t1创建表t11,”create table t11(i int) character set utf8”,则表t11的编码为utf8,假设不指定编码则编码为数据库t1的编码gbk.</p><p>　　此外,mysql表中的字段也能够有自己的编码,假设不指定字段编码,则字段编码与表的编码一致.</p><h2 id="三、MySQL连接字符集"><a href="#三、MySQL连接字符集" class="headerlink" title="三、MySQL连接字符集"></a>三、MySQL连接字符集</h2><p>　　前面谈到的编码内容基本都不会产生乱码问题,mysql中容易产生乱码的地方在character_set_client, character_set_connection, character_set_results这三个变量的设定.能够简单的通过set names utf8或者charset utf8命令来一次设置这三个參数.</p><p>　　从文档中的解释来看,mysql连接字符集转换主要包含以下三个步骤:</p><ul><li>1.character_set_client是client发送过来的sql语句的编码,由于服务端本身并不知道client的sql语句的编码是什么,所以是以这个变量作为clientsql语句的初始编码.而服务端接收到sql语句后,则会将sql语句转换为character_set_connection指定的编码(注意,对于字面值字符串,假设前面有introducer标记如<em>latin1或</em>utf8,则不会进行这一步转换).转换完毕,才会真正运行sql语句.</li><li>2.进行内部操作前将sql语句中的数据从character_set_connection转换为数据表中对应字段的编码.</li><li>3.将操作结果从内部字符集编码转换为character_set_results编码.</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之携程</title>
      <link href="2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/python%E4%B9%8B%E5%8D%8F%E7%A8%8B/"/>
      <url>2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/python%E4%B9%8B%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9712056.html#_label1">一 引子</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9712056.html#_label2">二 协程介绍</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9712056.html#_label3">三 Greenlet</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9712056.html#_label4">四 Gevent介绍</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9712056.html#_label5">五 Gevent之同步与异步</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9712056.html#_label6">六 Gevent之应用举例一</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9712056.html#_label7">七 Gevent之应用举例二</a></li></ul><h3 id="一-引子"><a href="#一-引子" class="headerlink" title="一 引子"></a>一 引子</h3><p>　　本节的主题是基于单线程来实现并发，即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并发，为此我们需要先回顾下并发的本质：切换+保存状态</p><p>　　cpu正在运行一个任务，会在两种情况下切走去执行其他的任务（切换由操作系统强制控制），一种情况是该任务发生了阻塞，另外一种情况是该任务计算的时间过长或有一个优先级更高的程序替代了它</p><p>　　协程本质上就是一个线程，以前线程任务的切换是由操作系统控制的，遇到I/O自动切换，现在我们用协程的目的就是较少操作系统切换的开销（开关线程，创建寄存器、堆栈等，在他们之间进行切换等），在我们自己的程序里面来控制任务的切换。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20180202102945937-1050863538.png" alt="img"></p><p>　　　　ps：在介绍进程理论时，提及进程的三种执行状态，而线程才是执行单位，所以也可以将上图理解为线程的三种状态 </p><p>　　一：其中第二种情况并不能提升效率，只是为了让cpu能够雨露均沾，实现看起来所有任务都被“同时”执行的效果，如果多个任务都是纯计算的，这种切换反而会降低效率。为此我们可以基于yield来验证。yield本身就是一种在单线程下可以保存任务运行状态的方法，我们来简单复习一下：</p><pre><code>#1 yiled可以保存状态，yield的状态保存与操作系统的保存线程状态很像，但是yield是代码级别控制的，更轻量级#2 send可以把一个函数的结果传给另外一个函数，以此实现单线程内程序之间的切换  </code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timedef func1():    for i in range(11):        #yield        print('这是我第%s次打印啦' % i)        time.sleep(1)def func2():    g = func1()    #next(g)    for k in range(10):        print('哈哈，我第%s次打印了' % k)        time.sleep(1)        #next(g)#不写yield，下面两个任务是执行完func1里面所有的程序才会执行func2里面的程序，有了yield，我们实现了两个任务的切换+保存状态func1()func2()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#基于yield并发执行，多任务之间来回切换，这就是个简单的协程的体现，但是他能够节省I/O时间吗？不能import timedef consumer():    '''任务1:接收数据,处理数据'''    while True:        x=yield        # time.sleep(1) #发现什么？只是进行了切换，但是并没有节省I/O时间        print('处理了数据：',x)def producer():    '''任务2:生产数据'''    g=consumer()    next(g)  #找到了consumer函数的yield位置    for i in range(3):    # for i in range(10000000):        g.send(i)  #给yield传值，然后再循环给下一个yield传值，并且多了切换的程序，比直接串行执行还多了一些步骤，导致执行效率反而更低了。        print('发送了数据：',i)start=time.time()#基于yield保存状态,实现两个任务直接来回切换,即并发的效果#PS:如果每个任务中都加上打印,那么明显地看到两个任务的打印是你一次我一次,即并发执行的.producer() #我在当前线程中只执行了这个函数，但是通过这个函数里面的send切换了另外一个任务stop=time.time()# 串行执行的方式# res=producer()# consumer(res) # stop=time.time()print(stop-start)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　二：第一种情况的切换。在任务一遇到io情况下，切到任务二去执行，这样就可以利用任务一阻塞的时间完成任务二的计算，效率的提升就在于此。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timedef func1():    while True:        print('func1')        yielddef func2():    g=func1()    for i in range(10000000):        i+1        next(g)        time.sleep(3)        print('func2')start=time.time()func2()stop=time.time()print(stop-start)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>协程就是告诉Cpython解释器，你不是nb吗，不是搞了个GIL锁吗，那好，我就自己搞成一个线程让你去执行，省去你切换线程的时间，我自己切换比你切换要快很多，避免了很多的开销，对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下的多个任务能在一个任务遇到io阻塞时就切换到另外一个任务去计算，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，从而可以迷惑操作系统，让其看到：该线程好像是一直在计算，io比较少，从而更多的将cpu的执行权限分配给我们的线程。</strong></p><p>　　协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。为了实现它，我们需要找寻一种可以同时满足以下条件的解决方案：</p><pre><code>#1. 可以控制多个任务之间的切换，切换之前将任务的状态保存下来，以便重新运行时，可以基于暂停的位置继续执行。#2. 作为1的补充：可以检测io操作，在遇到io操作的情况下才发生切换</code></pre><h3 id="二-协程介绍"><a href="#二-协程介绍" class="headerlink" title="二 协程介绍"></a>二 协程介绍</h3><p>　　协程：是单线程下的并发，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：<strong>协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。、</strong></p><p>　　需要强调的是：</p><pre><code>#1. python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）#2. 单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）</code></pre><p>　　对比操作系统控制线程的切换，用户在单线程内控制协程的切换</p><p>　　优点如下：</p><pre><code>#1. 协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级#2. 单线程内就可以实现并发的效果，最大限度地利用cpu</code></pre><p>　　缺点如下：</p><pre><code>#1. 协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程#2. 协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程</code></pre><p>　　总结协程特点：</p><ol><li><strong>必须在只有一个单线程里实现并发</strong></li><li><strong>修改共享数据不需加锁</strong></li><li><strong>用户程序里自己保存多个控制流的上下文栈</strong></li><li><strong>附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））</strong></li></ol><h3 id="三-Greenlet"><a href="#三-Greenlet" class="headerlink" title="三 Greenlet"></a>三 Greenlet</h3><p>　　如果我们在单个线程内有20个任务，要想实现在多个任务之间切换，使用yield生成器的方式过于麻烦（需要先得到初始化一次的生成器，然后再调用send。。。非常麻烦），而使用greenlet模块可以非常简单地实现这20个任务直接的切换</p><pre><code>#安装pip3 install greenlet</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></p><p>  #真正的协程模块就是使用greenlet完成的切换</p><pre><code>from greenlet import greenletdef eat(name):    print('%s eat 1' %name)  #2    g2.switch('taibai')   #3    print('%s eat 2' %name) #6    g2.switch() #7def play(name):    print('%s play 1' %name) #4    g1.switch()      #5    print('%s play 2' %name) #8g1=greenlet(eat)g2=greenlet(play)g1.switch('taibai')#可以在第一次switch时传入参数，以后都不需要  1</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　单纯的切换（在没有io的情况下或者没有重复开辟内存空间的操作），反而会降低程序的执行速度</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#顺序执行import timedef f1():    res=1    for i in range(100000000):        res+=idef f2():    res=1    for i in range(100000000):        res*=istart=time.time()f1()f2()stop=time.time()print('run time is %s' %(stop-start)) #10.985628366470337#切换from greenlet import greenletimport timedef f1():    res=1    for i in range(100000000):        res+=i        g2.switch()def f2():    res=1    for i in range(100000000):        res*=i        g1.switch()start=time.time()g1=greenlet(f1)g2=greenlet(f2)g1.switch()stop=time.time()print('run time is %s' %(stop-start)) # 52.763017892837524</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　greenlet只是提供了一种比generator更加便捷的切换方式，当切到一个任务执行时如果遇到io，那就原地阻塞，仍然是没有解决遇到IO自动切换来提升效率的问题。</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180927145314463-1559120537.png" alt="img"></p><p>　　上面这个图，是协程真正的意义，虽然没有规避固有的I/O时间，但是我们使用这个时间来做别的事情了，一般在工作中我们都是进程+线程+协程的方式来实现并发，以达到最好的并发效果，如果是4核的cpu，一般起5个进程，每个进程中20个线程（5倍cpu数量），每个线程可以起500个协程，大规模爬取页面的时候，等待网络延迟的时间的时候，我们就可以用协程去实现并发。 并发数量 = 5 * 20 * 500 = 50000个并发，这是一般一个4cpu的机器最大的并发数。nginx在负载均衡的时候最大承载量就是5w个</p><p>　　单线程里的这20个任务的代码通常会既有计算操作又有阻塞操作，我们完全可以在执行任务1时遇到阻塞，就利用阻塞的时间去执行任务2。。。。如此，才能提高效率，这就用到了Gevent模块。</p><h3 id="四-Gevent介绍"><a href="#四-Gevent介绍" class="headerlink" title="四 Gevent介绍"></a>四 Gevent介绍</h3><pre><code>#安装pip3 install gevent</code></pre><p>　　Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是<strong>Greenlet</strong>, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></p><pre><code>#用法g1=gevent.spawn(func,1,2,3,x=4,y=5)创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的，spawn是异步提交任务g2=gevent.spawn(func2)g1.join() #等待g1结束g2.join() #等待g2结束  有人测试的时候会发现，不写第二个join也能执行g2，是的，协程帮你切换执行了，但是你会发现，如果g2里面的任务执行的时间长，但是不写join的话，就不会执行完等到g2剩下的任务了#或者上述两步合作一步：gevent.joinall([g1,g2])g1.value#拿到func1的返回值</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>遇到IO阻塞时会自动切换任务</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import geventdef eat(name):    print('%s eat 1' %name)    gevent.sleep(2)    print('%s eat 2' %name)def play(name):    print('%s play 1' %name)    gevent.sleep(1)    print('%s play 2' %name)g1=gevent.spawn(eat,'egon')g2=gevent.spawn(play,name='egon')g1.join()g2.join()#或者gevent.joinall([g1,g2])print('主')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞,</strong></p><p>　　<strong>而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了</strong></p><p>　　<strong>from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前</strong></p><p>　　<strong>或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></p><pre><code>from gevent import monkey;monkey.patch_all() #必须写在最上面，这句话后面的所有阻塞全部能够识别了import gevent  #直接导入即可import timedef eat():    #print()　　    print('eat food 1')    time.sleep(2)  #加上mokey就能够识别到time模块的sleep了    print('eat food 2')def play():    print('play 1')    time.sleep(1)  #来回切换，直到一个I/O的时间结束，这里都是我们个gevent做得，不再是控制不了的操作系统了。    print('play 2')g1=gevent.spawn(eat)g2=gevent.spawn(play_phone)gevent.joinall([g1,g2])print('主')</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　我们可以用threading.current_thread().getName()来查看每个g1和g2，查看的结果为DummyThread-n，即假线程，虚拟线程，其实都在一个线程里面</p><p>　　进程线程的任务切换是由操作系统自行切换的，你自己不能控制</p><p>　　协程是通过自己的程序（代码）来进行切换的，自己能够控制，只有遇到协程模块能够识别的IO操作的时候，程序才会进行任务切换，实现并发效果，如果所有程序都没有IO操作，那么就基本属于串行执行了。</p><h3 id="五-Gevent之同步与异步"><a href="#五-Gevent之同步与异步" class="headerlink" title="五 Gevent之同步与异步"></a>五 Gevent之同步与异步</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from gevent import spawn,joinall,monkey;monkey.patch_all()import timedef task(pid):    """    Some non-deterministic task    """    time.sleep(0.5)    print('Task %s done' % pid)def synchronous():    for i in range(10):        task(i)def asynchronous():    g_l=[spawn(task,i) for i in range(10)]    joinall(g_l)if __name__ == '__main__':    print('Synchronous:')    synchronous()    print('Asynchronous:')    asynchronous()#上面程序的重要部分是将task函数封装到Greenlet内部线程的gevent.spawn。 初始化的greenlet列表存放在数组threads中，此数组被传给gevent.joinall 函数，后者阻塞当前流程，并执行所有给定的greenlet。执行流程只会在 所有greenlet执行完后才会继续向下走。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="六-Gevent之应用举例一"><a href="#六-Gevent之应用举例一" class="headerlink" title="六 Gevent之应用举例一"></a>六 Gevent之应用举例一</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from gevent import monkey;monkey.patch_all()import geventimport requestsimport timedef get_page(url):    print('GET: %s' %url)    response=requests.get(url)    if response.status_code == 200:        print('%d bytes received from %s' %(len(response.text),url))start_time=time.time()gevent.joinall([    gevent.spawn(get_page,'https://www.python.org/'),    gevent.spawn(get_page,'https://www.yahoo.com/'),    gevent.spawn(get_page,'https://github.com/'),])stop_time=time.time()print('run time is %s' %(stop_time-start_time))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　将上面的程序最后加上一段串行的代码看看效率：如果你的程序不需要太高的效率，那就不用什么并发啊协程啊之类的东西。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></a></p><pre><code>print('--------------------------------')s = time.time()requests.get('https://www.python.org/')requests.get('https://www.yahoo.com/')requests.get('https://github.com/')t = time.time()print('串行时间&gt;&gt;',t-s)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="七-Gevent之应用举例二"><a href="#七-Gevent之应用举例二" class="headerlink" title="七 Gevent之应用举例二"></a>七 Gevent之应用举例二</h3><p>　　通过gevent实现单线程下的socket并发（from gevent import monkey;monkey.patch_all()一定要放到导入socket模块之前，否则gevent无法识别socket的阻塞）</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180927160003464-1907938692.png" alt="img"></p><p>　　一个网络请求里面经过多个时间延迟time</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from gevent import monkey;monkey.patch_all()from socket import *import gevent#如果不想用money.patch_all()打补丁,可以用gevent自带的socket# from gevent import socket# s=socket.socket()def server(server_ip,port):    s=socket(AF_INET,SOCK_STREAM)    s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)    s.bind((server_ip,port))    s.listen(5)    while True:        conn,addr=s.accept()        gevent.spawn(talk,conn,addr)def talk(conn,addr):    try:        while True:            res=conn.recv(1024)            print('client %s:%s msg: %s' %(addr[0],addr[1],res))            conn.send(res.upper())    except Exception as e:        print(e)    finally:        conn.close()if __name__ == '__main__':    server('127.0.0.1',8080)服务端</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *client=socket(AF_INET,SOCK_STREAM)client.connect(('127.0.0.1',8080))while True:    msg=input('&gt;&gt;: ').strip()    if not msg:continue    client.send(msg.encode('utf-8'))    msg=client.recv(1024)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Threadfrom socket import *import threadingdef client(server_ip,port):    c=socket(AF_INET,SOCK_STREAM) #套接字对象一定要加到函数内，即局部名称空间内，放在函数外则被所有线程共享，则大家公用一个套接字对象，那么客户端端口永远一样了    c.connect((server_ip,port))    count=0    while True:        c.send(('%s say hello %s' %(threading.current_thread().getName(),count)).encode('utf-8'))        msg=c.recv(1024)        print(msg.decode('utf-8'))        count+=1if __name__ == '__main__':    for i in range(500):        t=Thread(target=client,args=('127.0.0.1',8080))        t.start()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat工具、pymysql模块</title>
      <link href="2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Navicat%E5%B7%A5%E5%85%B7%E3%80%81pymysql%E6%A8%A1%E5%9D%97%20/"/>
      <url>2019/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Navicat%E5%B7%A5%E5%85%B7%E3%80%81pymysql%E6%A8%A1%E5%9D%97%20/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/10023248.html#_label1">一 IDE工具介绍</a></li><li><a href="https://www.cnblogs.com/clschao/articles/10023248.html#_label3">二 pymysql模块</a></li></ul><h1 id="一-IDE工具介绍-Navicat"><a href="#一-IDE工具介绍-Navicat" class="headerlink" title="一 IDE工具介绍(Navicat)"></a>一 IDE工具介绍(Navicat)</h1><p>　　生产环境还是推荐使用mysql命令行，但为了方便我们测试，可以使用IDE工具，我们使用Navicat工具，这个工具本质上就是一个socket客户端，可视化的连接mysql服务端的一个工具，并且他是图形界面版的。我们使用它和直接使用命令行的区别就类似linux和windows系统操作起来的一个区别。</p><p>​       <a href="https://pan.baidu.com/s/1bpo5mqj"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAePSURBVGiBxZpbbBTXGcd/58zser3rtbkGQVtCIiWgioS0ywY19CJFWVrKpYQQtUoUUgmbpk1BUau2D+1WlbZ9aC6URiZNSG3SSHloUzVKEEntNaYllzaUpRG5QEEyGDfmYhsw9t5n5vRhZl3bu+udtY3zf5s5t993zjcz3/nOCKUU06FQPCqBLwP3AHcBtwILnOKLwCngHaADOJyIxKzpGFdMxYBQPOoH7ga+CqwClgANgAcQ46orIA8MAmeBd4E2oDMRiaUmyzApA0Lx6I3Ao8CDwKLJDu6oF3gJ2JOIxLqrbVyVAaF4tB74KfB9wF/tYBWUApqBXyUisWtuG7k2IBSPbgCexnaT66mzwM5EJLbfTWXpplIoHv018BrXHx5njNecMStqwhUIxaMe4I/AvdOCVr1eAb6ZiMTy5SqUNSAUj+rAG9ivxU9SHcDaRCRmlCqcyIVe5pOHB5vh5XKFJQ1w/G/T9SKahDaVeyaKXCgUj34N23VmVKaykAiEGP/9G6O1iUjsr6NvjDEgFI/WAf9h6h8nVxJAXpmkjBwNnlqylkHOMqjTfeWa9AJLE5HYcOGGPq7Cz5kxeEHazOHTPPzytvtZPfcWBvMp9nb9jf29x5jtDZRqtgiIAj8Z6aewAqF4dBHQBdRcf3hImTl80sPe8DZWzr5pTHn0gz/z4tm3mFcTLNU8C9yciMR6YexD/BgzAi9seM3L78ONRfAAseVb2LrkiwzmU0URocP42Eh/SilC8agPOAfMv37oBfgsPs1Ly8pGPjf7xgnrP3zkOf51pYta6R1f1AcsTkRimcIK3M0MwddqXlrDleEB7plzB33JNJosWof52MwjLrTOLYipLAxlUk0QPhq+JdzIHbMqwwOkjDz9fcMMpfPoxUasA5BOyLDKTYfX8mk8UqNe95MysuQsA1HKS8fBJ80sfs1La7jJNXzeMnn+5GGk5qW7P8WVZJERq0LxqK4Dq6kQZSoUV3MpHl7yJbbd9BWCHh9HLnfxiw//wkB2mDrdhyqxJoWZD2heWsJNrJi12BW8YVls7niWxKUu/L46lKXoGUhiKj/z6rwYlsJhXq0Da4D6ieAvZ5PsvGUNP1i6duR+ZMFyFvvn8u0je7mSSxYZMQKv19CysonbZ33GFXzeMrm341kOdCXw1wZBKYQAhODjyylMy+KGeh+WpeoVrJHYG/DxH7QRXctn2DEOvqClwYXsu3M7s70BkkZ2xJ0KbhPQa2gNu4fPWSab4r/jwBkHfpQEoEnBhasZzl9NI6XQpRB3SWApxRtwAIaNDJEFy/lhCfiClgUXsu/OJhq8tSSNDFLY8EHdx75wE7c1VAP/DK+fOYbfV/IDBo4Rl65l6b2SFgq1VALzylXOWybrFq6oOPiy4CJaw03Ue/xcyg4R1H20hptYXiX8G2f+XTTzpaRLwcBwltMXhhZU3FIOGRlXEJ+t/xQt4UaWBRfSEm5kecOnXbXLmgYb2wvwZR/FIkkhMEwlxefbf9YLLCxVKWPmWRKYx5++sIOA7i7KUJTxxxLKWgbfaH+Gtu73JnSbcpJCXJbY4XPJ71Kt5uXU0AW2J1pJmTlXnbqFz5h5Nk4BHpv5hMRO95XcbyoUDR4//+g/zfajLaRdGlFJGdNgQ/se2rvfw+9z7zbjZAjBOxJoB8omkhSKOd463u4/zfajrWTMsgkCV8qYeTa0N9Nx7rgz85NObQ4JQZsE3sZOJpWVQjHXW8db/afYnpi8EWkzz/q2PXR0H5/KzAMg4FyD3/umdNIV71ZqUDDizb6TPJLYR7ZKI9JGnvVtzRzsOe68baaYFRfin+c2P54rvEYPuGljGxHk730n+e6xF8hZJR+dIqXNPOvbm+nsed+Z+amn9KXgdfh/ON2JvUmoqMJKHLp0gkcS+yoakTUN1rU109nzwbTBCxjwaPIgOAYkIrEM8ILbDmwjAhy69BHfm2AlDGVx38HnONTz/lQf2DESghcHHtiVgrF74t3YG2ZXUsBcbx0HL37Eo8f+QN4yx5QbymJz3IkqpxMecromdxWuRwxwdvlPV9OZbUSAgxc/5DuJVk4Mnidl5Dhx9QLr2prZf+aoq9imGglB85UHf/PfkevpSGzZ4XMGYelkhjXOpwbJGFn8nlqma+btcbhQW6Pf2vetp4YK98YEc07Ga1u1HSsUfq2GWq9E1mYBhU/3MZ3wAFKKxtHwUCK56+QeH5/UCEowx+/j5huCSAHWNJ2AAkghnrr20O6i1/1E5wOvMMkMtSYFyaxBd18SUynkxAnbipKC/UNbf7uxZNkE7e7HPlyoWqalCNToLJkfQBNiSishhegM+r33lS0vV+CEGF/HPuapWqal8E/RCCnEq3MC3rW9W56o/ohptJzDhR9XTcDk3MlOQognh7bu/lHFujNxzFqNEUJwThNi5+BDu19107erY1YA59x2BfYbqqpfAwrPxI0TuJMQpKUQTwZ9ntvdwsMM/2qgSUEqa9Ddn8K07ISVEJwXQrzk1eSegQd2na2WZcZ/9tCkGBxK58/2DKSOaJpsq/PpnR9veSI5WYYpGTBabn+3UUp1HFuz4zAsmJbfbf4HePY0woFjuIwAAAAASUVORK5CYII=" alt="YPSuperKey Checked">下载链接：https://pan.baidu.com/s/1bpo5mqj</a></p><p>　　Navicat的安装教程看这篇博客：<a href="https://www.cnblogs.com/clschao/articles/10022040.html">https://www.cnblogs.com/clschao/articles/10022040.html</a></p><p>　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>掌握：#1. 测试+链接数据库#2. 新建库#3. 新建表，新增字段+类型+约束#4. 设计表：外键#5. 新建查询#6. 备份库/表#注意：批量加注释：ctrl+？键批量去注释：ctrl+shift+？键</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="二-pymysql模块"><a href="#二-pymysql模块" class="headerlink" title="二 pymysql模块"></a>二 pymysql模块</h1><p>　　我们要学的pymysql就是用来在python程序中如何操作mysql，它和mysql自带的那个客户端还有navicat是一样的，本质上就是一个套接字客户端，只不过这个套接字客户端是在python程序中用的，既然是客户端套接字，应该怎么用，是不是要连接服务端，并且和服务端进行通信啊，让我们来学习一下pymysql这个模块</p><pre><code>#安装pip3 install pymysql</code></pre><p>　　<strong>一 链接、执行sql、关闭（游标）</strong></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170915114556719-2064840662.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>import pymysqluser=input('用户名: ').strip()pwd=input('密码: ').strip()#链接，指定ip地址和端口，本机上测试时ip地址可以写localhost或者自己的ip地址或者127.0.0.1，然后你操作数据库的时候的用户名，密码，要指定你操作的是哪个数据库，指定库名，还要指定字符集。不然会出现乱码conn=pymysql.connect(host='localhost',port=3306,user='root',password='123',database='student',charset='utf8') #指定编码为utf8的时候，注意没有-，别写utf-8，数据库为#得到conn这个连接对象#游标cursor=conn.cursor() #这就想到于mysql自带的那个客户端的游标mysql&gt; 在这后面输入指令，回车执行#cursor=conn.cursor(cursor=pymysql.cursors.DictCursor) #获取字典数据类型表示的结果：{'sid': 1, 'gender': '男', 'class_id': 1, 'sname': '理解'} {'字段名':值}#然后给游标输入sql语句并执行sql语句executesql='select * from userinfo where name="%s" and password="%s"' %(user,pwd) #注意%s需要加引号，执行这句sql的前提是医药有个userinfo表，里面有name和password两个字段，还有一些数据，自己添加数据昂print(sql)res=cursor.execute(sql) #执行sql语句，返回sql查询成功的记录数目，是个数字，是受sql语句影响到的记录行数，其实除了受影响的记录的条数之外，这些记录的数据也都返回了给游标,这个就相当于我们subprocess模块里面的管道PIPE，乘放着返回的数据#all_data=cursor.fetchall()  #获取返回的所有数据，注意凡是取数据，取过的数据就没有了，结果都是元祖格式的#many_data=cursor.fetchmany(3) #一下取出3条数据，#one_data=cursor.fetchone()  #按照数据的顺序，一次只拿一个数据，下次再去就从第二个取了，因为第一个被取出去了，取一次就没有了，结果也都是元祖格式的</code></pre><p>  fetchone：(1, ‘男’, 1, ‘理解’)<br>  fetchone：(2, ‘女’, 1, ‘钢蛋’)<br>  fetchall：((3, ‘男’, 1, ‘张三’), (4, ‘男’, 1, ‘张一’)）</p><pre><code>#上面fetch的结果都是元祖格式的，没法看出哪个数据是对应的哪个字段，这样是不是不太好看，想一想，我们可以通过python的哪一种数据类型，能把字段和对应的数据表示出来最清晰，当然是字典{'字段名':值}#我们可以再创建游标的时候，在cursor里面加上一个参数：cursor=conn.cursor(cursor=pymysql.cursors.DictCursor)获取的结果就是字典格式的，fetchall或者fetchmany取出的结果是列表套字典的数据形式上面我们说，我们的数据取一次是不是就没有了啊，实际上不是的，这个取数据的操作就像读取文件内容一样，每次read之后，光标就移动到了对应的位置，我们可以通过seek来移动光标同样，我们可以移动游标的位置，继续取我们前面的数据,通过cursor.scroll(数字，模式)，第一个参数就是一个int类型的数字，表示往后移动的记录条数，第二个参数为移动的模式，有两个值：absolute：绝对移动，relative：相对移动#绝对移动：它是相对于所有数据的起始位置开始往后面移动的#相对移动：他是相对于游标的当前位置开始往后移动的#绝对移动的演示#print(cursor.fetchall())#cursor.scroll(3,'absolute') #从初始位置往后移动三条，那么下次取出的数据为第四条数据#print(cursor.fetchone())#相对移动的演示#print(cursor.fetchone())#cursor.scroll(1,'relative') #通过上面取了一次数据，游标的位置在第二条的开头，我现在相对移动了1个记录，那么下次再取，取出的是第三条，我相对于上一条，往下移动了一条#print(cursor.fetchone())print(res) #一个数字cursor.close() #关闭游标conn.close()   #关闭连接if res:    print('登录成功')else:    print('登录失败')</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181126210300343-1625574888.png" alt="img"></strong></p><p>　　<strong>二 execute()之sql注入</strong></p><p>　　　　之前我们进行用户名密码认证是先将用户名和密码保存到一个文件中，然后通过读文件里面的内容，来和客户端发送过来的用户名密码进行匹配，现在我们学了数据库，我们可以将这些用户数据保存到数据库中，然后通过数据库里面的数据来对客户端进行用户名和密码的认证。</p><p>　　　　自行创建一个用户信息表userinfo，里面包含两个字段，username和password，然后里面写两条记录</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/988061-20181128152923749-1640903707.png" alt="img"></p><p>　　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>#我们来使用数据来进行一下用户名和密码的认证操作import pymysqlconn = pymysql.connect(    host='127.0.0.1',    port=3306,    user='root',    password='666',    database='crm',    charset='utf8')cursor = conn.cursor(pymysql.cursors.DictCursor)uname = input('请输入用户名：')pword = input('请输入密码：')sql = "select * from userinfo where username='%s' and password='%s';"%(uname,pword)res = cursor.execute(sql) #res我们说是得到的行数，如果这个行数不为零，说明用户输入的用户名和密码存在，如果为0说名存在，你想想对不print(res) #如果输入的用户名和密码错误，这个结果为0，如果正确，这个结果为1if res:    print('登陆成功')else:    print('用户名和密码错误！')#通过上面的验证方式，比我们使用文件来保存用户名和密码信息的来进行验证操作要方便很多。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　</p><p>　　　　但是我们来看下面的操作，如果将在输入用户名的地方输入一个 chao’空格然后–空格然后加上任意的字符串，就能够登陆成功，也就是只知道用户名的情况下，他就能登陆成功的情况：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>uname = input('请输入用户名：')pword = input('请输入密码：')sql = "select * from userinfo where username='%s' and password='%s';"%(uname,pword)print(sql)res = cursor.execute(sql) #res我们说是得到的行数，如果这个行数不为零，说明用户输入的用户名和密码存在，如果为0说名存在，你想想对不print(res) #如果输入的用户名和密码错误，这个结果为0，如果正确，这个结果为1if res:    print('登陆成功')else:    print('用户名和密码错误！')#运行看结果：居然登陆成功请输入用户名：chao' -- xxx请输入密码：select * from userinfo where username='chao' -- xxx' and password='';1登陆成功我们来分析一下：此时uname这个变量等于什么，等于chao' -- xxx,然后我们来看我们的sql语句被这个字符串替换之后是个什么样子：select * from userinfo where username='chao' -- xxx' and password=''; 其中chao后面的这个'，在进行字符串替换的时候，我们输入的是chao',这个引号和前面的引号组成了一对，然后后面--在sql语句里面是注释的意思，也就是说--后面的sql语句被注释掉了。也就是说，拿到的sql语句是select * from userinfo where username='chao';然后就去自己的数据库里面去执行了，发现能够找到对应的记录，因为有用户名为chao的记录，然后他就登陆成功了，但是其实他连密码都不知道，只知道个用户名。。。，他完美的跳过了你的认证环节。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　然后我们再来看一个例子，直接连用户名和密码都不知道，但是依然能够登陆成功的情况：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>请输入用户名：xxx' or 1=1 -- xxxxxx请输入密码：select * from userinfo where username='xxx' or 1=1 -- xxxxxx' and password='';3登陆成功我们只输入了一个xxx' 加or 加 1=1 加 -- 加任意字符串看上面被执行的sql语句你就发现了，or 后面跟了一个永远为真的条件，那么即便是username对不上，但是or后面的条件是成立的，也能够登陆成功。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　上面两个例子就是两个sql注入的问题，看完上面这两个例子，有没有感觉后背发凉啊同志们，别急，我们来解决一下这个问题，怎么解决呢？</p><p>　　　　　　有些网站直接在你输入内容的时候，是不是就给你限定了，你不能输入一些特殊的符号，因为有些特殊符号可以改变sql的执行逻辑，其实不光是–，还有一些其他的符号也能改变sql语句的执行逻辑，这个方案我们是在客户端给用户输入的地方进行限制，但是别人可不可以模拟你的客户端来发送请求，是可以的，他模拟一个客户端，不按照你的客户端的要求来，就发一些特殊字符，你的客户端是限制不了的。所以单纯的在客户端进行这个特殊字符的过滤是不能解决根本问题的，那怎么办？我们服务端也需要进行验证，可以通过正则来将客户端发送过来的内容进行特殊字符的匹配，如果有这些特殊字符，我们就让它登陆失败。</p><p>　　　　在服务端来解决sql注入的问题：不要自己来进行sql字符串的拼接了，pymysql能帮我们拼接，他能够防止sql注入，所以以后我们再写sql语句的时候按下面的方式写：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><pre><code>之前我们的sql语句是这样写的：sql = "select * from userinfo where username='%s' and password='%s';"%(uname,pword)以后再写的时候，sql语句里面的%s左右的引号去掉，并且语句后面的%(uname,pword)这些内容也不要自己写了，按照下面的方式写sql = "select * from userinfo where username=%s and password=%s;"难道我们不传值了吗，不是的，我们通过下面的形式，在excute里面写参数：#cursor.execute(sql,[uname,pword]) ，其实它本质也是帮你进行了字符串的替换，只不过它会将uname和pword里面的特殊字符给过滤掉。看下面的例子：uname = input('请输入用户名：') #输入的内容是：chao' -- xxx或者xxx' or 1=1 -- xxxxxpword = input('请输入密码：')sql = "select * from userinfo where username=%s and password=%s;"print(sql)res = cursor.execute(sql,[uname,pword]) #res我们说是得到的行数，如果这个行数不为零，说明用户输入的用户名和密码存在，如果为0说名存在，你想想对不print(res) #如果输入的用户名和密码错误，这个结果为0，如果正确，这个结果为1if res:    print('登陆成功')else:    print('用户名和密码错误！')#看结果：请输入用户名：xxx' or 1=1 -- xxxxx请输入密码：select * from userinfo where username=%s and password=%s;0用户名和密码错误！</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　通过pymysql提供的excute完美的解决了问题。</p><pre><code>总结咱们刚才说的两种sql注入的语句#1、sql注入之：用户存在，绕过密码chao' -- 任意字符#2、sql注入之：用户不存在，绕过用户与密码xxx' or 1=1 -- 任意字符</code></pre><p>　　　　解决方法总结：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code># 原来是我们对sql进行字符串拼接# sql="select * from userinfo where name='%s' and password='%s'" %(user,pwd)# print(sql)# res=cursor.execute(sql)#改写为（execute帮我们做字符串拼接，我们无需且一定不能再为%s加引号了）sql="select * from userinfo where name=%s and password=%s" #！！！注意%s需要去掉引号，因为pymysql会自动为我们加上res=cursor.execute(sql,[user,pwd]) #pymysql模块自动帮我们解决sql注入的问题，只要我们按照pymysql的规矩来。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>三 增、删、改：conn.commit()</strong></p><p>　　　　查操作在上面已经说完了，我们来看一下增删改，也要注意，sql语句不要自己拼接，交给excute来拼接</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>import pymysql#链接conn=pymysql.connect(host='localhost',port='3306',user='root',password='123',database='crm',charset='utf8')#游标cursor=conn.cursor()#执行sql语句#part1# sql='insert into userinfo(name,password) values("root","123456");'# res=cursor.execute(sql) #执行sql语句，返回sql影响成功的行数# print(res)# print(cursor.lastrowid) #返回的是你插入的这条记录是到了第几条了#part2# sql='insert into userinfo(name,password) values(%s,%s);'# res=cursor.execute(sql,("root","123456")) #执行sql语句，返回sql影响成功的行数# print(res)#还可以进行更改操作：#res=cursor.excute("update userinfo set username='taibaisb' where id=2")#print(res) #结果为1#part3sql='insert into userinfo(name,password) values(%s,%s);'res=cursor.executemany(sql,[("root","123456"),("lhf","12356"),("eee","156")]) #执行sql语句，返回sql影响成功的行数，一次插多条记录print(res)#上面的几步，虽然都有返回结果，也就是那个受影响的函数res，但是你去数据库里面一看，并没有保存到数据库里面，conn.commit() #必须执行conn.commit,注意是conn，不是cursor，执行这句提交后才发现表中插入记录成功，没有这句，上面的这几步操作其实都没有成功保存。cursor.close()conn.close()</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>四 查：fetchone，fetchmany，fetchall</strong></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/1036857-20170914075702438-239735784.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>import pymysql#链接conn=pymysql.connect(host='localhost',user='root',password='123',database='egon')#游标cursor=conn.cursor()#执行sql语句sql='select * from userinfo;'rows=cursor.execute(sql) #执行sql语句，返回sql影响成功的行数rows,将结果放入一个集合，等待被查询# cursor.scroll(3,mode='absolute') # 相对绝对位置移动# cursor.scroll(3,mode='relative') # 相对当前位置移动res1=cursor.fetchone()res2=cursor.fetchone()res3=cursor.fetchone()res4=cursor.fetchmany(2)res5=cursor.fetchall()print(res1)print(res2)print(res3)print(res4)print(res5)print('%s rows in set (0.00 sec)' %rows)conn.commit() #提交后才发现表中插入记录成功cursor.close()conn.close()'''(1, 'root', '123456')(2, 'root', '123456')(3, 'root', '123456')((4, 'root', '123456'), (5, 'root', '123456'))((6, 'root', '123456'), (7, 'lhf', '12356'), (8, 'eee', '156'))rows in set (0.00 sec)'''</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>五 获取插入的最后一条数据的自增ID</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/ExpandedBlockStart.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><pre><code>import pymysqlconn=pymysql.connect(host='localhost',user='root',password='123',database='egon')cursor=conn.cursor()sql='insert into userinfo(name,password) values("xxx","123");'rows=cursor.execute(sql)print(cursor.lastrowid) #在插入语句后查看conn.commit()cursor.close()conn.close()</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/sjk/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之线程</title>
      <link href="2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Python%E4%B9%8B%E7%BA%BF%E7%A8%8B/"/>
      <url>2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Python%E4%B9%8B%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>线程</p><p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_1">一 背景知识</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_2">二 线程与进程的关系</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_3">三 线程的特点</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_4">四 线程的实际应用场景</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_5">五 内存中的线程</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_6">六 用户级线程和内核级线程（了解）</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_7">七 python与线程</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_8">八 Threading模块</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_9">九 锁</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_10">十 信号量</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_11">十一 事件Event</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_12">十二 条件Condition（了解）</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_13">十三 定时器(了解)</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_14">十四 线程队列</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9684694.html#part_15">十五 Python标准模块–concurrent.futures</a></li><li></li></ul><h3 id="一-背景知识"><a href="#一-背景知识" class="headerlink" title="一 背景知识"></a>一 背景知识</h3><p>　　1.进程</p><p>　　　　之前我们已经了解了操作系统中进程的概念，程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p><p>　　2.有了进程为什么还要线程</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#什么是线程：#指的是一条流水线的工作过程，关键的一句话：一个进程内最少自带一个线程，其实进程根本不能执行，进程不是执行单位，是资源的单位，分配资源的单位#线程才是执行单位#进程：做手机屏幕的工作过程,刚才讲的#我们的py文件在执行的时候，如果你站在资源单位的角度来看，我们称为一个主进程，如果站在代码执行的角度来看，它叫做主线程，只是一种形象的说法，其实整个代码的执行过程成为线程，也就是干这个活儿的本身称为线程，但是我们后面学习的时候，我们就称为线程去执行某个任务，其实那某个任务的执行过程称为一个线程，一条流水线的执行过程为线程#进程vs线程#1 同一个进程内的多个线程是共享该进程的资源的，不同进程内的线程资源肯定是隔离的#2 创建线程的开销比创建进程的开销要小的多#并发三个任务：1启动三个进程：因为每个进程中有一个线程，但是我一个进程中开启三个线程就够了#同一个程序中的三个任务需要执行，你是用三个进程好 ，还是三个线程好？#例子：    # pycharm 三个任务：键盘输入  屏幕输出  自动保存到硬盘    #如果三个任务是同步的话，你键盘输入的时候，屏幕看不到    #咱们的pycharm是不是一边输入你边看啊，就是将串行变为了三个并发的任务    #解决方案：三个进程或者三个线程，哪个方案可行。如果是三个进程，进程的资源是不是隔离的并且开销大，最致命的就是资源隔离，但是用户输入的数据还要给另外一个进程发送过去，进程之间能直接给数据吗？你是不是copy一份给他或者通信啊，但是数据是同一份，我们有必要搞多个进程吗，线程是不是共享资源的，我们是不是可以使用多线程来搞，你线程1输入的数据，线程2能不能看到，你以后的场景还是应用多线程多，而且起线程我们说是不是很快啊，占用资源也小，还能共享同一个进程的资源，不需要将数据来回的copy！</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p><ul><li><ul><li>　　进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li><li>　　进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li></ul></li></ul><p>　　　　如果这两个缺点理解比较困难的话，举个现实的例子也许你就清楚了：如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二。</p><p>　　　　现在你应该明白了进程的缺陷了，而解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。而实际的操作系统中，也同样引入了这种类似的机制——线程。</p><p>　　3.线程的出现</p><p>　　　　60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入<strong>轻型进程</strong>；二是由于对称多处理机（SMP）出现，<strong>可以满足多个运行单位</strong>，而多个进程并行开销过大。</p><p>　　　　　　因此在80年代，出现了<strong>能独立运行的基本单位</strong>——线程（Threads）<strong>。</strong></p><p>　　　　　　<strong>注意：进程是资源分配的最小单位,线程是CPU调度的最小单位.</strong></p><p>　　　　　　　<strong>每一个进程中至少有一个线程。</strong>　</p><p> 　　　　</p><p>　　　　在传统操作系统中，每个进程有一个地址空间，而且默认就有一个控制线程</p><p>　　　　线程顾名思义，就是一条流水线工作的过程，一条流水线必须属于一个车间，一个车间的工作过程是一个进程</p><p>　　　　车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一个流水线</p><p>　　　　流水线的工作需要电源，电源就相当于cpu</p><p>　　　　所以，<strong>进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程才是cpu上的执行单位。</strong></p><p>　　　　多线程（即多个控制线程）的概念是，在一个进程中存在多个控制线程，多个控制线程共享该进程的地址空间，相当于一个车间内有多条流水线，都共用一个车间的资源。</p><p>　　　　例如，北京地铁与上海地铁是不同的进程，而北京地铁里的13号线是一个线程，北京地铁所有的线路共享北京地铁所有的资源，比如所有的乘客可以被所有线路拉。</p><h3 id="二-进程和线程的关系"><a href="#二-进程和线程的关系" class="headerlink" title="二 进程和线程的关系"></a>二 进程和线程的关系</h3><p>　　　　<strong><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/827651-20180118212223115-85632065.png" alt="img"></strong></p><p>　　　　<strong>线程与进程的区别</strong>可以归纳为以下4点：</p><p>　　　　　　1）地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p><p>　　　　　　2）通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。（就类似进程中的锁的作用）</p><p>　　　　　　3）调度和切换：线程上下文切换比进程上下文切换要快得多。</p><p>　　　　　　4）在多线程操作系统中（现在咱们用的系统基本都是多线程的操作系统），进程不是一个可执行的实体，真正去执行程序的不是进程，是线程，你可以理解进程就是一个线程的容器。</p><h3 id="三-线程的特点"><a href="#三-线程的特点" class="headerlink" title="三 线程的特点"></a>三 线程的特点</h3><p>　　先简单了解一下线程有哪些特点，里面的堆栈啊主存区啊什么的后面会讲，大家先大概了解一下就好啦。</p><p>　　在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</p><p>　　　　1）轻型实体</p><p>　　　　　　线程中的实体基本上不拥有系统资源，只是有一些必不可少的、能保证独立运行的资源。</p><p>　　　　　　线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>TCB包括以下信息：（1）线程状态。（2）当线程不运行时，被保存的现场资源。（3）一组执行堆栈。（4）存放每个线程的局部变量主存区。（5）访问同一个进程中的主存和其它资源。用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　</p><p>　　2）独立调度和分派的基本单位。</p><p>　　　　在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</p><p>　　3）共享进程资源。</p><p>　　　　线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p><p>　　4）可并发执行。</p><p>　　　　在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</p><p>　　</p><h3 id="四-线程的实际应用场景"><a href="#四-线程的实际应用场景" class="headerlink" title="四 线程的实际应用场景"></a>四 线程的实际应用场景</h3><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/827651-20180118213009115-1272261459.png" alt="img"></p><p>　　开启一个字处理软件进程，该进程肯定需要办不止一件事情，比如监听键盘输入，处理文字，定时自动将文字保存到硬盘，这三个任务操作的都是同一块数据，因而不能用多进程。只能在一个进程里并发地开启三个线程,如果是单线程，那就只能是，键盘输入时，不能处理文字和自动保存，自动保存时又不能输入和处理文字。</p><p>之前我们将的socket是不是通过多进程去实现过呀，如果有500个人同时和我聊天，那我是不是要起500进程啊，能行吗？不好，对不对，那么怎么办，我就可以开几个进程，然后每个进程里面开多个线程来处理多个请求和通信。再举例：我用qq是一个进程，然后我和一个人聊天的时候，是不是还可以去接收别人给我发的消息啊，这个是不是并行的啊，就类似我一个进程开了多个线程来帮我并发接收消息。</p><h3 id="五-内存中的线程"><a href="#五-内存中的线程" class="headerlink" title="五 内存中的线程"></a>五 内存中的线程</h3><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/827651-20180118213709271-527249129.png" alt="img"></p><p>　　　　多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程。</p><p>　　　　而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。</p><p>　　　　不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。</p><p>　　　　类似于进程，每个线程也有自己的堆栈，不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。</p><p>　　　　线程通常是有益的，但是带来了不小程序设计难度，线程的问题是：</p><p>　　　　　　1. 父进程有多个线程，那么开启的子线程是否需要同样多的线程</p><p>　　　　　　2. 在同一个进程中，如果一个线程关闭了文件，而另外一个线程正准备往该文件内写内容呢？</p><p>　　　　因此，在多线程的代码中，需要更多的心思来设计程序的逻辑、保护程序的数据。</p><h3 id="六-用户级线程和内核级线程（了解）"><a href="#六-用户级线程和内核级线程（了解）" class="headerlink" title="六 用户级线程和内核级线程（了解）"></a>六 用户级线程和内核级线程（了解）</h3><p>线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。 </p><p>1.用户级线程</p><p>　　　　内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/827651-20180121020547006-752791661.png" alt="img"></p><p>　　　　在用户空间模拟操作系统对进程的调度，来调用一个进程中的线程，每个进程中都会有一个运行时系统，用来调度线程。此时当该进程获取cpu时，进程内再调度出一个线程去执行，同一时刻只有一个线程执行。</p><p>2.内核级线程</p><p> 　　　　内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/827651-20180121020859803-1526586154.png" alt="img"></p><p>3.用户级和内核级线程的对比</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>1 内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。2 用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。3 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。4 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。5 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　内核级线程的优缺点：</p><pre><code>优点：当有多个处理机时，一个进程的多个线程可以同时执行。缺点：由内核进行调度。</code></pre><p> 用户级线程的优缺点：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>优点：　　线程的调度不需要内核直接参与，控制简单。　　可以在不支持线程的操作系统中实现。　　创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。　　允许每个进程定制自己的调度算法，线程管理比较灵活。　　线程能够利用的表空间和堆栈空间比内核级线程多。　　同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。缺点：　　资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 3.混合实现</p><p>　　　　用户级与内核级的多路复用，内核同一调度内核线程，每个内核线程对应n个用户线程，用户和内核都能感知到的线程，用户创建一个线程，那么操作系统内核也跟着创建一个线程来专门执行你用户的这个线程。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/827651-20180121021033553-698190505.png" alt="img"></p><p>　　　　在linux操作系统上也实现了这种混合的方式NPTL，看下面的介绍。</p><p> 4.linux操作系统的NPTL</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>历史在内核2.6以前的调度实体都是进程，内核并没有真正支持线程。它是能过一个系统调用clone()来实现的，这个调用创建了一份调用进程的拷贝，跟fork()不同的是,这份进程拷贝完全共享了调用进程的地址空间。LinuxThread就是通过这个系统调用来提供线程在内核级的支持的(许多以前的线程实现都完全是在用户态，内核根本不知道线程的存在)。非常不幸的是，这种方法有相当多的地方没有遵循POSIX标准，特别是在信号处理，调度，进程间通信原语等方面。很显然，为了改进LinuxThread必须得到内核的支持，并且需要重写线程库。为了实现这个需求，开始有两个相互竞争的项目：IBM启动的NGTP(Next Generation POSIX Threads)项目，以及Redhat公司的NPTL。在2003年的年中，IBM放弃了NGTP，也就是大约那时，Redhat发布了最初的NPTL。NPTL最开始在redhat linux 9里发布，现在从RHEL3起内核2.6起都支持NPTL，并且完全成了GNU C库的一部分。设计NPTL使用了跟LinuxThread相同的办法，在内核里面线程仍然被当作是一个进程，并且仍然使用了clone()系统调用(在NPTL库里调用)。但是，NPTL需要内核级的特殊支持来实现，比如需要挂起然后再唤醒线程的线程同步原语futex.NPTL也是一个1*1的线程库，就是说，当你使用pthread_create()调用创建一个线程后，在内核里就相应创建了一个调度实体，在linux里就是一个新进程，这个方法最大可能的简化了线程的实现。除NPTL的1*1模型外还有一个m*n模型，通常这种模型的用户线程数会比内核的调度实体多。在这种实现里，线程库本身必须去处理可能存在的调度，这样在线程库内部的上下文切换通常都会相当的快，因为它避免了系统调用转到内核态。然而这种模型增加了线程实现的复杂性,并可能出现诸如优先级反转的问题，此外，用户态的调度如何跟内核态的调度进行协调也是很难让人满意。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="七-python与线程"><a href="#七-python与线程" class="headerlink" title="七 python与线程"></a>七 python与线程</h3><p>1.全局解释器锁GIL（用一下threading模块之后再来看~~）</p><p>　　　　Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行。虽然 Python 解释器中可以“运行”多个线程，但在任意时刻只有一个线程在解释器中运行。<br>　　　　　　对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p><p>　　　　　　在多线程环境中，Python 虚拟机按以下方式执行：</p><p>　　　　　　　　a、设置 GIL；</p><p>　　　　　　　　b、切换到一个线程去运行；</p><p>　　　　　　　　c、运行指定数量的字节码指令或者线程主动让出控制(可以调用 time.sleep(0))；</p><p>　　　　　　　　d、把线程设置为睡眠状态；</p><p>　　　　　　　　e、解锁 GIL；</p><p>　　　　　　　　d、再次重复以上所有步骤。<br>　　　　　　在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，直到这个函数结束为止(由于在这期间没有Python的字节码被运行，所以不会做线程切换)编写扩展的程序员可以主动解锁GIL。</p><p>2.python线程模块的选择</p><p>　　　　Python提供了几个用于多线程编程的模块，包括thread、threading和Queue等。thread和threading模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，threading提供了更高级别、功能更强的线程管理的功能。Queue模块允许用户创建一个可以用于多个线程之间共享数据的队列数据结构。<br>　　　　避免使用thread模块，因为更高级别的threading模块更为先进，对线程的支持更为完善，而且使用thread模块里的属性有可能会与threading出现冲突；其次低级别的thread模块的同步原语很少(实际上只有一个)，而threading模块则有很多；再者，thread模块中当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作，至少threading模块能确保重要的子线程退出后进程才退出。 </p><p>　　　　就像我们熟悉的time模块，它比其他模块更加接近底层，越是接近底层，用起来越麻烦，就像时间日期转换之类的就比较麻烦，但是后面我们会学到一个datetime模块，提供了更为简便的时间日期处理方法，它是建立在time模块的基础上来的。又如socket和socketserver（底层还是用的socket）等等，这里的threading就是thread的高级模块。</p><p>　　　　thread模块不支持守护线程，当主线程退出时，所有的子线程不论它们是否还在工作，都会被强行退出。而threading模块支持守护线程，守护线程一般是一个等待客户请求的服务器，如果没有客户提出请求它就在那等着，如果设定一个线程为守护线程，就表示这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。</p><h3 id="八-Threading模块"><a href="#八-Threading模块" class="headerlink" title="八 Threading模块"></a>八 Threading模块</h3><p>multiprocess模块的完全模仿了threading模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍（<a href="https://docs.python.org/3/library/threading.html?highlight=threading#">官方链接</a>）</p><p>我们先简单应用一下threading模块来看看并发效果：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timefrom threading import Thread#多线程并发，是不是看着和多进程很类似def func(n):    time.sleep(1)    print(n)#并发效果，1秒打印出了所有的数字for i in range(10):    t = Thread(target=func,args=(i,))    t.start()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　1.线程创建</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Threadimport timedef sayhi(name):    time.sleep(2)    print('%s say hello' %name)if __name__ == '__main__':    t=Thread(target=sayhi,args=('太白',))    t.start()    print('主线程')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timefrom threading import Threadclass Sayhi(Thread):    def __init__(self,name):        super().__init__()        self.name=name    def run(self):        time.sleep(2)        print('%s say hello' % self.name)if __name__ == '__main__':    t = Sayhi('太白')    t.start()    print('主线程')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2.多线程与多进程</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Threadfrom multiprocessing import Processimport osdef work():    print('hello',os.getpid())if __name__ == '__main__':    #part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样    t1=Thread(target=work)    t2=Thread(target=work)    t1.start()    t2.start()    print('主线程/主进程pid',os.getpid())    #part2:开多个进程,每个进程都有不同的pid    p1=Process(target=work)    p2=Process(target=work)    p1.start()    p2.start()    print('主线程/主进程pid',os.getpid())</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>那么哪些东西存在进程里，那些东西存在线程里呢？</p><p>进程：导入的模块、执行的python文件的文件所在位置、内置的函数、文件里面的这些代码、全局变量等等，然后线程里面有自己的堆栈（类似于一个列表，后进先出）和寄存器，里面存着自己线程的变量，操作（add）等等，占用的空间很小。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180925190121411-724368505.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Threadfrom multiprocessing import Processimport osimport timedef work():    print('hello')if __name__ == '__main__':    s1 = time.time()    #在主进程下开启线程    t=Thread(target=work)    t.start()    t.join()    t1 = time.time() - s1    print('进程的执行时间：',t1)    print('主线程/主进程')    '''    打印结果:    hello    进程的执行时间： 0.0    主线程/主进程    '''    s2 = time.time()    #在主进程下开启子进程    t=Process(target=work)    t.start()    t.join()    t2 = time.time() - s2    print('线程的执行时间：', t2)    print('主线程/主进程')    '''    打印结果:    hello    线程的执行时间： 0.5216977596282959    主线程/主进程    '''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from  threading import Threadfrom multiprocessing import Processimport osdef work():    global n  #修改全局变量的值    n=0if __name__ == '__main__':    # n=100    # p=Process(target=work)    # p.start()    # p.join()    # print('主',n) #毫无疑问子进程p已经将自己的全局的n改成了0,但改的仅仅是它自己的,查看父进程的n仍然为100    n=1    t=Thread(target=work)    t.start()    t.join()   #必须加join，因为主线程和子线程不一定谁快，一般都是主线程快一些，所有我们要等子线程执行完毕才能看出效果    print('主',n) #查看结果为0,因为同一进程内的线程之间共享进程内的数据# 通过一个global就实现了全局变量的使用，不需要进程的IPC通信方法</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　在这里我们简单总结一下：</p><p>　　　　进程是最小的内存分配单位</p><p>　　　　线程是操作系统调度的最小党委</p><p>　　　　线程被CPU执行了</p><p>　　　　进程内至少含有一个线程</p><p>　　　　进程中可以开启多个线程　</p><p>　　　　　　开启一个线程所需要的时间要远小于开启一个进程</p><p>　　　　　　多个线程内部有自己的数据栈，数据不共享</p><p>　　　　　　全局变量在多个线程之间是共享的</p><p>　　3.多线程实现socket（练习）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import multiprocessingimport threadingimport sockets=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.bind(('127.0.0.1',8080))s.listen(5)def action(conn):    while True:        data=conn.recv(1024)        print(data)        msg = input('服务端输入:') #在多线程里面可以使用input输入内容，那么就可以实现客户端和服务端的聊天了，多进程不能输入        conn.send(bytes(msg,encoding='utf-8'))if __name__ == '__main__':    while True:        conn,addr=s.accept()        p=threading.Thread(target=action,args=(conn,))        p.start()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　讲一讲代码</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>mport sockets=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect(('127.0.0.1',8080))while True:    msg=input('&gt;&gt;: ').strip()    if not msg:continue    s.send(msg.encode('utf-8'))    data=s.recv(1024)    print(data)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　在socket通信里面是不是有大量的I/O啊，recv、accept等等，我们使用多线程效率更高，因为开销小。</p><p>　　4.Thread类的其他方法</p><p>　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>Thread实例对象的方法  # isAlive(): 返回线程是否活动的。  # getName(): 返回线程名。  # setName(): 设置线程名。threading模块提供的一些方法：  # threading.currentThread(): 返回当前的线程变量。  # threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。  # threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Threadimport threadingfrom multiprocessing import Processimport osdef work():    import time    time.sleep(3)    print(threading.current_thread().getName())if __name__ == '__main__':    #在主进程下开启线程    t=Thread(target=work)    t.start()    print(threading.current_thread())#主线程对象    print(threading.current_thread().getName()) #主线程名称    print(threading.current_thread().ident) #主线程ID    print(threading.get_ident()) #主线程ID    print(threading.enumerate()) #连同主线程在内有两个运行的线程    print(threading.active_count())    print('主线程/主进程')    '''    打印结果:    &lt;_MainThread(MainThread, started 14104)&gt;    MainThread    14104    14104    [&lt;_MainThread(MainThread, started 14104)&gt;, &lt;Thread(Thread-1, started 17976)&gt;]    2    主线程/主进程    Thread-1    '''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Threadimport timedef sayhi(name):    time.sleep(2)    print('%s say hello' %name)if __name__ == '__main__':    t=Thread(target=sayhi,args=('太白',))    t2=Thread(target=sayhi,args=('alex',))    t.start()    t2.start()    t.join()  #因为这个线程用了join方法，主线程等待子线程的运行结束    print('主线程')    print(t.is_alive())  #所以t这个线程肯定是执行结束了，结果为False    print(t2.is_alive()) #有可能是True，有可能是False，看子线程和主线程谁执行的快    '''    egon say hello    主线程    False    '''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　5.守护线程</p><p>　　<strong>无论是进程还是线程，都遵循：守护xx会等待主xx运行完毕后被销毁。**</strong>需要强调的是：运行完毕并非终止运行**</p><pre><code>#1.对主进程来说，运行完毕指的是主进程代码运行完毕#2.对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕</code></pre><p>　　详细解释</p><pre><code>#1 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，#2 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束，因为进程执行结束是要回收资源的，所有必须确保你里面的非守护子线程全部执行完毕。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Threadimport timedef sayhi(name):    time.sleep(2)    print('%s say hello' %name)if __name__ == '__main__':    t=Thread(target=sayhi,args=('taibai',))    t.setDaemon(True) #必须在t.start()之前设置    t.start()    print('主线程')    print(t.is_alive())    '''    主线程    True    '''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Threadfrom multiprocessing import Processimport timedef func1():    while True:        print(666)        time.sleep(0.5)def func2():    print('hello')    time.sleep(3)if __name__ == '__main__':    # t = Thread(target=func1,)    # t.daemon = True  #主线程结束，守护线程随之结束    # # t.setDaemon(True) #两种方式，和上面设置守护线程是一样的    # t.start()    # t2 = Thread(target=func2,) #这个子线程要执行3秒，主线程的代码虽然执行完了，但是一直等着子线程的任务执行完毕，主线程才算完毕，因为通过结果你会发现我主线程虽然代码执行完毕了，\    # 但是主线程的的守护线程t1还在执行，说明什么，说明我的主线程还没有完毕，只不过是代码执行完了，一直等着子线程t2执行完毕，我主线程的守护线程才停止，说明子线程执行完毕之后，我的主线程才执行完毕    # t2.start()    # print('主线程代码执行完啦！')    p = Process(target=func1,)    p.daemon = True    p.start()    p2 = Process(target=func2,)    p2.start()    time.sleep(1) #让主进程等1秒，为了能看到func1的打印效果    print('主进程代码执行完啦！') #通过结果你会发现，如果主进程的代码运行完毕了，那么主进程就结束了，因为主进程的守护进程p随着主进程的代码结束而结束了，守护进程被回收了，这和线程是不一样的，主线程的代码完了并不代表主线程运行完毕了，需要等着所有其他的非守护的子线程执行完毕才算完毕</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>今天的内容就到这里啦，同学们整理整理前面的内容吧<del>~</del> </p><h3 id="九-锁"><a href="#九-锁" class="headerlink" title="九 锁"></a>九 锁</h3><p>1.GIL锁（Global Interpreter Lock）</p><p>　　首先，一些语言（java、c++、c）是支持同一个进程中的多个线程是可以应用多核CPU的，也就是我们会听到的现在4核8核这种多核CPU技术的牛逼之处。那么我们之前说过应用多进程的时候如果有共享数据是不是会出现数据不安全的问题啊，就是多个进程同时一个文件中去抢这个数据，大家都把这个数据改了，但是还没来得及去更新到原来的文件中，就被其他进程也计算了，导致数据不安全的问题啊，所以我们是不是通过加锁可以解决啊，多线程大家想一下是不是一样的，并发执行就是有这个问题。但是python最早期的时候对于多线程也加锁，但是python比较极端的（在当时电脑cpu确实只有1核）加了一个GIL全局解释锁，是解释器级别的，锁的是整个线程，而不是线程里面的某些数据操作，每次只能有一个线程使用cpu，也就说多线程用不了多核，但是他不是python语言的问题，是CPython解释器的特性，如果用Jpython解释器是没有这个问题的，Cpython是默认的，因为速度快，Jpython是java开发的，在Cpython里面就是没办法用多核，这是python的弊病，历史问题，虽然众多python团队的大神在致力于改变这个情况，但是暂没有解决。（这和解释型语言（python，php）和编译型语言有关系吗？？？待定！，编译型语言一般在编译的过程中就帮你分配好了，解释型要边解释边执行，所以为了防止出现数据不安全的情况加上了这个锁，这是所有解释型语言的弊端？？）</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180926110737618-1763911053.png" alt="img"></p><p>　　　　但是有了这个锁我们就不能并发了吗？当我们的程序是偏计算的，也就是cpu占用率很高的程序（cpu一直在计算），就不行了，但是如果你的程序是I/O型的（一般你的程序都是这个）（input、访问网址网络延迟、打开/关闭文件读写），在什么情况下用的到高并发呢（金融计算会用到，人工智能（阿尔法狗），但是一般的业务场景用不到，爬网页，多用户网站、聊天软件、处理文件），I/O型的操作很少占用CPU，那么多线程还是可以并发的，因为cpu只是快速的调度线程，而线程里面并没有什么计算，就像一堆的网络请求，我cpu非常快速的一个一个的将你的多线程调度出去，你的线程就去执行I/O操作了，</p><p>　　详细的GIL锁介绍：<a href="https://www.cnblogs.com/clschao/articles/9705317.html">链接：https://www.cnblogs.com/clschao/articles/9705317.html</a></p><p>2.同步锁</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>三个需要注意的点：#1.线程抢的是GIL锁，GIL锁相当于执行权限，拿到执行权限后才能拿到互斥锁Lock，其他线程也可以抢到GIL，但如果发现Lock仍然没有被释放则阻塞，即便是拿到执行权限GIL也要立刻交出来#2.join是等待所有，即整体串行，而锁只是锁住修改共享数据的部分，即部分串行，要想保证数据安全的根本原理在于让并发变成串行，join与互斥锁都可以实现，毫无疑问，互斥锁的部分串行效率要更高#3. 一定要看本小节最后的GIL与互斥锁的经典分析</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>GIL VS Lock    机智的同学可能会问到这个问题，就是既然你之前说过了，Python已经有一个GIL来保证同一时间只能有一个线程来执行了，为什么这里还需要lock? 　首先我们需要达成共识：锁的目的是为了保护共享的数据，同一时间只能有一个线程来修改共享的数据    然后，我们可以得出结论：保护不同的数据就应该加不同的锁。　最后，问题就很明朗了，GIL 与Lock是两把锁，保护的数据不一样，前者是解释器级别的（当然保护的就是解释器级别的数据，比如垃圾回收的数据），后者是保护用户自己开发的应用程序的数据，很明显GIL不负责这件事，只能用户自定义加锁处理，即Lock过程分析：所有线程抢的是GIL锁，或者说所有线程抢的是执行权限　　线程1抢到GIL锁，拿到执行权限，开始执行，然后加了一把Lock，还没有执行完毕，即线程1还未释放Lock，有可能线程2抢到GIL锁，开始执行，执行过程中发现Lock还没有被线程1释放，于是线程2进入阻塞，被夺走执行权限，有可能线程1拿到GIL，然后正常执行到释放Lock。。。这就导致了串行运行的效果　　既然是串行，那我们执行　　t1.start()　　t1.join　　t2.start()　　t2.join()　　这也是串行执行啊，为何还要加Lock呢，需知join是等待t1所有的代码执行完，相当于锁住了t1的所有代码，而Lock只是锁住一部分操作共享数据的代码。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>详解：</p><pre><code>因为Python解释器帮你自动定期进行内存回收，你可以理解为python解释器里有一个独立的线程，每过一段时间它起wake up做一次全局轮询看看哪些内存数据是可以被清空的，此时你自己的程序 里的线程和 py解释器自己的线程是并发运行的，假设你的线程删除了一个变量，py解释器的垃圾回收线程在清空这个变量的过程中的clearing时刻，可能一个其它线程正好又重新给这个还没来及得清空的内存空间赋值了，结果就有可能新赋值的数据被删除了，为了解决类似的问题，python解释器简单粗暴的加了锁，即当一个线程运行时，其它人都不能动，这样就解决了上述的问题，  这可以说是Python早期版本的遗留问题。</code></pre><p> 看一段代码：解释为什么要加锁，如果下面代码中work函数里面的那个time.sleep(0.005)，我的电脑用的这个时间片段，每次运行都呈现不同的结果，我们可以改改时间试一下。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Thread,Lockimport os,timedef work():    global n    # lock.acquire() #加锁    temp=n    time.sleep(0.1) #一会将下面循环的数据加大并且这里的时间改的更小试试    n=temp-1    # time.sleep(0.02)    # n = n - 1    '''如果这样写的话看不出来效果，因为这样写就相当于直接将n的指向改了，就好比从10，经过1次减1之后，n就直接指向了9，速度太快，看不出效果，那么我们怎么办呢，找一个中间变量来接收n，然后对这个中间变量进行修改，然后再赋值给n，多一个给n赋值的过程，那么在这个过程中间，我们加上一点阻塞时间，来看效果，就像读文件修改数据之后再写回文件的过程。那么这个程序就会出现结果为9的情况，首先一个进程的全局变量对于所有线程是共享的，由于我们在程序给中间变量赋值，然后给n再次赋值的过程中我们加了一些I/O时间，遇到I/O就切换，那么每个线程都拿到了10，并对10减1了，然后大家都得到了9，然后再赋值给n，所有n等于了9'''    # lock.release()if __name__ == '__main__':    lock=Lock()    n=100    l=[]    # for i in range(10000):  #如果这里变成了10000，你在运行一下看看结果    for i in range(100):  #如果这里变成了10000，你在运行一下看看结果        p=Thread(target=work)        l.append(p)        p.start()    for p in l:        p.join()    print(n) #结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　上面这个代码示例，如果循环次数变成了10000，在我的电脑上就会出现不同的结果，因为在线程切换的那个time.sleep的时间内，有些线程还没有被切换到，也就是有些线程还没有拿到n的值，所以计算结果就没准了。</p><p><strong>锁通常被用来实现对共享资源的同步访问。为每一个共享资源创建一个Lock对象，当你需要访问该资源时，调用acquire方法来获取锁对象（如果其它线程已经获得了该锁，则当前线程需等待其被释放），待资源访问完后，再调用release方法释放锁：</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>import threadingR=threading.Lock()R.acquire() ##R.acquire()如果这里还有一个acquire，你会发现，程序就阻塞在这里了，因为上面的锁已经被拿到了并且还没有释放的情况下，再去拿就阻塞住了'''对公共数据的操作'''R.release()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 通过上面的代码示例1，我们看到多个线程抢占资源的情况，可以通过加锁来解决，看代码：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Thread,Lockimport os,timedef work():    global n    lock.acquire() #加锁    temp=n    time.sleep(0.1)    n=temp-1    lock.release()if __name__ == '__main__':    lock=Lock()    n=100    l=[]    for i in range(100):        p=Thread(target=work)        l.append(p)        p.start()    for p in l:        p.join()    print(n) #结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 看上面代码的图形解释：</p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180926163758975-598723035.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>分析：    #1.100个线程去抢GIL锁，即抢执行权限    #2. 肯定有一个线程先抢到GIL（暂且称为线程1），然后开始执行，一旦执行就会拿到lock.acquire()    #3. 极有可能线程1还未运行完毕，就有另外一个线程2抢到GIL，然后开始运行，但线程2发现互斥锁lock还未被线程1释放，于是阻塞，被迫交出执行权限，即释放GIL    #4.直到线程1重新抢到GIL，开始从上次暂停的位置继续执行，直到正常释放互斥锁lock，然后其他的线程再重复2 3 4的过程 </code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#不加锁:并发执行,速度快,数据不安全from threading import current_thread,Thread,Lockimport os,timedef task():    global n    print('%s is running' %current_thread().getName())    temp=n    time.sleep(0.5)    n=temp-1if __name__ == '__main__':    n=100    lock=Lock()    threads=[]    start_time=time.time()    for i in range(100):        t=Thread(target=task)        threads.append(t)        t.start()    for t in threads:        t.join()    stop_time=time.time()    print('主:%s n:%s' %(stop_time-start_time,n))'''Thread-1 is runningThread-2 is running......Thread-100 is running主:0.5216062068939209 n:99'''#不加锁:未加锁部分并发执行,加锁部分串行执行,速度慢,数据安全from threading import current_thread,Thread,Lockimport os,timedef task():    #未加锁的代码并发运行    time.sleep(3)    print('%s start to run' %current_thread().getName())    global n    #加锁的代码串行运行    lock.acquire()    temp=n    time.sleep(0.5)    n=temp-1    lock.release()if __name__ == '__main__':    n=100    lock=Lock()    threads=[]    start_time=time.time()    for i in range(100):        t=Thread(target=task)        threads.append(t)        t.start()    for t in threads:        t.join()    stop_time=time.time()    print('主:%s n:%s' %(stop_time-start_time,n))'''Thread-1 is runningThread-2 is running......Thread-100 is running主:53.294203758239746 n:0'''#有的同学可能有疑问:既然加锁会让运行变成串行,那么我在start之后立即使用join,就不用加锁了啊,也是串行的效果啊#没错:在start之后立刻使用jion,肯定会将100个任务的执行变成串行,毫无疑问,最终n的结果也肯定是0,是安全的,但问题是#start后立即join:任务内的所有代码都是串行执行的,而加锁,只是加锁的部分即修改共享数据的部分是串行的#单从保证数据安全方面,二者都可以实现,但很明显是加锁的效率更高.from threading import current_thread,Thread,Lockimport os,timedef task():    time.sleep(3)    print('%s start to run' %current_thread().getName())    global n    temp=n    time.sleep(0.5)    n=temp-1if __name__ == '__main__':    n=100    lock=Lock()    start_time=time.time()    for i in range(100):        t=Thread(target=task)        t.start()        t.join()    stop_time=time.time()    print('主:%s n:%s' %(stop_time-start_time,n))'''Thread-1 start to runThread-2 start to run......Thread-100 start to run主:350.6937336921692 n:0 #耗时是多么的恐怖'''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 3.死锁与递归锁</p><p>　　　　进程也有死锁与递归锁，在进程那里忘记说了，放到这里一切说了额，进程的死锁和线程的是一样的，而且一般情况下进程之间是数据不共享的，不需要加锁，由于线程是对全局的数据共享的，所以对于全局的数据进行操作的时候，要加锁。</p><p>　　　　所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Lock as Lockimport timemutexA=Lock()mutexA.acquire()mutexA.acquire()print(123)mutexA.release()mutexA.release()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Thread,Lockimport timemutexA=Lock()mutexB=Lock()class MyThread(Thread):    def run(self):        self.func1()        self.func2()    def func1(self):        mutexA.acquire()        print('\033[41m%s 拿到A锁&gt;&gt;&gt;\033[0m' %self.name)        mutexB.acquire()        print('\033[42m%s 拿到B锁&gt;&gt;&gt;\033[0m' %self.name)        mutexB.release()        mutexA.release()    def func2(self):        mutexB.acquire()          print('\033[43m%s 拿到B锁???\033[0m' %self.name)        time.sleep(2)        #分析：当线程1执行完func1，然后执行到这里的时候，拿到了B锁，线程2执行func1的时候拿到了A锁，那么线程2还要继续执行func1里面的代码，再去拿B锁的时候，发现B锁被人拿了，那么就一直等着别人把B锁释放，那么就一直等着，等到线程1的sleep时间用完之后，线程1继续执行func2，需要拿A锁了，但是A锁被线程2拿着呢，还没有释放，因为他在等着B锁被释放，那么这俩人就尴尬了，你拿着我的老A，我拿着你的B，这就尴尬了，俩人就停在了原地        mutexA.acquire()        print('\033[44m%s 拿到A锁???\033[0m' %self.name)        mutexA.release()        mutexB.release()if __name__ == '__main__':    for i in range(10):        t=MyThread()        t.start()'''Thread-1 拿到A锁&gt;&gt;&gt;Thread-1 拿到B锁&gt;&gt;&gt;Thread-1 拿到B锁???Thread-2 拿到A锁&gt;&gt;&gt;然后就卡住，死锁了'''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。</p><p>　　　　这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import RLock as Lockimport timemutexA=Lock()mutexA.acquire()mutexA.acquire()print(123)mutexA.release()mutexA.release()</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>典型问题：科学家吃面 ，看下面代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timefrom threading import Thread,Locknoodle_lock = Lock()fork_lock = Lock()def eat1(name):    noodle_lock.acquire()    print('%s 抢到了面条'%name)    fork_lock.acquire()    print('%s 抢到了叉子'%name)    print('%s 吃面'%name)    fork_lock.release()    noodle_lock.release()def eat2(name):    fork_lock.acquire()    print('%s 抢到了叉子' % name)    time.sleep(1)    noodle_lock.acquire()    print('%s 抢到了面条' % name)    print('%s 吃面' % name)    noodle_lock.release()    fork_lock.release()for name in ['taibai','egon','wulaoban']:    t1 = Thread(target=eat1,args=(name,))    t2 = Thread(target=eat2,args=(name,))    t1.start()    t2.start()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timefrom threading import Thread,RLockfork_lock = noodle_lock = RLock()def eat1(name):    noodle_lock.acquire()    print('%s 抢到了面条'%name)    fork_lock.acquire()    print('%s 抢到了叉子'%name)    print('%s 吃面'%name)    fork_lock.release()    noodle_lock.release()def eat2(name):    fork_lock.acquire()    print('%s 抢到了叉子' % name)    time.sleep(1)     noodle_lock.acquire()    print('%s 抢到了面条' % name)    print('%s 吃面' % name)    noodle_lock.release()    fork_lock.release()for name in ['taibai','wulaoban']:    t1 = Thread(target=eat1,args=(name,))    t1.start()for name in ['alex','peiqi']:    t2 = Thread(target=eat2,args=(name,))    t2.start()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　递归锁大致描述：　　当我们的程序中需要两把锁的时候，你就要注意，别出现死锁，最好就去用递归锁。</p><p>　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180926164920077-1095824302.png" alt="img"></p><h3 id="十-信号量"><a href="#十-信号量" class="headerlink" title="十 信号量"></a>十 信号量</h3><p>　　同进程的一样</p><p>　　Semaphore管理一个内置的计数器，<br>　　每当调用acquire()时内置计数器-1；<br>　　调用release() 时内置计数器+1；<br>　　计数器不能小于0；当计数器为0时，acquire()将阻塞线程直到其他线程调用release()。</p><p>　　实例：(同时只有5个线程可以获得semaphore,即可以限制最大连接数为5)：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Thread,Semaphoreimport threadingimport time# def func():#     if sm.acquire():#         print (threading.currentThread().getName() + ' get semaphore')#         time.sleep(2)#         sm.release()def func():    sm.acquire()    print('%s get sm' %threading.current_thread().getName())    time.sleep(3)    sm.release()if __name__ == '__main__':    sm=Semaphore(5)    for i in range(23):        t=Thread(target=func)        t.start()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>大家还记得信号量和进程池的区别吗，线程也有线程池，和信号量也是那点区别</p><p><a href="http://url.cn/5DMsS9r">互斥锁与信号量推荐博客：http://url.cn/5DMsS9r</a></p><h3 id="十一-事件"><a href="#十一-事件" class="headerlink" title="十一 事件"></a>十一 事件</h3><p>　　同进程的一样</p><p>　　线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行</p><p>事件的基本方法：</p><pre><code>event.isSet()：返回event的状态值；event.wait()：如果 event.isSet()==False将阻塞线程；event.set()： 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；event.clear()：恢复event的状态值为False。</code></pre><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180926170617977-1281765192.png" alt="img"></p><p>还记得我们进程那里的事件用的什么例子吗，是不是红绿灯啊，这次我们不讲红绿灯的例子了，换个新的！ </p><p>例如，有多个工作线程尝试链接MySQL，我们想要在链接前确保MySQL服务正常才让那些工作线程去连接MySQL服务器，如果连接不成功，都会去尝试重新连接。那么我们就可以采用threading.Event机制来协调各个工作线程的连接操作</p><p>MySQL是啥呢？简单说一下：</p><pre><code>mysql就是一个数据库，存数据用的东西，它就像一个文件夹，里面存着很多的excel表格，我们可以在表格里面写数据，存数据。但是如果我们要使用数据库，我们必须先要去连接它，你和他建立了连接关系，你才能操作它里面存放的数据。</code></pre><p> 我们先模拟一个场景：</p><p>　　首先起两个线程：</p><p>　　　　第一个线程的用处：连接数据库，那么我这个线程需要等待一个信号，告诉我我们之间的网络是可以连通的。</p><p>　　　　第二个线程的用处：检测与数据库之间的网络是否联通，并发送一个可联通或者不可联通的信号。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from threading import Thread,Eventimport threadingimport time,randomdef conn_mysql():    count=1    while not event.is_set():        if count &gt; 3:            raise TimeoutError('链接超时') #自己发起错误        print('&lt;%s&gt;第%s次尝试链接' % (threading.current_thread().getName(), count))        event.wait(0.5) #        count+=1    print('&lt;%s&gt;链接成功' %threading.current_thread().getName())def check_mysql():    print('\033[45m[%s]正在检查mysql\033[0m' % threading.current_thread().getName())    t1 = random.randint(0,3)    print('&gt;&gt;&gt;&gt;',t1)    time.sleep(t1)    event.set()if __name__ == '__main__':    event=Event()    check = Thread(target=check_mysql)    conn1=Thread(target=conn_mysql)    conn2=Thread(target=conn_mysql)    check.start()    conn1.start()    conn2.start()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="十二-条件Condition（了解）"><a href="#十二-条件Condition（了解）" class="headerlink" title="十二 条件Condition（了解）"></a>十二 条件Condition（了解）</h3><p>使得线程等待，只有满足某条件时，才释放n个线程，看一下大概怎么用就可以啦~~</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timefrom threading import Thread,RLock,Condition,current_threaddef func1(c):    c.acquire(False) #固定格式    # print(1111)    c.wait()  #等待通知,    time.sleep(3)  #通知完成后大家是串行执行的，这也看出了锁的机制了    print('%s执行了'%(current_thread().getName()))    c.release()if __name__ == '__main__':    c = Condition()    for i in range(5):        t = Thread(target=func1,args=(c,))        t.start()    while True:        num = int(input('请输入你要通知的线程个数:'))        c.acquire() #固定格式        c.notify(num)  #通知num个线程别等待了，去执行吧        c.release()#结果分析： # 请输入你要通知的线程个数:3# 请输入你要通知的线程个数:Thread-1执行了 #有时候你会发现的你结果打印在了你要输入内容的地方，这是打印的问题，没关系，不影响# Thread-3执行了# Thread-2执行了</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="十三-定时器（了解）"><a href="#十三-定时器（了解）" class="headerlink" title="十三 定时器（了解）"></a>十三 定时器（了解）</h3><p> 定时器，指定n秒后执行某个操作，这个做定时任务的时候可能会用到。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timefrom threading import Timer,current_thread #这里就不需要再引入Timerimport threadingdef hello():    print(current_thread().getName())    print("hello, world")    # time.sleep(3) #如果你的子线程的程序执行时间比较长，那么这个定时任务也会乱，当然了，主要还是看业务需求t = Timer(10, hello)  #创建一个子线程去执行后面的函数t.start()  # after 1 seconds, "hello, world" will be printed# for i in range(5):#     t = Timer(2, hello)#     t.start()  #     time.sleep(3) #这个是创建一个t用的时间是2秒，创建出来第二个的时候，第一个已经过了两秒了，所以你的5个t的执行结果基本上就是2秒中，这个延迟操作。print(threading.active_count())print('主进程',current_thread().getName())</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="十四-线程队列"><a href="#十四-线程队列" class="headerlink" title="十四 线程队列"></a>十四 线程队列</h3><p>　　线程之间的通信我们列表行不行呢，当然行，那么队列和列表有什么区别呢？</p><p>　　queue队列 ：使用import queue，用法与进程Queue一样</p><p>　　queue is especially useful in threaded programming when information must be exchanged safely between multiple threads.</p><ul><li>　　<strong>class queue.Queue(maxsize=0) #先进先出</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import queue #不需要通过threading模块里面导入，直接import queue就可以了，这是python自带的#用法基本和我们进程multiprocess中的queue是一样的q=queue.Queue()q.put('first')q.put('second')q.put('third')# q.put_nowait() #没有数据就报错，可以通过try来搞print(q.get())print(q.get())print(q.get())# q.get_nowait() #没有数据就报错，可以通过try来搞'''结果(先进先出):firstsecondthird'''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>class queue.LifoQueue(maxsize=0) #last in fisrt out</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import queueq=queue.LifoQueue() #队列，类似于栈，栈我们提过吗，是不是先进后出的顺序啊q.put('first')q.put('second')q.put('third')# q.put_nowait()print(q.get())print(q.get())print(q.get())# q.get_nowait()'''结果(后进先出):thirdsecondfirst'''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>class queue.PriorityQueue(maxsize=0) #存储数据时可设置优先级的队列</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import queueq=queue.PriorityQueue()#put进入一个元组,元组的第一个元素是优先级(通常是数字,也可以是非数字之间的比较),数字越小优先级越高q.put((-10,'a'))q.put((-5,'a'))  #负数也可以# q.put((20,'ws'))  #如果两个值的优先级一样，那么按照后面的值的acsii码顺序来排序,如果字符串第一个数元素相同，比较第二个元素的acsii码顺序# q.put((20,'wd'))# q.put((20,{'a':11})) #TypeError: unorderable types: dict() &lt; dict() 不能是字典# q.put((20,('w',1)))  #优先级相同的两个数据，他们后面的值必须是相同的数据类型才能比较，可以是元祖，也是通过元素的ascii码顺序来排序q.put((20,'b'))q.put((20,'a'))q.put((0,'b'))q.put((30,'c'))print(q.get())print(q.get())print(q.get())print(q.get())print(q.get())print(q.get())'''结果(数字越小优先级越高,优先级高的优先出队):'''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>这三种队列都是线程安全的，不会出现多个线程抢占同一个资源或数据的情况。</p><h3 id="十五-Python标准模块–concurrent-futures"><a href="#十五-Python标准模块–concurrent-futures" class="headerlink" title="十五 Python标准模块–concurrent.futures"></a>十五 Python标准模块–concurrent.futures</h3><p>到这里就差我们的线程池没有讲了，我们用一个新的模块给大家讲，早期的时候我们没有线程池，现在python提供了一个新的标准或者说内置的模块，这个模块里面提供了新的线程池和进程池，之前我们说的进程池是在multiprocessing里面的，现在这个在这个新的模块里面，他俩用法上是一样的。</p><p>为什么要将进程池和线程池放到一起呢，是为了统一使用方式，使用threadPollExecutor和ProcessPollExecutor的方式一样，而且只要通过这个concurrent.futures导入就可以直接用他们两个了</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>concurrent.futures模块提供了高度封装的异步调用接口ThreadPoolExecutor：线程池，提供异步调用ProcessPoolExecutor: 进程池，提供异步调用Both implement the same interface, which is defined by the abstract Executor class.#2 基本方法#submit(fn, *args, **kwargs)异步提交任务#map(func, *iterables, timeout=None, chunksize=1) 取代for循环submit的操作#shutdown(wait=True) 相当于进程池的pool.close()+pool.join()操作wait=True，等待池内所有任务执行完毕回收完资源后才继续wait=False，立即返回，并不会等待池内的任务执行完毕但不管wait参数为何值，整个程序都会等到所有任务执行完毕submit和map必须在shutdown之前#result(timeout=None)取得结果#add_done_callback(fn)回调函数</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timeimport osimport threadingfrom concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutordef func(n):    time.sleep(2)    print('%s打印的：'%(threading.get_ident()),n)    return n*ntpool = ThreadPoolExecutor(max_workers=5) #默认一般起线程的数据不超过CPU个数*5# tpool = ProcessPoolExecutor(max_workers=5) #进程池的使用只需要将上面的ThreadPoolExecutor改为ProcessPoolExecutor就行了，其他都不用改#异步执行t_lst = []for i in range(5):    t = tpool.submit(func,i) #提交执行函数,返回一个结果对象，i作为任务函数的参数 def submit(self, fn, *args, **kwargs):  可以传任意形式的参数    t_lst.append(t)  #    # print(t.result())    #这个返回的结果对象t，不能直接去拿结果，不然又变成串行了，可以理解为拿到一个号码，等所有线程的结果都出来之后，我们再去通过结果对象t获取结果tpool.shutdown() #起到原来的close阻止新任务进来 + join的作用，等待所有的线程执行完毕print('主线程')for ti in t_lst:    print('&gt;&gt;&gt;&gt;',ti.result())# 我们还可以不用shutdown()，用下面这种方式# while 1:#     for n,ti in enumerate(t_lst):#         print('&gt;&gt;&gt;&gt;', ti.result(),n)#     time.sleep(2) #每个两秒去去一次结果，哪个有结果了，就可以取出哪一个，想表达的意思就是说不用等到所有的结果都出来再去取，可以轮询着去取结果,因为你的任务需要执行的时间很长，那么你需要等很久才能拿到结果，通过这样的方式可以将快速出来的结果先拿出来。如果有的结果对象里面还没有执行结果，那么你什么也取不到，这一点要注意，不是空的，是什么也取不到,那怎么判断我已经取出了哪一个的结果，可以通过枚举enumerate来搞，记录你是哪一个位置的结果对象的结果已经被取过了，取过的就不再取了#结果分析： 打印的结果是没有顺序的，因为到了func函数中的sleep的时候线程会切换，谁先打印就没准儿了，但是最后的我们通过结果对象取结果的时候拿到的是有序的，因为我们主线程进行for循环的时候，我们是按顺序将结果对象添加到列表中的。# 37220打印的： 0# 32292打印的： 4# 33444打印的： 1# 30068打印的： 2# 29884打印的： 3# 主线程# &gt;&gt;&gt;&gt; 0# &gt;&gt;&gt;&gt; 1# &gt;&gt;&gt;&gt; 4# &gt;&gt;&gt;&gt; 9# &gt;&gt;&gt;&gt; 16</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　ProcessPoolExecutor的使用：</p><pre><code>只需要将这一行代码改为下面这一行就可以了，其他的代码都不用变tpool = ThreadPoolExecutor(max_workers=5) #默认一般起线程的数据不超过CPU个数*5# tpool = ProcessPoolExecutor(max_workers=5)你就会发现为什么将线程池和进程池都放到这一个模块里面了，用法一样</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorimport threadingimport os,time,randomdef task(n):    print('%s is runing' %threading.get_ident())    time.sleep(random.randint(1,3))    return n**2if __name__ == '__main__':    executor=ThreadPoolExecutor(max_workers=3)    # for i in range(11):    #     future=executor.submit(task,i)    s = executor.map(task,range(1,5)) #map取代了for+submit    print([i for i in s])</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timeimport osimport threadingfrom concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutordef func(n):    time.sleep(2)    return n*ndef call_back(m):    print('结果为：%s'%(m.result()))tpool = ThreadPoolExecutor(max_workers=5)t_lst = []for i in range(5):    t = tpool.submit(func,i).add_done_callback(call_back)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorfrom multiprocessing import Poolimport requestsimport jsonimport osdef get_page(url):    print('&lt;进程%s&gt; get %s' %(os.getpid(),url))    respone=requests.get(url)    if respone.status_code == 200:        return {'url':url,'text':respone.text}def parse_page(res):    res=res.result()    print('&lt;进程%s&gt; parse %s' %(os.getpid(),res['url']))    parse_res='url:&lt;%s&gt; size:[%s]\n' %(res['url'],len(res['text']))    with open('db.txt','a') as f:        f.write(parse_res)if __name__ == '__main__':    urls=[        'https://www.baidu.com',        'https://www.python.org',        'https://www.openstack.org',        'https://help.github.com/',        'http://www.sina.com.cn/'    ]    # p=Pool(3)    # for url in urls:    #     p.apply_async(get_page,args=(url,),callback=pasrse_page)    # p.close()    # p.join()    p=ProcessPoolExecutor(3)    for url in urls:        p.submit(get_page,url).add_done_callback(parse_page) #parse_page拿到的是一个future对象obj，需要用obj.result()拿到结果</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之进程</title>
      <link href="2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Python%E4%B9%8B%E8%BF%9B%E7%A8%8B/"/>
      <url>2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Python%E4%B9%8B%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>进程</p><p><strong>本节目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9629392.html#part_1">一 背景知识</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9629392.html#part_2">二 什么是进程</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9629392.html#part_3">三 进程调度</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9629392.html#part_4">四 并发与并行</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9629392.html#part_5">五 同步\异步\阻塞\非阻塞</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9629392.html#part_6">六 进程的创建与结束</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9629392.html#part_7">七 multiprocess模块</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9629392.html#part_8">八 进程池和mutiprocess.Poll</a></li><li></li></ul><h3 id="一-背景知识"><a href="#一-背景知识" class="headerlink" title="一 背景知识"></a>一 背景知识</h3><p>　　<strong>顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。</strong></p><p>　　<strong>进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。</strong></p><p>　　<strong>所以想要真正了解进程，必须事先了解操作系统，点击进入</strong>    </p><p>　　PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。</p><p>　　<strong>必备的理论基础：</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>#一 操作系统的作用：    1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口    2：管理、调度进程，并且将多个进程对硬件的竞争变得有序#二 多道技术：    1.产生背景：针对单核，实现并发    ps：    现在的主机一般是多核，那么每个核都会利用多道技术    有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个    cpu中的任意一个，具体由操作系统调度算法决定。    2.空间上的复用：如内存中同时有多道程序    3.时间上的复用：复用一个cpu的时间片       强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样            才能保证下次切换回来时，能基于上次切走的位置继续运行</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="二-什么是进程"><a href="#二-什么是进程" class="headerlink" title="二 什么是进程"></a>二 什么是进程</h3><p>　　进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。我们自己在python文件中写了一些代码，这叫做程序，运行这个python文件的时候，这叫做进程。</p><p>　　狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p><p>　　广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><p>　　举例： 比如py1文件中有个变量a=1，py2文件中有个变量a=2，他们两个会冲突吗？不会的，是不是，因为两个文件运行起来后是两个进程，操作系统让他们在内存上隔离开，对吧。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）（python的文件）、数据区域（data region）（python文件中定义的一些变量数据）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。[3] 进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。并发性：任何进程都可以同其他进程一起并发执行独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进结构特征：进程由程序、数据和进程控制块三部分组成。多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。举例：就像qq一样，qq是我们安装在自己电脑上的客户端程序，其实就是一堆的代码文件，我们不运行qq，那么他就是一堆代码程序，当我们运行qq的时候，这些代码运行起来，就成为一个进程了。</code></pre><p><strong>注意：同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。比如打开暴风影音，虽然都是同一个软件，但是一个可以播放苍井空，一个可以播放饭岛爱。</strong></p><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20181021203918377-1288339897.png" alt="img"></p><h3 id="三-进程调度"><a href="#三-进程调度" class="headerlink" title="三 进程调度"></a>三 进程调度</h3><p>要想多个进程交替运行，操作系统必须对这些进程进行调度，这个调度也不是随即进行的，而是需要遵循一定的法则，由此就有了进程的调度算法。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业，而不利于I/O繁忙型的作业（进程）。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度，也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>时间片轮转(Round Robin，RR)法的基本思路是让每个进程在就绪队列中的等待时间与享受服务的时间成比例。在时间片轮转法中，需要将CPU的处理时间分成固定大小的时间片，例如，几十毫秒至几百毫秒。如果一个进程在被调度选中之后用完了系统规定的时间片，但又未完成要求的任务，则它自行释放自己所占有的CPU而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。      显然，轮转法只能用来调度分配一些可以抢占的资源。这些可以抢占的资源可以随时被剥夺，而且可以将它们再分配给别的进程。CPU是可抢占资源的一种。但打印机等资源是不可抢占的。由于作业调度是对除了CPU之外的所有系统硬件资源的分配，其中包含有不可抢占资源，所以作业调度不使用轮转法。在轮转法中，时间片长度的选取非常重要。首先，时间片长度的选择会直接影响到系统的开销和响应时间。如果时间片长度过短，则调度程序抢占处理机的次数增多。这将使进程上下文切换次数也大大增加，从而加重系统开销。反过来，如果时间片长度选择过长，例如，一个时间片能保证就绪队列中所需执行时间最长的进程能执行完毕，则轮转法变成了先来先服务法。时间片长度的选择是根据系统对响应时间的要求和就绪队列中所允许最大的进程数来确定的。      在轮转法中，加入到就绪队列的进程有3种情况：      一种是分给它的时间片用完，但进程还未完成，回到就绪队列的末尾等待下次调度去继续执行。      另一种情况是分给该进程的时间片并未用完，只是因为请求I/O或由于进程的互斥与同步关系而被阻塞。当阻塞解除之后再回到就绪队列。      第三种情况就是新创建进程进入就绪队列。      如果对这些进程区别对待，给予不同的优先级和时间片从直观上看，可以进一步改善系统服务质量和效率。例如，我们可把就绪队列按照进程到达就绪队列的类型和进程被阻塞时的阻塞原因分成不同的就绪队列，每个队列按FCFS原则排列，各队列之间的进程享有不同的优先级，但同一队列内优先级相同。这样，当一个进程在执行完它的时间片之后，或从睡眠中被唤醒以及被创建之后，将进入不同的就绪队列。  </code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　对于多级反馈队列，windows不太清楚，但是在linux里面可以设置某个进程的优先级，提高了有限级有可能就会多执行几个时间片。</p><h3 id="四-并发与并行"><a href="#四-并发与并行" class="headerlink" title="四 并发与并行"></a>四 并发与并行</h3><p>通过进程之间的调度，也就是进程之间的切换，我们用户感知到的好像是两个视频文件同时在播放，或者音乐和游戏同时在进行，那就让我们来看一下什么叫做并发和并行</p><p>无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真是干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务</p><p>　　<strong>并发：</strong>是伪并行，即看起来是同时运行。单个cpu+多道技术就可以实现并发，（并行也属于并发）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>你是一个cpu，你同时谈了三个女朋友，每一个都可以是一个恋爱任务，你被这三个任务共享要玩出并发恋爱的效果，应该是你先跟女友1去看电影，看了一会说：不好，我要拉肚子，然后跑去跟第二个女友吃饭，吃了一会说：那啥，我去趟洗手间，然后跑去跟女友3开了个房，然后在你的基友眼里，你就在和三个女友同时在一起玩。</code></pre><p>　　<strong>并行：</strong>并行：同时运行，只有具备多个cpu才能实现并行</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>将多个cpu必须成高速公路上的多个车道，进程就好比每个车道上行驶的车辆，并行就是说，大家在自己的车道上行驶，会不影响，同时在开车。这就是并行</code></pre><p>　　单核下，可以利用多道技术，多个核，每个核也都可以利用多道技术（<strong>多道技术是针对单核而言的</strong>）</p><p>　　有四个核，六个任务，这样同一时间有四个任务被执行，假设分别被分配给了cpu1，cpu2，cpu3，cpu4，</p><p>　　一旦任务1遇到I/O就被迫中断执行，此时任务5就拿到cpu1的时间片去执行，这就是单核下的多道技术</p><p>　　而一旦任务1的I/O结束了，操作系统会重新调用它(<strong>需知进程的调度、分配给哪个cpu运行，由操作系统说了算</strong>)，可能被分配给四个cpu中的任意一个去执行</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/1036857-20170506233723679-411353203.png" alt="img"></p><p>　　所有现代计算机经常会在同一时间做很多件事，一个用户的PC（无论是单cpu还是多cpu），都可以同时运行多个任务（一个任务可以理解为一个进程）。</p><p>　　　　启动一个进程来杀毒（360软件）</p><p>　　　　启动一个进程来看电影（暴风影音）</p><p>　　　　启动一个进程来聊天（腾讯QQ）</p><p>　　所有的这些进程都需被管理，于是一个支持多进程的多道程序系统是至关重要的</p><p>　　多道技术概念回顾：内存中同时存入多道（多个）程序，cpu从一个进程快速切换到另外一个，使每个进程各自运行几十或几百毫秒，这样，虽然在某一个瞬间，一个cpu只能执行一个任务，但在1秒内，cpu却可以运行多个进程，这就给人产生了并行的错觉，即伪并行，以此来区分多处理器操作系统的真正硬件并行（多个cpu共享同一个物理内存）</p><h3 id="五-同步-异步-阻塞-非阻塞（重点）"><a href="#五-同步-异步-阻塞-非阻塞（重点）" class="headerlink" title="五 同步\异步\阻塞\非阻塞（重点）"></a>五 同步\异步\阻塞\非阻塞（重点）</h3><p>1.进程状态介绍</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/827651-20180110201327535-1120359184.png" alt="img"></p><p>　　在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。</p><p>　　（1）就绪(Ready)状态</p><p>　　　　当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</p><p>　　（2）执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。</p><p>　　（3）阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。</p><p>　　　　事件请求：input、sleep、文件输入输出、recv、accept等</p><p>　　　　事件发生：sleep、input等完成了</p><p>　　　　时间片到了之后有回到就绪状态，这三个状态不断的在转换。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/827651-20180110204322676-135915799.png" alt="img"></p><p>2.同步异步</p><pre><code>　　　　所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。其实就是一个程序结束才执行另外一个程序，串行的，不一定两个程序就有依赖关系。</code></pre><p><code>　　　　所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了</code>。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，<code>所以它``是不可靠的``任务序列</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>比如我们去楼下的老家肉饼吃饭，饭点好了，取餐的时候发生了一些同步异步的事情。同步：我们都站在队里等着取餐，前面有个人点了一份肉饼，后厨做了很久，但是由于同步机制，我们还是要站在队里等着前面那个人的肉饼做好取走，我们才往前走一步。异步：我们点完餐之后，点餐员给了我们一个取餐号码，跟你说，你不用在这里排队等着，去找个地方坐着玩手机去吧，等饭做好了，我叫你。这种机制(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中等着取餐的你)往往注册一个回调机制，在所等待的事件被触发时由触发机制(点餐员)通过某种机制(喊号，‘250号你的包子好了‘)找到等待该事件的人。</code></pre><p>3.阻塞与非阻塞</p><p> 　　阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的</p><pre><code>继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。相反，有的人喜欢在等待取餐的时候一边打游戏一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。阻塞的方法：input、time.sleep，socket中的recv、accept等等。</code></pre><p> 4.同步/异步 与 阻塞和非阻塞</p><ol><li><strong>同步阻塞形式</strong></li></ol><p>　　　　效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。</p><ol><li><strong>异步阻塞形式</strong></li></ol><p>　　　　如果在排队取餐的人<code>采用的是异步的方式去等待消息被触发（通知）</code>，也就是领了一张小纸条，假如在这段时间里他不能做其它的事情，就在那坐着等着，不能玩游戏等，那么很显然，这个人被阻塞在了这个等待的操作上面；</p><p>　　　　<strong>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong></p><ol><li><strong>同步非阻塞形式</strong></li></ol><p>　　　　实际上是效率低下的。</p><p>　　　　想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，<code>这个程序需要在这两种不同的行为之间来回的切换</code>，效率可想而知是低下的。</p><ol><li><strong>异步非阻塞形式</strong></li></ol><p>　　　　效率更高，</p><p>　　　　因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，<code>程序没有在两种不同的操作中来回切换</code>。</p><p>　　　　比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉点餐员说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p><p>　　很多人会把同步和阻塞混淆，是<code>因为很多时候同步操作会以阻塞的形式表现出来</code>，同样的，很多人也会把异步和非阻塞混淆，<code>因为异步操作一般都不会在真正的IO操作处被阻塞</code>。</p><h3 id="六-进程的创建、结束与并发的实现（了解）"><a href="#六-进程的创建、结束与并发的实现（了解）" class="headerlink" title="六 进程的创建、结束与并发的实现（了解）"></a>六 进程的创建、结束与并发的实现（了解）</h3><p>1.进程的创建</p><p>　　　　但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。</p><p>　　　　而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程</p><p>　　　　　　1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）</p><p>　　　　　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）</p><p>　　　　　　3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）</p><p>　　　　　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）</p><p>　　</p><p>　　　　无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的：</p><p>　　　　　　1. 在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）</p><p>　　　　　　2. 在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。</p><p>　</p><p>　　　　关于创建的子进程，UNIX和windows</p><p>　　　　　　1.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（<strong>多道技术要求物理层面实现进程之间内存的隔离</strong>），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。</p><p>　　　　　　2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。</p><p>2.进程的结束　</p><p>　　　　1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）</p><p>　　　　2. 出错退出（自愿，python a.py中a.py不存在）</p><p>　　　　3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try…except…）</p><p>　　　　4. 被其他进程杀死（非自愿，如kill -9）</p><p> 3.进程并发的实现（了解）</p><p>　　　　进程并发的实现在于，硬件中断一个正在运行的进程，把此时进程运行的所有状态保存下来，为此，操作系统维护一张表格，即进程表（process table），每个进程占用一个进程表项（这些表项也称为进程控制块）</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/1036857-20171229144430038-509212133.png" alt="img"></p><p>　　　　该表存放了进程状态的重要信息：程序计数器、堆栈指针、内存分配状况、所有打开文件的状态、帐号和调度信息，以及其他在进程由运行态转为就绪态或阻塞态时，必须保存的信息，从而保证该进程在再次启动时，就像从未被中断过一样。</p><p>===========================================================</p><p> 上面的内容都是进程的一些理论基础，下面的内容是python中进程的应用实战</p><p>=====================================================================</p><p>今天的内容就到这个地方吧，同学们好好整理一下<del>~</del></p><p>　　<strong>通过上面内容的学习，我们已经了解了很多进程相关的理论知识，了解进程是什么应该不再困难了，刚刚我们已经了解了，运行中的程序就是一个进程。所有的进程都是通过它的父进程来创建的。因此，运行起来的python程序也是一个进程，那么我们也可以在程序中再创建进程。多个进程可以实现并发效果，也就是说，当我们的程序中存在多个进程的时候，在某些时候，就会让程序的执行速度变快。以我们之前所学的知识，并不能实现创建进程这个功能，所以我们就需要借助python中强大的模块。</strong></p><h3 id="七-multiprocess模块"><a href="#七-multiprocess模块" class="headerlink" title="七 multiprocess模块"></a>七 multiprocess模块</h3><p>仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。重点强调：进程没有任何共享状态，进程修改的数据，改动仅限于该进程内，但是通过一些特殊的方法，可以实现进程之间数据的共享。</p><p>1.process模块介绍</p><p> 　　process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。</p><pre><code>Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）强调：1. 需要使用关键字的方式来指定参数2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</code></pre><p>　　　　我们先写一个程序来看看：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>#当前文件名称为test.py# from multiprocessing import Process## def func():#     print(12345)## if __name__ == '__main__': #windows 下才需要写这个，这和系统创建进程的机制有关系，不用深究，记着windows下要写就好啦#     #首先我运行当前这个test.py文件，运行这个文件的程序，那么就产生了进程，这个进程我们称为主进程##     p = Process(target=func,) #将函数注册到一个进程中，p是一个进程对象，此时还没有启动进程，只是创建了一个进程对象。并且func是不加括号的，因为加上括号这个函数就直接运行了对吧。#     p.start() #告诉操作系统，给我开启一个进程，func这个函数就被我们新开的这个进程执行了，而这个进程是我主进程运行过程中创建出来的，所以称这个新创建的进程为主进程的子进程，而主进程又可以称为这个新进程的父进程。　　　　　　　　　 #而这个子进程中执行的程序，相当于将现在这个test.py文件中的程序copy到一个你看不到的python文件中去执行了，就相当于当前这个文件，被另外一个py文件import过去并执行了。　　　　　　　　　 #start并不是直接就去执行了，我们知道进程有三个状态，进程会进入进程的三个状态，就绪，（被调度，也就是时间片切换到它的时候）执行，阻塞，并且在这个三个状态之间不断的转换，等待cpu执行时间片到了。#     print('*' * 10) #这是主进程的程序，上面开启的子进程的程序是和主进程的程序同时运行的，我们称为异步</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　上面说了，我们通过主进程创建的子进程是异步执行的，那么我们就验证一下，并且看一下子进程和主进程(也就是父进程)的ID号（讲一下pid和ppid，使用pycharm举例），来看看是否是父子关系。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ContractedBlock.gif" alt="img"> 子进程与主进程</p><p>　　　　</p><p>　　　　打开windows下的任务管理器，<strong>看pycharm的pid进程号，是我们上面运行的test.py这个文件主进程的父进程号：</strong></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180918114320645-1740038451.png" alt="img"></p><p>　　　　看一个问题，说明linux和windows两个不同的操作系统创建进程的不同机制导致的不同结果：　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timeimport osfrom multiprocessing import Processdef func():    print('aaaa')    time.sleep(1)    print('子进程&gt;&gt;',os.getpid())    print('该子进程的父进程&gt;&gt;',os.getppid())    print(12345)print('太白老司机~~~~') #如果我在这里加了一个打印，你会发现运行结果中会出现两次打印出来的太白老司机，因为我们在主进程中开了一个子进程，子进程中的程序相当于import的主进程中的程序，那么import的时候会不会执行你import的那个文件的程序啊，前面学的，是会执行的，所以出现了两次打印#其实是因为windows开起进程的机制决定的，在linux下是不存在这个效果的，因为windows使用的是process方法来开启进程，他就会拿到主进程中的所有程序，而linux下只是去执行我子进程中注册的那个函数，不会执行别的程序，这也是为什么在windows下要加上执行程序的时候，要加上if __name__ == '__main__':，否则会出现子进程中运行的时候还开启子进程，那就出现无限循环的创建进程了，就报错了</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　一个进程的生命周期：如果子进程的运行时间长，那么等到子进程执行结束程序才结束，如果主进程的执行时间长，那么主进程执行结束程序才结束，实际上我们在子进程中打印的内容是在主进程的执行结果中看不出来的，但是pycharm帮我们做了优化，因为它会识别到你这是开的子进程，帮你把子进程中打印的内容打印到了显示台上。</p><p>　　　　如果说一个主进程运行完了之后，我们把pycharm关了，但是子进程还没有执行结束，那么子进程还存在吗？这要看你的进程是如何配置的，如果说我们没有配置说我主进程结束，子进程要跟着结束，那么主进程结束的时候，子进程是不会跟着结束的，他会自己执行完，如果我设定的是主进程结束，子进程必须跟着结束，那么就不会出现单独的子进程（孤儿进程）了，具体如何设置，看下面的守护进程的讲解。比如说，我们将来启动项目的时候，可能通过cmd来启动，那么我cmd关闭了你的项目就会关闭吗，不会的，因为你的项目不能停止对外的服务，对吧。</p><p>　　　　Process类中参数的介绍：</p><pre><code>参数介绍：1 group参数未使用，值始终为None2 target表示调用对象，即子进程要执行的任务3 args表示调用对象的位置参数元组，args=(1,2,'egon',)4 kwargs表示调用对象的字典,kwargs={'name':'egon','age':18}5 name为子进程的名称</code></pre><p>　　　　给要执行的函数传参数：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>def func(x,y):    print(x)    time.sleep(1)    print(y)if __name__ == '__main__':    p = Process(target=func,args=('姑娘','来玩啊！'))#这是func需要接收的参数的传送方式。    p.start()    print('父进程执行结束！')#执行结果：父进程执行结束！姑娘来玩啊！</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　Process类中各方法的介绍：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>1 p.start()：启动进程，并调用该子进程中的p.run() 2 p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  3 p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁4 p.is_alive():如果p仍然运行，返回True5 p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程  </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　</p><p>　　　　join方法的例子：</p><p>　　　　让主进程加上join的地方等待（也就是阻塞住），等待子进程执行完之后，再继续往下执行我的主进程，好多时候，我们主进程需要子进程的执行结果，所以必须要等待。join感觉就像是将子进程和主进程拼接起来一样，将异步改为同步执行。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>def func(x,y):    print(x)    time.sleep(1)    print(y)if __name__ == '__main__':    p = Process(target=func,args=('姑娘','来玩啊！'))    p.start()    print('我这里是异步的啊！')  #这里相对于子进程还是异步的    p.join()  #只有在join的地方才会阻塞住，将子进程和主进程之间的异步改为同步    print('父进程执行结束！')#打印结果：我这里是异步的啊！姑娘来玩啊！父进程执行结束！</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　怎么样开启多个进程呢？for循环。并且我有个需求就是说，所有的子进程异步执行，然后所有的子进程全部执行完之后，我再执行主进程，怎么搞？看代码</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#下面的注释按照编号去看，别忘啦！import timeimport osfrom multiprocessing import Processdef func(x,y):    print(x)    # time.sleep(1) #进程切换：如果没有这个时间间隔，那么你会发现func执行结果是打印一个x然后一个y，再打印一个x一个y，不会出现打印多个x然后打印y的情况，因为两个打印距离太近了而且执行的也非常快，但是如果你这段程序运行慢的话，你就会发现进程之间的切换了。    print(y)if __name__ == '__main__':    p_list= []    for i in range(10):        p = Process(target=func,args=('姑娘%s'%i,'来玩啊！'))        p_list.append(p)        p.start()    [ap.join() for ap in p_list] #4、这是解决办法，前提是我们的子进程全部都已经去执行了，那么我在一次给所有正在执行的子进程加上join，那么主进程就需要等着所有子进程执行结束才会继续执行自己的程序了，并且保障了所有子进程是异步执行的。        # p.join() #1、如果加到for循环里面，那么所有子进程包括父进程就全部变为同步了，因为for循环也是主进程的，循环第一次的时候，一个进程去执行了，然后这个进程就join住了，那么for循环就不会继续执行了，等着第一个子进程执行结束才会继续执行for循环去创建第二个子进程。        #2、如果我不想这样的，也就是我想所有的子进程是异步的，然后所有的子进程执行完了再执行主进程    #p.join() #3、如果这样写的话，多次运行之后，你会发现会出现主进程的程序比一些子进程先执行完，因为我们p.join()是对最后一个子进程进行了join，也就是说如果这最后一个子进程先于其他子进程执行完，那么主进程就会去执行，而此时如果还有一些子进程没有执行完，而主进程执行　　　　　　　　 #完了，那么就会先打印主进程的内容了，这个cpu调度进程的机制有关系，因为我们的电脑可能只有4个cpu，我的子进程加上住进程有11个，虽然我for循环是按顺序起进程的，但是操作系统一定会按照顺序给你执行你的进程吗，答案是不会的，操作系统会按照自己的算法来分配进              #程给cpu去执行，这里也解释了我们打印出来的子进程中的内容也是没有固定顺序的原因，因为打印结果也需要调用cpu，可以理解成进程在争抢cpu，如果同学你想问这是什么算法，这就要去研究操作系统啦。那我们的想所有子进程异步执行，然后再执行主进程的这个需求怎么解决啊    print('不要钱~~~~~~~~~~~~~~~~！')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　 </p><p>　　模拟两个应用场景：1、同时对一个文件进行写操作  2、同时创建多个文件</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timeimport osimport refrom multiprocessing import Process#多进程同时对一个文件进行写操作def func(x,y,i):    with open(x,'a',encoding='utf-8') as f:        print('当前进程%s拿到的文件的光标位置&gt;&gt;%s'%(os.getpid(),f.tell()))        f.write(y)#多进程同时创建多个文件# def func(x, y):#     with open(x, 'w', encoding='utf-8') as f:#         f.write(y)if __name__ == '__main__':    p_list= []    for i in range(10):        p = Process(target=func,args=('can_do_girl_lists.txt','姑娘%s'%i,i))         # p = Process(target=func,args=('can_do_girl_info%s.txt'%i,'姑娘电话0000%s'%i))        p_list.append(p)        p.start()    [ap.join() for ap in p_list] #这就是个for循环，只不过用列表生成式的形式写的    with open('can_do_girl_lists.txt','r',encoding='utf-8') as f:        data = f.read()        all_num = re.findall('\d+',data) #打开文件，统计一下里面有多少个数据，每个数据都有个数字，所以re匹配一下就行了        print('&gt;&gt;&gt;&gt;&gt;',all_num,'.....%s'%(len(all_num)))    #print([i in in os.walk(r'你的文件夹路径')])    print('不要钱~~~~~~~~~~~~~~~~！')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　Process类中自带封装的各属性的介绍</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>1 p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置2 p.name:进程的名称3 p.pid：进程的pid4 p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)5 p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2.Process类的使用</p><p>　　<strong>注意：在windows中Process()必须放到# if <strong>name</strong> == ‘<strong>main</strong>‘:下</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>Since Windows has no fork, the multiprocessing module starts a new Python process and imports the calling module. If Process() gets called upon import, then this sets off an infinite succession of new processes (or until your machine runs out of resources). This is the reason for hiding calls to Process() insideif __name__ == "__main__"since statements inside this if-statement will not get called upon import.由于Windows没有fork，多处理模块启动一个新的Python进程并导入调用模块。 如果在导入时调用Process（），那么这将启动无限继承的新进程（或直到机器耗尽资源）。 这是隐藏对Process（）内部调用的原，使用if __name__ == “__main __”，这个if语句中的语句将不会在导入时被调用。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　</p><p>　　　　进程的创建<strong>第二种方法（继承）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>class MyProcess(Process): #自己写一个类，继承Process类    #我们通过init方法可以传参数，如果只写一个run方法，那么没法传参数，因为创建对象的是传参就是在init方法里面，面向对象的时候，我们是不是学过    def __init__(self,person):        super().__init__()        self.person=person    def run(self):        print(os.getpid())        print(self.pid)        print(self.pid)        print('%s 正在和女主播聊天' %self.person)    # def start(self):    #     #如果你非要写一个start方法，可以这样写，并且在run方法前后，可以写一些其他的逻辑    #     self.run()if __name__ == '__main__':    p1=MyProcess('Jedan')    p2=MyProcess('太白')    p3=MyProcess('alexDSB')    p1.start() #start内部会自动调用run方法    p2.start()    # p2.run()    p3.start()    p1.join()    p2.join()    p3.join()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　</p><p>　　　　进程之间的数据是隔离的：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#我们说进程之间的数据是隔离的，也就是数据不共享，看下面的验证from multiprocessing import Processn=100 #首先我定义了一个全局变量，在windows系统中应该把全局变量定义在if __name__ == '__main__'之上就可以了def work():    global n    n=0    print('子进程内: ',n)if __name__ == '__main__':    p=Process(target=work)    p.start()    p.join() #等待子进程执行完毕，如果数据共享的话，我子进程是不是通过global将n改为0了，但是你看打印结果，主进程在子进程执行结束之后，仍然是n=100，子进程n=0，说明子进程对n的修改没有在主进程中生效，说明什么？说明他们之间的数据是隔离的，互相不影响的    print('主进程内: ',n)#看结果：# 子进程内:  0# 主进程内:  100</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　练习：我们之前学socket的时候，知道tcp协议的socket是不能同时和多个客户端进行连接的，(这里先不考虑socketserver那个模块)，对不对，那我们自己通过多进程来实现一下同时和多个客户端进行连接通信。</p><p> 　　　　服务端代码示例：（注意一点：通过这个是不能做qq聊天的，因为qq聊天是qq的客户端把信息发给另外一个qq的客户端，中间有一个服务端帮你转发消息，而不是我们这样的单纯的客户端和服务端对话，并且子进程开启之后咱们是没法操作的，并且没有为子进程input输入提供控制台，所有你再在子进程中写上了input会报错，EOFError错误，这个错误的意思就是你的input需要输入，但是你输入不了，就会报这个错误。而子进程的输出打印之类的，是pycharm做了优化，将所有子进程中的输出结果帮你打印出来了，但实质还是不同进程的。）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *from multiprocessing import Processdef talk(conn,client_addr):    while True:        try:            msg=conn.recv(1024)            print('客户端消息&gt;&gt;',msg)            if not msg:break            conn.send(msg.upper())            #在这里有同学可能会想，我能不能在这里写input来自己输入内容和客户端进行对话？朋友，是这样的，按说是可以的，但是需要什么呢？需要你像我们用pycharm的是一样下面有一个输入内容的控制台，当我们的子进程去执行的时候，我们是没有地方可以显示能够让你输入内容的控制台的，所以你没办法输入，就会给你报错。        except Exception:            breakif __name__ == '__main__': #windows下start进程一定要写到这下面    server = socket(AF_INET, SOCK_STREAM)    # server.setsockopt(SOL_SOCKET, SO_REUSEADDR,1)  # 如果你将如果你将bind这些代码写到if __name__ == '__main__'这行代码的上面，那么地址重用必须要有，因为我们知道windows创建的子进程是对整个当前文件的内容进行的copy，前面说了就像import，如果你开启了子进程，那么子进程是会执行bind的，那么你的主进程bind了这个ip和端口，子进程在进行bind的时候就会报错。    server.bind(('127.0.0.1', 8080))    #有同学可能还会想，我为什么多个进程就可以连接一个server段的一个ip和端口了呢，我记得当时说tcp的socket的时候，我是不能在你这个ip和端口被连接的情况下再连接你的啊，这里是因为当时我们就是一个进程，一个进程里面是只能一个连接的，多进程是可以多连接的，这和进程之间是单独的内存空间有关系，先这样记住他，好吗？    server.listen(5)    while True:        conn,client_addr=server.accept()        p=Process(target=talk,args=(conn,client_addr))        p.start()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　客户端代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *client=socket(AF_INET,SOCK_STREAM)client.connect(('127.0.0.1',8080))while True:    msg=input('&gt;&gt;: ').strip()    if not msg:continue    client.send(msg.encode('utf-8'))    msg=client.recv(1024)    print(msg.decode('utf-8'))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　</p><p>　　　　上面我们通过多进程实现了并发，但是有个问题</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>每来一个客户端，都在服务端开启一个进程，如果并发来一个万个客户端，要开启一万个进程吗，你自己尝试着在你自己的机器上开启一万个，10万个进程试一试。解决方法：进程池，本篇博客后面会讲到，大家继续学习呀</code></pre><p> 　　　　Process对象的其他方法或属性（简单了解一下就可以啦）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#进程对象的其他方法一:terminate,is_alivefrom multiprocessing import Processimport timeimport randomclass Piao(Process):    def __init__(self,name):        self.name=name        super().__init__()    def run(self):        print('%s is 打飞机' %self.name)        # s = input('???') #别忘了再pycharm下子进程中不能input输入，会报错EOFError: EOF when reading a line，因为子进程中没有像我们主进程这样的在pycharm下的控制台可以输入东西的地方        time.sleep(2)        print('%s is 打飞机结束' %self.name)if __name__ == '__main__':    p1=Piao('太白')    p1.start()    time.sleep(5)    p1.terminate()#关闭进程,不会立即关闭,有个等着操作系统去关闭这个进程的时间,所以is_alive立刻查看的结果可能还是存活，但是稍微等一会，就被关掉了    print(p1.is_alive()) #结果为True    print('等会。。。。')    time.sleep(1)    print(p1.is_alive()) #结果为False</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Processimport timeimport randomclass Piao(Process):    def __init__(self,name):        # self.name=name        # super().__init__() #Process的__init__方法会执行self.name=Piao-1,        #                    #所以加到这里,会覆盖我们的self.name=name        #为我们开启的进程设置名字的做法        super().__init__()        self.name=name    def run(self):        print('%s is piaoing' %self.name)        time.sleep(random.randrange(1,3))        print('%s is piao end' %self.name)p=Piao('egon')p.start()print('开始')print(p.pid) #查看pid</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　僵尸进程与孤儿进程（简单了解 一下就可以啦）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>参考博客：http://www.cnblogs.com/Anker/p/3271773.html一：僵尸进程（有害）　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。详解如下我们知道在unix/linux中，正常情况下子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束，如果子进程一结束就立刻回收其全部资源，那么在父进程内将无法获取子进程的状态信息。因此，UNⅨ提供了一种机制可以保证父进程可以在任意时刻获取子进程结束时的状态信息：1、在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）2、直到父进程通过wait / waitpid来取时才释放. 但这样就导致了问题，如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。　　任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。二：孤儿进程（无害）　　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。　　孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。我们来测试一下（创建完子进程后，主进程所在的这个脚本就退出了，当父进程先于子进程结束时，子进程会被init收养，成为孤儿进程，而非僵尸进程），文件内容import osimport sysimport timepid = os.getpid()ppid = os.getppid()print 'im father', 'pid', pid, 'ppid', ppidpid = os.fork()#执行pid=os.fork()则会生成一个子进程#返回值pid有两种值：#    如果返回的pid值为0，表示在子进程当中#    如果返回的pid值&gt;0，表示在父进程当中if pid &gt; 0:    print 'father died..'    sys.exit(0)# 保证主线程退出完毕time.sleep(1)print 'im child', os.getpid(), os.getppid()执行文件，输出结果：im father pid 32515 ppid 32015father died..im child 32516 1看，子进程已经被pid为1的init进程接收了，所以僵尸进程在这种情况下是不存在的，存在只有孤儿进程而已，孤儿进程声明周期结束自然会被init来销毁。三：僵尸进程危害场景：　　例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。四：测试#1、产生僵尸进程的程序test.py内容如下#coding:utf-8from multiprocessing import Processimport time,osdef run():    print('子',os.getpid())if __name__ == '__main__':    p=Process(target=run)    p.start()    print('主',os.getpid())    time.sleep(1000)#2、在unix或linux系统上执行[root@vm172-31-0-19 ~]# python3  test.py &amp;[1] 18652[root@vm172-31-0-19 ~]# 主 18652子 18653[root@vm172-31-0-19 ~]# ps aux |grep ZUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot     18653  0.0  0.0      0     0 pts/0    Z    20:02   0:00 [python3] &lt;defunct&gt; #出现僵尸进程root     18656  0.0  0.0 112648   952 pts/0    S+   20:02   0:00 grep --color=auto Z[root@vm172-31-0-19 ~]# top #执行top命令发现1zombietop - 20:03:42 up 31 min,  3 users,  load average: 0.01, 0.06, 0.12Tasks:  93 total,   2 running,  90 sleeping,   0 stopped,   1 zombie%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :  1016884 total,    97184 free,    70848 used,   848852 buff/cacheKiB Swap:        0 total,        0 free,        0 used.   782540 avail Mem   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                                                        root      20   0   29788   1256    988 S  0.3  0.1   0:01.50 elfin                                                                                                                      #3、等待父进程正常结束后会调用wait／waitpid去回收僵尸进程但如果父进程是一个死循环，永远不会结束，那么该僵尸进程就会一直存在，僵尸进程过多，就是有害的解决方法一：杀死父进程解决方法二：对开启的子进程应该记得使用join，join会回收僵尸进程参考python2源码注释class Process(object):    def join(self, timeout=None):        '''        Wait until child process terminates        '''        assert self._parent_pid == os.getpid(), 'can only join a child process'        assert self._popen is not None, 'can only join a started process'        res = self._popen.wait(timeout)        if res is not None:            _current_process._children.discard(self)join方法中调用了wait，告诉系统释放僵尸进程。discard为从自己的children中剔除解决方法三：http://blog.csdn.net/u010571844/article/details/50419798</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>3.守护进程</p><p>　　　　之前我们讲的子进程是不会随着主进程的结束而结束，子进程全部执行完之后，程序才结束，那么如果有一天我们的需求是我的主进程结束了，由我主进程创建的那些子进程必须跟着结束，怎么办？守护进程就来了！</p><p>　　　　主进程创建守护进程</p><p>　　　　　　其一：守护进程会在主进程代码执行结束后就终止</p><p>　　　　　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p><p>　　　　注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import osimport timefrom multiprocessing import Processclass Myprocess(Process):    def __init__(self,person):        super().__init__()        self.person = person    def run(self):        print(os.getpid(),self.name)        print('%s正在和女主播聊天' %self.person)        time.sleep(3)if __name__ == '__main__':    p=Myprocess('太白')    p.daemon=True #一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行    p.start()    # time.sleep(1) # 在sleep时linux下查看进程id对应的进程ps -ef|grep id    print('主')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>4.进程同步（锁）</p><p> 　　　　通过刚刚的学习，我们千方百计实现了程序的异步，让多个任务可以同时在几个进程中并发处理，他们之间的运行没有顺序，一旦开启也不受我们控制。尽管并发编程让我们能更加充分的利用IO资源，但是也给我们带来了新的问题：进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的，而共享带来的是竞争，竞争带来的结果就是错乱，如何控制，就是加锁处理。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import osimport timeimport randomfrom multiprocessing import Processdef work(n):    print('%s: %s is running' %(n,os.getpid()))    time.sleep(random.random())    print('%s:%s is done' %(n,os.getpid()))if __name__ == '__main__':    for i in range(5):        p=Process(target=work,args=(i,))        p.start()# 看结果：通过结果可以看出两个问题：问题一：每个进程中work函数的第一个打印就不是按照我们for循环的0-4的顺序来打印的#问题二：我们发现，每个work进程中有两个打印，但是我们看到所有进程中第一个打印的顺序为0-2-1-4-3，但是第二个打印没有按照这个顺序，变成了2-1-0-3-4，说明我们一个进程中的程序的执行顺序都混乱了。#问题的解决方法，第二个问题加锁来解决，第一个问题是没有办法解决的，因为进程开到了内核，有操作系统来决定进程的调度，我们自己控制不了# 0: 9560 is running# 2: 13824 is running# 1: 7476 is running# 4: 11296 is running# 3: 14364 is running# 2:13824 is done# 1:7476 is done# 0:9560 is done# 3:14364 is done# 4:11296 is done</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#由并发变成了串行,牺牲了运行效率,但避免了竞争from multiprocessing import Process,Lockimport os,timedef work(n,lock):    #加锁，保证每次只有一个进程在执行锁里面的程序，这一段程序对于所有写上这个锁的进程，大家都变成了串行    lock.acquire()    print('%s: %s is running' %(n,os.getpid()))    time.sleep(1)    print('%s:%s is done' %(n,os.getpid()))    #解锁，解锁之后其他进程才能去执行自己的程序    lock.release()if __name__ == '__main__':    lock=Lock()    for i in range(5):        p=Process(target=work,args=(i,lock))        p.start()#打印结果：# 2: 10968 is running# 2:10968 is done# 0: 7932 is running# 0:7932 is done# 4: 4404 is running# 4:4404 is done# 1: 12852 is running# 1:12852 is done# 3: 980 is running# 3:980 is done#结果分析：（自己去多次运行一下，看看结果，我拿出其中一个结果来看）通过结果我们可以看出，多进程刚开始去执行的时候，每次运行，首先打印出来哪个进程的程序是不固定的，但是我们解决了上面打印混乱示例代码的第二个问题，那就是同一个进程中的两次打印都是先完成的，然后才切换到下一个进程去，打印下一个进程中的两个打印结果，说明我们控制住了同一进程中的代码执行顺序，如果涉及到多个进程去操作同一个数据或者文件的时候，就不担心数据算错或者文件中的内容写入混乱了。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　</p><p>　　　　上面这种情况虽然使用加锁的形式实现了顺序的执行，但是程序又重新变成串行了，这样确实会浪费了时间，却保证了数据的安全。</p><p>　　　　接下来，我们以模拟抢票为例，来看看数据安全的重要性。 </p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#注意：首先在当前文件目录下创建一个名为db的文件#文件db的内容为：{"count":1}，只有这一行数据,并且注意，每次运行完了之后，文件中的1变成了0，你需要手动将0改为1，然后在去运行代码。#注意一定要用双引号，不然json无法识别#并发运行，效率高，但竞争写同一文件，数据写入错乱from multiprocessing import Process,Lockimport time,json,random#查看剩余票数def search():    dic=json.load(open('db')) #打开文件，直接load文件中的内容，拿到文件中的包含剩余票数的字典    print('\033[43m剩余票数%s\033[0m' %dic['count'])#抢票def get():    dic=json.load(open('db'))    time.sleep(0.1)       #模拟读数据的网络延迟，那么进程之间的切换，导致所有人拿到的字典都是{"count": 1}，也就是每个人都拿到了这一票。    if dic['count'] &gt;0:        dic['count']-=1        time.sleep(0.2)   #模拟写数据的网络延迟        json.dump(dic,open('db','w'))        #最终结果导致，每个人显示都抢到了票，这就出现了问题~        print('\033[43m购票成功\033[0m')def task():    search()    get()if __name__ == '__main__':    for i in range(3): #模拟并发100个客户端抢票        p=Process(target=task)        p.start()#看结果分析：由于网络延迟等原因使得进程切换，导致每个人都抢到了这最后一张票# 剩余票数1# 剩余票数1# 剩余票数1# 购票成功# 购票成功# 购票成功</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#注意：首先在当前文件目录下创建一个名为db的文件#文件db的内容为：{"count":1}，只有这一行数据,并且注意，每次运行完了之后，文件中的1变成了0，你需要手动将0改为1，然后在去运行代码。#注意一定要用双引号，不然json无法识别#加锁保证数据安全，不出现混乱from multiprocessing import Process,Lockimport time,json,random#查看剩余票数def search():    dic=json.load(open('db')) #打开文件，直接load文件中的内容，拿到文件中的包含剩余票数的字典    print('\033[43m剩余票数%s\033[0m' %dic['count'])#抢票def get():    dic=json.load(open('db'))    time.sleep(0.1)       #模拟读数据的网络延迟，那么进程之间的切换，导致所有人拿到的字典都是{"count": 1}，也就是每个人都拿到了这一票。    if dic['count'] &gt;0:        dic['count']-=1        time.sleep(0.2)   #模拟写数据的网络延迟        json.dump(dic,open('db','w'))        #最终结果导致，每个人显示都抢到了票，这就出现了问题~        print('\033[43m购票成功\033[0m')    else:        print('sorry，没票了亲！')def task(lock):    search()    #因为抢票的时候是发生数据变化的时候，所有我们将锁加加到这里    lock.acquire()    get()    lock.release()if __name__ == '__main__':    lock = Lock() #创建一个锁    for i in range(3): #模拟并发100个客户端抢票        p=Process(target=task,args=(lock,)) #将锁作为参数传给task函数        p.start()#看结果分析：只有一个人抢到了票# 剩余票数1# 剩余票数1# 剩余票数1# 购票成功   #幸运的人儿# sorry，没票了亲！# sorry，没票了亲！</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　进程锁总结：　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。虽然可以用文件共享数据实现进程间通信，但问题是：1.效率低（共享数据基于文件，而文件是硬盘上的数据）2.需要自己加锁处理#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。队列和管道都是将数据存放于内存中队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。IPC通信机制（了解）：IPC是intent-Process Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。IPC不是某个系统所独有的，任何一个操作系统都需要有相应的IPC机制，比如Windows上可以通过剪贴板、管道和邮槽等来进行进程间通信，而Linux上可以通过命名共享内容、信号量等来进行进程间通信。Android它也有自己的进程间通信方式，Android建构在Linux基础上，继承了一部分Linux的通信方式。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>第二天进程的学习就到这里啦<del>~</del></p><p>5.队列（推荐使用）</p><p>　　　　进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的。队列就像一个特殊的列表，但是可以设置固定长度，并且从前面插入数据，从后面取出数据，先进先出。</p><pre><code>Queue([maxsize]) 创建共享的进程队列。参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁实现。</code></pre><p>　　　　<strong>先看下面的代码示例，然后再看方法介绍。</strong></p><p>　　　　queue的方法介绍</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>q = Queue([maxsize]) 创建共享的进程队列。maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁定实现。另外，还需要运行支持线程以便队列中的数据传输到底层管道中。 Queue的实例q具有以下方法：q.get( [ block [ ,timeout ] ] ) 返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。q.get_nowait( ) 同q.get(False)方法。q.put(item [, block [,timeout ] ] ) 将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。q.qsize() 返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。q.empty() 如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。q.full() 如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　queue的其他方法（了解）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>q.close() 关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在get（）操作上，关闭生产者中的队列不会导致get（）方法返回错误。q.cancel_join_thread() 不会再进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞。q.join_thread() 连接队列的后台线程。此方法用于在调用q.close()方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread()方法可以禁止这种行为。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　我们看一些代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Queueq=Queue(3) #创建一个队列对象，队列长度为3#put ,get ,put_nowait,get_nowait,full,emptyq.put(3)   #往队列中添加数据q.put(2)q.put(1)# q.put(4)   # 如果队列已经满了，程序就会停在这里，等待数据被别人取走，再将数据放入队列。           # 如果队列中的数据一直不被取走，程序就会永远停在这里。try:    q.put_nowait(4) # 可以使用put_nowait，如果队列满了不会阻塞，但是会因为队列满了而报错。except: # 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去，但是会丢掉这个消息。    print('队列已经满了')# 因此，我们再放入数据之前，可以先看一下队列的状态，如果已经满了，就不继续put了。print(q.full()) #查看是否满了，满了返回True，不满返回Falseprint(q.get())  #取出数据print(q.get())print(q.get())# print(q.get()) # 同put方法一样，如果队列已经空了，那么继续取就会出现阻塞。try:    q.get_nowait(3) # 可以使用get_nowait，如果队列满了不会阻塞，但是会因为没取到值而报错。except: # 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去。    print('队列已经空了')print(q.empty()) #空了</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#看下面的队列的时候，按照编号看注释import timefrom multiprocessing import Process, Queue# 8. q = Queue(2) #创建一个Queue对象，如果写在这里，那么在windows还子进程去执行的时候，我们知道子进程中还会执行这个代码，但是子进程中不能够再次创建了，也就是这个q就是你主进程中创建的那个q，通过我们下面在主进程中先添加了一个字符串之后，在去开启子进程，你会发现，小鬼这个字符串还在队列中，也就是说，我们使用的还是主进程中创建的这个队列。def f(q):    # q = Queue() #9. 我们在主进程中开启了一个q，如果我们在子进程中的函数里面再开一个q，那么你下面q.put('姑娘，多少钱~')添加到了新创建的这q里里面了    q.put('姑娘，多少钱~')  #4.调用主函数中p进程传递过来的进程参数 put函数为向队列中添加一条数据。    # print(q.qsize()) #6.查看队列中有多少条数据了def f2(q):    print('》》》》》》》》')    print(q.get())  #5.取数据if __name__ == '__main__':    q = Queue() #1.创建一个Queue对象    q.put('小鬼')    p = Process(target=f, args=(q,)) #2.创建一个进程    p2 = Process(target=f2, args=(q,)) #3.创建一个进程    p.start()    p2.start()    time.sleep(1) #7.如果阻塞一点时间，就会出现主进程运行太快，导致我们在子进程中查看qsize为1个。    # print(q.get()) #结果：小鬼    print(q.get()) #结果：姑娘，多少钱~    p.join()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　接下来看一个稍微复杂一些的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import osimport timeimport multiprocessing# 向queue中输入数据的函数def inputQ(queue):    info = str(os.getpid()) + '(put):' + str(time.asctime())    queue.put(info)# 向queue中输出数据的函数def outputQ(queue):    info = queue.get()    print ('%s%s\033[32m%s\033[0m'%(str(os.getpid()), '(get):',info))# Mainif __name__ == '__main__':    #windows下，如果开启的进程比较多的话，程序会崩溃，为了防止这个问题，使用freeze_support()方法来解决。知道就行啦    multiprocessing.freeze_support()    record1 = []   # store input processes    record2 = []   # store output processes    queue = multiprocessing.Queue(3)    # 输入进程    for i in range(10):        process = multiprocessing.Process(target=inputQ,args=(queue,))        process.start()        record1.append(process)    # 输出进程    for i in range(10):        process = multiprocessing.Process(target=outputQ,args=(queue,))        process.start()        record2.append(process)    for p in record1:        p.join()    for p in record2:        p.join()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　队列是进程安全的：同一时间只能一个进程拿到队列中的一个数据，你拿到了一个数据，这个数据别人就拿不到了。</p><p>　　　　下面我们来看一个叫做生产者消费者模型的东西：</p><p>　　　　　　在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</p><p>　　　　<strong>为什么要使用生产者和消费者模式</strong></p><p>　　　　　　在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</p><p>　　　　<strong>什么是生产者消费者模式</strong></p><p>　　　　　　生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力，并且我可以根据生产速度和消费速度来均衡一下多少个生产者可以为多少个消费者提供足够的服务，就可以开多进程等等，而这些进程都是到阻塞队列或者说是缓冲区中去获取或者添加数据。</p><p>　　　　通俗的解释：看图说话。。背景有点乱，等我更新~~</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180920163222371-1293192246.png" alt="img"></p><p>　　　　<strong>那么我们基于队列来实现一个生产者消费者模型，代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process,Queueimport time,random,osdef consumer(q):    while True:        res=q.get()        time.sleep(random.randint(1,3))        print('\033[45m%s 吃 %s\033[0m' %(os.getpid(),res))def producer(q):    for i in range(10):        time.sleep(random.randint(1,3))        res='包子%s' %i        q.put(res)        print('\033[44m%s 生产了 %s\033[0m' %(os.getpid(),res))if __name__ == '__main__':    q=Queue()    #生产者们:即厨师们    p1=Process(target=producer,args=(q,))    #消费者们:即吃货们    c1=Process(target=consumer,args=(q,))    #开始    p1.start()    c1.start()    print('主')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#生产者消费者模型总结    #程序中有两类角色        一类负责生产数据（生产者）        一类负责处理数据（消费者）    #引入生产者消费者模型为了解决的问题是：        平衡生产者与消费者之间的工作能力，从而提高程序整体处理数据的速度    #如何实现：        生产者&lt;--&gt;队列&lt;——&gt;消费者    #生产者消费者模型实现类程序的解耦和</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　通过上面基于队列的生产者消费者代码示例，我们发现一个问题：主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。</p><p>　　　　解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process,Queueimport time,random,osdef consumer(q):    while True:        res=q.get()        if res is None:break #收到结束信号则结束        time.sleep(random.randint(1,3))        print('\033[45m%s 吃 %s\033[0m' %(os.getpid(),res))def producer(q):    for i in range(5):        time.sleep(random.randint(1,3))        res='包子%s' %i        q.put(res)        print('\033[44m%s 生产了 %s\033[0m' %(os.getpid(),res))    q.put(None) #在自己的子进程的最后加入一个结束信号if __name__ == '__main__':    q=Queue()    #生产者们:即厨师们    p1=Process(target=producer,args=(q,))    #消费者们:即吃货们    c1=Process(target=consumer,args=(q,))    #开始    p1.start()    c1.start()    print('主')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process,Queueimport time,random,osdef consumer(q):    while True:        res=q.get()        if res is None:break #收到结束信号则结束        time.sleep(random.randint(1,3))        print('\033[45m%s 吃 %s\033[0m' %(os.getpid(),res))def producer(q):    for i in range(2):        time.sleep(random.randint(1,3))        res='包子%s' %i        q.put(res)        print('\033[44m%s 生产了 %s\033[0m' %(os.getpid(),res))if __name__ == '__main__':    q=Queue()    #生产者们:即厨师们    p1=Process(target=producer,args=(q,))    #消费者们:即吃货们    c1=Process(target=consumer,args=(q,))    #开始    p1.start()    c1.start()    p1.join() #等待生产者进程结束    q.put(None) #发送结束信号    print('主')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　但上述解决方式，在有多个生产者和多个消费者时，由于队列我们说了是进程安全的，我一个进程拿走了结束信号，另外一个进程就拿不到了，还需要多发送一个结束信号，有几个取数据的进程就要发送几个结束信号，我们则需要用一个很low的方式去解决</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process,Queueimport time,random,osdef consumer(q):    while True:        res=q.get()        if res is None:break #收到结束信号则结束        time.sleep(random.randint(1,3))        print('\033[45m%s 吃 %s\033[0m' %(os.getpid(),res))def producer(name,q):    for i in range(2):        time.sleep(random.randint(1,3))        res='%s%s' %(name,i)        q.put(res)        print('\033[44m%s 生产了 %s\033[0m' %(os.getpid(),res))if __name__ == '__main__':    q=Queue()    #生产者们:即厨师们    p1=Process(target=producer,args=('包子',q))    p2=Process(target=producer,args=('骨头',q))    p3=Process(target=producer,args=('泔水',q))    #消费者们:即吃货们    c1=Process(target=consumer,args=(q,))    c2=Process(target=consumer,args=(q,))    #开始    p1.start()    p2.start()    p3.start()    c1.start()    p1.join() #必须保证生产者全部生产完毕,才应该发送结束信号    p2.join()    p3.join()    q.put(None) #有几个消费者就应该发送几次结束信号None    q.put(None) #发送结束信号    print('主')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　其实我们的思路无非是发送结束信号而已，有另外一种队列提供了这种机制</p><p>　　　　<strong>JoinableQueue([maxsize])</strong> </p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>#JoinableQueue([maxsize])：这就像是一个Queue对象，但队列允许项目的使用者通知生成者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。   #参数介绍：    maxsize是队列中允许最大项数，省略则无大小限制。    　 #方法介绍：    JoinableQueue的实例p除了与Queue对象相同的方法之外还具有：    q.task_done()：使用者使用此方法发出信号，表示q.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常    q.join():生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用q.task_done（）方法为止，也就是队列中的数据全部被get拿走了。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process,JoinableQueueimport time,random,osdef consumer(q):    while True:        res=q.get()        # time.sleep(random.randint(1,3))        time.sleep(random.random())        print('\033[45m%s 吃 %s\033[0m' %(os.getpid(),res))        q.task_done() #向q.join()发送一次信号,证明一个数据已经被取走并执行完了def producer(name,q):    for i in range(10):        # time.sleep(random.randint(1,3))        time.sleep(random.random())        res='%s%s' %(name,i)        q.put(res)        print('\033[44m%s 生产了 %s\033[0m' %(os.getpid(),res))    print('%s生产结束'%name)    q.join() #生产完毕，使用此方法进行阻塞，直到队列中所有项目均被处理。    print('%s生产结束~~~~~~'%name)if __name__ == '__main__':    q=JoinableQueue()    #生产者们:即厨师们    p1=Process(target=producer,args=('包子',q))    p2=Process(target=producer,args=('骨头',q))    p3=Process(target=producer,args=('泔水',q))    #消费者们:即吃货们    c1=Process(target=consumer,args=(q,))    c2=Process(target=consumer,args=(q,))    c1.daemon=True #如果不加守护，那么主进程结束不了，但是加了守护之后，必须确保生产者的内容生产完并且被处理完了，所有必须还要在主进程给生产者设置join，才能确保生产者生产的任务被执行完了，并且能够确保守护进程在所有任务执行完成之后才随着主进程的结束而结束。    c2.daemon=True    #开始    p_l=[p1,p2,p3,c1,c2]    for p in p_l:        p.start()    p1.join() #我要确保你的生产者进程结束了，生产者进程的结束标志着你生产的所有的人任务都已经被处理完了    p2.join()    p3.join()    print('主')    # 主进程等---&gt;p1,p2,p3等----&gt;c1,c2    # p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据    # 因而c1,c2也没有存在的价值了,不需要继续阻塞在进程中影响主进程了。应该随着主进程的结束而结束,所以设置成守护进程就可以了。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>6.管道（了解）</p><p>　　　　进程间通信（IPC）方式二：管道（不推荐使用，了解即可），会导致数据不安全的情况出现，后面我们会说到为什么会带来数据 不安全的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#创建管道的类：Pipe([duplex]):在进程之间创建一条管道，并返回元组（conn1,conn2）,其中conn1，conn2表示管道两端的连接对象，强调一点：必须在产生Process对象之前产生管道#参数介绍：dumplex:默认管道是全双工的，如果将duplex射成False，conn1只能用于接收，conn2只能用于发送。#主要方法：    conn1.recv():接收conn2.send(obj)发送的对象。如果没有消息可接收，recv方法会一直阻塞。如果连接的另外一端已经关闭，那么recv方法会抛出EOFError。    conn1.send(obj):通过连接发送对象。obj是与序列化兼容的任意对象 #其他方法：conn1.close():关闭连接。如果conn1被垃圾回收，将自动调用此方法conn1.fileno():返回连接使用的整数文件描述符conn1.poll([timeout]):如果连接上的数据可用，返回True。timeout指定等待的最长时限。如果省略此参数，方法将立即返回结果。如果将timeout射成None，操作将无限期地等待数据到达。conn1.recv_bytes([maxlength]):接收c.send_bytes()方法发送的一条完整的字节消息。maxlength指定要接收的最大字节数。如果进入的消息，超过了这个最大值，将引发IOError异常，并且在连接上无法进行进一步读取。如果连接的另外一端已经关闭，再也不存在任何数据，将引发EOFError异常。conn.send_bytes(buffer [, offset [, size]])：通过连接发送字节数据缓冲区，buffer是支持缓冲区接口的任意对象，offset是缓冲区中的字节偏移量，而size是要发送字节数。结果数据以单条消息的形式发出，然后调用c.recv_bytes()函数进行接收    conn1.recv_bytes_into(buffer [, offset]):接收一条完整的字节消息，并把它保存在buffer对象中，该对象支持可写入的缓冲区接口（即bytearray对象或类似的对象）。offset指定缓冲区中放置消息处的字节位移。返回值是收到的字节数。如果消息长度大于可用的缓冲区空间，将引发BufferTooShort异常。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process, Pipedef f(conn):    conn.send("Hello 妹妹") #子进程发送了消息    conn.close()if __name__ == '__main__':    parent_conn, child_conn = Pipe() #建立管道，拿到管道的两端，双工通信方式，两端都可以收发消息    p = Process(target=f, args=(child_conn,)) #将管道的一段给子进程    p.start() #开启子进程    print(parent_conn.recv()) #主进程接受了消息    p.join()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180921153111478-850184201.png" alt="img"></p><p>　　　　应该特别注意管道端点的正确管理问题。<strong>如果是生产者或消费者中都没有使用管道的某个端点，就应将它关闭</strong>。这也说明了为何在<strong>生产者中关闭了管道的输出端，在消费者中关闭管道的输入端</strong>。如果忘记执行这些步骤，程序可能在消费者中的recv（）操作上挂起（就是阻塞）。管道是由操作系统进行引用计数的，必须在所有进程中关闭管道的相同一端就会能生成EOFError异常。因此，在生产者中关闭管道不会有任何效果，除非消费者也关闭了相同的管道端点。 　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process, Pipedef f(parent_conn,child_conn):    #parent_conn.close() #不写close将不会引发EOFError    while True:        try:            print(child_conn.recv())        except EOFError:            child_conn.close()            breakif __name__ == '__main__':    parent_conn, child_conn = Pipe()    p = Process(target=f, args=(parent_conn,child_conn,))    p.start()    child_conn.close()    parent_conn.send('hello')    parent_conn.close()    p.join()            </code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　主进程将管道的两端都传送给子进程，子进程和主进程共用管道的两种报错情况，都是在recv接收的时候报错的：</p><p>　　　　1.主进程和子进程中的管道的相同一端都关闭了，出现EOFError；</p><p>　　　　2.如果你管道的一端在主进程和子进程中都关闭了，但是你还用这个关闭的一端去接收消息，那么就会出现OSError；</p><p>　　　　所以你关闭管道的时候，就容易出现问题，需要将所有只用这个管道的进程中的两端全部关闭才行。当然也可以通过异常捕获（try：except EOFerror）来处理。</p><p>　　　　虽然我们在主进程和子进程中都打印了一下conn1一端的对象，发现两个不再同一个地址，但是子进程中的管道和主进程中的管道还是可以通信的，因为管道是同一套，系统能够记录。　　　　</p><p>　　　　我们的目的就是关闭所有的管道，那么主进程和子进程进行通信的时候，可以给子进程传管道的一端就够了，并且用我们之前学到的，信息发送完之后，再发送一个结束信号None，那么你收到的消息为None的时候直接结束接收或者说结束循环，就不用每次都关闭各个进程中的管道了。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Pipe,Processdef func(conn):    while True:        msg = conn.recv()        if msg is None:break        print(msg)if __name__ == '__main__':    conn1,conn2 = Pipe()    p = Process(target=func,args=(conn1,))    p.start()    for i in range(10):        conn2.send('约吧')    conn2.send(None)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process,Pipedef consumer(p,name):    produce, consume=p    produce.close()    while True:        try:            baozi=consume.recv()            print('%s 收到包子:%s' %(name,baozi))        except EOFError:            breakdef producer(seq,p):    produce, consume=p    consume.close()    for i in seq:        produce.send(i)if __name__ == '__main__':    produce,consume=Pipe()    c1=Process(target=consumer,args=((produce,consume),'c1'))    c1.start()    seq=(i for i in range(10))    producer(seq,(produce,consume))    produce.close()    consume.close()    c1.join()    print('主进程')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　</p><p>　　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>关于管道会造成数据不安全问题的官方解释：    The two connection objects returned by Pipe() represent the two ends of the pipe. Each connection object has send() and recv() methods (among others). Note that data in a pipe may become corrupted if two processes (or threads) try to read from or write to the same end of the pipe at the same time. Of course there is no risk of corruption from processes using different ends of the pipe at the same time.        由Pipe方法返回的两个连接对象表示管道的两端。每个连接对象都有send和recv方法（除其他之外）。注意，如果两个进程（或线程）试图同时从管道的同一端读取或写入数据，那么管道中的数据可能会损坏。当然，在使用管道的不同端部的过程中不存在损坏风险。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process,Pipe,Lockdef consumer(p,name,lock):    produce, consume=p    produce.close()    while True:        lock.acquire()        baozi=consume.recv()        lock.release()        if baozi:            print('%s 收到包子:%s' %(name,baozi))        else:            consume.close()            breakdef producer(p,n):    produce, consume=p    consume.close()    for i in range(n):        produce.send(i)    produce.send(None)    produce.send(None)    produce.close()if __name__ == '__main__':    produce,consume=Pipe()    lock = Lock()    c1=Process(target=consumer,args=((produce,consume),'c1',lock))    c2=Process(target=consumer,args=((produce,consume),'c2',lock))    p1=Process(target=producer,args=((produce,consume),10))    c1.start()    c2.start()    p1.start()    produce.close()    consume.close()    c1.join()    c2.join()    p1.join()    print('主进程')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　管道可以用于双工通信，通常利用在客户端/服务端中使用的请求/响应模型，或者远程过程调用，就可以使用管道编写与进程交互的程序，像前面将网络通信的时候，我们使用了一个叫subprocess的模块，里面有个参数是pipe管道，执行系统指令，并通过管道获取结果。</p><p>7.数据共享（了解）</p><p>　　　　展望未来，基于消息传递的并发编程是大势所趋</p><p>　　　　即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合</p><p>　　　　通过消息队列交换数据。这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中</p><p>　　　　<strong>进程间应该尽量避免通信，即便需要通信，也应该选择进程安全的工具来避免加锁带来的问题，应该尽量避免使用本节所讲的共享数据的方式，以后我们会尝试使用数据库来解决进程之间的数据共享问题。</strong></p><p>　　　　进程之间数据共享的模块之一Manager模块：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此A manager object returned by Manager() controls a server process which holds Python objects and allows other processes to manipulate them using proxies.A manager returned by Manager() will support types list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array.</code></pre><p> 　　多进程共同去处理共享数据的时候，就和我们多进程同时去操作一个文件中的数据是一样的，不加锁就会出现错误的结果，进程不安全的，所以也需要加锁</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Manager,Process,Lockdef work(d,lock):    with lock: #不加锁而操作共享的数据,肯定会出现数据错乱        d['count']-=1if __name__ == '__main__':    lock=Lock()    with Manager() as m:        dic=m.dict({'count':100})        p_l=[]        for i in range(100):            p=Process(target=work,args=(dic,lock))            p_l.append(p)            p.start()        for p in p_l:            p.join()        print(dic)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>总结一下，进程之间的通信：队列、管道、数据共享也算</p><p>下面要讲的信号量和事件也相当于锁，也是全局的，所有进程都能拿到这些锁的状态，进程之间这些锁啊信号量啊事件啊等等的通信，其实底层还是socekt，只不过是基于文件的socket通信，而不是跟上面的数据共享啊空间共享啊之类的机制，我们之前学的是基于网络的socket通信，还记得socket的两个家族吗，一个文件的一个网络的，所以将来如果说这些锁之类的报错，可能你看到的就是类似于socket的错误，简单知道一下就可以啦<del>~</del></p><p>工作中常用的是锁，信号量和事件不常用，但是信号量和事件面试的时候会问到，你能知道就行啦<del>~</del></p><p>8.信号量（了解）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>互斥锁同时只允许一个线程更改数据，而信号量Semaphore是同时允许一定数量的线程更改数据 。假设商场里有4个迷你唱吧，所以同时可以进去4个人，如果来了第五个人就要在外面等待，等到有人出来才能再进去玩。实现：信号量同步基于内部计数器，每调用一次acquire()，计数器减1；每调用一次release()，计数器加1.当计数器为0时，acquire()调用被阻塞。这是迪科斯彻（Dijkstra）信号量概念P()和V()的Python实现。信号量同步机制适用于访问像服务器这样的有限资源。信号量与进程池的概念很像，但是要区分开，信号量涉及到加锁的概念</code></pre><p> 　　比如大保健：提前设定好，一个房间只有4个床（计数器现在为4），那么同时只能四个人进来，谁先来的谁先占一个床（acquire，计数器减1），4个床满了之后（计数器为0了），第五个人就要等着，等其中一个人出来（release，计数器加1），他就去占用那个床了。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process,Semaphoreimport time,randomdef go_ktv(sem,user):    sem.acquire()    print('%s 占到一间ktv小屋' %user)    time.sleep(random.randint(0,3)) #模拟每个人在ktv中待的时间不同    sem.release()if __name__ == '__main__':    sem=Semaphore(4)    p_l=[]    for i in range(13):        p=Process(target=go_ktv,args=(sem,'user%s' %i,))        p.start()        p_l.append(p)    for i in p_l:        i.join()    print('============》')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>9.事件（了解）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 set、wait、clear。    事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。clear：将“Flag”设置为Falseset：将“Flag”设置为True</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process,Semaphore,Eventimport time,randome = Event() #创建一个事件对象print(e.is_set())  #is_set()查看一个事件的状态，默认为False，可通过set方法改为Trueprint('look here！')# e.set()          #将is_set()的状态改为True。# print(e.is_set())#is_set()查看一个事件的状态，默认为False，可通过set方法改为Tr# e.clear()        #将is_set()的状态改为False# print(e.is_set())#is_set()查看一个事件的状态，默认为False，可通过set方法改为Tre.wait()           #根据is_set()的状态结果来决定是否在这阻塞住，is_set()=False那么就阻塞，is_set()=True就不阻塞print('give me！！')#set和clear  修改事件的状态 set--&gt;True   clear--&gt;False#is_set     用来查看一个事件的状态#wait       依据事件的状态来决定是否阻塞 False--&gt;阻塞  True--&gt;不阻塞</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Process, Eventimport time, randomdef car(e, n):    while True:        if not e.is_set():  # 进程刚开启，is_set()的值是Flase，模拟信号灯为红色            print('\033[31m红灯亮\033[0m，car%s等着' % n)            e.wait()    # 阻塞，等待is_set()的值变成True，模拟信号灯为绿色            print('\033[32m车%s 看见绿灯亮了\033[0m' % n)            time.sleep(random.randint(2,4))            if not e.is_set():   #如果is_set()的值是Flase，也就是红灯，仍然回到while语句开始                continue            print('车开远了,car', n)            break# def police_car(e, n):#     while True:#         if not e.is_set():# 进程刚开启，is_set()的值是Flase，模拟信号灯为红色#             print('\033[31m红灯亮\033[0m，car%s等着' % n)#             e.wait(0.1) # 阻塞，等待设置等待时间，等待0.1s之后没有等到绿灯就闯红灯走了#             if not e.is_set():#                 print('\033[33m红灯,警车先走\033[0m，car %s' % n)#             else:#                 print('\033[33;46m绿灯，警车走\033[0m，car %s' % n)#         breakdef traffic_lights(e, inverval):    while True:        time.sleep(inverval)        if e.is_set():            print('######', e.is_set())            e.clear()  # ----&gt;将is_set()的值设置为False        else:            e.set()    # ----&gt;将is_set()的值设置为True            print('***********',e.is_set())if __name__ == '__main__':    e = Event()    for i in range(10):        p=Process(target=car,args=(e,i,))  # 创建10个进程控制10辆车        time.sleep(random.random(1, 3))    #车不是一下子全过来        p.start()    # for i in range(5):    #     p = Process(target=police_car, args=(e, i,))  # 创建5个进程控制5辆警车    #     p.start()    #信号灯必须是单独的进程，因为它不管你车开到哪了，我就按照我红绿灯的规律来闪烁变换，对吧    t = Process(target=traffic_lights, args=(e, 5))  # 创建一个进程控制红绿灯    t.start()    print('预备~~~~开始！！！')</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="八-进程池和mutiprocess-Poll"><a href="#八-进程池和mutiprocess-Poll" class="headerlink" title="八 进程池和mutiprocess.Poll"></a>八 进程池和mutiprocess.Poll</h3><p>　　为什么要有进程池?进程池的概念。</p><p>　　在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程（空间，变量，文件信息等等的内容）也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，维护一个很大的进程列表的同时，调度的时候，还需要进行切换并且记录每个进程的执行节点，也就是记录上下文（各种变量等等乱七八糟的东西，虽然你看不到，但是操作系统都要做），这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。就看我们上面的一些代码例子，你会发现有些程序是不是执行的时候比较慢才出结果，就是这个原因，那么我们要怎么做呢？</p><p>　　在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果</p><p>multiprocess.Poll模块</p><p> 　　<strong>创建进程池的类：如果指定numprocess为3，则进程池会从无到有创建三个进程，然后自始至终使用这三个进程去执行所有任务（高级一些的进程池可以根据你的并发量，搞成动态增加或减少进程池中的进程数量的操作），不会开启其他进程，提高操作系统效率，减少空间的占用等。</strong></p><p> 　　概念介绍：</p><pre><code>Pool([numprocess  [,initializer [, initargs]]]):创建进程池</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值initializer：是每个工作进程启动时要执行的可调用对象，默认为Noneinitargs：是要传给initializer的参数组</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>p.apply(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。'''需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()'''p.apply_async(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。'''此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。'''p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成P.jion():等待所有工作进程退出。此方法只能在close（）或teminate()之后调用</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。obj.ready():如果调用完成，返回Trueobj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常obj.wait([timeout]):等待结果变为可用。obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timefrom multiprocessing import Pool,Process#针对range(100)这种参数的# def func(n):#     for i in range(3):#         print(n + 1)def func(n):    print(n)    # 结果：    #     (1, 2)    #     alexdef func2(n):    for i in range(3):        print(n - 1)if __name__ == '__main__':    #1.进程池的模式    s1 = time.time()  #我们计算一下开多进程和进程池的执行效率    poll = Pool(5) #创建含有5个进程的进程池    # poll.map(func,range(100)) #异步调用进程，开启100个任务,map自带join的功能    poll.map(func,[(1,2),'alex']) #异步调用进程，开启100个任务,map自带join的功能    # poll.map(func2,range(100))  #如果想让进程池完成不同的任务，可以直接这样搞    #map只限于接收一个可迭代的数据类型参数，列表啊，元祖啊等等，如果想做其他的参数之类的操作，需要用后面我们要学的方法。    # t1 = time.time() - s1    #    # #2.多进程的模式    # s2 = time.time()    # p_list = []    # for i in range(100):    #     p = Process(target=func,args=(i,))    #     p_list.append(p)    #     p.start()    # [pp.join() for pp in p_list]    # t2 = time.time() - s2    #    # print('t1&gt;&gt;',t1) #结果：0.5146853923797607s 进程池的效率高    # print('t2&gt;&gt;',t2) #结果：12.092015027999878s</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　有一点，map是异步执行的，并且自带close和join</p><p>　　一般约定俗成的是进程池中的进程数量为CPU的数量，工作中要看具体情况来考量。</p><p>　　实际应用代码示例：</p><p>　　<strong>同步与异步两种执行方式：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import os,timefrom multiprocessing import Pooldef work(n):    print('%s run' %os.getpid())    time.sleep(1)    return n**2if __name__ == '__main__':    p=Pool(3) #进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务    res_l=[]    for i in range(10):        res=p.apply(work,args=(i,)) # 同步调用，直到本次任务执行完毕拿到res，等待任务work执行的过程中可能有阻塞也可能没有阻塞                                    # 但不管该任务是否存在阻塞，同步调用都会在原地等着        res_l.append(res)    print(res_l)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import osimport timeimport randomfrom multiprocessing import Pooldef work(n):    print('%s run' %os.getpid())    time.sleep(random.random())    return n**2if __name__ == '__main__':    p=Pool(3) #进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务    res_l=[]    for i in range(10):        res=p.apply_async(work,args=(i,)) # 异步运行，根据进程池中有的进程数，每次最多3个子进程在异步执行，并且可以执行不同的任务，传送任意的参数了。                                          # 返回结果之后，将结果放入列表，归还进程，之后再执行新的任务                                          # 需要注意的是，进程池中的三个进程不会同时开启或者同时结束                                          # 而是执行完一个就释放一个进程，这个进程就去接收新的任务。          res_l.append(res)    # 异步apply_async用法：如果使用异步提交的任务，主进程需要使用join，等待进程池内任务都处理完，然后可以用get收集结果    # 否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了    p.close() #不是关闭进程池，而是结束进程池接收任务，确保没有新任务再提交过来。    p.join()   #感知进程池中的任务已经执行结束，只有当没有新的任务添加进来的时候，才能感知到任务结束了，所以在join之前必须加上close方法    for res in res_l:        print(res.get()) #使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#一：使用进程池（异步调用,apply_async）#coding: utf-8from multiprocessing import Process,Poolimport timedef func(msg):    print( "msg:", msg)    time.sleep(1)    return msgif __name__ == "__main__":    pool = Pool(processes = 3)    res_l=[]    for i in range(10):        msg = "hello %d" %(i)        res=pool.apply_async(func, (msg, ))   #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去        res_l.append(res)        # s = res.get() #如果直接用res这个结果对象调用get方法获取结果的话，这个程序就变成了同步，因为get方法直接就在这里等着你创建的进程的结果，第一个进程创建了，并且去执行了，那么get就会等着第一个进程的结果，没有结果就一直等着，那么主进程的for循环是无法继续的，所以你会发现变成了同步的效果    print("==============================&gt;") #没有后面的join，或get，则程序整体结束，进程池中的任务还没来得及全部执行完也都跟着主进程一起结束了    pool.close() #关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成    pool.join()   #调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束    print(res_l) #看到的是&lt;multiprocessing.pool.ApplyResult object at 0x10357c4e0&gt;对象组成的列表,而非最终的结果,但这一步是在join后执行的,证明结果已经计算完毕,剩下的事情就是调用每个对象下的get方法去获取结果    for i in res_l:        print(i.get()) #使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get#二：使用进程池（同步调用,apply）#coding: utf-8from multiprocessing import Process,Poolimport timedef func(msg):    print( "msg:", msg)    time.sleep(0.1)    return msgif __name__ == "__main__":    pool = Pool(processes = 3)    res_l=[]    for i in range(10):        msg = "hello %d" %(i)        res=pool.apply(func, (msg, ))   #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去        res_l.append(res) #同步执行，即执行完一个拿到结果，再去执行另外一个    print("==============================&gt;")    pool.close()    pool.join()   #调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束    print(res_l) #看到的就是最终的结果组成的列表    for i in res_l: #apply是同步的，所以直接得到结果，没有get()方法        print(i)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>进程池版的socket并发聊天代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#Pool内的进程数默认是cpu核数，假设为4（查看方法os.cpu_count()）#开启6个客户端，会发现2个客户端处于等待状态#在每个进程内查看pid，会发现pid使用为4个，即多个客户端公用4个进程from socket import *from multiprocessing import Poolimport osserver=socket(AF_INET,SOCK_STREAM)server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)server.bind(('127.0.0.1',8080))server.listen(5)def talk(conn):    print('进程pid: %s' %os.getpid())    while True:        try:            msg=conn.recv(1024)            if not msg:break            conn.send(msg.upper())        except Exception:            breakif __name__ == '__main__':    p=Pool(4)    while True:        conn,*_=server.accept()        p.apply_async(talk,args=(conn,))        # p.apply(talk,args=(conn,client_addr)) #同步的话，则同一时间只有一个客户端能访问</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *client=socket(AF_INET,SOCK_STREAM)client.connect(('127.0.0.1',8080))while True:    msg=input('&gt;&gt;: ').strip()    if not msg:continue    client.send(msg.encode('utf-8'))    msg=client.recv(1024)    print(msg.decode('utf-8'))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　</p><p> 　　发现：并发开启多个客户端，服务端同一时间只有4个不同的pid，只能结束一个客户端，另外一个客户端才会进来.</p><p> 　　同时最多和4个人进行聊天，因为进程池中只有4个进程可供调用，那有同学会问，我们这么多人想同时聊天怎么办，又不让用多进程，进程池也不能开太多的进程，那咋整啊，后面我们会学到多线程，到时候大家就知道了，现在你们先这样记住就好啦</p><p> 　　然后我们再提一个回调函数</p><pre><code>需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数，这是进程池特有的，普通进程没有这个机制，但是我们也可以通过进程通信来拿到返回值，进程池的这个回调也是进程通信的机制完成的。我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I/O的过程，直接拿到的是任务的结果</code></pre><p>　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import osfrom multiprocessing import Pooldef func1(n):    print('func1&gt;&gt;',os.getpid())    print('func1')    return n*ndef func2(nn):    print('func2&gt;&gt;',os.getpid())    print('func2')    print(nn)    # import time    # time.sleep(0.5)if __name__ == '__main__':    print('主进程：',os.getpid())    p = Pool(5)    #args里面的10给了func1，func1的返回值作为回调函数的参数给了callback对应的函数，不能直接给回调函数直接传参数，他只能是你任务函数func1的函数的返回值    # for i in range(10,20): #如果是多个进程来执行任务，那么当所有子进程将结果给了回调函数之后，回调函数又是在主进程上执行的，那么就会出现打印结果是同步的效果。我们上面func2里面注销的时间模块打开看看    #     p.apply_async(func1,args=(i,),callback=func2)    p.apply_async(func1,args=(10,),callback=func2)    p.close()    p.join()#结果# 主进程： 11852  #发现回调函数是在主进程中完成的，其实如果是在子进程中完成的，那我们直接将代码写在子进程的任务函数func1里面就行了，对不对，这也是为什么称为回调函数的原因。# func1&gt;&gt; 17332# func1# func2&gt;&gt; 11852# func2# 100</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　回调函数在写的时候注意一点，回调函数的形参执行有一个，如果你的执行函数有多个返回值，那么也可以被回调函数的这一个形参接收，接收的是一个元祖，包含着你执行函数的所有返回值。</p><p>　　</p><p>　　使用进程池来搞爬虫的时候，最耗时间的是请求地址的网络请求延迟，那么如果我们在将处理数据的操作加到每个子进程中，那么所有在进程池后面排队的进程就需要等更长的时间才能获取进程池里面的执行进程来执行自己，所以一般我们就将请求作成一个执行函数，通过进程池去异步执行，剩下的数据处理的内容放到另外一个进程或者主进程中去执行，将网络延迟的时间也利用起来，效率更高。</p><p>　　requests这个模块的get方法请求页面，就和我们在浏览器上输入一个网址然后回车去请求别人的网站的效果是一样的。安装requests模块的指令：在cmd窗口执行pip install requests。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>import requestsresponse = requests.get('http://www.baidu.com')print(response)print(response.status_code) #200正常，404找不到网页，503等5开头的是人家网站内部错误print(response.content.decode('utf-8'))</code></pre><p>　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Poolimport requestsimport jsonimport osdef get_page(url):    print('&lt;进程%s&gt; get %s' %(os.getpid(),url))    respone=requests.get(url)    if respone.status_code == 200:        return {'url':url,'text':respone.text}def pasrse_page(res):    print('&lt;进程%s&gt; parse %s' %(os.getpid(),res['url']))    parse_res='url:&lt;%s&gt; size:[%s]\n' %(res['url'],len(res['text']))    with open('db.txt','a') as f:        f.write(parse_res)if __name__ == '__main__':    urls=[        'https://www.baidu.com',        'https://www.python.org',        'https://www.openstack.org',        'https://help.github.com/',        'http://www.sina.com.cn/'    ]    p=Pool(3)    res_l=[]    for url in urls:        res=p.apply_async(get_page,args=(url,),callback=pasrse_page)        res_l.append(res)    p.close()    p.join()    print([res.get() for res in res_l]) #拿到的是get_page的结果,其实完全没必要拿该结果,该结果已经传给回调函数处理了'''打印结果:&lt;进程3388&gt; get https://www.baidu.com&lt;进程3389&gt; get https://www.python.org&lt;进程3390&gt; get https://www.openstack.org&lt;进程3388&gt; get https://help.github.com/&lt;进程3387&gt; parse https://www.baidu.com&lt;进程3389&gt; get http://www.sina.com.cn/&lt;进程3387&gt; parse https://www.python.org&lt;进程3387&gt; parse https://help.github.com/&lt;进程3387&gt; parse http://www.sina.com.cn/&lt;进程3387&gt; parse https://www.openstack.org[{'url': 'https://www.baidu.com', 'text': '&lt;!DOCTYPE html&gt;\r\n...',...}]'''</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Poolimport time,randomimport requestsimport redef get_page(url,pattern):    response=requests.get(url)    if response.status_code == 200:        return (response.text,pattern)def parse_page(info):    page_content,pattern=info    res=re.findall(pattern,page_content)    for item in res:        dic={            'index':item[0],            'title':item[1],            'actor':item[2].strip()[3:],            'time':item[3][5:],            'score':item[4]+item[5]        }        print(dic)if __name__ == '__main__':    pattern1=re.compile(r'&lt;dd&gt;.*?board-index.*?&gt;(\d+)&lt;.*?title="(.*?)".*?star.*?&gt;(.*?)&lt;.*?releasetime.*?&gt;(.*?)&lt;.*?integer.*?&gt;(.*?)&lt;.*?fraction.*?&gt;(.*?)&lt;',re.S)    url_dic={        'http://maoyan.com/board/7':pattern1,    }    p=Pool()    res_l=[]    for url,pattern in url_dic.items():        res=p.apply_async(get_page,args=(url,pattern),callback=parse_page)        res_l.append(res)    for i in res_l:        i.get()    # res=requests.get('http://maoyan.com/board/7')    # print(re.findall(pattern,res.text))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>如果在主进程中等待进程池中所有任务都执行完毕后，再统一处理结果，则无需回调函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Poolimport time,random,osdef work(n):    time.sleep(1)    return n**2if __name__ == '__main__':    p=Pool()    res_l=[]    for i in range(10):        res=p.apply_async(work,args=(i,))        res_l.append(res)    p.close()    p.join() #等待进程池中所有进程执行完毕    nums=[]    for res in res_l:        nums.append(res.get()) #拿到所有结果    print(nums) #主进程拿到所有的处理结果,可以在主进程中进行统一进行处理</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　进程池和信号量的区别：</p><p>　　进程池是多个需要被执行的任务在进程池外面排队等待获取进程对象去执行自己，而信号量是一堆进程等待着去执行一段逻辑代码。</p><p>　　信号量不能控制创建多少个进程，但是可以控制同时多少个进程能够执行，但是进程池能控制你可以创建多少个进程。</p><p>　　举例：就像那些开大车拉煤的，信号量是什么呢，就好比我只有五个车道，你每次只能过5辆车，但是不影响你创建100辆车，但是进程池相当于什么呢？相当于你只有5辆车，每次5个车拉东西，拉完你再把车放回来，给别的人拉煤用。</p><p>　　其他语言里面有更高级的进程池，在设置的时候，可以将进程池中的进程动态的创建出来，当需求增大的时候，就会自动在进程池中添加进程，需求小的时候，自动减少进程，并且可以设置进程数量的上线，最多为多，python里面没有。</p><p>　　<a href="https://docs.python.org/dev/library/concurrent.futures.html"><strong>进程池的其他实现方式：https://docs.python.org/dev/library/concurrent.futures.html</strong></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之IO多路复用</title>
      <link href="2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/python%E4%B9%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/python%E4%B9%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="python之IO多路复用"><a href="#python之IO多路复用" class="headerlink" title="python之IO多路复用"></a><a href="https://www.cnblogs.com/clschao/articles/9713797.html">python之IO多路复用</a></h1><p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/clschao/articles/9713797.html#_label1">一 IO模型介绍</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9713797.html#_label2">二 阻塞IO(blocking IO)</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9713797.html#_label3">三 非阻塞IO(non-blocking IO)</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9713797.html#_label4">四 多路复用IO(IO multiplexing)</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9713797.html#_label5">五 异步IO(Asynchronous I/O)</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9713797.html#_label6">六 IO模型比较分析</a></li><li><a href="https://www.cnblogs.com/clschao/articles/9713797.html#_label7">七 selectors模块</a></li></ul><h3 id="一-IO模型介绍"><a href="#一-IO模型介绍" class="headerlink" title="一 IO模型介绍"></a>一 IO模型介绍</h3><p><a href="http://www.cnblogs.com/linhaifeng/articles/7430066.html#_label4"> </a></p><p>　　同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，我先限定一下本文的上下文。</p><p>　　本文讨论的背景是Linux环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I/O Models ”，Stevens在这节中详细说明了各种IO的特点和区别，如果英文够好的话，推荐直接阅读。Stevens的文风是有名的深入浅出，所以不用担心看不懂。本文中的流程图也是截取自参考文献。</p><p>　　Stevens在文章中一共比较了五种IO Model：<br>　　* blocking IO          阻塞IO<br>　　* nonblocking IO    非阻塞IO<br>　　* IO multiplexing    IO多路复用<br>　　* signal driven IO   信号驱动IO（不常见，不讲）<br>　　* asynchronous IO 异步IO<br>　　由signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model。</p><p>　　再说一下IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read、recv举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read/recv读数据的操作发生时，该操作会经历两个阶段：</p><pre><code>#1）等待数据准备 (Waiting for the data to be ready)#2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</code></pre><p>　　记住这两点很重要，因为这些IO模型的区别就是在两个阶段上各有不同的情况。</p><p>　　补充：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></p><pre><code>#1、输入操作：read、readv、recv、recvfrom、recvmsg共5个函数，如果会阻塞状态，则会经理wait data和copy data两个阶段，如果设置为非阻塞则在wait 不到data时抛出异常#2、输出操作：write、writev、send、sendto、sendmsg共5个函数，在发送缓冲区满了会阻塞在原地，如果设置为非阻塞，则会抛出异常#3、接收外来链接：accept，与输入操作类似#4、发起外出链接：connect，与输出操作类似</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="二-阻塞IO-blocking-IO"><a href="#二-阻塞IO-blocking-IO" class="headerlink" title="二 阻塞IO(blocking IO)"></a>二 阻塞IO(blocking IO)</h3><p>　　在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：（recvfrom和tcp里面的recv在这些IO模型里面是一样的）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/1036857-20170831215423765-2063960072.png" alt="img"></p><p>　　上面的图形分析：两个阶段的阻塞</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180927164450341-1028249965.png" alt="img"></p><p>　　当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。</p><p>　　而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>　　<strong>所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。</strong></p><p>　　<strong>这里我们回顾一下同步/异步/阻塞/非阻塞：</strong></p><p>　　　　<strong>同步：提交一个任务之后要等待这个任务执行完毕</strong></p><p>　　　　<strong>异步：只管提交任务，不等待这个任务执行完毕就可以去做其他的事情</strong></p><p>　　　　<strong>阻塞：recv、recvfrom、accept，线程阶段  运行状态–&gt;阻塞状态–&gt;就绪</strong></p><p>　　　　<strong>非阻塞：没有阻塞状态</strong></p><p>　　<strong>在一个线程的IO模型中，我们recv的地方阻塞，我们就开启多线程，但是不管你开启多少个线程，这个recv的时间是不是没有被规避掉，不管是多线程还是多进程都没有规避掉这个IO时间。</strong></p><p>　　几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv() 等接口开始的，使用这些接口可以很方便的构建服务器/客户机的模型。然而大部分的socket接口都是阻塞型的。如下图</p><p>　　ps：所谓阻塞型接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/1036857-20170831220441233-1942812160.png" alt="img"></p><p>　　实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。</p><p>　　一个简单的解决方案：</p><pre><code>#在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。</code></pre><p>　　该方案的问题是：</p><pre><code>#开启多进程或都线程的方式，在遇到要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态。</code></pre><p>　　改进方案：    </p><pre><code>#很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。</code></pre><p>　　改进后方案其实也存在着问题：</p><pre><code>#“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。</code></pre><p>　　<strong>对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</strong></p><h3 id="三-非阻塞IO"><a href="#三-非阻塞IO" class="headerlink" title="三 非阻塞IO"></a>三 非阻塞IO</h3><p>　　Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/1036857-20170831221803468-1908924864.png" alt="img"></p><p>　　从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是用户就可以在本次到下次再发起read询问的时间间隔内做其他事情，或者直接再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存（这一阶段仍然是阻塞的），然后返回。</p><p>　　也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p><p>　　<strong>所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。</strong></p><p>　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code># 服务端import socketimport timeserver=socket.socket()server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)server.bind(('127.0.0.1',8083))server.listen(5)server.setblocking(False) #设置不阻塞r_list=[]  #用来存储所有来请求server端的conn连接w_list={}  #用来存储所有已经有了请求数据的conn的请求数据while 1:    try:        conn,addr=server.accept() #不阻塞，会报错        r_list.append(conn)  #为了将连接保存起来，不然下次循环的时候，上一次的连接就没有了    except BlockingIOError:        # 强调强调强调：！！！非阻塞IO的精髓在于完全没有阻塞！！！        # time.sleep(0.5) # 打开该行注释纯属为了方便查看效果        print('在做其他的事情')        print('rlist: ',len(r_list))        print('wlist: ',len(w_list))        # 遍历读列表，依次取出套接字读取内容        del_rlist=[] #用来存储删除的conn连接        for conn in r_list:            try:                data=conn.recv(1024) #不阻塞，会报错                if not data: #当一个客户端暴力关闭的时候，会一直接收b''，别忘了判断一下数据                    conn.close()                    del_rlist.append(conn)                    continue                w_list[conn]=data.upper()            except BlockingIOError: # 没有收成功，则继续检索下一个套接字的接收                continue            except ConnectionResetError: # 当前套接字出异常，则关闭，然后加入删除列表，等待被清除                conn.close()                del_rlist.append(conn)        # 遍历写列表，依次取出套接字发送内容        del_wlist=[]        for conn,data in w_list.items():            try:                conn.send(data)                del_wlist.append(conn)            except BlockingIOError:                continue        # 清理无用的套接字,无需再监听它们的IO操作        for conn in del_rlist:            r_list.remove(conn)        #del_rlist.clear() #清空列表中保存的已经删除的内容        for conn in del_wlist:            w_list.pop(conn)        #del_wlist.clear()#客户端import socketimport osimport timeimport threadingclient=socket.socket()client.connect(('127.0.0.1',8083))while 1:    res=('%s hello' %os.getpid()).encode('utf-8')    client.send(res)    data=client.recv(1024)    print(data.decode('utf-8'))##多线程的客户端请求版本# def func():#     sk = socket.socket()#     sk.connect(('127.0.0.1',9000))#     sk.send(b'hello')#     time.sleep(1)#     print(sk.recv(1024))#     sk.close()## for i in range(20):#     threading.Thread(target=func).start()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>虽然我们上面的代码通过设置非阻塞，规避了IO操作，但是非阻塞IO模型绝不被推荐。</strong></p><p>　　我们不能否则其优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在“”同时“”执行）。</p><p>　　但是也难掩其缺点：</p><pre><code>#1. 循环调用recv()将大幅度推高CPU占用率；这也是我们在代码中留一句time.sleep(2)的原因,否则在低配主机下极容易出现卡机情况#2. 任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</code></pre><p>　　<strong>此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。</strong></p><h3 id="四-多路复用IO-IO-multiplexing-（重点）"><a href="#四-多路复用IO-IO-multiplexing-（重点）" class="headerlink" title="四 多路复用IO(IO multiplexing)（重点）"></a>四 多路复用IO(IO multiplexing)（重点）</h3><p>　　<strong>先看解释图，里面的select就像个代理。</strong></p><p>　　IO multiplexing这个词可能有点陌生，但是如果我说select/epoll，大概就都能明白了。有些地方也称这种IO方式为<strong>事件驱动IO</strong>(event driven IO)。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/1036857-20170831225603562-854824774.png" alt="img"></p><p>　　先看解释图：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180928113313487-1004509799.png" alt="img"></p><p>　　当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>　　这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为它不仅阻塞了还多需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)，当只有一个连接请求的时候，这个模型还不如阻塞IO效率高。但是，用select的优势在于它可以同时处理多个connection，而阻塞IO那里不能，我不管阻塞不阻塞，你所有的连接包括recv等操作，我都帮你监听着（以什么形式监听的呢？先不要考虑，下面会讲的~~），其中任何一个有变动（有链接，有数据），我就告诉你用户，那么你就可以去调用这个数据了，这就是他的NB之处。这个IO多路复用模型机制是操作系统帮我们提供的，在windows上有这么个机制叫做select，那么如果我们想通过自己写代码来控制这个机制或者自己写这么个机制，我们可以使用python中的select模块来完成上面这一系列代理的行为。在一切皆文件的unix下，这些可以接收数据的对象或者连接，都叫做文件描述符fd</p><p>　　<strong>强调：</strong></p><p>　　　　<strong>1. 如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong></p><p>　　　　<strong>2. 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</strong></p><p>　　<strong>python中的select模块：</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>import selectfd_r_list, fd_w_list, fd_e_list = select.select(rlist, wlist, xlist, [timeout])参数： 可接受四个参数（前三个必须）    rlist: wait until ready for reading  #等待读的对象，你需要监听的需要获取数据的对象列表    wlist: wait until ready for writing  #等待写的对象，你需要写一些内容的时候，input等等，也就是说我会循环他看看是否有需要发送的消息，如果有我取出这个对象的消息并发送出去，一般用不到，这里我们也给一个[]。    xlist: wait for an “exceptional condition”  #等待异常的对象，一些额外的情况，一般用不到，但是必须传，那么我们就给他一个[]。    timeout: 超时时间    当超时时间 ＝ n(正整数)时，那么如果监听的句柄均无任何变化，则select会阻塞n秒，之后返回三个空列表，如果监听的句柄有变化，则直接执行。返回值：三个列表与上面的三个参数列表是对应的　　select方法用来监视文件描述符(当文件描述符条件不满足时，select会阻塞)，当某个文件描述符状态改变后，会返回三个列表    1、当参数1 序列中的fd满足“可读”条件时，则获取发生变化的fd并添加到fd_r_list中    2、当参数2 序列中含有fd时，则将该序列中所有的fd添加到 fd_w_list中    3、当参数3 序列中的fd发生错误时，则将该发生错误的fd添加到 fd_e_list中    4、当超时时间为空，则select会一直阻塞，直到监听的句柄发生变化</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>结论: select的优势在于可以处理多个连接，不适用于单个连接</strong>  </p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#服务端from socket import *import selectserver = socket(AF_INET, SOCK_STREAM)server.bind(('127.0.0.1',8093))server.listen(5)# 设置为非阻塞server.setblocking(False)# 初始化将服务端socket对象加入监听列表，后面还要动态添加一些conn连接对象，当accept的时候sk就有感应，当recv的时候conn就有动静rlist=[server,]rdata = {}  #存放客户端发送过来的消息wlist=[]  #等待写对象wdata={}  #存放要返回给客户端的消息print('预备！监听！！！')count = 0 #写着计数用的，为了看实验效果用的，没用while True:    # 开始 select 监听,对rlist中的服务端server进行监听，select函数阻塞进程，直到rlist中的套接字被触发（在此例中，套接字接收到客户端发来的握手信号，从而变得可读，满足select函数的“可读”条件），被触发的（有动静的）套接字（服务器套接字）返回给了rl这个返回值里面；    rl,wl,xl=select.select(rlist,wlist,[],0.5)    print('%s 次数&gt;&gt;'%(count),wl)    count = count + 1    # 对rl进行循环判断是否有客户端连接进来,当有客户端连接进来时select将触发    for sock in rl:        # 判断当前触发的是不是socket对象, 当触发的对象是socket对象时,说明有新客户端accept连接进来了        if sock == server:            # 接收客户端的连接, 获取客户端对象和客户端地址信息            conn,addr=sock.accept()            #把新的客户端连接加入到监听列表中，当客户端的连接有接收消息的时候，select将被触发，会知道这个连接有动静，有消息，那么返回给rl这个返回值列表里面。            rlist.append(conn)        else:            # 由于客户端连接进来时socket接收客户端连接请求，将客户端连接加入到了监听列表中(rlist)，客户端发送消息的时候这个连接将触发            # 所以判断是否是客户端连接对象触发            try:                data=sock.recv(1024)                #没有数据的时候，我们将这个连接关闭掉，并从监听列表中移除                if not data:                    sock.close()                    rlist.remove(sock)                    continue                print("received {0} from client {1}".format(data.decode(), sock))                #将接受到的客户端的消息保存下来                rdata[sock] = data.decode()                #将客户端连接对象和这个对象接收到的消息加工成返回消息，并添加到wdata这个字典里面                wdata[sock]=data.upper()                #需要给这个客户端回复消息的时候，我们将这个连接添加到wlist写监听列表中                wlist.append(sock)            #如果这个连接出错了，客户端暴力断开了（注意，我还没有接收他的消息，或者接收他的消息的过程中出错了）            except Exception:                #关闭这个连接                sock.close()                #在监听列表中将他移除，因为不管什么原因，它毕竟是断开了，没必要再监听它了                rlist.remove(sock)    # 如果现在没有客户端请求连接,也没有客户端发送消息时，开始对发送消息列表进行处理，是否需要发送消息    for sock in wl:        sock.send(wdata[sock])        wlist.remove(sock)        wdata.pop(sock)    # #将一次select监听列表中有接收数据的conn对象所接收到的消息打印一下    # for k,v in rdata.items():    #     print(k,'发来的消息是：',v)    # #清空接收到的消息    # rdata.clear()---------------------------------------#客户端from socket import *client=socket(AF_INET,SOCK_STREAM)client.connect(('127.0.0.1',8093))while True:    msg=input('&gt;&gt;: ').strip()    if not msg:continue    client.send(msg.encode('utf-8'))    data=client.recv(1024)    print(data.decode('utf-8'))client.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>select监听fd变化的过程分析：</strong></p><pre><code>#用户进程创建socket对象，拷贝监听的fd到内核空间，每一个fd会对应一张系统文件表，内核空间的fd响应到数据后，就会发送信号给用户进程数据已到；#用户进程再发送系统调用，比如（accept）将内核空间的数据copy到用户空间，同时作为接受数据端内核空间的数据清除，这样重新监听时fd再有新的数据又可以响应到了（发送端因为基于TCP协议所以需要收到应答后才会清除）。</code></pre><p>　　<strong>该模型的优点：</strong></p><pre><code>#相比其他模型，使用select() 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。</code></pre><p>　　<strong>该模型的缺点：</strong></p><pre><code>#首先select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/dev/poll，…。如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难。#其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。</code></pre><p> 　　select做得事情和第二阶段的阻塞没有关系，就是从内核态将数据拷贝到用户态的阻塞，始终帮你做得监听的工作，帮你节省了一些第一阶段阻塞的时间。</p><p> 　　IO多路复用的机制：</p><p>　　　　select机制： Windows、Linux</p><p>　　　　poll机制    ： Linux    #和lselect监听机制一样，但是对监听列表里面的数量没有限制，select默认限制是1024个，但是他们两个都是操作系统轮询每一个被监听的文件描述符（如果数量很大，其实效率不太好），看是否有可读操作。</p><p>　　　　epoll机制  ： Linux    #它的监听机制和上面两个不同，他给每一个监听的对象绑定了一个回调函数，你这个对象有消息，那么触发回调函数给用户，用户就进行系统调用来拷贝数据，并不是轮询监听所有的被监听对象，这样的效率高很多。</p><h3 id="五-异步IO-Asynchronous-I-O"><a href="#五-异步IO-Asynchronous-I-O" class="headerlink" title="五 异步IO(Asynchronous I/O)"></a>五 异步IO(Asynchronous I/O)</h3><p>​    Linux下的asynchronous IO其实用得不多，从内核2.6版本才开始引入。先看一下它的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/1036857-20170831232911015-2140233396.png" alt="img"></p><p>​    用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel操作系统会等待数据（阻塞）准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180928150200092-681844617.png" alt="img"></p><p>　　貌似异步IO这个模型很牛~~但是你发现没有，这不是我们自己代码控制的，都是操作系统完成的，而python在copy数据这个阶段没有提供操纵操作系统的接口，所以用python没法实现这套异步IO机制，其他几个IO模型都没有解决第二阶段的阻塞（用户态和内核态之间copy数据），但是C语言是可以实现的，因为大家都知道C语言是最接近底层的，虽然我们用python实现不了，但是python仍然有异步的模块和框架（tornado、twstied，高并发需求的时候用），这些模块和框架很多都是用底层的C语言实现的，它帮我们实现了异步，你只要使用就可以了，但是你要知道这个异步是不是很好呀，不需要你自己等待了，操作系统帮你做了所有的事情，你就直接收数据就行了，就像你有一张银行卡，银行定期给你打钱一样。</p><h3 id="六-IO模型比较分析"><a href="#六-IO模型比较分析" class="headerlink" title="六 IO模型比较分析"></a>六 IO模型比较分析</h3><p>　　到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。<br>　　先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><p>　　再说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：<br>　　A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes;<br>　　An asynchronous I/O operation does not cause the requesting process to be blocked;<br>　　两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，四个IO模型可以分为两大类，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO这一类，而 asynchronous I/O后一类 。</p><p>　　有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p>　　各个IO Model的比较如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/1036857-20170831233640827-1762703640.png" alt="img"></p><p>　　经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h3 id="七-selectors模块"><a href="#七-selectors模块" class="headerlink" title="七 selectors模块"></a>七 selectors模块</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>IO复用：为了解释这个名词，首先来理解下复用这个概念，复用也就是共用的意思，这样理解还是有些抽象，为此，咱们来理解下复用在通信领域的使用，在通信领域中为了充分利用网络连接的物理介质，往往在同一条网络链路上采用时分复用或频分复用的技术使其在同一链路上传输多路信号，到这里我们就基本上理解了复用的含义，即公用某个“介质”来尽可能多的做同一类(性质)的事，那IO复用的“介质”是什么呢？为此我们首先来看看服务器编程的模型，客户端发来的请求服务端会产生一个进程来对其进行服务，每当来一个客户请求就产生一个进程来服务，然而进程不可能无限制的产生，因此为了解决大量客户端访问的问题，引入了IO复用技术，即：一个进程可以同时对多个客户请求进行服务。也就是说IO复用的“介质”是进程(准确的说复用的是select和poll，因为进程也是靠调用select和poll来实现的)，复用一个进程(select和poll)来对多个IO进行服务，虽然客户端发来的IO是并发的但是IO所需的读写数据多数情况下是没有准备好的，因此就可以利用一个函数(select和poll)来监听IO所需的这些数据的状态，一旦IO有数据可以进行读写了，进程就来对这样的IO进行服务。理解完IO复用后，我们在来看下实现IO复用中的三个API(select、poll和epoll)的区别和联系select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。三者的原型如下所示：int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);int poll(struct pollfd *fds, nfds_t nfds, int timeout);int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 1.select的第一个参数nfds为fdset集合中最大描述符值加1，fdset是一个位数组，其大小限制为__FD_SETSIZE（1024），位数组的每一位代表其对应的描述符是否需要被检查。第二三四参数表示需要关注读、写、错误事件的文件描述符位数组，这些参数既是输入参数也是输出参数，可能会被内核修改用于标示哪些描述符上发生了关注的事件，所以每次调用select前都需要重新初始化fdset。timeout参数为超时时间，该结构会被内核修改，其值为超时剩余的时间。 select的调用步骤如下：（1）使用copy_from_user从用户空间拷贝fdset到内核空间（2）注册回调函数__pollwait（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll 来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数 据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是 current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout 指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。（8）把fd_set从内核空间拷贝到用户空间。总结下select的几大缺点：（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（3）select支持的文件描述符数量太小了，默认是10242．  poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。 poll的实现机制与select类似，其对应内核中的sys_poll，只不过poll向内核传递pollfd数组，然后对pollfd中的每个描述符进行poll，相比处理fdset来说，poll效率更高。poll返回后，需要对pollfd中的每个元素检查其revents值，来得指事件是否发生。3．直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll 和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函 数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注 册要监听的事件类型；epoll_wait则是等待事件的产生。　　对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定 EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝 一次。　　对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在 epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调 函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用 schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。　　对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子, 在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。总结：（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升。（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　这三种IO多路复用模型在不同的平台有着不同的支持，而epoll在windows下就不支持，好在我们有selectors模块，帮我们默认选择当前平台下最合适的，我们只需要写监听谁，然后怎么发送消息接收消息，但是具体怎么监听的，选择的是select还是poll还是epoll，这是selector帮我们自动选择的。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#服务端from socket import *import selectorssel=selectors.DefaultSelector()def accept(server_fileobj,mask):    conn,addr=server_fileobj.accept()    sel.register(conn,selectors.EVENT_READ,read)def read(conn,mask):    try:        data=conn.recv(1024)        if not data:            print('closing',conn)            sel.unregister(conn)            conn.close()            return        conn.send(data.upper()+b'_SB')    except Exception:        print('closing', conn)        sel.unregister(conn)        conn.close()server_fileobj=socket(AF_INET,SOCK_STREAM)server_fileobj.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)server_fileobj.bind(('127.0.0.1',8088))server_fileobj.listen(5)server_fileobj.setblocking(False) #设置socket的接口为非阻塞sel.register(server_fileobj,selectors.EVENT_READ,accept) #相当于网select的读列表里append了一个文件句柄server_fileobj,并且绑定了一个回调函数acceptwhile True:    events=sel.select() #检测所有的fileobj，是否有完成wait data的    for sel_obj,mask in events:        callback=sel_obj.data #callback=accpet        callback(sel_obj.fileobj,mask) #accpet(server_fileobj,1)#客户端from socket import *c=socket(AF_INET,SOCK_STREAM)c.connect(('127.0.0.1',8088))while True:    msg=input('&gt;&gt;: ')    if not msg:continue    c.send(msg.encode('utf-8'))    data=c.recv(1024)    print(data.decode('utf-8'))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　关于selector模块的简单介绍看这里&gt;&gt;：<a href="https://www.cnblogs.com/clschao/articles/9718463.html">https://www.cnblogs.com/clschao/articles/9718463.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#!/usr/bin/env python  import select  import socket  response = b''  serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  serversocket.bind(('0.0.0.0', 8080))  serversocket.listen(1)  # 因为socket默认是阻塞的，所以需要使用非阻塞（异步）模式。  serversocket.setblocking(0)  # 创建一个epoll对象  epoll = select.epoll()  # 在服务端socket上面注册对读event的关注。一个读event随时会触发服务端socket去接收一个socket连接  epoll.register(serversocket.fileno(), select.EPOLLIN)  try:      # 字典connections映射文件描述符（整数）到其相应的网络连接对象      connections = {}      requests = {}      responses = {}      while True:          # 查询epoll对象，看是否有任何关注的event被触发。参数“1”表示，我们会等待1秒来看是否有event发生。          # 如果有任何我们感兴趣的event发生在这次查询之前，这个查询就会带着这些event的列表立即返回          events = epoll.poll(1)          # event作为一个序列（fileno，event code）的元组返回。fileno是文件描述符的代名词，始终是一个整数。          for fileno, event in events:              # 如果是服务端产生event,表示有一个新的连接进来              if fileno == serversocket.fileno():                  connection, address = serversocket.accept()                  print('client connected:', address)                  # 设置新的socket为非阻塞模式                  connection.setblocking(0)                  # 为新的socket注册对读（EPOLLIN）event的关注                  epoll.register(connection.fileno(), select.EPOLLIN)                  connections[connection.fileno()] = connection                  # 初始化接收的数据                  requests[connection.fileno()] = b''              # 如果发生一个读event，就读取从客户端发送过来的新数据              elif event &amp; select.EPOLLIN:                  print("------recvdata---------")                  # 接收客户端发送过来的数据                  requests[fileno] += connections[fileno].recv(1024)                  # 如果客户端退出,关闭客户端连接，取消所有的读和写监听                  if not requests[fileno]:                      connections[fileno].close()                      # 删除connections字典中的监听对象                      del connections[fileno]                      # 删除接收数据字典对应的句柄对象                      del requests[connections[fileno]]                      print(connections, requests)                      epoll.modify(fileno, 0)                  else:                      # 一旦完成请求已收到，就注销对读event的关注，注册对写（EPOLLOUT）event的关注。写event发生的时候，会回复数据给客户端                      epoll.modify(fileno, select.EPOLLOUT)                      # 打印完整的请求，证明虽然与客户端的通信是交错进行的，但数据可以作为一个整体来组装和处理                      print('-' * 40 + '\n' + requests[fileno].decode())              # 如果一个写event在一个客户端socket上面发生，它会接受新的数据以便发送到客户端              elif event &amp; select.EPOLLOUT:                  print("-------send data---------")                  # 每次发送一部分响应数据，直到完整的响应数据都已经发送给操作系统等待传输给客户端                  byteswritten = connections[fileno].send(requests[fileno])                  requests[fileno] = requests[fileno][byteswritten:]                  if len(requests[fileno]) == 0:                      # 一旦完整的响应数据发送完成，就不再关注写event                      epoll.modify(fileno, select.EPOLLIN)              # HUP（挂起）event表明客户端socket已经断开（即关闭），所以服务端也需要关闭。              # 没有必要注册对HUP event的关注。在socket上面，它们总是会被epoll对象注册              elif event &amp; select.EPOLLHUP:                  print("end hup------")                  # 注销对此socket连接的关注                  epoll.unregister(fileno)                  # 关闭socket连接                  connections[fileno].close()                  del connections[fileno]  finally:      # 打开的socket连接不需要关闭，因为Python会在程序结束的时候关闭。这里显式关闭是一个好的代码习惯      epoll.unregister(serversocket.fileno())      epoll.close()      serversocket.close()  ---------------------本文来自 richard1ybb 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/richard1ybb/article/details/74573200?utm_source=copy </code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　今天的内容就到这里啦<del>~</del></p><p>　　作业:基于selectors模块实现并发的FTP</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-GIL锁</title>
      <link href="2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/python--GIL%E9%94%81/"/>
      <url>2019/11/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/python--GIL%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>GIL锁</p><p><strong>本节目录</strong></p><ul><li><p>一 介绍</p></li><li><p>二 GIL介绍</p></li><li><p>三 GIL与Lock</p></li><li><p>四 GIL与多线程</p></li><li><p>五 多线程性能测试</p></li></ul><h3 id="一-背景知识"><a href="#一-背景知识" class="headerlink" title="一 背景知识"></a>一 背景知识</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>'''定义：In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)'''结论：在Cpython解释器中，同一个进程下开启的多线程，同一时刻只能有一个线程执行，无法利用多核优势</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　首先需要明确的一点是<code>GIL</code>并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把<code>GIL</code>归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL</p><p><a href="http://www.dabeaz.com/python/UnderstandingGIL.pdf">　　这篇文章透彻的剖析了GIL对python多线程的影响，强烈推荐看一下：http://www.dabeaz.com/python/UnderstandingGIL.pdf </a></p><h3 id="二-GIL介绍"><a href="#二-GIL介绍" class="headerlink" title="二 GIL介绍"></a>二 GIL介绍</h3><p>　　GIL本质就是一把互斥锁，既然是互斥锁，所有互斥锁的本质都一样，都是将并发运行变成串行，以此来控制同一时间内共享数据只能被一个任务所修改，进而保证数据安全。</p><p>　　可以肯定的一点是：保护不同的数据的安全，就应该加不同的锁。</p><p>　　要想了解GIL，首先确定一点：每次执行python程序，都会产生一个独立的进程。例如python test.py，python aaa.py，python bbb.py会产生3个不同的python进程</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ContractedBlock.gif" alt="img"> 验证python test.py只会产生一个进程</p><p>在一个python的进程内，不仅有test.py的主线程或者由该主线程开启的其他线程，还有解释器开启的垃圾回收等解释器级别的线程，总之，所有线程都运行在这一个进程内，毫无疑问</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>#1 所有数据都是共享的，这其中，代码作为一种数据也是被所有线程共享的（test.py的所有代码以及Cpython解释器的所有代码）例如：test.py定义一个函数work（代码内容如下图），在进程内所有线程都能访问到work的代码，于是我们可以开启三个线程然后target都指向该代码，能访问到意味着就是可以执行。#2 所有线程的任务，都需要将任务的代码当做参数传给解释器的代码去执行，即所有的线程要想运行自己的任务，首先需要解决的是能够访问到解释器的代码。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　综上：</p><p>　　如果多个线程的target=work，那么执行流程是</p><p>　　多个线程先访问到解释器的代码，即拿到执行权限，然后将target的代码交给解释器的代码去执行</p><p>　　解释器的代码是所有线程共享的，所以垃圾回收线程也可能访问到解释器的代码而去执行，这就导致了一个问题:对于同一个数据100，可能线程1执行x=100的同时，而垃圾回收执行的是回收100的操作，解决这种问题没有什么高明的方法，就是加锁处理，如下图的GIL，保证python解释器同一时间只能执行一个任务的代码</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180926100512742-1573465285.png" alt="img"></p><p>　　</p><h3 id="三-GIL与Lock"><a href="#三-GIL与Lock" class="headerlink" title="三 GIL与Lock"></a>三 GIL与Lock</h3><p><strong>GIL保护的是解释器级的数据，保护用户自己的数据则需要自己加锁处理，如下图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/988061-20180926100556096-1593917726.png" alt="img"></p><h3 id="四-GIL与多线程"><a href="#四-GIL与多线程" class="headerlink" title="四 GIL与多线程"></a>四 GIL与多线程</h3><p>　　有了GIL的存在，同一时刻同一进程中只有一个线程被执行</p><p>　　听到这里，有的同学立马质问：进程可以利用多核，但是开销大，而python的多线程开销小，但却无法利用多核优势，也就是说python没用了，php才是最牛逼的语言？</p><p>　　别着急啊，老娘还没讲完呢。</p><p>　　要解决这个问题，我们需要在几个点上达成一致：</p><pre><code>#1. cpu到底是用来做计算的，还是用来做I/O的？#2. 多cpu，意味着可以有多个核并行完成计算，所以多核提升的是计算性能#3. 每个cpu一旦遇到I/O阻塞，仍然需要等待，所以多核对I/O操作没什么用处 </code></pre><p>　　一个工人相当于cpu，此时计算相当于工人在干活，I/O阻塞相当于为工人干活提供所需原材料的过程，工人干活的过程中如果没有原材料了，则工人干活的过程需要停止，直到等待原材料的到来。</p><p>　　如果你的工厂干的大多数任务都要有准备原材料的过程（I/O密集型），那么你有再多的工人，意义也不大，还不如一个人，在等材料的过程中让工人去干别的活，</p><p>　　反过来讲，如果你的工厂原材料都齐全，那当然是工人越多，效率越高</p><p>　　结论：</p><p>　　　　对计算来说，cpu越多越好，但是对于I/O来说，再多的cpu也没用</p><p>　　　　当然对运行一个程序来说，随着cpu的增多执行效率肯定会有所提高（不管提高幅度多大，总会有所提高），这是因为一个程序基本上不会是纯计算或者纯I/O，所以我们只能相对的去看一个程序到底是计算密集型还是I/O密集型，从而进一步分析python的多线程到底有无用武之地</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><pre><code>#分析：我们有四个任务需要处理，处理方式肯定是要玩出并发的效果，解决方案可以是：方案一：开启四个进程方案二：一个进程下，开启四个线程#单核情况下，分析结果: 　　如果四个任务是计算密集型，没有多核来并行计算，方案一徒增了创建进程的开销，方案二胜　　如果四个任务是I/O密集型，方案一创建进程的开销大，且进程的切换速度远不如线程，方案二胜#多核情况下，分析结果：　　如果四个任务是计算密集型，多核意味着并行计算，在python中一个进程中同一时刻只有一个线程执行用不上多核，方案一胜　　如果四个任务是I/O密集型，再多的核也解决不了I/O问题，方案二胜#结论：现在的计算机基本上都是多核，python对于计算密集型的任务开多线程的效率并不能带来多大性能上的提升，甚至不如串行(没有大量切换)，但是，对于IO密集型的任务效率还是有显著提升的。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="五-多线程性能测试"><a href="#五-多线程性能测试" class="headerlink" title="五 多线程性能测试"></a>五 多线程性能测试</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Processfrom threading import Threadimport os,timedef work():    res=0    for i in range(100000000):        res*=iif __name__ == '__main__':    l=[]    print(os.cpu_count()) #本机为4核    start=time.time()    for i in range(4):        p=Process(target=work) #耗时5s多        p=Thread(target=work) #耗时18s多        l.append(p)        p.start()    for p in l:        p.join()    stop=time.time()    print('run time is %s' %(stop-start))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/bfbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from multiprocessing import Processfrom threading import Threadimport threadingimport os,timedef work():    time.sleep(2)    print('===&gt;')if __name__ == '__main__':    l=[]    print(os.cpu_count()) #本机为4核    start=time.time()    for i in range(400):        # p=Process(target=work) #耗时12s多,大部分时间耗费在创建进程上        p=Thread(target=work) #耗时2s多        l.append(p)        p.start()    for p in l:        p.join()    stop=time.time()    print('run time is %s' %(stop-start))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　应用：</p><p>　　　　多线程用于IO密集型，如socket，爬虫，web<br>　　　　多进程用于计算密集型，如金融分析</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信协议(互联网协议)</title>
      <link href="2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE(%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE)/"/>
      <url>2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE(%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE)/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li>一.操作系统基础</li><li>二.网络通信原理</li><li>2.1 互联网的本质就是一系列的网络协议</li><li>2.2 osi七层协议</li><li>2.3 tcp/ip五层模型讲解</li><li>2.3.1 物理层</li><li>2.3.2 数据链路层</li><li>2.3.3 网络层</li><li>2.3.4 传输层</li><li>2.3.5 应用层</li><li>2.3.6 socket</li><li>三.网络通信实现</li><li>四.结合协议来看网络通信流程</li></ul><h1 id="一-操作系统基础"><a href="#一-操作系统基础" class="headerlink" title="一.操作系统基础"></a>一.操作系统基础</h1><p>　　操作系统:(Operating System，简称OS)是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。</p><p>　　注：计算机(硬件)－&gt;os－&gt;应用软件</p><h1 id="二-网络通信原理"><a href="#二-网络通信原理" class="headerlink" title="二.网络通信原理"></a>二.网络通信原理</h1><h2 id="2-1-互联网的本质就是一系列的网络协议"><a href="#2-1-互联网的本质就是一系列的网络协议" class="headerlink" title="　　2.1 互联网的本质就是一系列的网络协议"></a>　　2.1 互联网的本质就是一系列的网络协议</h2><p>　　　　当我们通过自己电脑的浏览器访问京东的时候，<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903142447081-1749440758.png" alt="img">，我们是在浏览器上输入了一个网址，但是我们都知道，互联网连接的电脑互相通信的是电信号，我们的电脑是怎么将我们输入的网址变成了电信号然后发送出去了呢，并且我们发送出去的消息是不是应该让京东的服务器能够知道，我们是在请求它的网站呢，也就是说京东是不是应该知道我发送的消息是什么意思呢。是不是发送的消息应该有一些固定的格式呢？让所有电脑都能识别的消息格式，他就像英语成为世界上所有人通信的统一标准一样，如果把计算机看成分布于世界各地的人，那么连接两台计算机之间的internet实际上就是一系列统一的标准，这些标准称之为互联网协议，互联网的本质就是一系列的协议，总称为‘互联网协议’（Internet Protocol Suite)。</p><p>互联网协议的功能：定义计算机如何接入internet，以及接入internet的计算机通信的标准。</p><p>先看一下网络通信的整个流程，下面是图解</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903162358128-1934554515.png" alt="img"></p><h2 id="2-2-osi七层协议"><a href="#2-2-osi七层协议" class="headerlink" title="　　2.2 osi七层协议"></a>　　2.2 osi七层协议</h2><p>　　　　互联网协议按照功能不同分为osi七层或tcp/ip五层或tcp/ip四层</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161008145544426-736439132.png" alt="img"></p><p>　　　　下面这些协议简单知道一些常用的就行。（不是重点）</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180910150727847-1240133782.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>各层的功能简述：    【1】物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。　　【2】数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。　　【3】网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。　　【4】传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。　　【5】会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。　　【6】表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。　　【7】应用层： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。各层中涉及的协议的简单解释：应用层　　·DHCP(动态主机分配协议)　　· DNS (域名解析）　　· FTP（File Transfer Protocol）文件传输协议　　· Gopher （英文原义：The Internet Gopher Protocol 中文释义：（RFC-1436）网际Gopher协议）　　· HTTP （Hypertext Transfer Protocol）超文本传输协议　　· IMAP4 (Internet Message Access Protocol 4) 即 Internet信息访问协议的第4版本　　· IRC （Internet Relay Chat ）网络聊天协议　　· NNTP （Network News Transport Protocol）RFC-977）网络新闻传输协议　　· XMPP 可扩展消息处理现场协议　　· POP3 (Post Office Protocol 3)即邮局协议的第3个版本　　· SIP 信令控制协议　　· SMTP （Simple Mail Transfer Protocol）即简单邮件传输协议　　· SNMP (Simple Network Management Protocol,简单网络管理协议)　　· SSH （Secure Shell）安全外壳协议　　· TELNET 远程登录协议　　· RPC （Remote Procedure Call Protocol）（RFC-1831）远程过程调用协议　　· RTCP （RTP Control Protocol）RTP 控制协议　　· RTSP （Real Time Streaming Protocol）实时流传输协议　　· TLS （Transport Layer Security Protocol）安全传输层协议　　· SDP( Session Description Protocol）会话描述协议　　· SOAP （Simple Object Access Protocol）简单对象访问协议　　· GTP 通用数据传输平台　　· STUN （Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议　　· NTP （Network Time Protocol）网络校时协议传输层　　·TCP（Transmission Control Protocol）传输控制协议　　· UDP (User Datagram Protocol）用户数据报协议　　· DCCP （Datagram Congestion Control Protocol）数据报拥塞控制协议　　· SCTP（STREAM CONTROL TRANSMISSION PROTOCOL）流控制传输协议　　· RTP(Real-time Transport Protocol或简写RTP）实时传送协议　　· RSVP （Resource ReSer Vation Protocol）资源预留协议　　· PPTP ( Point to Point Tunneling Protocol）点对点隧道协议网络层IP(IPv4 · IPv6) Internet Protocol（网络之间互连的协议）ARP : Address Resolution Protocol即地址解析协议，实现通过IP地址得知其物理地址。RARP :Reverse Address Resolution Protocol 反向地址转换协议允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。ICMP :（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。ICMPv6:IGMP :Internet 组管理协议（IGMP）是因特网协议家族中的一个组播协议，用于IP 主机向任一个直接相邻的路由器报告他们的组成员情况。RIP : 路由信息协议（RIP）是一种在网关与主机之间交换路由选择信息的标准。OSPF : (Open Shortest Path First开放式最短路径优先).BGP :（Border Gateway Protocol ）边界网关协议，用来连接Internet上独立系统的路由选择协议IS-IS:（Intermediate System to Intermediate System Routing Protocol）中间系统到中间系统的路由选择协议.IPsec:“Internet 协议安全性”是一种开放标准的框架结构，通过使用加密的安全服务以确保在 Internet 协议 (IP) 网络上进行保密而安全的通讯。数据链路层　　802.11 · 802.16 · Wi-Fi · WiMAX · ATM · DTM · 令牌环 · 以太网 · FDDI · 帧中继 · GPRS · EVDO · HSPA · HDLC · PPP · L2TP · ISDN物理层　　以太网物理层 · 调制解调器 · PLC · SONET/SDH · G.709 · 光导纤维 · 同轴电缆 · 双绞线</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　我们现在只需要了解五层的协议就好了，ok吗？我们写的程序属于哪一层呢，属于应用层。</p><p>　　　　每层运行常见物理设备</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161008144925254-1398507493.png" alt="img"></p><h2 id="2-3-tcp-ip五层模型讲解"><a href="#2-3-tcp-ip五层模型讲解" class="headerlink" title="　　2.3 tcp/ip五层模型讲解"></a>　　2.3 tcp/ip五层模型讲解</h2><p>　　　　我们将应用层，表示层，会话层并作应用层，从tcp／ip五层协议的角度来阐述每层的由来与功能，搞清楚了每层的主要协议</p><p>　　　　就理解了整个互联网通信的原理。</p><p>　　　　首先，用户感知到的只是最上面一层应用层，自上而下每层都依赖于下一层，所以我们从最下一层开始切入，比较好理解</p><p>　　　　每层都运行特定的协议，越往上越靠近用户，越往下越靠近硬件</p><h3 id="2-3-1-物理层"><a href="#2-3-1-物理层" class="headerlink" title="　　2.3.1 物理层"></a>　　2.3.1 物理层</h3><p>　　　　物理层由来：上面提到，孤立的计算机之间要想一起玩，就必须接入internet，言外之意就是计算机之间必须完成组网</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161008154500754-704720294.png" alt="img"></p><p>　　　　物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0</p><h3 id="2-3-2-数据链路层"><a href="#2-3-2-数据链路层" class="headerlink" title="　　2.3.2 数据链路层"></a>　　2.3.2 数据链路层</h3><p>　　　　数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思</p><p>　　　　数据链路层的功能：定义了电信号的分组方式</p><p>　　　　<strong><em>以太网协议：</em></strong></p><p>　　　　早期的时候各个公司都有自己的分组方式，后来形成了统一的标准，即以太网协议ethernet</p><p>　　　　ethernet规定</p><ul><li>一组电信号构成一个数据包，叫做‘帧’</li><li>每一数据帧分成：报头head和数据data两部分</li></ul><table><thead><tr><th>head</th><th>data</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>　　head包含：(固定18个字节)</p><ul><li>发送者／源地址，6个字节</li><li>接收者／目标地址，6个字节</li><li>数据类型，6个字节</li></ul><p>　　data包含：(最短46字节，最长1500字节)</p><ul><li>数据包的具体内容</li></ul><p>　　　　head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送</p><p>　　<strong><em>mac地址：</em></strong></p><p>　　　　head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址</p><p>　　　　mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161008164852129-1597186542.png" alt="img"></p><p>　　<strong>广播：</strong></p><p>　　　　有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址）</p><p>　　　　ethernet（以太网）采用最原始的方式，广播的方式进行通信，即计算机通信基本靠吼</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161008171118317-164674895.png" alt="img"></p><h3 id="2-3-3-网络层"><a href="#2-3-3-网络层" class="headerlink" title="　　2.3.3 网络层"></a>　　2.3.3 网络层</h3><p>　　　　网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机就可以彼此通信了，问题是世界范围的互联网是由</p><p>　　　　一个个彼此隔离的小的局域网组成的，那么如果所有的通信都采用以太网的广播方式，那么一台机器发送的包全世界都会收到，</p><p>　　　　这就不仅仅是效率低的问题了，这会是一种灾难</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161008172732957-102296982.png" alt="img"></p><p>　　　　上图结论：必须找出一种方法来区分哪些计算机属于同一广播域，哪些不是。如果是就采用广播的方式发送，如果不是，</p><p>　　　　就采用路由的方式（向不同广播域／子网分发数据包），mac地址是无法区分的，它只跟厂商有关</p><p>　　　　网络层功能：引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址</p><p>　　<strong><em>IP协议：</em></strong></p><ul><li>规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示</li><li>范围0.0.0.0-255.255.255.255 (4个点分十进制，也就是4个8位二进制数)</li><li>一个ip地址通常写成四段十进制数，例：172.16.10.1</li></ul><p>　　ipv6，通过上面可以看出，ip紧缺，所以为了满足更多ip需要，出现了ipv6协议：6个冒号分割的16进制数表示，这个应该是将来的趋势，但是ipv4还是用的最多的，因为我们一般一个公司就一个对外的IP地址，我们所有的机器上网都走这一个IP出口。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>每个以太网设备在出厂时都有一个唯一的MAC地址，为什么还需要为每台主机再分配一个IP地址?每台主机都分配唯一的IP地址，为什么还要在网络设备(如网卡，集线器，路由器等)生产时内嵌一个唯一的MAC地址呢?唯一的MAC地址    MAC（Media Access Control或者Medium Access Control）地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。 MAC地址是网卡决定的，是固定的。    MAC地址，长度是48比特（6字节），由16进制的数字组成，分为前24位和后24位：    前24位叫做组织唯一标志符（Organizationally Unique Identifier，即    OUI），是由IEEE的注册管理机构给不同厂家分配的代码，区分了不同的厂家。    后24位是由厂家自己分配的，称为扩展标识符。同一个厂家生产的网卡中MAC地址后24位是不同的。    每个以太网设备在出厂时都有一个唯一的MAC地址。一个局域网内唯一的IP地址    IP地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。    IP地址被用来给Internet上的电脑一个编号。日常见到的情况是每台联网的PC上都需要有IP地址，才能正常通信。    我们可以把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，而Internet中的路由器，就相当于电信局的“程控式交换机”。    IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）。每台主机都分配唯一的IP地址，为什么还要一个唯一的MAC地址呢    建立osi七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。网络七层的划分也是为了使网络的不同功能模块（不同层次）分担起不同的职责，从而带来如下好处：    减轻问题的复杂程度，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错；在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作，各层之间则相对独立，一种高层协议可放在多种低层协议上运行；能有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需对整个网络动大手术。从上可知：    MAC用于第二层传输，IP用于第三层传输。分为两层，用两个地址，一个原因就是为了兼容性，能让异构网互联，即让两个不同架构之间的网络也能通信，传输过程中Mac会变，IP不变。    IP地址的作用很重要的一部分就是屏蔽底下链路层的差异，因为它是一个逻辑地址，所以可以适应于多种链路；以太网这种链路层组网方式中，要通过mac地址来通信，其实ip协议完全可以运行于串口（通常运行slip或ppp等链路层协议）等其他形式的链路之上，这时并不需要一个mac地址；在局域网中两台电脑之间传输数据包用MAC地址即可识别，而通过路由器访问互联网 ，传输数据包中的MAC地址就转成路由器的MAC地址。此时就要靠IP来识别，当我要换了一台路由器时候，只要我的IP地址不变，要跟我们传输数据的对象只要记住IP地址即可与我们通信而不需记住我们的mac地址。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>ip地址分成两部分</strong></p><ul><li>网络部分：标识子网</li><li>主机部分：标识主机</li></ul><p>　　注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网</p><p>　　例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网</p><p>　　<strong><em>子网掩码</em></strong></p><p>　　　　所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>　　知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>　　比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，</p><p>　　172.16.10.1：10101100.00010000.00001010.000000001</p><p>　　255255.255.255.0:11111111.11111111.11111111.00000000</p><p>　　AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p><p>　　172.16.10.2：10101100.00010000.00001010.000000010</p><p>　　255.255.255.0:11111111.11111111.11111111.00000000</p><p>　　AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p><p>　　结果都是172.16.10.0，因此它们在同一个子网络。</p><p>　　ip地址与子网掩码 按位与 得到网段地址</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903165231862-1191637583.png" alt="img"></p><p>　　总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><p>　　<strong><em>ip数据包</em></strong></p><p>　　ip数据包也分为head和data部分，无须为ip包定义单独的栏位，直接放入以太网包的data部分</p><p>　　head：长度为20到60字节</p><p>　　data：最长为65,515字节。</p><p>　　而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><table><thead><tr><th>以太网头</th><th>ip 头</th><th>ip数据</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>　　 <strong><em>ARP协议</em></strong></p><p>　　　　arp协议由来：计算机通信基本靠吼，即广播的方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送，在谈及以太网协议时候，我门了解到</p><p>　　　　通信是基于mac的广播方式实现，计算机在发包时，获取自身的mac是容易的，如何获取目标主机的mac，就需要通过arp协议</p><p>　　　　arp协议功能：广播的方式发送数据包，获取目标主机的mac地址</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。　　主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。　　收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。　　地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。 </code></pre><p>　　　　协议工作方式：每台主机ip都是已知的（我只知道我的局域网ip地址，要给一个非同一网络的我不知道ip地址的电脑发消息，怎么办：NET穿透）</p><p>　　　　例如：主机172.16.10.10/24访问172.16.10.11/24</p><p>　　一：首先通过ip地址和子网掩码区分出自己所处的子网</p><table><thead><tr><th>场景</th><th>数据包地址</th></tr></thead><tbody><tr><td>同一子网</td><td>目标主机mac，目标主机ip</td></tr><tr><td>不同子网</td><td>网关mac，目标主机ip</td></tr></tbody></table><p>　　二：分析172.16.10.10/24与172.16.10.11/24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.1,通过arp获取的是网关的mac)</p><table><thead><tr><th></th><th>源mac</th><th>目标mac</th><th>源ip</th><th>目标ip</th><th>数据部分</th></tr></thead><tbody><tr><td>发送端主机</td><td>发送端mac</td><td>FF:FF:FF:FF:FF:FF</td><td>172.16.10.10/24</td><td>172.16.10.11/24</td><td>数据</td></tr></tbody></table><p>　　三：这个包会以广播的方式在发送端所处的子网内传输，所有主机接收后拆开包，发现目标ip为自己的，就响应，返回自己的mac</p><h3 id="2-3-4-传输层"><a href="#2-3-4-传输层" class="headerlink" title="　　2.3.4 传输层"></a>　　2.3.4 传输层</h3><p>　　　　传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机吗，但是只找到主机有用吗，是不是程序之间进行的沟通啊像QQ、浏览器和京东服务器，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序，</p><p>　　　　那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。</p><p>　　　　传输层功能：建立端口到端口的通信(端对端通信)</p><p>　　　　补充：端口范围0-65535，0-1023为系统占用端口</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903170336910-294051751.png" alt="img"></p><p> 　　　　0.0.0.0和127.0.0.1参看 <a href="https://www.cnblogs.com/clschao/articles/9579553.html">https://www.cnblogs.com/clschao/articles/9579553.html</a></p><p>　　　　127.0.0.1就是你本机程序之间进行通信的地址，就是自己玩自己，不和别人玩，这叫做本机的回环地址，我们测试的时候自己模拟客户端和服务端。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>根据用途和安全性级别的不同，IP地址还可以大致分为两类：公共地址和私有地址。公用地址在Internet中使用，可以在Internet中随意访问。私有地址只能在内部网络中使用，只有通过代理服务器才能与Internet通信。 一个机构网络要连入Internet，必须申请公用IP地址。但是考虑到网络安全和内部实验等特殊情况，在IP地址中专门保留了三个区域作为私有地址，其地址范围如下： 网络类别ip地址范围网络数a类网  10.0.0.0~10.255.255.255   1b类网  172.16.0.0~172.31.255.255   16c类网  192.168.0.0~192.168.255.255   255    使用保留地址的网络只能在内部进行通信，而不能与其他网络互连。因为本网络中的保留地址同样也可能被其它网络使用，如果进行网络互连，那么寻找路由时就会因为地址的不唯一而出现问题。但是这些使用保留地址的网络可以通过将本网络内的保留地址翻译转换成公共地址的方式实现与外部网络的互连。这也是保证网络安全的重要方法之一。 特殊IP地址(保留IP地址)介绍     就像我们每个人都有一个身份证号码一样，网络里的每台电脑(更确切地说，是每一个设备的网络接口)都有一个IP地址用于标示自己。我们可能都知道这些地址由四个字节组成，用点分十进制表示以及它们的A，B，C分类等，然而，在总数大约为四十多亿个可用IP 地址里，你知道下面一些常见的有特殊意义地址吗？我们一起来看看吧： 一、0.0.0.0     严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一 律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。 二、255.255.255.255     限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。 三、127.0.0.1     本机地址，主要用于测试。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的 数据包。 四、224.0.0.1     组播地址，注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP (Internet路由发现协议，使用组播功能)功能，那么你的主机路由表中应该有这样一条路由。 五、169.254.x.x     如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九 是你的网络不能正常运行了。 六、10.x.x.x、172.16。x。x～172.31。x。x、192.168。x。x     私有地址，这些地址被大量用于企业内部网络中。一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互连，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私 有网络在接入Internet时，要使用地址翻译(NAT)，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。     对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903171515034-171380845.png" alt="img"></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903171834582-2022787976.png" alt="img"></p><p>　　tcp协议：(TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。)</p><p>　　当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex，双方都可以收发消息) 的通信。</p><p>　　这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p><p>　　它是可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><table><thead><tr><th>以太网头</th><th>ip 头</th><th>tcp头</th><th>数据</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>　　udp协议：不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><table><thead><tr><th>以太网头</th><th>ip头</th><th>udp头</th><th>数据</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。 UDP---用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快现在Internet上流行的协议是TCP/IP协议，该协议中对低于1024的端口都有确切的定义，他们对应着Internet上一些常见的服务。这些常见的服务可以分为使用TCP端口（面向连接）和使用UDP端口（面向无连接）两种。 说到TCP和UDP,首先要明白“连接”和“无连接”的含义，他们的关系可以用一个形象地比喻来说明，就是打电话和写信。两个人如果要通话，首先要建立连接——即打电话时的拨号，等待响应后——即接听电话后，才能相互传递信息，最后还要断开连接——即挂电话。写信就比较简单了，填写好收信人的地址后将信投入邮筒，收信人就可以收到了。从这个分析可以看出，建立连接可以在需要痛心地双方建立一个传递信息的通道，在发送方发送请求连接信息接收方响应后，由于是在接受方响应后才开始传递信息，而且是在一个通道中传送，因此接受方能比较完整地收到发送方发出的信息，即信息传递的可靠性比较高。但也正因为需要建立连接，使资源开销加大（在建立连接前必须等待接受方响应，传输信息过程中必须确认信息是否传到及断开连接时发出相应的信号等），独占一个通道，在断开连接钱不能建立另一个连接，即两人在通话过程中第三方不能打入电话。而无连接是一开始就发送信息（严格说来，这是没有开始、结束的），只是一次性的传递，是先不需要接受方的响应，因而在一定程度上也无法保证信息传递的可靠性了，就像写信一样，我们只是将信寄出去，却不能保证收信人一定可以收到。 TCP是面向连接的，有比较高的可靠性， 一些要求比较高的服务一般使用这个协议，如FTP、Telnet、SMTP、HTTP、POP3等。而UDP是面向无连接的，使用这个协议的常见服务有DNS、SNMP、QQ等。对于QQ必须另外说明一下，QQ2003以前是只使用UDP协议的，其服务器使用8000端口，侦听是否有信息传来，客户端使用4000端口，向外发送信息（这也就不难理解在一般的显IP的QQ版本中显示好友的IP地址信息中端口常为4000或其后续端口的原因了），即QQ程序既接受服务又提供服务，在以后的QQ版本中也支持使用TCP协议了。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="tcp报文"><a href="#tcp报文" class="headerlink" title="　　tcp报文"></a>　　tcp报文</h3><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180907175054154-1471843746.png" alt="img"></p><h3 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="　　TCP报文首部"></a>　　TCP报文首部</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code> 1 源端口和目的端口，各占2个字节，分别写入源端口和目的端口； 2 序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始； 3 确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701； 4 数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远； 5 保留，占6位，保留今后使用，但目前应都位0； 6 紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据； 7 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1； 8 推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1； 9 复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；10 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；11 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；12 窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；13 检验和，占2字节，校验首部和数据这两部分；14 紧急指针，占2字节，指出本报文段中的紧急数据的字节数；15 选项，长度可变，定义一些其他的可选的参数。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　<strong>tcp三次握手和四次挥手</strong></p><p>　　　　我们知道网络层，可以实现两个主机之间的通信。但是这并不具体，因为，真正进行通信的实体是在主机中的进程，是一个主机中的一个进程与另外一个主机中的一个进程在交换数据。IP协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程。而端到端的通信才应该是应用进程之间的通信。</p><p>　　　　UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p><p>　　　　TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p><p>常用的端口号：</p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TFTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>HTTP</th><th>SSH</th><th>MYSQL</th></tr></thead><tbody><tr><td>熟知端口</td><td>21,20</td><td>69</td><td>23</td><td>25</td><td>53</td><td>80</td><td>22</td><td>3306</td></tr><tr><td>传输层协议</td><td>TCP</td><td>UDP</td><td>TCP</td><td>TCP</td><td>UDP</td><td>TCP</td><td></td><td></td></tr></tbody></table><p>　　三次握手：</p><ol><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li><li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li><li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 </li></ol><h4 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="　　为什么TCP客户端最后还要发送一次确认呢？"></a>　　为什么TCP客户端最后还要发送一次确认呢？</h4><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><pre><code>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</code></pre><p>　　四次挥手：</p><p>　　数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。服务端也可以主动关闭，一个流程。</p><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="　　为什么客户端最后还要等待2MSL？"></a>　　为什么客户端最后还要等待2MSL？</h4><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。为什么建立连接是三次握手，关闭连接确是四次挥手呢？建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="　　如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>　　如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>　　　　TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 </p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161008185648160-191189690.png" alt="img"></p><h3 id=""><a href="#" class="headerlink" title="　　　　"></a>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903180410254-588107395.png" alt="img"></h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>三次握手：TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK[1]，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。[1] TCP三次握手的过程如下：客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。四次挥手：建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。(1) 某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。(2) 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。(3) 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。(4) 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。[1] 既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。注意：(1) “通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。[2] (2) 在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。(3) 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。[2] 为什么是四次挥手，是因为TCP建立的是全双工通道，你和我断了，我还是可以给你发消息的，所以你断了之后，也需要我进行断开链接，所以要进行四次挥手确认。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="2-3-5-应用层"><a href="#2-3-5-应用层" class="headerlink" title="　　2.3.5 应用层"></a>　　2.3.5 应用层</h3><p>　　　　应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 </p><p>　　　　应用层功能：规定应用程序的数据格式。</p><p>　　　　例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><p> 　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161008190023098-992049015.png" alt="img"></p><p> 　　　　</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903154726160-661452116.png" alt="img"></p><h3 id="2-3-6-socket"><a href="#2-3-6-socket" class="headerlink" title="　　2.3.6 socket"></a>　　2.3.6 socket</h3><p>　　　　我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。</p><p>　　　　能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161013091647484-1707663286.png" alt="img"></p><p>　　　　socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p><h1 id="三-网络通信实现"><a href="#三-网络通信实现" class="headerlink" title="三.网络通信实现"></a>三.网络通信实现</h1><p>　　想实现网络通信，每台主机需具备四要素</p><ul><li>本机的IP地址</li><li>子网掩码</li><li>网关的IP地址</li><li>DNS的IP地址</li></ul><p>　　获取这四要素分两种方式</p><p>　　　　1.静态获取：即手动配置</p><p>　　　　2.动态获取：通过dhcp获取</p><table><thead><tr><th>以太网头</th><th>ip头</th><th>udp头</th><th>dhcp数据包</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>　　（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p>　　（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p>　　（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>　　　　这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>　　　　接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>　　　　新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数</p><h1 id="四-结合协议来看网络通信流程"><a href="#四-结合协议来看网络通信流程" class="headerlink" title="四.结合协议来看网络通信流程"></a>四.结合协议来看网络通信流程</h1><p>　　1.本机获取</p><ul><li>本机的IP地址：192.168.1.100</li><li>子网掩码：255.255.255.0</li><li>网关的IP地址：192.168.1.1</li><li>DNS的IP地址：8.8.8.8</li></ul><p>　　2.打开浏览器，想要访问Google，在地址栏输入了网址：<a href="http://www.google.com./">www.google.com。</a></p><p>　　3.dns协议(基于udp协议)</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/1036857-20161008191742160-1888861499.png" alt="img"></p><p>　　13台根dns：</p><p>　　　　A.root-servers.net198.41.0.4美国<br>　　　　B.root-servers.net192.228.79.201美国（另支持<a href="https://www.baidu.com/s?wd=IPv6&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0">IPv6</a>）<br>　　　　C.root-servers.net192.33.4.12法国<br>　　　　D.root-servers.net128.8.10.90美国<br>　　　　E.root-servers.net192.203.230.10美国<br>　　　　F.root-servers.net192.5.5.241美国（另支持<a href="https://www.baidu.com/s?wd=IPv6&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0">IPv6</a>）<br>　　　　G.root-servers.net192.112.36.4美国<br>　　　　H.root-servers.net128.63.2.53美国（另支持<a href="https://www.baidu.com/s?wd=IPv6&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0">IPv6</a>）<br>　　　　I.root-servers.net192.36.148.17瑞典<br>　　　　J.root-servers.net192.58.128.30美国<br>　　　　K.root-servers.net193.0.14.129英国（另支持IPv6）<br>　　　　L.root-servers.net198.32.64.12美国<br>　　　　M.root-servers.net202.12.27.33日本（另支持IPv6）</p><p>　　域名定义：<a href="http://jingyan.baidu.com/article/1974b289a649daf4b1f774cb.html">http://jingyan.baidu.com/article/1974b289a649daf4b1f774cb.html</a></p><p>　　顶级域名：以.com,.net,.org,.cn等等属于国际顶级域名，根据目前的国际互联网域名体系，国际顶级域名分为两类：类别顶级域名(gTLD)和地理顶级域名(ccTLD)两种。类别顶级域名是　　　　　　　　            以”COM”、”NET”、”ORG”、”BIZ”、”INFO”等结尾的域名，均由国外公司负责管理。地理顶级域名是以国家或地区代码为结尾的域名，如”CN”代表中国，”UK”代表英国。地理顶级域名一般由各个国家或地区负责管理。</p><p>　　二级域名：二级域名是以顶级域名为基础的地理域名，比喻中国的二级域有，.com.cn,.net.cn,.org.cn,.gd.cn等.子域名是其父域名的子域名，比喻父域名是abc.com,子域名就是<a href="http://www.abc.com或者*.abc.com/">www.abc.com或者*.abc.com</a>.<br>　　一般来说，二级域名是域名的一条记录，比如alidiedie.com是一个域名，<a href="http://www.alidiedie.com是其中比较常用的记录,一般默认是用这个,但是类似*.alidiedie.com的域名全部称作是alidiedie.com的二级/">www.alidiedie.com是其中比较常用的记录，一般默认是用这个，但是类似*.alidiedie.com的域名全部称作是alidiedie.com的二级</a></p><p>　　4.HTTP部分的内容，类似于下面这样：</p><blockquote><p>GET / HTTP/1.1<br>Host: <a href="http://www.google.com/">www.google.com</a><br>Connection: keep-alive<br>User-Agent: Mozilla/5.0 (Windows NT 6.1) ……<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Encoding: gzip,deflate,sdch<br>Accept-Language: zh-CN,zh;q=0.8<br>Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>Cookie: … …</p></blockquote><p>　　我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><p>　　5 TCP协议</p><p>　　　　TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>　　　　TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><p>　　6 IP协议</p><p>　　　　然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>　　　　IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><p>　　7 以太网协议</p><p>　　　　最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>　　　　以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><p>　　8 服务器端响应</p><p>　　　　经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>　　　　根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p><p>　　　　本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信的整个流程</title>
      <link href="2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B/"/>
      <url>2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本节目录</strong></p><ul><li>一 客户端\服务端架构(哪里用到了网络通信)</li><li>二 网络通信的整个流程</li><li>三 DNS服务器</li><li>五 交换机、路由器和网关(含DHCP)</li><li>六 总结及其他一些内容简介</li></ul><h3 id="一-客户端-服务端架构-哪里用到了网络通信"><a href="#一-客户端-服务端架构-哪里用到了网络通信" class="headerlink" title="一 客户端\服务端架构(哪里用到了网络通信)"></a>一 客户端\服务端架构(哪里用到了网络通信)</h3><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180909111821878-1619979408.png" alt="img"></p><p>　　我们使用qq、微信和别人聊天，通过浏览器来浏览页面、看京东的网站，通过优酷、快播(此处只是怀念一下它)看片片啥的等等，通过无线打印机来打印一个word文档等，只要有无线、有网、有4G，我们就能好好的聊天，好好的看片片、好好的购物什么的，对吧，那么这些操作都叫做网络通信，确切来说都需要使用网络通信，前提是你要有网(大家记着这个’网’，我下面会给大家详解)，原来生活中处处使用了网络通信，我们通过网络通信的不同形式：比如说qq是我们下载到电脑或者手机上的应用程序(qq应用程序就是人家腾讯开发的软件，放到你的电脑或者手机上供你使用的，大概明白应用程序意思就行，不用深究<del>)，浏览器也是我们下载的应用程序，但是浏览器是通过页面来访问别人的网站的，而打印机我是通过我电脑上的word来操作使用的。根据这些不同的场景或者说不用的沟通方式，在业内划分了下面几个架构(架构：就是不同的结构，例子1：每个公司的部门组成不同。例子2：每个建筑的钢筋结构不同。)。在看下面的几个架构之前，我们需要知道什么是客户端，什么是服务端。客户端：安装在你电脑上的qq，浏览器(360浏览器、chrome浏览器、IE浏览器等)，当我们使用qq发送消息的时候，消息先发送到了腾讯，然后腾讯在转发到你朋友的qq上，此时你的qq就是客户端，腾讯就是服务端。当我们使用浏览器来看京东的网站的时候，我们电脑上的浏览器就叫做客户端，京东就叫做服务端。ok</del>ok~</p><p>　　客户端英文名称：Client，服务端英文名称：Server，下面所说的C\S架构就是说的Client\Server架构。</p><p>　　　　a.硬件C\S架构：打印机。</p><p>　　　　b.软件C\S架构：QQ、微信、优酷、暴风影音、浏览器(IE、火狐，360浏览器等)。其中浏览器又比较特殊，很多网站是基于浏览器来进行访问的，浏览器和各个网站服务端进行的通讯方式又常被成为B\S架构(浏览器英文名称：Browser)</p><h3 id="二-网络通信的整个流程"><a href="#二-网络通信的整个流程" class="headerlink" title="二 网络通信的整个流程"></a>二 网络通信的整个流程</h3><p>明白了上面的C\S架构之后，我们就以自己本地的电脑上的浏览器去访问的京东网站的整个流程这种B\S架构来举例，有同学可能会问：你怎么不用qq或者微信来举例啊，是这样，因为qq和微信这种P2P的通信方式还是比较特殊的，也比较繁琐，具体为什么说它繁琐，我在博客的最后给大家说一下，然后有兴趣的同学可以去研究一番<del>~</del></p><p>　　<strong>网卡和mac地址</strong></p><p>　　　　你的电脑想要联网，首先要有一个网卡，而且电脑要做好相关的网路配置（如何配置，在下面有介绍）</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903162559427-566168410.png" alt="img"></p><p>　　　　　　电脑插网线的地方就做网卡，网卡提供了网络的接口，这是硬件上面的，大家都是到网口是吧，我怎么找到电脑的网卡呢，有人说用IP地址，IP地址并不是，而是全球唯一的mac地址，专门给网络设备设定的，是出厂的时候就给定好的，一个设备的mac地址号码是全球唯一的。 head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址。 　　mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p><p>　　　　　　查看mac地址的方法：windows下在cmd窗口输入ipconfig -all指令：下面显示的这个物理地址就是mac地址。</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180911102616106-1486781056.png" alt="img"></p><p>　　　　由于mac地址很难记忆，所以又出现了IP地址，在说IP地址之前，我们先说一下编码，我们都是到一个字节等于8位对吧，8个2进制的数，那么8位是不是可以表示256个字节啊，由于全球有太多的机器需要联网，那么网络设备的编号应该长一些，对不对，由4个点分十进制组成，由点分割的四个十进制的数，而十进制的数是不是在计算机中也是由二进制表示的啊，那么就成了这个样子：00000000.00000000.00000000.00000000 – 11111111.11111111.11111111.11111111，0.0.0.0–255.255.255.255，也就是由4个8位的二进制数表示，这个表示就是我们的IP地址的形式。</p><p>　　　　　　如果你用网线连网的，查看自己网络的属性，并且可以将ipv4版本的ip地址可以设置成静态的、也可以自动获取（动态分配的），下面是网络配置的大致方法：</p><p>　　　　　　1、</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180911104038230-1693601245.png" alt="img"></p><p>　　　　　　2、</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180911104124547-363692766.png" alt="img"></p><p>　　　　　　3、</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180911104500755-2122961438.png" alt="img"></p><p>　　　　　　配置好自己电脑的网络信息之后，我们就有了身份证（mac地址）和名字（IP地址），通过他们，我们就在网络中有了自己的身份，只要有网，我们就可以正大光明的和别人进行通信了。</p><p>　　　　　　</p><p>　　　　　　arp协议功能：广播的方式发送数据包，获取目标主机的mac地址</p><p>　　　　　　下面是网络通信流程图：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180909111944359-1323196399.png" alt="img"></p><p>　　流程描述：</p><p>第一步：打开浏览器，想要请求访问京东，在地址栏输入了网址：<a href="http://www.jd.com.(www.jd.com是域名就是一个ip地址的名称,ip地址不好记,所有有了域名.)/">www.jd.com。（www.jd.com是域名就是一个IP地址的名称，IP地址不好记，所有有了域名。）</a></p><p>第二步：先将请求信息发给了交换机，然后交给了路由器，路由发给DNS服务器，通过DNS协议去找我们要访问的京东的IP地址：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180909112504683-1737949469.png" alt="img"></p><p>　　第三步：查到的京东服务器对应的IP地址之后，路由器通过路由协议找到一个路由转发的最优路径，将你的请求信息还送给这个IP地址的京东的路由器</p><p>　　第四步：京东的路由器发给了京东网站的服务器上</p><p>　　第五步：京东网站服务器按照来的时候的路径，在返回给你他自己的网站</p><p>　　第六步：当你打开浏览器的时候，你的电脑给你的浏览器这个运行起来的程序给了一个编号，叫做端口号，当你的电脑收到京东发送过来的消息的时候，你的电脑通过端口号找到你的浏览器，你的浏览器拿到了京东的网站信息，然后将网站呈现在了自己的浏览器上</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180909115038045-794284281.png" alt="img"></p><p>　　</p><p>　　内网和外网： 　　</p><p>　　　　所谓内网就是我们平常说的局域网。局域网就是在固定的一个地理区域内由2台以上的电脑用网线和其他网络设备搭建而成的一个封闭的计算机组。它可以是邻居之间的2台电脑，也可以是一幢<a href="https://www.baidu.com/s?wd=100%E5%B1%82&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">1</a>00层大楼里的1000台电脑。局域网可以是独立封闭运行的，也可以是和外网相连接的。<br>所谓外网，也就是广域网。是一种地域跨度非常大的网络集合。它是由无数个局域网+独立服务器构成的。注意，此处所说的局域网既可以是小型的广域网，也可以是局域网。<br>　　　　实际上，从规模上来看我们很难分辨局域网与广域网，因为大小都是相对的。所以。真正局域网与广域网的分别是通过IP地址来实现的。<br>　　　　任何一台电脑要上网，都必须在网络上有一个唯一的IP地址。在局域网内，这个IP地址是唯一的。但是在另外一个局域网，这个IP地址仍然能够使用。<br>　　　　网络A里有一台IP地址为192.168.1.231的客户端，网络B里也可以有一台同样IP的电脑。那么。我们就说这2台机器分别在2个局域网里。但是在广域网内，所有的IP地址都是唯一的。山西电信的<a href="https://www.baidu.com/s?wd=DNS%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">D</a>NS服务器IP地址是61.134.1.4.那么，这个地址在全世界都是唯一的，不可重复的。这就是广域网和局域网的区别。</p><p>　　　　如果只有内网的ip地址你是不能上网的，你上网肯定要通过一个外网地址，这个外网地址又称为公网地址，这个公网地址是全球唯一的，他在你的对外出口的路由器上，也就是你的外网网关地址。</p><h3 id="三-DNS服务器"><a href="#三-DNS服务器" class="headerlink" title="三 DNS服务器"></a>三 DNS服务器</h3><p>当我们请求https:\<a href="http://www.jd.com的时候,首先电脑会在本地的dns缓存中找是否有这个dns缓存(dns(domain/">www.JD.com的时候，首先电脑会在本地的DNS缓存中找是否有这个DNS缓存（DNS（Domain</a> Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。 DNS是计算机域名系统 (Domain Name System 或Domain Name Service) 的缩写，它是由域名解析器和域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。其中域名必须对应一个IP地址，一个IP地址可以有多个域名，而IP地址不一定有域名。域名系统采用类似目录树的等级结构。域名服务器通常为客户机/服务器模式中的服务器方，它主要有两种形式：主服务器和转发服务器。将域名映射为IP地址的过程就称为“域名解析”。）本地的DNS缓存是在我们访问过一个网站之后，例如京东，那么本地会保存一个京东域名和京东服务器IP地址的映射关系，将来再次请求的时候，就不用再到外部的DNS上查询这个域名对应的IP地址了，提高了效率，如果是第一次请求，请看上面的DNS查询过程</p><p>步骤</p><p>　　<strong>本地查询顺序</strong>：</p><p>　　　　浏览器缓存： 浏览器会按照一定的频率缓存DNS记录。chrome://net-internals/#dns 查看chormeDNS缓存。</p><p>　　　　操作系统缓存： 如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找。cmd命令ipconfig /displaydns 用于查看操作系统dns缓存。</p><p>　　　　路由缓存： 路由器也有DNS缓存。 找本机的hosts文件 Windows host文件路径： C:\WINDOWS\system32\drivers\etc\hosts （由于直接修改之后不能保存，可以copy一份到桌面，修改之后，在替换掉原路径下的文件就可以了）,hosts文件以静态映射的方式提供IP地址与主机名的对照表。</p><p>　　　　ISP(网络服务提供商)：如果还是没有，那么就去检查ISP有没有吧~,每一个ISP（网络服务提供商），或一个大学，甚至是一个大学里的系都会有一个自己的本地域名服务器，他会在url第一次访问时缓存该域名的指向。下次再访问时，他会从缓存里把这个url曾经指向的IP调出来。</p><p>　　</p><p>　　　　<strong>递归查询</strong></p><p>　　　　　　第一步：在hosts静态文件、DNS解析器缓存中查找某主机的IP地址</p><p>　　　　　　第二步：上一步无法找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、服务器缓存中查找</p><p>　　　　　　第三步：本地DNS服务器查不到就向ISP(ISP是互联网服务提供商(Internet Service Provider))的简称，ISP有专门的DNS服务器应对DNS查询请求。再找不到就根据‘根提示文件’向负责顶级域‘.com’的DNS服务器查询</p><p>　　　　　　第四步：’根DNS服务器’根据查询域名中的’xyz.com’，再向xyz.com的区域服务器查询</p><p>　　　　　　第五步：<a href="http://www.xyz.abc.com的dns服务器直接解析该域名,将查询到的ip再原路返回给请求查询的主机/">www.xyz.abc.com的DNS服务器直接解析该域名，将查询到的ip再原路返回给请求查询的主机</a></p><p>　　　　<strong>迭代查询：</strong></p><p>　　　　　　第一步：在hosts静态文件、DNS解析器缓存中查找某主机的IP地址</p><p>　　　　　　第二步：上一步无法找到，在DNS本地服务器(即域服务器)查找所有本层次的区域服务器</p><p>　　　　　　第三步：本地DNS服务器查不到就向ISP是互联网服务提供商(Internet Service Provider)的简称，ISP有专门的DNS服务器应对DNS查询请求。再找不到就查询上一层次的所有区域服务器，以此类推直至根域名DNS服务器‘.’</p><p>　　　　　　第四步：到达根域名服务器后又向下查询，直至查到结果为止。</p><p>　　　　<strong>迭代查询与递归查询结合</strong></p><p>　　　　递归查询需要经过逐层查询才能获得查询结果，当查询具有许多层次的DNS结构时效率很低，所以一般采用两者相结合的查询方式。</p><p>　　　　　　第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址</p><p>　　　　　　第二步：上一步无法找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、服务器缓存中查找</p><p>　　　　　　第三步：本地DNS服务器查不到就向ISP是互联网服务提供商(Internet Service Provider)的简称，ISP有专门的DNS服务器应对DNS查询请求。再找不到就根据‘根提示文件’向负责顶级域‘.com’的根DNS服务器查询</p><p>　　　　　　第四步：根DNS服务器直接将其区域DNS服务器的ip地址返回给本地服务器，而不用再向xyz.com的区域服务器查询。</p><p>　　　　　　第五步：（京东有自己DNS服务器）本地DNS服务器将结果返回给请求的主机</p><p>　　　　</p><h3 id="四-交换机、路由器和网关-含DHCP"><a href="#四-交换机、路由器和网关-含DHCP" class="headerlink" title="四 交换机、路由器和网关(含DHCP)"></a>四 交换机、路由器和网关(含DHCP)</h3><p>然后通过路由A转发将消息发出去，消息中包含目标路由D的网关的IP地址，网关分很多的类型：传输网关、应用网关、协议网关等等，我们经常说的网关是指的传输网关，简称网关，我们主要就看它，网关在路由器这里，当请求信息发送到了网关这里的时候，我们先到路由表里面看看有没有这个请求的目标地址的IP，如果没有说明不是我们自己网络内部的IP地址，需要路由转发出去，到internet网络中，但是网络这么大，怎么办，那么通过网关计算出一个最佳的传输路径去找到对应的目标网关地址，在路由转发的过程中(当请求被路由B接收到了之后，路由B打开之后发现不是找自己的，就会把请求信息包继续转发)然后传输到这个网关地址的路由器上，目标网关路由器上设置了一些IP地址+端口和各个服务器上的映射关系，即便是所有的交换机都接收到了这个请求，但是还是能够找到对应的服务器。在通过交换机发送到对应的服务器上</p><p>那么网关到底是什么呢？网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为 “192.168.1.1<del>192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1</del>192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上， TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程也是如此。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>假设你的名字叫小不点，你住在一个大院子里，你的邻居有很多小伙伴，在门口传达室还有个看大门的李大爷，李大爷就是你的网关。当你想跟院子里的某个小伙伴玩，只要你在院子里大喊一声他的名字，他听到了就会回应你，并且跑出来跟你玩。　　但是你不被允许走出大门，你想与外界发生的一切联系，都必须由门口的李大爷（网关）用电话帮助你联系。假如你想找你的同学小明聊天，小明家住在很远的另外一个院子里，他家的院子里也有一个看门的王大爷（小明的网关）。但是你不知道小明家的电话号码，不过你的班主任老师有一份你们班全体同学的名单和电话号码对照表，你的老师就是你的DNS服务器。于是你在家里拨通了门口李大爷的电话，有了下面的对话：　　小不点：李大爷，我想找班主任查一下小明的电话号码行吗？　　李大爷：好，你等着。（接着李大爷给你的班主任挂了一个电话，问清楚了小明的电话）问到了，他家的号码是211.99.99.99　　小不点：太好了！李大爷，我想找小明，你再帮我联系一下小明吧。　　李大爷：没问题。（接着李大爷向电话局发出了请求接通小明家电话的请求，最后一关当然是被转接到了小明家那个院子的王大爷那里，然后王大爷把电话给转到小明家）　　就这样你和小明取得了联系。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>京东的路由器干了什么呢：京东的路由器拿到请求消息之后，需要发给内网(局域网)中的对应的服务器上，这里在路由器上做了一个映射关系也就是说只要访问我这个192.168.3.0:443端口的请求，都去找京东的服务器A，就类似这么个映射关系，具体情况看到时候路由器交换机怎么设置</p><p>路由器对外部网络的通信都是通过外网接口(wan口)去转发出去的，也就是不管你是内网中的哪个电脑，你的请求都要通过路由的外网接口发送出去，别人对你的请求都是通过外网接口接收进来的，至于路由器上对内的lan口是怎么分配IP地址给内网的，要看路由器怎么设置划分vlan也就是子网（内部局域网），每个lan口的IP地址可以是静态的，也可以是动态分配的(DHCP协议)，而且可以划分网段，例如：我的1号lan口对接的网段是192.168.1.0-192.168.1.255，那么所有这个网段的电脑的信息进出都走这个lan口到路由器上，对于连接路由器的交换机来讲，主要的作用就是搭桥用的，搭桥的意思就是让连接该交换机的所有电脑都能够连接起来，只要是同一个网段的互相都可以进行通信，当然这个也要看交换机怎么配置，具体路由器和交换机的配置在这里就不说了，内容很多，大家大概明白它的流程和意思就可以了，喜欢网络的同学，大家可以去深入研究一下，关于公司的网络配置，我会给大家来一个简单的流程给大家参考一下。 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段 交换机又分二层交换机和三层交换机，二层交换机主要就是个搭桥的作用，三层交换机还兼有路由的作用，一般现在的交换机都有DHCP功能，也就是说交换机下面连接的这些电脑的子网IP或者说是局域网IP也可以由交换机来动态生成和分配，路由器和交换机所生成的子网IP都是自己在路由器和交换机上设置的，和路由器上的外网IP没有关系，具体的划分又分为24位的16位的等等，举例：24位的就是10.11.1.0-10.11.1.255这256个IP地址，0表示后面的8bit是00000000，255表示后面的8bit是11111111<br>　　详细一些的交换机和路由器的工作原理，大家可以去看我这篇博客：<a href="https://www.cnblogs.com/clschao/articles/9612944.html">https://www.cnblogs.com/clschao/articles/9612944.html</a></p><p>细说二层交换机、三层交换机、四层交换机。百科：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>第二层交换机，是根据第二层数据链路层的MAC地址和通过站表选择路由来完成端到端的数据交换的。二层交换机具体的工作流程如下：（1） 当交换机从某个端口收到一个数据包，它先读取帧头中的源MAC地址，并将MAC地址与源端口做对应存储在站表中。（2） 再去读取帧头中的目的MAC地址，并在地址表中查找相应的端口；（3） 如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上；（4） 如表中找不到相应的端口则把数据包广播到同一VLAN下的所有端口，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。不断的循环这个过程，对于全网的MAC地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。    因为站表的建立与维护是由交换机自动完成，而路由器又是属于第三层设备，其寻址过程是根据IP地址寻址和通过路由表与路由协议产生的。所以，第二层交换机的最大好处是数据传输速度快，因为它只须识别数据帧中的MAC地址，而直接根据MAC地址产生选择转发端口的算法又十分简单，非常便于采用ASIC专用芯片实现。显然，第二层交换机的解决方案，实际上是一个“处处交换”的廉价方案，虽然该方案也能划分子网、限制广播、建立VLAN，但它的控制能力较小、灵活性不够，也无法控制各信息点的流量，缺乏方便实用的路由功能。第三层交换机，是直接根据第三层网络层IP地址来完成端到端的数据交换的。三层交换机的工作原理：    使用IP的设备A------------------------三层交换机------------------------使用IP的设备B    比如A要给B发送数据，已知目的IP，那么A就用子网掩码取得网络地址，判断目的IP是否与自己在同一网段。    如果在同一网段，但不知道转发数据所需的MAC地址，A就发送一个ARP请求，B返回其MAC地址，A用此MAC封装数据包并发送给交换机，交换机起用二层交换模块，查找MAC地址表，将数据包转发到相应的端口。    如果目的IP地址显示不是同一网段的，那么A要实现和B的通讯，在流缓存条目中没有对应MAC地址条目，就将第一个正常数据包发送向一个缺省网关，这个缺省网关一般在操作系统中已经设好，对应第三层路由模块，所以可见对于不是同一子网的数据，最先在MAC表中放的是缺省网关的MAC地址；然后就由三层模块接收到此数据包，查询路由表以确定到达B的路由，将构造一个新的帧头，其中以缺省网关的MAC地址为源MAC地址，以主机B的MAC地址为目的MAC地址。通过一定的识别触发机制，确立主机A与B的MAC地址及转发端口的对应关系，并记录进流缓存条目表，以后的A到B的数据，就直接交由二层交换模块完成。这就通常所说的一次路由多次转发。表面上看，第三层交换机是第二层交换器与路由器的合二而一，然而这种结合并非简单的物理结合，而是各取所长的逻辑结合。其重要表现是，当某一信息源的第一个数据流进行第三层交换后，其中的路由系统将会产生一个MAC地址与IP地址的映射表，并将该表存储起来，当同一信息源的后续数据流再次进入交换环境时，交换机将根据第一次产生并保存的地址映射表，直接从第二层由源地址传输到目的地址，不再经过第三路由系统处理，从而消除了路由选择时造成的网络延迟，提高了数据包的转发效率，解决了网间传输信息时路由产生的速率瓶颈。所以说，第三层交换机既可完成第二层交换机的端口交换功能，又可完成部分路由器的路由功能。即第三层交换机的交换机方案，实际上是一个能够支持多层次动态集成的解决方案，虽然这种多层次动态集成功能在某些程度上也能由传统路由器和第二层交换机搭载完成，但这种搭载方案与采用三层交换机相比，不仅需要更多的设备配置、占用更大的空间、设计更多的布线和花费更高的成本，而且数据传输性能也要差得多，因为在海量数据传输中，搭载方案中的路由器无法克服路由传输速率瓶颈。第四层交换机    显然，第二层交换机和第三层交换机都是基于端口地址的端到端的交换过程，虽然这种基于MAC地址和IP地址的交换机技术，能够极大地提高各节点之间的数据传输率，但却无法根据端口主机的应用需求来自主确定或动态限制端口的交换过程和数据流量，即缺乏第四层智能应用交换需求。第四层交换机不仅可以完成端到端交换，还能根据端口主机的应用特点，确定或限制它的交换流量。简单地说，第四层交换机是基于传输层数据包的交换过程的，是一类基于TCP/IP协议应用层的用户应用交换需求的新型局域网交换机。第四层交换机支持TCP/UDP第四层以下的所有协议，可识别至少80个字节的数据包包头长度，可根据TCP/UDP端口号来区分数据包的应用类型，从而实现应用层的访问控制和服务质量保证。所以，与其说第四层交换机是硬件网络设备，还不如说它是软件网络管理系统。也就是说，第四层交换机是一类以软件技术为主，以硬件技术为辅的网络管理交换设备。最后值得指出的是，某些人在不同程度上还存在一些模糊概念，认为所谓第四层交换机实际上就是在第三层交换机上增加了具有通过辨别第四层协议端口的能力，仅在第三层交换机上增加了一些增值软件罢了，因而并非工作在传输层，而是仍然在第三层上进行交换操作，只不过是对第三层交换更加敏感而已，从根本上否定第四层交换的关键技术与作用。我们知道，数据包的第二层IEEE802.1P字段或第三层IPToS字段可以用于区分数据包本身的优先级，我们说第四层交换机基于第四层数据包交换，这是说它可以根据第四层TCP/UDP端口号来分析数据包应用类型，即第四层交换机不仅完全具备第三层交换机的所有交换功能和性能，还能支持第三层交换机不可能拥有的网络流量和服务质量控制的智能型功能。重要技术    如上所述，第二层交换设备是依赖于MAC地址和802.1Q协议的VLAN标签信息来完成链路层交换过程的，第三层交换/路由设备则是将IP地址信息用于网络路径选择来完成交换过程的，第四层交换设备则是用传输层数据包的包头信息来帮助信息交换和传输处理的。也就是说，第四层交换机的交换信息所描述的具体内容，实质上是一个包含在每个IP包中的所有协议或进程，如用于Web传输的HTTP，用于文件传输的FTP，用于终端通信的Telnet，用于安全通信的SSL等协议。这样，在一个IP网络里，普遍使用的第四层交换协议，其实就是TCP（用于基于连接的对话，例如FTP）和UDP（用基于无连接的通信，例如SNMP或SMTP）这两个协议。    由于TCP和UDP数据包的包头不仅包括了“端口号”这个域，它还指明了正在传输的数据包是什么类型的网络数据，使用这种与特定应用有关的信息（端口号），就可以完成大量与网络数据及信息传输和交换相关的质量服务，其中最值得说明的是如下五项重要应用技术，因为它们是第四层交换机普遍采用的主要技术。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/827651-20171219165313678-1840473855.png" alt="img"></p><p>　　广域网和路由器：（广域网是个相对的概念，是相对于局域网来说的）</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc/988061-20180903162123427-525619134.png" alt="img"></p><p>　　为了避免广播风暴（以前通过mac地址就可以通信，mac地址通信是广播的形式，如果世界上所有的电脑都通过这种形式通信，就会形成广播风暴，堵塞网络不说，全部信息都变得不安全了，因为所有人都可以收到你发的信息）：分了多个局域网，然后通过路由器连起来了。</p><h3 id="五-总结及其他一些内容简介"><a href="#五-总结及其他一些内容简介" class="headerlink" title="五 总结及其他一些内容简介"></a>五 总结及其他一些内容简介</h3><p>最后，至于路由是如何进行转发的、内部路由表是如何保存的、网关是如何计算最后传输路线的、路由的内网是如何划分的、DHCP和静态IP是如何设置的，DHCP又是如何分配IP地址的，交换机内部工作原理、路由和交换机如何进行配置等等，我们在本篇博客上就不进行深入研究了，本篇博客是为了让小白同学熟悉一下网路相关知识。谢谢大家谅解，如何大家想了解其他的内容，请给我留言，我就会把相关内容整理出来，分享给大家。你的问题是我们共同进步的动力。</p><p>为什么说qq这种p2p的网络通信方式比较特殊呢，因为它是两个局域网的电脑或者手机进行通讯，双方不能确定对方的IP地址，因为你的qq也不知道在哪里登陆，用什么网络，对吧，也就是说双方不知道对方的IP地址，怎么办，需要借助第三方承接，就是腾讯，那么这里面就涉及到了udp打洞，net穿透等技术，有兴趣的可以去了解一下，腾讯为什么nb，也是因为它基本上是国内第一家实现了这些技术的公司，让我们的qq沟通更加方便。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程之socket</title>
      <link href="2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket/"/>
      <url>2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket/</url>
      
        <content type="html"><![CDATA[<h3 id="一-为什么要学习socket"><a href="#一-为什么要学习socket" class="headerlink" title="一 为什么要学习socket"></a>一 为什么要学习socket</h3><p>首先我们python基础部分已经学完了，而socket是我们基础进阶的课程，也就是说，你自己现在完全可以写一些小程序了，但是前面的学习和练习，我们写的代码都是在自己的电脑上运行的，虽然我们学过了模块引入，文件引入import等等，我可以在程序中获取到另一个文件的内容，对吧，但是那么突然有一天，你的朋友和你说：”把你电脑上的一个文件通过你自己写的程序发送到我的电脑上”，这时候怎么办？你是不是会想，what？这怎么搞？就在此时，突然灵感来了，我可以通过qq、云盘、微信等发送给他啊，可是人家说了，让你用自己写的程序啊，嗯，这是个问题，此时又来一个灵感，我给他发送文件肯定是通过网络啊，这就产生了网络，对吧，那我怎么让我的程序能够通过网络来联系到我的朋友呢，并且把文件发送给他呢，那么查了一下，发现网络通信通过socket可以搞，但是怎么搞呢？首先，查询结果是对的，socket就是网络通信的工具，任何一门语言都有socket，他不是任何一个语言的专有名词，而是大家通过自己的程序与其他电脑进行网络通信的时候都用它。知道为什么要学习socket了吧<del>朋友们</del>而你使用自己的电脑和别人的电脑进行联系并发送消息或者文件等操作就叫做网络通信。</p><p>对于一个小白来讲，看到这一节标题的你，此刻的你内心是拒绝的，不明白在说些什么。我理解你的心情，不要惊慌、不要着急，且听我娓娓道来。</p><p>大家通过上面的内容大致的了解了一下什么是网络通信，那么在我们的日常生活中，哪里用到了网络通信呢，网络通信的整个流程又是什么样子的呢？我们要学的socket是怎么在网络中发挥作用的呢？让我们怀揣着这 三个问题 来进行下面的学习。</p><h3 id="二-客户端-服务端架构-哪里用到了网络通信"><a href="#二-客户端-服务端架构-哪里用到了网络通信" class="headerlink" title="二 客户端\服务端架构(哪里用到了网络通信)"></a>二 客户端\服务端架构(哪里用到了网络通信)</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905154656926-139794185.png" alt="img"></p><p>我们使用qq、微信和别人聊天，通过浏览器来浏览页面、看京东的网站，通过优酷、快播(此处只是怀念一下)看片片啥的等等，通过无线打印机来打印一个word文档等，只要有无线、有网、有4G，我们就能好好的聊天，好好的看片片、好好的购物什么的，对吧，那么这些操作都叫做网络通信，确切来说都需要使用网络通信，前提是你要有网(大家记着这个’网’，我下面会给大家详解)，原来生活中处处使用了网络通信，我们通过网络通信的不同形式：比如说qq是我们下载到电脑或者手机上的应用程序(qq应用程序就是人家腾讯开发的软件，放到你的电脑或者手机上供你使用的，大概明白应用程序意思就行，不用深究~~)，浏览器也是我们下载的应用程序，但是浏览器是通过页面来访问别人的网站的，而打印机我是通过我电脑上的word来操作使用的。根据这些不同的场景或者说不用的沟通方式，在业内划分了下面两个架构(架构：就是不同的组成结构)。在看下面的几个架构之前，我们需要知道什么是客户端，什么是服务端。客户端：安装在你电脑上的qq，浏览器(360浏览器、chrome浏览器、IE浏览器等)，当我们使用qq发送消息的时候，消息先发送到了腾讯，然后腾讯在转发到你朋友的qq上，此时你的qq就是客户端，腾讯就是服务端。当我们使用浏览器来看京东的网站的时候，我们电脑上的浏览器就叫做客户端，京东就叫做服务端。</p><p>客户端英文名称：Client(使用服务端的服务)，服务端英文名称：Server(一直运行着，等待服务别人，不能有一天访问百度，百度页面打不开，不行吧。)，下面所说的C\S架构就是说的Client\Server架构。</p><p>　　　　a.硬件C\S架构：打印机。</p><p>　　　　b.软件C\S架构：QQ、微信、优酷、暴风影音、浏览器(IE、火狐，360浏览器等)。其中浏览器又比较特殊，很多网站是基于浏览器来进行访问的，浏览器和各个网站服务端进行的通讯方式又常被成为B\S架构(浏览器英文名称：Browser)，web开发就是这个，后面大家知道有前端的课程对吧，前端就是浏览器上的知识，以后你会经常和浏览器打交道，学完前端就可以进行web开发全栈开发了。如果我把所有的东西都做成应用程序是不是很麻烦啊，要装很多的软件对吧，所有就开始有了B\S架构，只需要个浏览器就能使用很多的工具了，并且提供了一个统一入口，这也是为什么B\S架构火了起来。但是手机端的还是用的应用程序多一些，但是手机端B\S架构也是一个趋势，就像微信的小程序和公众号，为什么说是一个趋势呢，不仅仅是因为方便因为省钱，而是提供了一个统一的入口，其实微信早就实现了。统一入口是什么意思呢？就像我们公司经常用的一个公司内部管理系统，请假、打卡、报销、查客户等等，如果这些功能都需要打开一个网页或者app，是不是很难受啊，那么公司就做了这么一个系统，大家在这个系统上关于上班的一些你需要的功能就都能完成了，这就是统一入口。这也是一个开发思想，大程序分成几个小程序，开发速度也快，开发一个小功能就能上线，而不需要等着所有的功能全部开发完成才上线，解耦分治思想，公司做开发时这种思想很流行，迭代开发。说多了。。</p><p>　　　　不管哪个架构，他们都要进行网络通信，基本都要用socket，我们学习socekt就是为了完成C\S架构项目的开发</p><h3 id="三-网络通信的整个流程"><a href="#三-网络通信的整个流程" class="headerlink" title="三 网络通信的整个流程"></a>三 网络通信的整个流程</h3><p>还记得上面我说过的那个’网’吗，在这一节就给大家讲解，有些同学对网络是既熟悉又陌生，熟悉是因为我们都知道，我们安装一个路由器，拉一个网线，或者用无限路由器，连上网线或者连上wifi就能够上网购物、看片片、吃鸡了，但是这一系列的神操作到底是怎么让我们上网了呢？让我们起底揭秘！由于网络的内容非常的多，本篇博客主要是学socket网络编程，所以我把网络这方面的内容放到了我另外一篇博客上，这个博客很简单，不是什么深入研究类的博客，没有学过网络的或者说对网络不太熟悉的同学可以去看看，地址是<a href="https://www.cnblogs.com/clschao/articles/9613442.html">网络通信的整个流程</a>，有网络基础的同学，可以直接往下面学习，如果你自认上学时是个学渣，也可以过去大致溜一眼<del>将来你面向的是开发，所有网络这一块对你来讲就是大致知道就可以了，但是以后想在技术上有深造，那么就需要你深入的研究一下网络了，内容非常多，学海无涯</del></p><p>别忘了端口+IP能够确定一台电脑上的某一个应用程序~~</p><p>　　那么我们通过下面的代码简单看一下socket到底是个什么样子，大概怎么使用：下面的程序就是一个应用程序，和qq啊、微信啊是一样的，都叫做应用程序。</p><p>　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socket#创建一个socket对象server = socket.socket()  #相当于创建了一部电话ip_port = ('192.168.111.1',8001) #创建一个电话卡server.bind(ip_port) #插上电话卡server.listen(5) #监听着电话，我能监听5个，接到一个电话之后，后面还能有四个人给我打电话，但是后面这四个人都要排队等着，等着我第一个电话挂掉，再来第6个的时候，第六个人的手机会报错print('11111')#等着别人给我打电话，打来电话的时候，我就拿到了和对方的这个连线通道conn和对方的电话号码addrconn,addr = server.accept()  #阻塞住,一直等到有人连接我，连接之后得到一个元祖，里面是连线通道conn和对方的地址(ip+端口)print('22222')print(conn)print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;',addr)while True:    from_client_data = conn.recv(1024) #服务端必须通过两者之间的连接通道来收消息    from_client_data = from_client_data.decode('utf-8')    print(from_client_data)    if from_client_data == 'bye':        break    server_input = input('明威说&gt;&gt;&gt;&gt;：')    conn.send(server_input.encode('utf-8'))    if server_input == 'bye':        breakconn.close() #挂电话server.close() #关手机</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　listen（3），这个3的意思是我连接着一个，后面还可以有三个排队的，也就是支持4个人的服务，但是后面三个要排队。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#_*_coding:utf-8_*_import socketimport timeclient = socket.socket()server_ip_port = ('192.168.111.1',8001)client.connect(server_ip_port)while True:    client_input = input('小文说&gt;&gt;&gt;&gt;：')    client.send(client_input.encode('utf-8')) #给服务端发送消息    if client_input == 'bye':        break    from_server_data = client.recv(1024)    print('来自服务端的消息：',from_server_data.decode('utf-8'))    if from_server_data.decode('utf-8') == 'bye':        breakclient.close() #客户端挂电话</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>注意：先运行server，然后再运行client</strong>，然后你会发现client这个文件再输出台的地方让你输入内容，你输入一个内容然后回车，你会发现server那边的控制台就输出了以client发送的内容</p><p> 　　</p><p>　　今天的内容就到这里，今天学习的怎么样啊同学们，大家好好再重新过一遍，然后把练习题做一做。</p><p><strong>==============================================</strong></p><p>　　这里留两个小练习：</p><p>　　　　1.</p><p>　　　　　　server端：接收时间戳时间，转换成格式化时间</p><p>　　　　　　client端：每隔10秒中把时间戳发给server端，time.time()</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import timet = time.time() #获取时间戳str_t = str(t)print(str_t)stru_t = time.localtime(float(str_t)) #将时间戳转换为结构化时间s2 = time.strftime('%Y-%m-%d %H:%M:%S',stru_t) #将结构化时间转为格式化时间print(s2,type(s2))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　2.  一直对话的程序</p><p>　　　　　　server收一个发一个</p><p>　　　　　　client发一个收一个</p><h3 id="四-网络通信协议-互联网协议"><a href="#四-网络通信协议-互联网协议" class="headerlink" title="四 网络通信协议(互联网协议)"></a>四 网络通信协议(互联网协议)</h3><p>第二天再讲这里，大家第二天再看这里把<del>~</del></p><p>网络通信协议是网络传输的灵魂，非常重要，协议即准则，准则是传输消息的格式要求，那么我们从电脑上发出一个消息，到底是以什么样的消息格式发到了对方的手上呢，来看一看这里&gt;&gt;&gt;，<a href="https://www.cnblogs.com/clschao/articles/9578922.html">网络通信协议</a></p><h3 id="五-osi七层模型"><a href="#五-osi七层模型" class="headerlink" title="五 osi七层模型"></a>五 osi七层模型</h3><p>互联网的核心就是由一堆协议组成，协议就是标准，标准就是大家都认可的，所有人都按照这个来，这样大家都能够互相了解，互相深入了<del>~</del>比如全世界人通信的标准是英语</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905155106930-315839262.png" alt="img"></p><p>五层通信流程：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905155126985-411829218.png" alt="img"></p><h3 id="六-socket"><a href="#六-socket" class="headerlink" title="六 socket"></a>六 socket</h3><p>结合上图来看，socket在哪一层呢，我们继续看下图</p><p>socket在内的五层通讯流程：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905155205942-1989190998.png" alt="img"></p><p>Socket又称为套接字，它是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。当我们使用不同的协议进行通信时就得使用不同的接口，还得处理不同协议的各种细节，这就增加了开发的难度，软件也不易于扩展(就像我们开发一套公司管理系统一样，报账、会议预定、请假等功能不需要单独写系统，而是一个系统上多个功能接口，不需要知道每个功能如何去实现的)。于是UNIX BSD就发明了socket这种东西，socket屏蔽了各个协议的通信细节，使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。这就好比操作系统给我们提供了使用底层硬件功能的系统调用，通过系统调用我们可以方便的使用磁盘（文件操作），使用内存，而无需自己去进行磁盘读写，内存管理。socket其实也是一样的东西，就是提供了tcp/ip协议的抽象，对外提供了一套接口，同过这个接口就可以统一、方便的使用tcp/ip协议的功能了。</p><p>其实站在你的角度上看，socket就是一个模块。我们通过调用模块中已经实现的方法建立两个进程之间的连接和通信。也有人将socket说成ip+port，因为ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序。 所以我们只要确立了ip和port就能找到一个应用程序，并且使用socket模块来与之通信。</p><h3 id="七-套接字socket的发展史及分类"><a href="#七-套接字socket的发展史及分类" class="headerlink" title="七 套接字socket的发展史及分类"></a>七 套接字socket的发展史及分类</h3><p>套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。</p><p><strong>基于文件类型的套接字家族</strong></p><p>套接字家族的名字：AF_UNIX</p><p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</p><p><strong>基于网络类型的套接字家族</strong></p><p>套接字家族的名字：AF_INET</p><p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我们只使用AF_INET)</p><h3 id="八-基于TCP和UDP两个协议下socket的通讯流程"><a href="#八-基于TCP和UDP两个协议下socket的通讯流程" class="headerlink" title="八 基于TCP和UDP两个协议下socket的通讯流程"></a>八 基于TCP和UDP两个协议下socket的通讯流程</h3><p><strong>1.TCP和UDP对比</strong></p><p>TCP（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；文件传输程序。</p><p>UDP（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文(数据包)，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。</p><p>直接看图对比其中差异</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180910152216034-363782334.png" alt="img"></p><p>　</p><p>继续往下看</p><p>TCP和UDP下socket差异对比图：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905155326926-1558587752.png" alt="img"></p><p>上面的图只是让大家感受一下TCP和UDP协议下，socket工作流程的不同，两者之间的差异是tcp需要连接，udp不需要，有些同学是不是有些迷糊，老师，这里面的bind、listen啥的都是什么东西啊，我感觉人生是迷茫的！calm down！下面我们就分开两者，细细学习！</p><p><strong>2.TCP协议下的socket</strong></p><p>来吧！先上图！</p><p>基于TCP的socket通讯流程图片：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905155518924-192745121.png" alt="img"></p><p>虽然上图将通讯流程中的大致描述了一下socket各个方法的作用，但是还是要总结一下通讯流程(下面一段内容)</p><p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p><p>上代码感受一下，需要创建两个文件，文件名称随便起，为了方便看，我的两个文件名称为tcp_server.py(服务端)和tcp_client.py(客户端)，将下面的server端的代码拷贝到tcp_server.py文件中，将下面client端的代码拷贝到tcp_client.py的文件中，然后先运行tcp_server.py文件中的代码，再运行tcp_client.py文件中的代码，然后在pycharm下面的输出窗口看一下效果。</p><p>server端代码示例(如果比喻成打电话)</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketsk = socket.socket()sk.bind(('127.0.0.1',8898))  #把地址绑定到套接字sk.listen()          #监听链接conn,addr = sk.accept() #接受客户端链接ret = conn.recv(1024)  #接收客户端信息print(ret)       #打印客户端信息conn.send(b'hi')        #向客户端发送信息conn.close()       #关闭客户端套接字sk.close()        #关闭服务器套接字(可选)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>client端代码示例</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketsk = socket.socket()           # 创建客户套接字sk.connect(('127.0.0.1',8898))    # 尝试连接服务器sk.send(b'hello!')ret = sk.recv(1024)         # 对话(发送/接收)print(ret)sk.close()            # 关闭客户套接字</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>socket绑定IP和端口时可能出现下面的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905161642943-1660586761.png" alt="img"></p><p>　　　　解决办法：　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#加入一条socket配置，重用ip和端口import socketfrom socket import SOL_SOCKET,SO_REUSEADDRsk = socket.socket()sk.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #在bind前加，允许地址重用sk.bind(('127.0.0.1',8898))  #把地址绑定到套接字sk.listen()          #监听链接conn,addr = sk.accept() #接受客户端链接ret = conn.recv(1024)   #接收客户端信息print(ret)              #打印客户端信息conn.send(b'hi')        #向客户端发送信息conn.close()       #关闭客户端套接字sk.close()        #关闭服务器套接字(可选)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　但是如果你加上了上面的代码之后还是出现这个问题：<strong>OSError: [WinError 10013] 以一种访问权限不允许的方式做了一个访问套接字的尝试</strong>。那么只能换端口了，因为你的电脑不支持端口重用。</p><p>　　　　<strong>记住一点，用socket进行通信，必须是一收一发对应好。</strong></p><p>关于setsockopt可以看这篇文章。<a href="https://www.cnblogs.com/clschao/articles/9588313.html">关于setsockopt的使用</a></p><p>　　提一下：网络相关或者需要和电脑上其他程序通信的程序才需要开一个端口。</p><p>　　</p><p>　　在看UDP协议下的socket之前，我们还需要加一些内容来讲：看代码</p><p>　　　　server端</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketfrom socket import SOL_SOCKET,SO_REUSEADDRsk = socket.socket()# sk.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) sk.bind(('127.0.0.1',8090))sk.listen()conn,addr = sk.accept()  #在这阻塞，等待客户端过来连接while True:    ret = conn.recv(1024)  #接收消息  在这还是要阻塞，等待收消息    ret = ret.decode('utf-8')  #字节类型转换为字符串中文    print(ret)    if ret == 'bye':        #如果接到的消息为bye，退出        break    msg = input('服务端&gt;&gt;')  #服务端发消息    conn.send(msg.encode('utf-8'))    if msg == 'bye':        breakconn.close()sk.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　client端</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketsk = socket.socket()sk.connect(('127.0.0.1',8090)) #连接服务端while True:    msg = input('客户端&gt;&gt;&gt;')  #input阻塞，等待输入内容    sk.send(msg.encode('utf-8'))    if msg == 'bye':        break    ret = sk.recv(1024)    ret = ret.decode('utf-8')    print(ret)    if ret == 'bye':        breaksk.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　你会发现，第一个连接的客户端可以和服务端收发消息，但是第二个连接的客户端发消息服务端是收不到的</p><p>　　原因解释：</p><p>　　　　tcp属于长连接，长连接就是一直占用着这个链接，这个连接的端口被占用了，第二个客户端过来连接的时候，他是可以连接的，但是处于一个占线的状态，就只能等着去跟服务端建立连接，除非一个客户端断开了(优雅的断开可以，如果是强制断开就会报错，因为服务端的程序还在第一个循环里面)，然后就可以进行和服务端的通信了。什么是优雅的断开呢？看代码。</p><p>server端代码：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketfrom socket import SOL_SOCKET,SO_REUSEADDRsk = socket.socket()# sk.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #允许地址重用，这个东西都说能解决问题，我非常不建议大家这么做，容易出问题sk.bind(('127.0.0.1',8090))sk.listen()# 第二步演示，再加一层while循环while True:    #下面的代码全部缩进进去，也就是循环建立连接，但是不管怎么聊，只能和一个聊，也就是另外一个优雅的断了之后才能和另外一个聊                #它不能同时和好多人聊，还是长连接的原因，一直占用着这个端口的连接，udp是可以的，然后我们学习udp    conn,addr = sk.accept()  #在这阻塞，等待客户端过来连接    while True:        ret = conn.recv(1024)  #接收消息  在这还是要阻塞，等待收消息        ret = ret.decode('utf-8')  #字节类型转换为字符串中文        print(ret)        if ret == 'bye':        #如果接到的消息为bye，退出            break        msg = input('服务端&gt;&gt;')  #服务端发消息        conn.send(msg.encode('utf-8'))        if msg == 'bye':            break    conn.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　   client端代码</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketsk = socket.socket()sk.connect(('127.0.0.1',8090)) #连接服务端while True:    msg = input('客户端&gt;&gt;&gt;')  #input阻塞，等待输入内容    sk.send(msg.encode('utf-8'))    if msg == 'bye':        break    ret = sk.recv(1024)    ret = ret.decode('utf-8')    print(ret)    if ret == 'bye':        break# sk.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　强制断开连接之后的报错信息：</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905162547925-846520233.png" alt="img"></p><p><strong>3.UDP协议下的socket</strong></p><p>老样子！先上图！</p><p>基于UDP的socket通讯流程:</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905162753923-1922806984.png" alt="img"></p><p>总结一下UDP下的socket通讯流程</p><p>　　先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，recvform接收消息，这个消息有两项，消息内容和对方客户端的地址，然后回复消息时也要带着你收到的这个客户端的地址，发送回去，最后关闭连接，一次交互结束</p><p>上代码感受一下，需要创建两个文件，文件名称随便起，为了方便看，我的两个文件名称为udp_server.py(服务端)和udp_client.py(客户端)，将下面的server端的代码拷贝到udp_server.py文件中，将下面cliet端的代码拷贝到udp_client.py的文件中，然后先运行udp_server.py文件中的代码，再运行udp_client.py文件中的代码，然后在pycharm下面的输出窗口看一下效果。</p><p>server端代码示例</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketudp_sk = socket.socket(type=socket.SOCK_DGRAM)   #创建一个服务器的套接字udp_sk.bind(('127.0.0.1',9000))        #绑定服务器套接字msg,addr = udp_sk.recvfrom(1024)print(msg)udp_sk.sendto(b'hi',addr)                 # 对话(接收与发送)udp_sk.close()                         # 关闭服务器套接字</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>client端代码示例</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><pre><code>import socketip_port=('127.0.0.1',9000)udp_sk=socket.socket(type=socket.SOCK_DGRAM)udp_sk.sendto(b'hello',ip_port)back_msg,addr=udp_sk.recvfrom(1024)print(back_msg.decode('utf-8'),addr)</code></pre><p>类似于qq聊天的代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#_*_coding:utf-8_*_import socketip_port=('127.0.0.1',8081)udp_server_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #DGRAM:datagram 数据报文的意思，象征着UDP协议的通信方式udp_server_sock.bind(ip_port)#你对外提供服务的端口就是这一个，所有的客户端都是通过这个端口和你进行通信的while True:    qq_msg,addr=udp_server_sock.recvfrom(1024)# 阻塞状态，等待接收消息    print('来自[%s:%s]的一条消息:\033[1;44m%s\033[0m' %(addr[0],addr[1],qq_msg.decode('utf-8')))    back_msg=input('回复消息: ').strip()    udp_server_sock.sendto(back_msg.encode('utf-8'),addr)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>#_*_coding:utf-8_*_import socketBUFSIZE=1024udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)qq_name_dic={    'taibai':('127.0.0.1',8081),    'Jedan':('127.0.0.1',8081),    'Jack':('127.0.0.1',8081),    'John':('127.0.0.1',8081),}while True:    qq_name=input('请选择聊天对象: ').strip()    while True:        msg=input('请输入消息,回车发送,输入q结束和他的聊天: ').strip()        if msg == 'q':break        if not msg or not qq_name or qq_name not in qq_name_dic:continue        udp_client_socket.sendto(msg.encode('utf-8'),qq_name_dic[qq_name])# 必须带着自己的地址，这就是UDP不一样的地方，不需要建立连接，但是要带着自己的地址给服务端，否则服务端无法判断是谁给我发的消息，并且不知道该把消息回复到什么地方，因为我们之间没有建立连接通道        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)# 同样也是阻塞状态，等待接收消息        print('来自[%s:%s]的一条消息:\033[1;44m%s\033[0m' %(addr[0],addr[1],back_msg.decode('utf-8')))udp_client_socket.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>接下来，给大家说一个真实的例子，也就是实际当中应用的，那么这是个什么例子呢？就是我们电脑系统上的时间，windows系统的时间是和微软的时间服务器上的时间同步的，而mac本是和苹果服务商的时间服务器同步的，这是怎么做的呢，首先他们的时间服务器上的时间是和国家同步的，你们用我的系统，那么你们的时间只要和我时间服务器上的时间同步就行了，对吧，我时间服务器是不是提供服务的啊，相当于一个服务端，我们的电脑就相当于客户端，就是通过UDP来搞的。</p><p>我们自制一个时间服务器的代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *from time import strftimeimport timeip_port = ('127.0.0.1', 9000)bufsize = 1024tcp_server = socket(AF_INET, SOCK_DGRAM)tcp_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)tcp_server.bind(ip_port)while True:    msg, addr = tcp_server.recvfrom(bufsize)    print('===&gt;', msg)    stru_time = time.localtime()  #当前的结构化时间    if not msg:        time_fmt = '%Y-%m-%d %X'    else:        time_fmt = msg.decode('utf-8')    back_msg = strftime(time_fmt,stru_time)    print(back_msg,type(back_msg))    tcp_server.sendto(back_msg.encode('utf-8'), addr)tcp_server.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *ip_port=('127.0.0.1',9000)bufsize=1024tcp_client=socket(AF_INET,SOCK_DGRAM)while True:    msg=input('请输入时间格式(例%Y %m %d)&gt;&gt;: ').strip()    tcp_client.sendto(msg.encode('utf-8'),ip_port)    data=tcp_client.recv(bufsize)    print('当前日期：',str(data,encoding='utf-8'))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>UDP来个小练习吧：</p><p>练习的需求是这样的：1、服务端需要提供的服务有：接收消息(时间格式的字符串)、将我的本地的时间转换成接收到的消息的格式(也就是个时间格式的字符串)、发回给客户端。2、客户端自行想一下怎么写。</p><p>TCP协议和UDP协议下socket的基本使用ok了，那我们来深入分析一下socket。(这一块的内容初学者不要看，对socket有些了解的同学可以研究一下，切记看不懂很正常，不要深究，现阶段你们就是学习应用为主！)&gt;&gt;&gt;&gt;看这里&gt;&gt;&gt;&gt;<a href="https://www.cnblogs.com/clschao/articles/9585555.html">socket原理剖析</a>，里面包含socket中各个方法的作用和方法中的参数。</p><p>这里我列出两个简易描述socket各个参数和方法的图，共大家参考：</p><p>socket类型：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906144232596-2066617742.png" alt="img"></p><p>　　socket各个方法的解释：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906144300844-1998252648.png" alt="img"></p><h3 id="九-粘包现象"><a href="#九-粘包现象" class="headerlink" title="九 粘包现象"></a>九 粘包现象</h3><p>　　</p><p>　　说粘包之前，我们先说两个内容，1.缓冲区、2.windows下cmd窗口调用系统指令</p><p>　　<strong>9.1 缓冲区（下面粘包现象的图里面还有关于缓冲区的解释）</strong></p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//1-15101Q60GV27.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。这些I/O缓冲区特性可整理如下：1.I/O缓冲区在每个TCP套接字中单独存在；2.I/O缓冲区在创建套接字时自动生成；3.即使关闭套接字也会继续传送输出缓冲区中遗留的数据；4.关闭套接字将丢失输入缓冲区中的数据。输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取：1.unsigned optVal;2.int optLen = sizeof(int);3.getsockopt(servSock, SOL_SOCKET, SO_SNDBUF,(char*)&amp;optVal, &amp;optLen);4.printf("Buffer length: %d\n", optVal);</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　<strong>9.2 windows下cmd窗口调用系统指令(linux下没有写出来，大家仿照windows的去摸索一下吧)</strong></p><p>　　　　a.首先ctrl+r，弹出左下角的下图，输入cmd指令，确定</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906142738973-2074079056.png" alt="img"></p><p>　　　　b.在打开的cmd窗口中输入dir（dir：查看当前文件夹下的所有文件和文件夹），你会看到下面的输出结果。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906142852952-794590143.png" alt="img"></p><p>　　　　　　另外还有ipconfig（查看当前电脑的网络信息），在windows没有ls这个指令(ls在linux下是查看当前文件夹下所有文件和文件夹的指令，和windows下的dir是类似的)，那么没有这个指令就会报下面这个错误</p><p>　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906143059056-530122725.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>linux shell中一个运行多个命令，命令间用;隔开即可windows的命令提示符中运行多条命令用的是：&amp;&amp;、||、&amp;aa &amp;&amp; bb就是执行aa，成功后再执行bbaa || bb先执行aa，若执行成功则不再执行bb，若失败则执行bba &amp; b表示执行a再执行b，无论a是否成功“执行成功”的意思是返回的errorlevel=0</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　</p><p>　　　　　　为什么要说这个系统指令呢，是希望借助系统指令和指令输出的结果来模拟一下粘包现象，那什么是粘包呢？</p><p> 　　今天的内容就先到这里，明天我们认识粘包~~，大家好好理解练习一下把。</p><p>-———————————————————————————————————————————————————————————————————————————————————-</p><p>　　<strong>9.3 粘包现象（两种）</strong></p><p>　　　　先上图：（本图是我做出来为了让小白同学有个大致的了解用的，其中很多地方更加的复杂，那就需要将来大家有多余的精力的时候去做一些深入的研究了，这里我就不带大家搞啦）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906161708494-693168966.png" alt="img"></p><p>　　　　关于MTU大家可以看看这篇文章 <a href="https://yq.aliyun.com/articles/222535">https://yq.aliyun.com/articles/222535</a>  还有百度百科 <a href="https://baike.baidu.com/item/mtu/508920?fr=aladdin">MTU百科</a></p><p>　　　　MTU简单解释：</p><pre><code>MTU是Maximum Transmission Unit的缩写。意思是网络上传送的最大数据包。MTU的单位是字节。 大部分网络设备的MTU都是1500个字节，也就是1500B。如果本机一次需要发送的数据比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度</code></pre><p>　　　　关于上图中提到的Nagle算法等建议大家去看一看Nagle算法、延迟ACK、linux下的TCP_NODELAY和TCP_CORK，这些内容等你们把python学好以后再去研究吧，网络的内容实在太多啦，也就是说大家需要努力的过程还很长，加油！</p><p>　　</p><p>　　超出缓冲区大小会报下面的错误，或者udp协议的时候，你的一个数据包的大小超过了你一次recv能接受的大小，也会报下面的错误，tcp不会，但是超出缓存区大小的时候，肯定会报这个错误。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180905174352945-226285646.png" alt="img"></p><p>　　<strong>9.4 模拟一个粘包现象</strong></p><p>　　　　在模拟粘包之前，我们先学习一个模块subprocess。</p><p>　　　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import subprocesscmd = input('请输入指令&gt;&gt;&gt;')res = subprocess.Popen(    cmd,                     #字符串指令：'dir','ipconfig',等等    shell=True,              #使用shell，就相当于使用cmd窗口    stderr=subprocess.PIPE,  #标准错误输出，凡是输入错误指令，错误指令输出的报错信息就会被它拿到    stdout=subprocess.PIPE,  #标准输出，正确指令的输出结果被它拿到)print(res.stdout.read().decode('gbk'))print(res.stderr.read().decode('gbk'))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　 　　注意：</p><p>　　　　　　　　如果是windows，那么<strong>res.stdout.read()读出的就是GBK编码的</strong>，在接收端需<strong>要用GBK解码</strong></p><p>　　　　　　　　<strong>且只能从管道里读一次结果，PIPE称为管道。</strong></p><p> 　　　　下面是subprocess和windows上cmd下的指令的对应示意图：subprocess的stdout.read()和stderr.read()，拿到的结果是bytes类型，所以需要转换为字符串打印出来看。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906164309154-1619216376.png" alt="img"></p><p>　　　　</p><p>　　　　好，既然我们会使用subprocess了，那么我们就通过它来模拟一个粘包，终于到模拟粘包现象了，这一天真的是好累。</p><p>　　　　<strong>tcp粘包演示(一)：</strong></p><p>　　　　　　先从上面粘包现象中的第一种开始：<strong>接收方没有及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）</strong> </p><p>　　　　　　server端代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>cket import *import subprocessip_port=('127.0.0.1',8080)BUFSIZE=1024tcp_socket_server=socket(AF_INET,SOCK_STREAM)tcp_socket_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)while True:    conn,addr=tcp_socket_server.accept()    print('客户端&gt;&gt;&gt;',addr)    while True:        cmd=conn.recv(BUFSIZE)        if len(cmd) == 0:break        res=subprocess.Popen(cmd.decode('gbk'),shell=True,                         stdout=subprocess.PIPE,                         stdin=subprocess.PIPE,                         stderr=subprocess.PIPE)        stderr=res.stderr.read()        stdout=res.stdout.read()        conn.send(stderr)        conn.send(stdout)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　　　client端代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketip_port = ('127.0.0.1',8080)size = 1024tcp_sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)res = tcp_sk.connect(ip_port)while True:    msg=input('&gt;&gt;: ').strip()    if len(msg) == 0:continue    if msg == 'quit':break    tcp_sk.send(msg.encode('utf-8'))    act_res=tcp_sk.recv(size)    print('接收的返回结果长度为&gt;',len(act_res))    print('std&gt;&gt;&gt;',act_res.decode('gbk')) #windows返回的内容需要用gbk来解码，因为windows系统的默认编码为gbk</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　<strong>tcp粘包演示(二)：发送数据时间间隔很短，数据也很小，会合到一起，产生粘包</strong></p><p>　　　　　　server端代码示例：（如果两次发送有一定的时间间隔，那么就不会出现这种粘包情况，试着在两次发送的中间加一个time.sleep(1)）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *ip_port=('127.0.0.1',8080)tcp_socket_server=socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)conn,addr=tcp_socket_server.accept()data1=conn.recv(10)data2=conn.recv(10)print('-----&gt;',data1.decode('utf-8'))print('-----&gt;',data2.decode('utf-8'))conn.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　client端代码示例：　　　　　　　　　　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketBUFSIZE=1024ip_port=('127.0.0.1',8080)s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)# res=s.connect_ex(ip_port)res=s.connect(ip_port)s.send('hi'.encode('utf-8'))s.send('meinv'.encode('utf-8'))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　示例二的结果：全部被第一个recv接收了</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906201121376-1105326406.png" alt="img"></p><p>　　　　<strong>udp粘包演示：</strong>注意：udp是面向包的，所以udp是不存在粘包的</p><p>　　　　　　server端代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketfrom socket import SOL_SOCKET,SO_REUSEADDR,SO_SNDBUF,SO_RCVBUFsk = socket.socket(type=socket.SOCK_DGRAM)# sk.setsockopt(SOL_SOCKET,SO_RCVBUF,80*1024)sk.bind(('127.0.0.1',8090))msg,addr = sk.recvfrom(1024)while True:    cmd = input('&gt;&gt;&gt;&gt;')    if cmd == 'q':        break    sk.sendto(cmd.encode('utf-8'),addr)    msg,addr = sk.recvfrom(1032)    # print('&gt;&gt;&gt;&gt;', sk.getsockopt(SOL_SOCKET, SO_SNDBUF))    # print('&gt;&gt;&gt;&gt;', sk.getsockopt(SOL_SOCKET, SO_RCVBUF))    print(len(msg))    print(msg.decode('utf-8'))sk.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　　   client端代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketfrom socket import SOL_SOCKET,SO_REUSEADDR,SO_SNDBUF,SO_RCVBUFsk = socket.socket(type=socket.SOCK_DGRAM)# sk.setsockopt(SOL_SOCKET,SO_RCVBUF,80*1024)sk.bind(('127.0.0.1',8090))msg,addr = sk.recvfrom(1024)while True:    cmd = input('&gt;&gt;&gt;&gt;')    if cmd == 'q':        break    sk.sendto(cmd.encode('utf-8'),addr)    msg,addr = sk.recvfrom(1024)    # msg,addr = sk.recvfrom(1218)    # print('&gt;&gt;&gt;&gt;', sk.getsockopt(SOL_SOCKET, SO_SNDBUF))    # print('&gt;&gt;&gt;&gt;', sk.getsockopt(SOL_SOCKET, SO_RCVBUF))    print(len(msg))    print(msg.decode('utf-8'))sk.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　  在udp的代码中，我们在server端接收返回消息的时候，我们设置的recvfrom(1024)，那么当我输入的执行指令为‘dir’的时候，dir在我当前文件夹下输出的内容大于1024，然后就报错了，报的错误也是下面这个：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906200005883-359417049.png" alt="img"></p><p>　　　　<strong>解释原因：是因为udp是面向报文的，意思就是每个消息是一个包，你接收端设置接收大小的时候，必须要比你发的这个包要大，不然一次接收不了就会报这个错误，而tcp不会报错，这也是为什么ucp会丢包的原因之一，这个和我们上面缓冲区那个错误的报错原因是不一样的。</strong>　　</p><p>　　<strong>9.5 TCP会粘包、UDP永远不会粘包</strong></p><p>　　　　看下面的解释原因：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。    1.TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。    2.UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。    3.tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　</p><p>　　补充两个问题：　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><pre><code>补充问题一：为何tcp是可靠传输，udp是不可靠传输    tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的。    而udp发送数据，对端是不会返回确认信息的，因此不可靠补充问题二：send(字节流)和sendall    send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失，一般的小数据就用send，因为小数据也用sendall的话有些影响代码性能，简单来讲就是还多while循环这个代码呢。　　用UDP协议发送时，用sendto函数最大能发送数据的长度为：65535- IP头(20) – UDP头(8)＝65507字节。用sendto函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。（丢弃这个包，不进行发送） 用TCP协议发送时，由于TCP是数据流协议，因此不存在包大小的限制（暂不考虑缓冲区的大小），这是指在用send函数时，数据长度参数不受限制。而实际上，所指定的这段数据并不一定会一次性发送出去，如果这段数据比较长，会被分段发送，如果比较短，可能会等待和下一次数据一起发送。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><p>　　粘包的原因：<strong>主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的</strong></p><p> 　　　　</p><p>　　学到这里，我们留一个小作业（做不做是你的事情，我的事情是真心的教会你，希望你尊重自己的努力）：实现一个简单的网盘功能。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180906203246378-1299711312.png" alt="img"></p><h3 id="十-粘包的解决方案"><a href="#十-粘包的解决方案" class="headerlink" title="十 粘包的解决方案"></a>十 粘包的解决方案</h3><p>　　<strong>解决方案（一）：</strong></p><p> 　　　　问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端发一个确认消息给发送端，然后发送端再发送过来后面的真实内容，接收端再来一个死循环接收完所有数据。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180907101754928-583127457.png" alt="img"></p><p>　　　　看代码示例：</p><p>　　　　　　server端代码　</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socket,subprocessip_port=('127.0.0.1',8080)s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)s.bind(ip_port)s.listen(5)while True:    conn,addr=s.accept()    print('客户端',addr)    while True:        msg=conn.recv(1024)        if not msg:break        res=subprocess.Popen(msg.decode('utf-8'),shell=True,\                            stdin=subprocess.PIPE,\                         stderr=subprocess.PIPE,\                         stdout=subprocess.PIPE)        err=res.stderr.read()        if err:            ret=err        else:            ret=res.stdout.read()        data_length=len(ret)        conn.send(str(data_length).encode('utf-8'))        data=conn.recv(1024).decode('utf-8')        if data == 'recv_ready':            conn.sendall(ret)    conn.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　　  client端代码示例</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socket,times=socket.socket(socket.AF_INET,socket.SOCK_STREAM)res=s.connect_ex(('127.0.0.1',8080))while True:    msg=input('&gt;&gt;: ').strip()    if len(msg) == 0:continue    if msg == 'quit':break    s.send(msg.encode('utf-8'))    length=int(s.recv(1024).decode('utf-8'))    s.send('recv_ready'.encode('utf-8'))    send_size=0    recv_size=0    data=b''    while recv_size &lt; length:        data+=s.recv(1024)        recv_size+=len(data)    print(data.decode('utf-8'))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　<strong>解决方案（二）：</strong></p><p>　　　　通过struck模块将需要发送的内容的长度进行打包，打包成一个4字节长度的数据发送到对端，对端只要取出前4个字节，然后对这四个字节的数据进行解包，拿到你要发送的内容的长度，然后通过这个长度来继续接收我们实际要发送的内容。不是很好理解是吧？哈哈，没关系，看下面的解释~~</p><p> 　　　   为什么要说一下这个模块呢，因为解决方案（一）里面你发现，我每次要先发送一个我的内容的长度，需要接收端接收，并切需要接收端返回一个确认消息，我发送端才能发后面真实的内容，这样是为了保证数据可靠性，也就是接收双方能顺利沟通，但是多了一次发送接收的过程，为了减少这个过程，我们就要使struck来发送你需要发送的数据的长度，来解决上面我们所说的通过发送内容长度来<strong>解决粘包的问题</strong>。</p><p>　　　　<strong>关于struck的介绍：</strong></p><p>　　　　　　<strong>了解c语言的人，一定会知道struct结构体在c语言中的作用，不了解C语言的同学也没关系，不影响，其实它就是定义了一种结构，里面包含不同类型的数据(int,char,bool等等)，方便对某一结构对象进行处理。而在网络通信当中，大多传递的数据是以二进制流（binary data）存在的。当传递字符串时，不必担心太多的问题，而当传递诸如int、char之类的基本数据的时候，就需要有一种机制将某些特定的结构体类型打包成二进制流的字符串然后再网络传输，而接收端也应该可以通过某种机制进行解包还原出原始的结构体数据。python中的struct模块就提供了这样的机制，该模块的主要作用就是对python基本类型值与用python字符串格式表示的C struct类型间的转化（This module performs conversions between Python values and C structs represented as Python strings.）。</strong></p><p>　　　　</p><p>　　　　struck模块的使用：struct模块中最重要的两个函数是pack()打包, unpack()解包。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180907120110643-1938700960.png" alt="img"></p><p>　　　　pack()：#我在这里只介绍一下’i’这个int类型，上面的图中列举除了可以打包的所有的数据类型，并且struck除了pack和uppack两个方法之外还有好多别的方法和用法，大家以后找时间可以去研究一下，这里我就不做介绍啦，网上的教程很多~~</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><pre><code>import structa=12# 将a变为二进制bytes=struct.pack('i',a) -------------------------------------------------------------------------------struct.pack('i',1111111111111) 如果int类型数据太大会报错struck.errorstruct.error: 'i' format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　　　　　pack方法图解：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180907130658547-1686249893.png" alt="img"></p><p>　　　　unpack()：</p><pre><code># 注意，unpack返回的是tuple !!a,=struct.unpack('i',bytes) #将bytes类型的数据解包后，拿到int类型数据</code></pre><p> 　　好，到这里我们将struck这个模块将int类型的数据打包成四个字节的方法了，那么我们就来使用它解决粘包吧。</p><p>　　先看一段伪代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import json,struct#假设通过客户端上传1T:1073741824000的文件a.txt#为避免粘包,必须自定制报头header={'file_size':1073741824000,'file_name':'/a/b/c/d/e/a.txt','md5':'8f6fbf8347faa4924a76856701edb0f3'} #1T数据,文件路径和md5值#为了该报头能传送,需要序列化并且转为bytes，因为bytes只能将字符串类型的数据转换为bytes类型的，所有需要先序列化一下这个字典，字典不能直接转化为byteshead_bytes=bytes(json.dumps(header),encoding='utf-8') #序列化并转成bytes,用于传输#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节head_len_bytes=struct.pack('i',len(head_bytes)) #这4个字节里只包含了一个数字,该数字是报头的长度#客户端开始发送conn.send(head_len_bytes) #先发报头的长度,4个bytesconn.send(head_bytes) #再发报头的字节格式conn.sendall(文件内容) #然后发真实内容的字节格式#服务端开始接收head_len_bytes=s.recv(4) #先收报头4个bytes,得到报头长度的字节格式x=struct.unpack('i',head_len_bytes)[0] #提取报头的长度head_bytes=s.recv(x) #按照报头长度x,收取报头的bytes格式header=json.loads(json.dumps(header)) #提取报头#最后根据报头的内容提取真实的数据,比如real_data_len=s.recv(header['file_size'])s.recv(real_data_len)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　下面看正式的代码：</p><p>　　server端代码示例：报头：就是消息的头部信息，我们要发送的真实内容为报头后面的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socket,struct,jsonimport subprocessphone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #忘了这是干什么的了吧，地址重用？想起来了吗~phone.bind(('127.0.0.1',8080))phone.listen(5)while True:    conn,addr=phone.accept()    while True:        cmd=conn.recv(1024)        if not cmd:break        print('cmd: %s' %cmd)        res=subprocess.Popen(cmd.decode('utf-8'),                             shell=True,                             stdout=subprocess.PIPE,                             stderr=subprocess.PIPE)        err=res.stderr.read()        if err:            back_msg=err        else:            back_msg=res.stdout.read()        conn.send(struct.pack('i',len(back_msg))) #先发back_msg的长度        conn.sendall(back_msg) #在发真实的内容        #其实就是连续的将长度和内容一起发出去，那么整个内容的前4个字节就是我们打包的后面内容的长度，对吧    conn.close(</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　client端代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socket,time,structs=socket.socket(socket.AF_INET,socket.SOCK_STREAM)res=s.connect_ex(('127.0.0.1',8080))while True:    msg=input('&gt;&gt;: ').strip()    if len(msg) == 0:continue    if msg == 'quit':break    s.send(msg.encode('utf-8'))  #发送给一个指令    l=s.recv(4)     #先接收4个字节的数据，因为我们将要发送过来的内容打包成了4个字节，所以先取出4个字节    x=struct.unpack('i',l)[0]  #解包，是一个元祖，第一个元素就是我们的内容的长度    print(type(x),x)    # print(struct.unpack('I',l))    r_s=0    data=b''    while r_s &lt; x:    #根据内容的长度来继续接收4个字节后面的内容。        r_d=s.recv(1024)        data+=r_d        r_s+=len(r_d)    # print(data.decode('utf-8'))    print(data.decode('gbk')) #windows默认gbk编码</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　</p><p>　　复杂一些的代码示例</p><p>　　server端：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socket,struct,jsonimport subprocessphone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)phone.bind(('127.0.0.1',8080))phone.listen(5)while True:    conn,addr=phone.accept()    while True:        cmd=conn.recv(1024)        if not cmd:break        print('cmd: %s' %cmd)        res=subprocess.Popen(cmd.decode('utf-8'),                             shell=True,                             stdout=subprocess.PIPE,                             stderr=subprocess.PIPE)        err=res.stderr.read()        print(err)        if err:            back_msg=err        else:            back_msg=res.stdout.read()        headers={'data_size':len(back_msg)}        head_json=json.dumps(headers)        head_json_bytes=bytes(head_json,encoding='utf-8')        conn.send(struct.pack('i',len(head_json_bytes))) #先发报头的长度        conn.send(head_json_bytes) #再发报头        conn.sendall(back_msg) #在发真实的内容    conn.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　client端：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *import struct,jsonip_port=('127.0.0.1',8080)client=socket(AF_INET,SOCK_STREAM)client.connect(ip_port)while True:    cmd=input('&gt;&gt;: ')    if not cmd:continue    client.send(bytes(cmd,encoding='utf-8'))    head=client.recv(4)    head_json_len=struct.unpack('i',head)[0]    head_json=json.loads(client.recv(head_json_len).decode('utf-8'))    data_len=head_json['data_size']    recv_size=0    recv_data=b''    while recv_size &lt; data_len:        recv_data+=client.recv(1024)        recv_size+=len(recv_data)    #print(recv_data.decode('utf-8'))    print(recv_data.decode('gbk')) #windows默认gbk编码</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　其实上面复杂的代码做了个什么事情呢，就是自定制了报头：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180907175454310-401989560.png" alt="img"></p><p>　　有同学问：老师，你为啥多次send啊，其实多次send和将数据拼接起来send一次是一样的，因为我们约定好了，你接收的时候先接收4个字节，然后再接收后面的内容。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><pre><code>整个流程的大致解释：我们可以把报头做成字典，字典里包含将要发送的真实数据的描述信息(大小啊之类的)，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节。我们在网络上传输的所有数据 都叫做数据包，数据包里的所有数据都叫做报文，报文里面不止有你的数据，还有ip地址、mac地址、端口号等等，其实所有的报文都有报头，这个报头是协议规定的，看一下发送时：先发报头长度再编码报头内容然后发送最后发真实内容接收时：先手报头长度，用struct取出来根据取出的长度收取报头内容，然后解码，反序列化从反序列化的结果中取出待取数据的描述信息，然后去取真实的数据内容 </code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><p>　　FTP上传下载文件的代码（简易版）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketimport structimport jsonsk = socket.socket()# buffer = 4096 # 当双方的这个接收发送的大小比较大的时候，就像这个4096，就会丢数据，这个等我查一下再告诉大家，改小了就ok的，在linux上也是ok的。buffer = 1024 #每次接收数据的大小sk.bind(('127.0.0.1',8090))sk.listen()conn,addr = sk.accept()#接收head_len = conn.recv(4)head_len = struct.unpack('i',head_len)[0] #解包json_head = conn.recv(head_len).decode('utf-8') #反序列化head = json.loads(json_head)filesize = head['filesize']with open(head['filename'],'wb') as f:    while filesize:        if filesize &gt;= buffer: #&gt;=是因为如果刚好等于的情况出现也是可以的。            content = conn.recv(buffer)            f.write(content)            filesize -= buffer        else:            content = conn.recv(buffer)            f.write(content)            breakconn.close()sk.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import osimport jsonimport socketimport structsk = socket.socket()sk.connect(('127.0.0.1',8090))buffer = 1024 #读取文件的时候，每次读取的大小head = {            'filepath':r'D:\打包程序', #需要下载的文件路径，也就是文件所在的文件夹            'filename':'xxx.mp4',  #改成上面filepath下的一个文件            'filesize':None,        }file_path = os.path.join(head['filepath'],head['filename'])filesize = os.path.getsize(file_path)head['filesize'] = filesize# json_head = json.dumps(head,ensure_ascii=False)  #字典转换成字符串json_head = json.dumps(head)  #字典转换成字符串bytes_head = json_head.encode('utf-8') #字符串转换成bytes类型print(json_head)print(bytes_head)#计算head的长度，因为接收端先接收我们自己定制的报头，对吧head_len = len(bytes_head) #报头长度pack_len = struct.pack('i',head_len)print(head_len)print(pack_len)sk.send(pack_len)  #先发送报头长度sk.send(bytes_head) #再发送bytes类型的报头#即便是视频文件，也是可以按行来读取的，也可以readline，也可以for循环，但是读取出来的数据大小就不固定了，影响效率，有可能读的比较小，也可能很大，像视频文件一般都是一行的二进制字节流。#所有我们可以用read，设定一个一次读取内容的大小，一边读一边发，一边收一边写with open(file_path,'rb') as f:    while filesize:        if filesize &gt;= buffer: #&gt;=是因为如果刚好等于的情况出现也是可以的。            content = f.read(buffer) #每次读取出来的内容            sk.send(content)            filesize -= buffer #每次减去读取的大小        else: #那么说明剩余的不够一次读取的大小了，那么只要把剩下的读取出来发送过去就行了            content = f.read(filesize)            sk.send(content)            breaksk.close()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　FTP上传下载文件的代码（升级版）(注：咱们学完网络编程就留FTP作业，这个代码可以参考，当你用函数的方式写完之后，再用面向对象进行改版却没有思路的时候再来看，别骗自己昂~~)</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketimport structimport jsonimport subprocessimport osclass MYTCPServer:    address_family = socket.AF_INET    socket_type = socket.SOCK_STREAM    allow_reuse_address = False    max_packet_size = 8192    coding='utf-8'    request_queue_size = 5    server_dir='file_upload'    def __init__(self, server_address, bind_and_activate=True):        """Constructor.  May be extended, do not override."""        self.server_address=server_address        self.socket = socket.socket(self.address_family,                                    self.socket_type)        if bind_and_activate:            try:                self.server_bind()                self.server_activate()            except:                self.server_close()                raise    def server_bind(self):        """Called by constructor to bind the socket.        """        if self.allow_reuse_address:            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        self.socket.bind(self.server_address)        self.server_address = self.socket.getsockname()    def server_activate(self):        """Called by constructor to activate the server.        """        self.socket.listen(self.request_queue_size)    def server_close(self):        """Called to clean-up the server.        """        self.socket.close()    def get_request(self):        """Get the request and client address from the socket.        """        return self.socket.accept()    def close_request(self, request):        """Called to clean up an individual request."""        request.close()    def run(self):        while True:            self.conn,self.client_addr=self.get_request()            print('from client ',self.client_addr)            while True:                try:                    head_struct = self.conn.recv(4)                    if not head_struct:break                    head_len = struct.unpack('i', head_struct)[0]                    head_json = self.conn.recv(head_len).decode(self.coding)                    head_dic = json.loads(head_json)                    print(head_dic)                    #head_dic={'cmd':'put','filename':'a.txt','filesize':123123}                    cmd=head_dic['cmd']                    if hasattr(self,cmd):                        func=getattr(self,cmd)                        func(head_dic)                except Exception:                    break    def put(self,args):        file_path=os.path.normpath(os.path.join(            self.server_dir,            args['filename']        ))        filesize=args['filesize']        recv_size=0        print('-----&gt;',file_path)        with open(file_path,'wb') as f:            while recv_size &lt; filesize:                recv_data=self.conn.recv(self.max_packet_size)                f.write(recv_data)                recv_size+=len(recv_data)                print('recvsize:%s filesize:%s' %(recv_size,filesize))tcpserver1=MYTCPServer(('127.0.0.1',8080))tcpserver1.run()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketimport structimport jsonimport osclass MYTCPClient:    address_family = socket.AF_INET    socket_type = socket.SOCK_STREAM    allow_reuse_address = False    max_packet_size = 8192    coding='utf-8'    request_queue_size = 5    def __init__(self, server_address, connect=True):        self.server_address=server_address        self.socket = socket.socket(self.address_family,                                    self.socket_type)        if connect:            try:                self.client_connect()            except:                self.client_close()                raise    def client_connect(self):        self.socket.connect(self.server_address)    def client_close(self):        self.socket.close()    def run(self):        while True:            inp=input("&gt;&gt;: ").strip()            if not inp:continue            l=inp.split()            cmd=l[0]            if hasattr(self,cmd):                func=getattr(self,cmd)                func(l)    def put(self,args):        cmd=args[0]        filename=args[1]        if not os.path.isfile(filename):            print('file:%s is not exists' %filename)            return        else:            filesize=os.path.getsize(filename)        head_dic={'cmd':cmd,'filename':os.path.basename(filename),'filesize':filesize}        print(head_dic)        head_json=json.dumps(head_dic)        head_json_bytes=bytes(head_json,encoding=self.coding)        head_struct=struct.pack('i',len(head_json_bytes))        self.socket.send(head_struct)        self.socket.send(head_json_bytes)        send_size=0        with open(filename,'rb') as f:            for line in f:                self.socket.send(line)                send_size+=len(line)                print(send_size)            else:                print('upload successful')client=MYTCPClient(('127.0.0.1',8080))client.run()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>ok<del>今天的内容就到这里，大家别着急，稳扎稳打，把上面学习的这些内容在好好理解理解，写写代码练习练习</del> </p><p>====================================================================================================================</p><h3 id="十一-验证客户端的链接合法性"><a href="#十一-验证客户端的链接合法性" class="headerlink" title="十一 验证客户端的链接合法性"></a>十一 验证客户端的链接合法性</h3><p>　　首先，我们来探讨一下，什么叫验证合法性， 举个例子：有一天，我开了一个socket服务端，只想让咱们这个班的同学使用，但是有一天，隔壁班的同学过来问了一下我开的这个服务端的ip和端口，然后他是不是就可以去连接我了啊，那怎么办，我是不是不想让他连接我啊，我需要验证一下你的身份，这就是验证连接的合法性，再举个例子，就像我们上面说的你的windows系统是不是连接微软的时间服务器来获取时间的啊，你的mac能到人家微软去获取时间吗，你愿意，人家微软还不愿意呢，对吧，那这时候，你每次连接我来获取时间的时候，我是不是就要验证你的身份啊，也就是你要带着你的系统信息，我要判断你是不是我微软的windows，对吧，如果是mac，我是不是不让你连啊，这就是连接合法性。如果验证你的连接是合法的，那么如果我还要对你的身份进行验证的需求，也就是要验证用户名和密码，那么我们还需要进行身份认证。连接认证&gt;&gt;身份认证&gt;&gt;ok你可以玩了。</p><p>　　</p><p>　　好大致描述相信大家基本理解了，如果这还没有理解，那么同学，我要哭晕在厕所了。</p><p>　　　　</p><p>　　如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现，直接看代码！（SSL，我们都）</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *import hmac,ossecret_key=b'Jedan has a big key!'def conn_auth(conn):    '''    认证客户端链接    :param conn:    :return:    '''    print('开始验证新链接的合法性')    msg=os.urandom(32)#生成一个32字节的随机字符串    conn.sendall(msg)    h=hmac.new(secret_key,msg)     digest=h.digest()    respone=conn.recv(len(digest))    return hmac.compare_digest(respone,digest)def data_handler(conn,bufsize=1024):    if not conn_auth(conn):        print('该链接不合法,关闭')        conn.close()        return    print('链接合法,开始通信')    while True:        data=conn.recv(bufsize)        if not data:break        conn.sendall(data.upper())def server_handler(ip_port,bufsize,backlog=5):    '''    只处理链接    :param ip_port:    :return:    '''    tcp_socket_server=socket(AF_INET,SOCK_STREAM)    tcp_socket_server.bind(ip_port)    tcp_socket_server.listen(backlog)    while True:        conn,addr=tcp_socket_server.accept()        print('新连接[%s:%s]' %(addr[0],addr[1]))        data_handler(conn,bufsize)if __name__ == '__main__':    ip_port=('127.0.0.1',9999)    bufsize=1024    server_handler(ip_port,bufsize)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>from socket import *import hmac,ossecret_key=b'Jedan has a big key！'def conn_auth(conn):    '''    验证客户端到服务器的链接    :param conn:    :return:    '''    msg=conn.recv(32)    h=hmac.new(secret_key,msg)    digest=h.digest()    conn.sendall(digest)def client_handler(ip_port,bufsize=1024):    tcp_socket_client=socket(AF_INET,SOCK_STREAM)    tcp_socket_client.connect(ip_port)    conn_auth(tcp_socket_client)    while True:        data=input('&gt;&gt;: ').strip()        if not data:continue        if data == 'quit':break        tcp_socket_client.sendall(data.encode('utf-8'))        respone=tcp_socket_client.recv(bufsize)        print(respone.decode('utf-8'))    tcp_socket_client.close()if __name__ == '__main__':    ip_port=('127.0.0.1',9999)    bufsize=1024    client_handler(ip_port,bufsize)</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　介绍代码中使用的两个方法：</p><p>　　<strong>1、os.urandom(n)</strong></p><p>　　　　其中os.urandom(n) 是一种bytes类型的随机生成n个字节字符串的方法，而且每次生成的值都不相同。再加上md5等加密的处理，就能够成内容不同长度相同的字符串了。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>os.urandom(n)函数在python官方文档中做出了这样的解释函数定位： Return a string of n random bytes suitable for cryptographic use. 意思就是，返回一个有n个byte那么长的一个string，然后很适合用于加密。然后这个函数，在文档中，被归结于os这个库的Miscellaneous Functions，意思是不同种类的函数（也可以说是混种函数） 原因是： This function returns random bytes from an OS-specific randomness source. （函数返回的随机字节是根据不同的操作系统特定的随机函数资源。即，这个函数是调用OS内部自带的随机函数的。有特异性）</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　　使用方法：</p><pre><code>import osfrom hashlib import md5for i in range(10):    print md5(os.urandom(24)).hexdigest()</code></pre><p>　　<strong>2、hmac</strong>： 我们完全可以用hashlib来实现，但是学个新的吗，没什么不好的，这个操作更方便一些。</p><p>　　　　Python自带的hmac模块实现了标准的Hmac算法，我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：</p><pre><code>import hmacmessage = b'Hello world'key = b'secret'h = hmac.new(key,message,digestmod='MD5')print(h.hexdigest())比较两个密文是否相同，可以用hmac.compare_digest(密文、密文)，然会True或者False。</code></pre><p> 　　　　可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。<strong>需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。</strong></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><pre><code>def hmac_md5(key, s):    return hmac.new(key.encode('utf-8'), s.encode('utf-8'), 'MD5').hexdigest()class User(object):    def __init__(self, username, password):        self.username = username        self.key = ''.join([chr(random.randint(48, 122)) for i in range(20)])        self.password = hmac_md5(self.key, password)</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="十二-socketserver模块实现并发"><a href="#十二-socketserver模块实现并发" class="headerlink" title="十二 socketserver模块实现并发"></a>十二 socketserver模块实现并发</h3><p>　　为什么要讲socketserver？我们之前写的tcp协议的socket是不是一次只能和一个客户端通信，如果用socketserver可以实现和多个客户端通信。它是在socket的基础上进行了一层封装，也就是说底层还是调用的socket，在py2.7里面叫做SocketServer也就是大写了两个S，在py3里面就小写了。后面我们要写的FTP作业，需要用它来实现并发，也就是同时可以和多个客户端进行通信，多个人可以同时进行上传下载等。</p><p>　　那么我们先看socketserver怎么用呢，然后在分析，先看下面的代码</p><p>　　</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><pre><code>import socketserver                              #1、引入模块class MyServer(socketserver.BaseRequestHandler): #2、自己写一个类，类名自己随便定义，然后继承socketserver这个模块里面的BaseRequestHandler这个类    def handle(self):                            #3、写一个handle方法，必须叫这个名字        #self.request                            #6、self.request 相当于一个conn        self.request.recv(1024)                  #7、收消息        msg = '亲，学会了吗'        self.request.send(bytes(msg,encoding='utf-8')) #8、发消息        self.request.close()                     #9、关闭连接        # 拿到了我们对每个客户端的管道，那么我们自己在这个方法里面的就写我们接收消息发送消息的逻辑就可以了        passif __name__ == '__mian__':    #thread 线程，现在只需要简单理解线程，别着急，后面很快就会讲到啦，看下面的图    server = socketserver.ThreadingTCPServer(('127.0.0.1',8090),MyServer)#4、使用socketserver的ThreadingTCPServer这个类，将IP和端口的元祖传进去，还需要将上面咱们自己定义的类传进去，得到一个对象，相当于我们通过它进行了bind、listen    server.serve_forever()                       #5、使用我们上面这个类的对象来执行serve_forever()方法，他的作用就是说，我的服务一直开启着，就像京东一样，不能关闭网站，对吧，并且serve_forever()帮我们进行了accept#注意：#有socketserver 那么有socketclient的吗？#当然不会有，我要作为客户去访问京东的时候，京东帮我也客户端了吗，客户端是不是在我们自己的电脑啊，并且socketserver对客户端没有太高的要求，只需要自己写一些socket就行了。</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　</p><p>　　<strong>ThreadingTCPServer，多线程，简单解释：看图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180908172855514-701166339.png" alt="img"></p><p>　　通过上面的代码，我们来分析socket的源码：（大家还记得面向对象的继承吗，来，实战的时候来啦）</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><pre><code>在整个socketserver这个模块中，其实就干了两件事情：1、一个是循环建立链接的部分，每个客户链接都可以连接成功  2、一个通讯循环的部分，就是每个客户端链接成功之后，要循环的和客户端进行通信。看代码中的：server=socketserver.ThreadingTCPServer(('127.0.0.1',8090),MyServer)还记得面向对象的继承吗？来，大家自己尝试着看看源码：查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer实例化得到server，先找ThreadMinxIn中的__init__方法，发现没有init方法，然后找类ThreadingTCPServer的__init__,在TCPServer中找到，在里面创建了socket对象，进而执行server_bind（相当于bind）,server_active（点进去看执行了listen）找server下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address)上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找__init__方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找....源码分析总结：基于tcp的socketserver我们自己定义的类中的　　self.server即套接字对象　　self.request即一个链接　　self.client_address即客户端地址基于udp的socketserver我们自己定义的类中的　　self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b'adsf', &lt;socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_DGRAM, proto=0, laddr=('127.0.0.1', 8080)&gt;)　　self.client_address即客户端地址</code></pre><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//copycode.gif" alt="复制代码"></a></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　一个完整的sockeserver代码示例：</p><p>　　　　服务端代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketserverclass Myserver(socketserver.BaseRequestHandler):    def handle(self):        self.data = self.request.recv(1024).strip()        print("{} wrote:".format(self.client_address[0]))        print(self.data)        self.request.sendall(self.data.upper())if __name__ == "__main__":    HOST, PORT = "127.0.0.1", 9999    # 设置allow_reuse_address允许服务器重用地址    socketserver.TCPServer.allow_reuse_address = True    # 创建一个server, 将服务地址绑定到127.0.0.1:9999    #server = socketserver.TCPServer((HOST, PORT),Myserver)    server = socketserver.ThreadingTCPServer((HOST, PORT),Myserver)    # 让server永远运行下去，除非强制停止程序    server.serve_forever()</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 　　　  客户端代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>import socketHOST, PORT = "127.0.0.1", 9999data = "hello"# 创建一个socket链接，SOCK_STREAM代表使用TCP协议with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:    sock.connect((HOST, PORT))          # 链接到客户端    sock.sendall(bytes(data + "\n", "utf-8")) # 向服务端发送数据    received = str(sock.recv(1024), "utf-8")# 从服务端接收数据print("Sent:     {}".format(data))print("Received: {}".format(received))</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　</p><h3 id="十三-网络编程的作业"><a href="#十三-网络编程的作业" class="headerlink" title="十三 网络编程的作业"></a>十三 网络编程的作业</h3><p> 　　好了同学们，到了这儿，我们的网络编程socket就讲完了，大致就是这些内容，给大家留个作业：（你的努力的成果你自己是看的到的~！）</p><p>　　加粗的是必须要做的，倾斜的是比较有难度的，大家别放松呀。</p><p><strong>1. 多用户同时登陆</strong></p><p>　　简单分析一下实现方式：</p><p>　　1.字符串操作以及打印 —— 实现上传下载的进度条功能</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//ExpandedBlockStart.gif" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>一、    import sys    import time    for i in range(50):        sys.stdout.write('&gt;')        sys.stdout.flush()        time.sleep(0.2)二、    #总共接收到的大小和总文件大小的比值：    #all_size_len表示当前总共接受的多长的数据，是累计的    #file_size表示文件的总大小        per_cent = round(all_size_len/file_size,2) #将比值做成两位数的小数    #通过\r来实现同一行打印，每次打印都回到行首打印        print('\r'+ '%s%%'%(str(int(per_cent*100))) + '*'*(int(per_cent*100)),end='')  #由于float类型的数据没法通过%s来进行字符串格式化，所以我在这里通过int来转换了一下，并用str转换了一下，后面再拼接上*，这个*的数量根据现在计算出来的比值来确定，就能够出来%3***这样的效果。自行使用上面的sys.stdout来实现一下这个直接print的效果。</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　2.socketserver —— 实现ftp server端和client端的交互</p><p>　　3.struct模块 —— 自定制报头解决文件上传下载过程中的粘包问题</p><p>　　4.hashlib或者hmac模块 —— 实现文件的一致性校验和用户密文登录</p><p>　　5.os模块 —— 实现目录的切换及查看文件文件夹等功能</p><p>　　6.文件操作 —— 完成上传下载文件及断点续传等功能</p><p>　　看一下流程图：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.05/wlbc//988061-20180909100442395-748634687.png" alt="img"></p><p>　　　　</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器与交换机的工作原理</title>
      <link href="2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>　　计算机网络往往由许多种不同类型的网络互连连接而成。如果几个计算机网络只是在物理上连接在一起，它们之间并不能进行通信，那么这种“互连”并没有什么实际意义。因此通常在谈到“互连”时，就已经暗示这些相互连接的计算机是可以进行通信的，也就是说，从功能上和逻辑上看，这些计算机网络已经组成了一个大型的计算机网络，或称为互联网络，也可简称为互联网、互连网。</p><p>　　将网络互相连接起来要使用一些中间设备(或中间系统)，ISO的术语称之为中继(relay)系统。根据中继系统所在的层次，可以有以下五种中继系统：</p><p>　　1.物理层(即常说的第一层、层L1)中继系统，即转发器(repeater)。</p><p>　　2.数据链路层(即第二层，层L2)，即网桥或桥接器(bridge)。</p><p>　　3.网络层(第三层，层L3)中继系统，即路由器(router)。</p><p>　　4.网桥和路由器的混合物桥路器(brouter)兼有网桥和路由器的功能。</p><p>　　5.在网络层以上的中继系统，即网关(gateway).</p><p>　　当中继系统是转发器时，一般不称之为网络互联，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。高层网关由于比较复杂，目前使用得较少。因此一般讨论网络互连时都是指用交换机和路由器进行互联的网络。本文主要阐述交换机和路由器及其区别。</p><p>　　<strong>交换机和路由器</strong></p><p>　　“交换”是今天网络里出现频率最高的一个词，从桥接到路由到ATM直至电话系统，无论何种场合都可将其套用，搞不清到底什么才是真正的交换。其实交换一词最早出现于电话系统，特指实现两个不同电话机之间话音信号的交换，完成该工作的设备就是电话交换机。所以从本意上来讲，交换只是一种技术概念，即完成信号由设备入口到出口的转发。因此，只要是和符合该定义的所有设备都可被称为交换设备。由此可见，“交换”是一个涵义广泛的词语，当它被用来描述数据网络第二层的设备时，实际指的是一个桥接设备;而当它被用来描述数据网络第三层的设备时，又指的是一个路由设备。</p><p>　　我们经常说到的以太网交换机实际是一个基于网桥技术的多端口第二层网络设备，它为数据帧从一个端口到另一个任意端口的转发提供了低时延、低开销的通路。</p><p>　　由此可见，交换机内部核心处应该有一个交换矩阵，为任意两端口间的通信提供通路，或是一个快速交换总线，以使由任意端口接收的数据帧从其他端口送出。在实际设备中，交换矩阵的功能往往由专门的芯片(ASIC)完成。另外，以太网交换机在设计思想上有一个重要的假设，即交换核心的速度非常之快，以致通常的大流量数据不会使其产生拥塞，换句话说，交换的能力相对于所传信息量而无穷大(与此相反，ATM交换机在设计上的思路是，认为交换的能力相对所传信息量而言有限)。</p><p>　　虽然以太网第二层交换机是基于多端口网桥发展而来，但毕竟交换有其更丰富的特性，使之不但是获得更多带宽的最好途径，而且还使网络更易管理。</p><p>　　而路由器是OSI协议模型的网络层中的分组交换设备(或网络层中继设备)，路由器的基本功能是把数据(IP报文)传送到正确的网络，包括</p><p>　　1.IP数据报的转发，包括数据报的寻径和传送;</p><p>　　2.子网隔离，抑制广播风暴;</p><p>　　3.维护路由表，并与其他路由器交换路由信息，这是IP报文转发的基础。</p><p>　　4.IP数据报的差错处理及简单的拥塞控制;</p><p>　　5.实现对IP数据报的过滤和记帐。</p><p>　　路由器—所谓路由就是指通过相互连接的网络把信息从源地点移动到目标地点的活动。一般来说，在路由过程中，信息至少会经过一个或多个中间节点。通常，人们会把路由和交换进行对比，这主要是因为在普通用户看来两者所实现的功能是完全一样的。其实，路由和交换之间的主要区别就是交换发生在OSI参考模型的第二层(数据链路层)，而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程中需要使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p><p>　　交换机—交换(switching)是按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术统称。广义的交换机(switch)就是一种在通信系统中完成信息交换功能的设备。</p><p>　　在计算机网络系统中，交换概念的提出是对于共享工作模式的改进。我们以前介绍过的HUB集线器就是一种共享设备，HUB本身不能识别目的地址，当同一局域网内的A主机给B主机传输数据时，数据包在以HUB为架构的网络上是以广播方式传输的，由每一台终端通过验证数据包头的地址信息来确定是否接收。也就是说，在这种工作方式下，同一时刻网络上只能传输一组数据帧的通讯，如果发生碰撞还得重试。这种方式就是共享网络带宽。</p><p>　　交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC(网卡的硬件地址)的NIC(网卡)挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。</p><p>　　使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。</p><p>　　交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps=20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。</p><p>　　总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址</p><p>　　说明二层交换机、三层交换机和路由器的基本工作原理和三者之间的主要区别。</p><p>　　<strong>1.二层交换技术</strong></p><p>　　二层交换机是数据链路层的设备，它能够读取数据包中的MAC地址信息并根据MAC地址来进行交换。</p><p>　　交换机内部有一个地址表，这个地址表标明了MAC地址和交换机端口的对应关系。当交换机从某个端口收到一个数据包，它首先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的，它再去读取包头中的目的MAC地址，并在地址表中查找相应的端口，如果表中有与这目的MAC地址对应的端口，则把数据包直接复制到这端口上，如果在表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。</p><p>　　二层交换机就是这样建立和维护它自己的地址表。由于二层交换机一般具有很宽的交换总线带宽，所以可以同时为很多端口进行数据交换。如果二层交换机有N个端口，每个端口的带宽是M，而它的交换机总线带宽超过N×M，那么这交换机就可以实现线速交换。二层交换机对广播包是不做限制的，把广播包复制到所有端口上。</p><p>　　二层交换机一般都含有专门用于处理数据包转发的ASIC (Application specific Integrated Circuit)芯片，因此转发速度可以做到非常快。</p><p>　　<strong>2.路由技术</strong></p><p>　　路由器是在OSI七层网络模型中的第三层——网络层操作的。</p><p>　　路由器内部有一个路由表，这表标明了如果要去某个地方，下一步应该往哪走。路由器从某个端口收到一个数据包，它首先把链路层的包头去掉(拆包)，读取目的IP地址，然后查找路由表，若能确定下一步往哪送，则再加上链路层的包头(打包)，把该数据包转发出去;如果不能确定下一步的地址，则向源地址返回一个信息，并把这个数据包丢掉。</p><p>　　路由技术和二层交换看起来有点相似，其实路由和交换之间的主要区别就是交换发生在OSI参考模型的第二层(数据链路层)，而路由发生在第三层。这一区别决定了路由和交换在传送数据的过程中需要使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p><p>　　路由技术其实是由两项最基本的活动组成，即决定最优路径和传输数据包。其中，数据包的传输相对较为简单和直接，而路由的确定则更加复杂一些。路由算法在路由表中写入各种不同的信息，路由器会根据数据包所要到达的目的地选择最佳路径把数据包发送到可以到达该目的地的下一台路由器处。当下一台路由器接收到该数据包时，也会查看其目标地址，并使用合适的路径继续传送给后面的路由器。依次类推，直到数据包到达最终目的地。</p><p>　　路由器之间可以进行相互通讯，而且可以通过传送不同类型的信息维护各自的路由表。路由更新信息主是这样一种信息，一般是由部分或全部路由表组成。通过分析其它路由器发出的路由更新信息，路由器可以掌握整个网络的拓扑结构。链路状态广播是另外一种在路由器之间传递的信息，它可以把信息发送方的链路状态及进的通知给其它路由器。</p><p>　　<strong>3.三层交换技术</strong></p><p>　　一个具有第三层交换功能的设备是一个带有第三层路由功能的第二层交换机，但它是二者的有机结合，并不是简单的把路由器设备的硬件及软件简单地叠加在局域网交换机上。</p><p>　　从硬件上看，第二层交换机的接口模块都是通过高速背板/总线(速率可高达几十Gbit/s)交换数据的，在第三层交换机中，与路由器有关的第三层路由硬件模块也插接在高速背板/总线上，这种方式使得路由模块可以与需要路由的其他模块间高速的交换数据，从而突破了传统的外接路由器接口速率的限制。在软件方面，第三层交换机也有重大的举措，它将传统的基于软件的路由器软件进行了界定。</p><p>　　其做法是：</p><p>　　对于数据包的转发：如IP/IPX包的转发，这些规律的过程通过硬件得以高速实现。</p><p>　　对于第三层路由软件：如路由信息的更新、路由表维护、路由计算、路由的确定等功能，用优化、高效的软件实现。</p><p>　　假设两个使用IP协议的机器通过第三层交换机进行通信的过程，机器A在开始发送时，已知目的IP地址，但尚不知道在局域网上发送所需要的MAC地址。要采用地址解析(ARP)来确定目的MAC地址。机器A把自己的IP地址与目的IP地址比较，从其软件中配置的子网掩码提取出网络地址来确定目的机器是否与自己在同一子网内。若目的机器B与机器A在同一子网内，A广播一个ARP请求，B返回其MAC地址，A得到目的机器B的MAC地址后将这一地址缓存起来，并用此MAC地址封包转发数据，第二层交换模块查找MAC地址表确定将数据包发向目的端口。若两个机器不在同一子网内，如发送机器A要与目的机器C通信，发送机器A要向“缺省网关”发出ARP包，而“缺省网关”的IP地址已经在系统软件中设置。这个IP地址实际上对应第三层交换机的第三层交换模块。所以当发送机器A对“缺省网关”的IP地址广播出一个ARP请求时，若第三层交换模块在以往的通信过程中已得到目的机器C的MAC地址，则向发送机器A回复C的MAC地址;否则第三层交换模块根据路由信息向目的机器广播一个ARP请求，目的机器C得到此ARP请示后向第三层交换模块回复其MAC地址，第三层交换模块保存此地址并回复给发送机器A。以后，当再进行A与C之间数据包转发进，将用最终的目的机器的MAC地址封装，数据转发过程全部交给第二层交换处理，信息得以高速交换。既所谓的一次选路，多次交换。</p><p>　　<strong>第三层交换具有以下突出特点</strong></p><p>　　有机的硬件结合使得数据交换加速;</p><p>　　优化的路由软件使 得路由过程效率提高;</p><p>　　除了必要的路由决定过程外，大部分数据转发过程由第二层交换处理;</p><p>　　多个子网互连时只是与第三层交换模块的逻辑连接，不象传统的外接路由器那样需增加端口，保护了用户的投资。</p><p>　　<strong>1、交换机的定义</strong></p><p>　　局域网交换机拥有许多端口，每个端口有自己的专用带宽，并且可以连接不同的网段。交换机各个端口之间的通信是同时的、并行的，这就大大提高了信息吞吐量。为了进一步提高性能，每个端口还可以只连接一个设备。</p><p>　　为了实现交换机之间的互连或与高档服务器的连接，局域网交换机一般拥有一个或几个高速端口，如100MB以太网端口、FDDI端口或155MB ATM端口，从而保证整个网络的传输性能。</p><p>　　<strong>2、交换机的特性</strong></p><p>　　通过集线器共享局域网的用户不仅是共享带宽，而且是竞争带宽。可能由于个别用户需要更多的带宽而导致其他用户的可用带宽相对减少，甚至被迫等待，因而也就耽误了通信和信息处理。利用交换机的网络微分段技术，可以将一个大型的共享式局域网的用户分成许多独立的网段，减少竞争带宽的用户数量，增加每个用户的可用带宽，从而缓解共享网络的拥挤状况。由于交换机可以将信息迅速而直接地送到目的地能大大提高速度和带宽，能 保护用户以前在介质方面的投资，并提供良好的可扩展性，因此交换机不但是网桥的理想替代物，而且是集线器的理想替代物。</p><p>　　与网桥和集线器相比，交换机从下面几方面改进了性能：</p><p>　　(1)通过支持并行通信，提高了交换机的信息吞吐量。</p><p>　　(2)将传统的一个大局域网上的用户分成若干工作组，每个端口连接一台设备 或连接一个工作组，有效地解决拥挤现像。这种方法人们称之为网络微分 段(Micro一segmentation)技术。</p><p>　　(3)虚拟网(VirtuaI LAN)技术的出现，给交换机的使用和管理带来了更大 的灵活性。我们将在后面专门介绍虚拟网。</p><p>　　(4)端口密度可以与集线器相媲美,一般的网络系统都是有一个或几个服务器，而绝大部分都是普通的客户机。客户机都需要访问服务器，这样就导致服务器的通信和事务处理能力成为整个网络性能好坏的关键。</p><p>　　交换机就主要从提高连接服务器的端口的速率以及相应的帧缓冲区的大小，来提高整个网络的性能，从而满足用户的要求。一些高档的交换机还采用全双工技术进一步提高端口的带宽。以前的网络设备基本上都是采用半双工的工作方式，即当一台主机发送数据包的时候， 它就不能接收数据包，当接收数据包的时候，就不能发送数据包。由于采用全双工技术，即主机在发送数据包的同时，还可以接收数据包，普通的10M端口就可以变成20M端口，普通的100M端口就可以变成200M 端口，这样就进一步提高了信息吞吐量。</p><p>　　<strong>3、交换机的工作原理</strong></p><p>　　传统的交换机本质上是具有流量控制能力的多端口网桥，即传统的(二层) 交换机。把路由技术引入交换机，可以完成网络层路由选择，故称为三层交换，这是交换机的新进展。交换机(二层交换)的工作原理交换机和网桥一样，是工作在链路层的联网设备，它的各个端口都具有桥接功能，每个端口可以连接一个LAN或一台高性能网站或服务器，能够通过自学习来了解每个端口的设备连接情况。所有端口由专用处理器进行控制，并经过控制管理总线转发信息。</p><p>　　同时可以用专门的网管软件进行集中管理。 除此之外，交换机为了提高数据交换的速度和效率，一般支持多种方式。</p><p>　　(1)存储转发</p><p>　　所有常规网桥都使用这种方法。它们在将数据帧发柱其他端口之前，要把收到的帧完全存储在内部的存储器中，对其检验后再发往其他端口，这样其延时等于接收一个完整的数据帧的时间及处理时间的总和。如果级联很长时，会导致严重的性能问题，但这种方法可以过滤掉错误的数据帧。</p><p>　　(2)切入法：</p><p>　　这种方法只检验数据帧的目标地址，这使得数据帧几乎马上就 可以传出去，从而大大降低延时。</p><p>　　其缺点是：错误帧也会被传出去。错误帧的概率较小的情况下，可以采用切入法以提高传输速度。而错误帧的概率较大的情况下，可以采用存储转发法/以减少错误帧的重传。</p><p>　　<strong>4、交换机的配置</strong></p><p>　　我们下面以Cisco公司的Catlystl900交换机为例，介绍交换机的一般配置过程。</p><p>　　对一台新的Catlystl900交换机，使用它的缺省配置就可以工作了。这因为它是一种将软件装在FlashMemory中的硬件设备，当加电时，它首先要进行一系列自检，对所有端口进行测试之后，交换机就处于工作状态。这时它的交换表是空的，它可以通过自学习来了解各个端口的设备连接情况，并将设备的 MAC地址记录在交换表中，当有信息交换时，交换机就根据交换表来进行数据转发。</p><p>　　但为了便于对它进行网络管理，Catlystl900交换机自己有一个MAC地址，这样就可以为它分配一个IP地址和屏蔽码。网络管理员须通过交换机的串口接一台终端或仿真终端，才能为它指定一个IP地址，其缺省值是0.0.0.0。指定IP地址以后，网络管理员就可以通过网络进行远程管理了。Catlystl900交换机的配置界面是菜单形式，缺省配置下，它的所有端口都属于同一个VLAN，很多情况下都不需要作什么修改。</p><p>　　(1)将微机串口通过RS一232电缆与Cata1yst1900的Console口连接，运行仿真终端软件，Catalyst 1900 启动后。</p><p>　　(2)回车后，进入主菜单。</p><p>　　(3)按“S”键，进入系统配置菜单：(配置系统名，位置，日期)。</p><p>　　(4)在主菜单中按“N”键进入网络管理菜单。</p><p>　　(5)配置IP地置。</p><p>　　(6)配置SNMP参数。</p><p>　　<strong>5、交换机的种类</strong></p><p>　　交换机是数据链路层设备，它可将多个物理LAN网段连接到一个大型网络上，与网络类似交换机传输和溢出也是基于MAC地址的传输。由于交换机是用硬件实现的，因此，传输速度很快。传输数据包时，交换机要么使用存储—转发交换方式，要么使用断—通交换方式。目前有许多类型的交换机，其中包括ATM交换机，LAN交换机和不同类型的WAN交换机。</p><p>　　<strong>ATM交换机</strong></p><p>　　ATM(Asynchronous Transfer Mode)交换机为工作组，企业网络中枢以及其它众多领域提供了高速交换信息和可伸缩带宽的能力。ATM交换机支持语音，视频和文本数据应用，并可用来交换固定长度的信息单位(有时也称元素)。企业网络是通过ATM中枢链路连接多个LAN组成的。</p><p>　　<strong>局域网交换机</strong></p><p>　　LAN交换机用于多LAN网段的相互连接，它在网络设备之间进行专用的无冲突的通信，同时支持多个设备间的对话。LAN交换机主要是用于高速交换数据帧。通过LAN交换机将一个0Mbps以太网与一个100Mbps 以太网互联。</p><p>　　<strong>路由器工作原理</strong></p><p>　　传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL(Time To Live)域也开始减数，并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。</p><p>　　路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优(或最经济)的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。</p><p>　　网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用;选择最合理的路由，引导通信也是路由器基本功能;多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。</p><p>　　一般来说，路由器的主要工作是对数据包进行存储转发，具体过程如下：</p><p>　　第一步：当数据包到达路由器，根据网络物理接口的类型，路由器调用相应的链路层功能模块，以解释处理此数据包的链路层协议报头。这一步处理比较简单，主要是对数据的完整性进行验证，如CRC校验、帧长度检查等。</p><p>　　第二步：在链路层完成对数据帧的完整性验证后，路由器开始处理此数据帧的IP层。这一过程是路由器功能的核心。根据数据帧中IP包头的目的IP地址，路由器在路由表中查找下一跳的IP地址;同时，IP数据包头的TTL(Time To Live)域开始减数，并重新计算校验和(Checksum)。</p><p>　　第三步：根据路由表中所查到的下一跳IP地址，将IP数据包送往相应的输出链路层，被封装上相应的链路层包头，最后经输出网络物理接口发送出去。</p><p>　　简单地说，路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳传输路径，并将该数据包有效地传送到目的站点。由此可见，选择最佳路径策略或叫选择最佳路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据——路由表(Routing Table)，供路由选择时使用。上述过程描述了路由器的主要而且关键的工作过程，但没有说明其它附加性能，例如访问控制、网络地址转换、排队优先级等。</p><p>　　ARP全称 地址解析协议在局域网内信息是以帧传输的。要记住地址就要有一个ARP缓存表，大概是几分钟刷新一次我忘记了。保存的就是当前局域网内与你连接的机器的IP和MAC的地址。ARP—a就可以查看到这个表。第一个是IP。第二个是网卡地址。第三个是连接类型。</p><p>　　<strong>交换机如何学习MAC地址的？</strong></p><p>　　假设一个交换机刚刚启动，MAC表完全是空的，局域网内有两台主机PC1和PC2，IP地址为192.168.0.1和192.168.0.2：那么交换机接到1端口的PC1的第一个数据帧，因为PC1只知道PC2的IP地址而不知道PC2的MAC地址，所以源IP地址为192.168.0.1源MAC地址是0000-0000-0001，目标IP地址为192.168.0.2而目标MAC地址是FFFF-FFFF-FFFF(此报文为ARP请求报文，是二层广播报问)，交换机首先将源MAC地址和相对应的端口记录在MAC表中，然后把这个数据帧从所有活动的端口转发出去，;假设PC2在2端口接收到数据帧对数据进行回应时，则目标MAC地址为0000-0000-0001源MAC地址为0000-0000-0002。此时交换机收到数据帧后，首先学习PC2的MAC地址和对应端口到MAC表，然后查找MAC地址表中是否有PC1的MAC地址，发现目标MAC地址对应端口1，则将此数据帧由交换机的1端口转发出去。此时PC1和PC2的MAC地址都已记录在交换机MAC表中，数据在开始正常转发。所以，交换机在转发数据帧的过程，就是查找目标MAC地址，学习源地址的过程，希望能理解!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2019/11/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读目录</strong></p><ul><li>一 为什么要有操作系统</li><li>二 什么是操作系统</li><li>三 操作系统与普通软件的区别</li><li>四 操作系统发展史</li><li>五 操作系统原理</li></ul><h2 id="一-为什么要有操作系统（两本书：现代操作系统、操作系统原理，学好python以后再去研究吧-）"><a href="#一-为什么要有操作系统（两本书：现代操作系统、操作系统原理，学好python以后再去研究吧-）" class="headerlink" title="一 为什么要有操作系统（两本书：现代操作系统、操作系统原理，学好python以后再去研究吧~~）"></a>一 为什么要有操作系统（两本书：现代操作系统、操作系统原理，学好python以后再去研究吧~~）</h2><p>　　现代的计算机系统主要是由一个或者多个处理器，主存，硬盘，键盘，鼠标，显示器，打印机，网络接口及其他输入输出设备组成。</p><p>　　一般而言，现代计算机系统是一个复杂的系统。</p><p>　　其一：如果每位应用程序员都必须掌握该系统所有的细节，那就不可能再编写代码了（严重影响了程序员的开发效率：全部掌握这些细节可能需要一万年….）</p><p>　　其二：并且管理这些部件并加以优化使用，是一件极富挑战性的工作，于是，计算安装了一层软件（系统软件），称为操作系统。它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。</p><p><strong>总结：</strong></p><p>　　<strong>程序员无法把所有的硬件操作细节都了解到，管理这些硬件并且加以优化使用是非常繁琐的工作，这个繁琐的工作就是操作系统来干的，有了他，程序员就从这些繁琐的工作中解脱了出来，只需要考虑自己的应用软件的编写就可以了，应用软件直接使用操作系统提供的功能来间接使用硬件。</strong></p><h2 id="二-什么是操作系统"><a href="#二-什么是操作系统" class="headerlink" title="二 什么是操作系统"></a>二 什么是操作系统</h2><p>　　<strong>精简的说的话，操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序。操作系统所处的位置如图1</strong></p><pre><code>#操作系统位于计算机硬件与应用软件之间，本质也是一个软件。操作系统由操作系统的内核（运行于内核态，管理硬件资源）以及系统调用（运行于用户态，为应用程序员写的应用程序提供系统调用接口）两部分组成，所以，单纯的说操作系统是运行于内核态的，是不准确的。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/1036857-20170118112402265-1697763795.png" alt="img"></p><p>​                                                                      图1</p><p>　　<strong>细说的话，操作系统应该分成两部分功能：</strong></p><pre><code>#一：隐藏了丑陋的硬件调用接口（键盘、鼠标、音箱等等怎么实现的，就不需要你管了），为应用程序员提供调用硬件资源的更好，更简单，更清晰的模型（系统调用接口）。应用程序员有了这些接口后，就不用再考虑操作硬件的细节，专心开发自己的应用程序即可。例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制（比如控制磁盘转动，移动磁头读写数据等细节），#二：将应用程序对硬件资源的竞态请求变得有序化例如：很多应用软件其实是共享一套计算机硬件，比方说有可能有三个应用程序同时需要申请打印机来输出内容，那么a程序竞争到了打印机资源就打印，然后可能是b竞争到打印机资源，也可能是c，这就导致了无序，打印机可能打印一段a的内容然后又去打印c...,操作系统的一个功能就是将这种无序变得有序。</code></pre><pre><code>#作用一：为应用程序提供如何使用硬件资源的抽象例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制注意：    操作系统提供给应用程序的该抽象是简单，清晰，优雅的。为何要提供该抽象呢？    硬件厂商需要为操作系统提供自己硬件的驱动程序（设备驱动，这也是为何我们要使用声卡，就必须安装声卡驱动。。。），厂商为了节省成本或者兼容旧的硬件，它们的驱动程序是复杂且丑陋的    操作系统就是为了隐藏这些丑陋的信息，从而为用户提供更好的接口    这样用户使用的shell，Gnome，KDE看到的是不同的界面，但其实都使用了同一套由linux系统提供的抽象接口#作用二：管理硬件资源    现代的操作系统运行同时运行多道程序，操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他I/O接口设备的分配。例如：    同一台计算机上同时运行三个程序，它们三个想在同一时刻在同一台计算机上输出结果，那么开始的几行可能是程序1的输出，接着几行是程序2的输出，然后又是程序3的输出，最终将是一团糟（程序之间是一种互相竞争资源的过程）    操作系统将打印机的结果送到磁盘的缓冲区，在一个程序完全结束后，才将暂存在磁盘上的文件送到打印机输出，同时其他的程序可以继续产生更多的输出结果（这些程序的输出没有真正的送到打印机），这样，操作系统就将由竞争产生的无序变得有序化。</code></pre><p> <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/1036857-20170825154958011-1047256710.png" alt="img"></p><p>​                                                     图 2</p><h2 id="三-操作系统与普通软件的区别"><a href="#三-操作系统与普通软件的区别" class="headerlink" title="三 操作系统与普通软件的区别"></a>三 操作系统与普通软件的区别</h2><p>　　1.主要区别是：你不想用暴风影音了你可以选择用迅雷播放器或者干脆自己写一个，但是你无法写一个属于操作系统一部分的程序（时钟中断处理程序），操作系统由硬件保护，不能被用户修改。</p><p>　　2.操作系统与用户程序的差异并不在于二者所处的地位。特别地，操作系统是一个大型、复杂、长寿的软件，</p><ul><li>大型：linux或windows的源代码有五百万行数量级。按照每页50行共1000行的书来算，五百万行要有100卷，要用一整个书架子来摆置，这还仅仅是内核部分。用户程序，如GUI，库以及基本应用软件（如windows Explorer等），很容易就能达到这个数量的10倍或者20倍之多。</li><li>长寿：操作系统很难编写，如此大的代码量，一旦完成，操作系统所有者便不会轻易扔掉，再写一个。而是在原有的基础上进行改进。（基本上可以把windows95/98/Me看出一个操作系统，而windows NT/2000/XP/Vista则是两位一个操作系统，对于用户来说它们十分相似。还有UNIX以及它的变体和克隆版本也演化了多年，如System V版，Solaris以及FreeBSD等都是Unix的原始版，不过尽管linux非常依照UNIX模式而仿制，并且与UNIX高度兼容，但是linux具有全新的代码基础）</li></ul><h2 id="四-操作系统发展史"><a href="#四-操作系统发展史" class="headerlink" title="四 操作系统发展史"></a>四 操作系统发展史</h2><h3 id="第一代（1940-1955）-手工操作—-穿孔卡片"><a href="#第一代（1940-1955）-手工操作—-穿孔卡片" class="headerlink" title="第一代（1940~1955）  手工操作—-穿孔卡片"></a><strong>第一代（1940~1955）  手工操作—-穿孔卡片</strong></h3><p>　　第一代之前人类是想用机械取代人力，第一代计算机的产生是计算机由机械时代进入电子时代的标志，从Babbage失败之后一直到第二次世界大战，数字计算机的建造几乎没有什么进展，第二次世界大战刺激了有关计算机研究的爆炸性进展。</p><p>　　lowa州立大学的john Atanasoff教授和他的学生Clifford Berry建造了据认为是第一台可工作的数字计算机。该机器使用300个真空管。大约在同时，Konrad Zuse在柏林用继电器构建了Z3计算机，英格兰布莱切利园的一个小组在1944年构建了Colossus，Howard Aiken在哈佛大学建造了Mark 1，宾夕法尼亚大学的William Mauchley和他的学生J.Presper Eckert建造了ENIAC。这些机器有的是二进制的，有的使用真空管，有的是可编程的，但都非常原始，设置需要花费数秒钟时间才能完成最简单的运算。</p><p>　　在这个时期，同一个小组里的工程师们，设计、建造、编程、操作及维护同一台机器，所有的程序设计是用纯粹的机器语言编写的，甚至更糟糕，需要通过成千上万根电缆接到插件板上连成电路来控制机器的基本功能。没有程序设计语言（汇编也没有），操作系统则是从来都没听说过。使用机器的过程更加原始</p><p>​      <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110182111238-747473806.png" alt="img">   <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110182812441-1603066554.png" alt="img"></p><p>　　穿孔卡带的过程：程序员将对应于程序和数据的已穿孔的纸带（或卡片）装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行；计算完毕，打印机输出计算结果；用户取走结果并卸下纸带（或卡片）后，才让下一个用户上机。</p><p>　　手工操作特点：</p><p>　　　　（1）用户独占全机。不会出现因资源已被其他用户占用而等待的现象，但资源的利用率低。</p><p>　　　　（2）CPU 等待手工操作。CPU的利用不充分。</p><p>　　　　（3）没有操作系统的概念。</p><p>　　　　（4）所有的程序设计都是直接操控硬件。</p><h3 id="第二代（1955-1965）-磁带存储—批处理系统"><a href="#第二代（1955-1965）-磁带存储—批处理系统" class="headerlink" title="第二代（1955~1965）  磁带存储—批处理系统"></a><strong>第二代（1955~1965）  磁带存储—批处理系统</strong></h3><p>　　 20世纪50年代后期，出现<a href="https://baike.baidu.com/item/%E4%BA%BA%E6%9C%BA%E7%9F%9B%E7%9B%BE">人机矛盾</a>：手工操作的慢速度和计算机的高速度之间形成了尖锐矛盾，手工操作方式已严重损害了系统资源的利用率（使资源利用率降为百分之几，甚至更低），不能容忍。唯一的解决办法：只有摆脱人的手工操作，实现作业的自动过渡。这样就出现了成<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86">批处理</a>。</p><p>　　批处理系统：加载在计算机上的一个<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">系统软件</a>，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（这作业包括程序、数据和命令）。</p><p><strong>特点：</strong></p><p>　　　　设计人员、生产人员、操作人员、程序人员和维护人员直接有了明确的分工，计算机被锁在专用空调房间中，由专业操作人员运行，这便是‘大型机’。</p><p>　　　　有了操作系统的概念</p><p>　　　　有了程序设计语言：FORTRAN语言或汇编语言</p><h3 id="1-联机批处理系统"><a href="#1-联机批处理系统" class="headerlink" title="　  1.联机批处理系统"></a>　  1.联机批处理系统</h3><p>　　　　首先出现的是联机批处理系统，即作业的输入/输出由CPU来处理。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110182929754-795493284.png" alt="img"></p><p>　　　　主机与输入机之间增加一个存储设备——磁带，在运行于主机上的监督程序的自动控制下，计算机可自动完成：成批(把一堆人的输入攒起来，一起出入，一大波人的输出攒起来，一起输出)地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行并把计算结果向输出机输出。完成了上一批作业后，监督程序又从输入机上输入另一批作业，保存在磁带上，并按上述步骤重复处理。</p><p>监督程序不停地处理各个作业，从而实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间，有效克服了人机矛盾，提高了计算机的利用率。</p><p>但是，在作业输入和结果输出时，主机的高速CPU仍处于空闲状态，等待慢速的输入/输出设备完成工作： 主机处于“忙等”状态。（忙等状态就是说CPU等着输出完成之后再去从输入机上读指令来执行，造成了CPU的浪费）</p><h3 id="2-脱机批处理系统"><a href="#2-脱机批处理系统" class="headerlink" title="　　2.脱机批处理系统"></a>　　2.脱机批处理系统</h3><p>　　　　为克服与缓解：高速主机与慢速外设（输入输出设备）的矛盾，提高CPU的利用率，又引入了<a href="https://baike.baidu.com/item/%E8%84%B1%E6%9C%BA%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">脱机批处理系统</a>，即输入/输出（input\output，简称I\O操作）脱离主机控制。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110183045738-226986599.png" alt="img"></p><p>​     　　　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110183131738-1701797644.png" alt="img"></p><p>　　　　　　卫星机：一台不与主机直接相连而专门用于与输入/输出设备打交道的。</p><p>　　　　　　其功能是：</p><p>　　　　　　　　（1）从输入机上读取用户作业并放到输入磁带上。</p><p>　　　　　　　　（2）从输出磁带上读取执行结果并传给输出机。</p><p>　　　　　    这样，主机不是直接与慢速的输入/输出设备打交道，而是与速度相对较快的磁带机发生关系，有效缓解了主机与设备的矛盾。主机与卫星机可并行工作，二者分工明确，可以充分发挥主机的高速计算能力。</p><p>​      　　　　  脱机批处理系统:20世纪60年代应用十分广泛，它极大缓解了人机矛盾及主机与外设的矛盾。</p><p>　　　　　    不足：但目前为止，所有的程序都还是串行执行的，也就是一个程序结束才执行下一个程序，每次主机内存中仅存放一道作业，每当主机中这个运行期间的作业或者说程序发出输入/输出（I/O）请求后，CPU要去高速磁带里读数据，计算结果要往高速磁带里面写数据，那么高速的CPU便处于等待低速的I/O完成状态，CPU并没有完全的运算起来，也可以理解为我要等着你输入或者等着你输出，致使CPU空闲。注意：之前系统的缺点说的是等待用户将程序全部输入进去，等待程序运行结束后输出最终结果的操作。现在说的是程序运行期间发生的输入\输出操作，也就是去高速磁带里面去读取程序数据，然后将输出数据写到高速磁带中，也是耗时的，cpu这段时间内的利用率也是很低的。</p><p>　　　　　　 为改善CPU的利用率，又引入了<strong>多道程序系统</strong>。</p><p>我们总结一下上面的几个操作系统，1、为了解决大家都要排队去运行自己的程序，出现了批处理系统，2、为了解决输出设备和输入设备的人工操作以及高速cpu和输入输出设备之间速度的差异问题，出现了高速磁带和脱机批处理系统，3、因为cpu的运算速度比高速磁带的读取和输出的速度要高很多，那么当程序运当中去和高速磁带打交道，并且解决程序串行，也就是一个程序完了之后，才能执行下一个的情况，出现了下面的多道系统。</p><h3 id="第三代（1955-1965）-多道程序系统（多道是重点-）"><a href="#第三代（1955-1965）-多道程序系统（多道是重点-）" class="headerlink" title="第三代（1955~1965）  多道程序系统（多道是重点\*\）**"></a><strong>第三代（1955~1965）  多道程序系统（多道是重点\</strong>*<em>\</em>）**</h3><p>　　多道技术产生的技术背景：cpu在执行一个任务的过程中，若需要操作硬盘，则发送操作硬盘的指令，指令一旦发出，硬盘上的机械手臂滑动读取数据到内存中，这一段时间，cpu需要等待，时间可能很短，但对于cpu来说已经很长很长，长到可以让cpu做很多其他的任务，如果我们让cpu在这段时间内切换到去做其他的任务，这样cpu不就充分利用了吗。</p><p>　　1.多道程序设计技术</p><p>　　　　所谓多道程序设计技术，就是指允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110183621582-153745188.png" alt="img"></p><p>　　　　在A程序计算时，I/O空闲， A程序I/O操作时，CPU空闲（B程序也是同样）；必须A工作完成后，B才能进入内存中开始工作，两者是串行的，全部完成共需时间=T1+T2。</p><p>​      　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110183714426-287499114.png" alt="img"></p><p>　　　　将A、B两道程序同时存放在内存中，它们在系统的控制下，可相互穿插、交替地在CPU上运行：当A程序因请求I/O操作而放弃CPU时，B程序就可占用CPU运行，这样 CPU不再空闲，而正进行A I/O操作的I/O设备也不空闲，显然，CPU和I/O设备都处于“忙”状态，大大提高了资源的利用率，从而也提高了系统的效率，A、B全部完成所需时间&lt;&lt;T1+T2。</p><p>　　　　多道程序设计技术不仅使CPU得到充分利用，同时改善I/O设备和内存的利用率，从而提高了整个系统的资源利用率和系统吞吐量（单位时间内处理作业（程序）的个数），最终提高了整个系统的效率。</p><p>　　　　单处理机系统中多道程序运行时的特点：</p><p>　　　　　　（1）多道：计算机内存中同时存放几道相互独立的程序；</p><p>　　　　　　（2）宏观上并行：同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；</p><p>　　　　　　（3）微观上串行：实际上，各道程序轮流地用CPU，并交替运行。</p><p>　　　　<strong>多道程序系统的出现，标志着操作系统渐趋成熟的阶段，先后出现了作业调度管理、处理机管理、存储器管理、外部设备管理、文件系统管理等功能。</strong></p><p>　　　　<strong>由于多个程序同时在计算机中运行，开始有了空间隔离的概念，只有内存空间的隔离，才能让数据更加安全、稳定。</strong></p><p>　　　　<strong>出了空间隔离之外，多道技术还第一次体现了时空复用的特点，遇到IO操作就切换程序，使得cpu的利用率提高了，计算机的工作效率也随之提高。</strong></p><p>　　　　<strong>空间上的复用</strong>：将内存分为几部分，每个部分放入一个程序，这样，同一时间内存中就有了多道程序。</p><p>　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/1036857-20170313010137401-1096621807.png" alt="img"></p><p>　　　　<strong>时间上的复用</strong>：当一个程序在等待I/O时，另一个程序可以使用cpu，如果内存中可以同时存放足够多的作业，则cpu的利用率可以接近100%</p><p>　　　　</p><p>　　2.多道批处理系统　　　　　</p><p>　　　　20世纪60年代中期，在前述的批处理系统中，引入多道程序设计技术后形成多道批处理系统（简称：批处理系统）。</p><p>　　　　它有两个特点：</p><p>　　　　　　（1）多道：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。</p><p>　　　　　　（2）成批：在系统运行过程中，不允许用户与其作业发生交互作用，即：作业一旦进入系统，用户就不能直接干预其作业的运行。</p><p>　　　　批处理系统的追求目标：提高系统资源利用率和系统吞吐量，以及作业流程的自动化。</p><p>　　　　批处理系统的一个重要缺点：不提供人机交互能力，给用户使用计算机带来不便。</p><p>　　　　虽然用户独占全机资源，并且直接控制程序的运行，可以随时了解程序运行情况。但这种工作方式因独占全机造成资源效率极低。</p><p>　　　　一种新的追求目标：既能保证计算机效率，又能方便用户使用计算机。 20世纪60年代中期，计算机技术和软件技术的发展使这种追求成为可能。</p><p> 　　　　但是 有两个缺点，举例：</p><p>　　　　　　<strong>1、时间复用上的缺点：</strong>程序员A的程序运行10分钟就能够运行结束，程序员B的程序需要运行24小时，如何程序员B的程序先运行，并且程序员B的程序没有任何I\O操作，那么程序员A需要等待24小时之后才能执行，那么这就不太合理了。</p><p>　　　　　　<strong>2、空间复用上的缺点：</strong>首先丧失的是安全性，比如你的qq程序可以访问操作系统的内存，这意味着你的qq可以拿到操作系统的所有权限。其次丧失的是稳定性，某个程序崩溃时有可能把别的程序的内存也给回收了，比方说把操作系统的内存给回收了，则操作系统崩溃。</p><p>　　　　为了解决<strong>空间</strong>复用上的问题：程序之间的内存必须分割，由操作系统控制。如果内存彼此不分割，则一个程序可以访问另外一个程序的内存。<br>　　　　为了解决<strong>时间</strong>出现了分时系统</p><p>　　　　</p><p>　　3.分时系统</p><p>　　　　由于CPU速度不断提高和采用分时技术，一台计算机可同时连接多个用户终端，而每个用户可在自己的终端上联机使用计算机，好象自己独占机器一样。</p><p>​      　　　　<img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/827651-20180110184819504-1786017242.png" alt="img"></p><p>　　　　分时技术：把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。</p><p>　　　　若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的印象是，好象他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。</p><p>具有上述特征的计算机系统称为分时系统，它允许多个用户同时联机使用计算机。</p><p>　　　　特点：</p><p>　　　　（1）多路性。若干个用户同时使用一台计算机。微观上看是各用户轮流使用计算机；宏观上看是各用户并行工作。</p><p>　　　　（2）交互性。用户可根据系统对请求的响应结果，进一步向系统提出新的请求。这种能使用户与系统进行人机对话的工作方式，明显地有别于批处理系统，因而，分时系统又被称为交互式系统。</p><p>　　　　（3）独立性。用户之间可以相互独立操作，互不干扰。系统保证各用户程序运行的完整性，不会发生相互混淆或破坏现象。</p><p>　　　　（4）及时性。系统可对用户的输入及时作出响应。分时系统性能的主要指标之一是响应时间，它是指：从终端发出命令到系统予以应答所需的时间。</p><p>　　　　<strong>分时系统的主要目标</strong>：对用户响应的及时性，即不至于用户等待每一个命令的处理时间过长。</p><p>分时系统可以同时接纳数十个甚至上百个用户，由于内存空间有限，往往采用对换（又称交换）方式的存储方法。即将未“轮到”的作业放入磁盘，一旦“轮到”，再将其调入内存；而时间片用完后，又将作业存回磁盘（俗称“滚进”、“滚出“法），使同一存储区域轮流为多个用户服务。</p><p>多用户分时系统是当今计算机操作系统中最普遍使用的一类操作系统。</p><p>​      　　<strong>注意：分时系统的分时间片工作，在没有遇到IO操作的时候就用完了自己的时间片被切走了，这样的切换工作其实并没有提高cpu的效率，反而使得计算机的效率降低了。为什么下降了呢？因为CPU需要切换，并且记录每次切换程序执行到了哪里，以便下次再切换回来的时候能够继续之前的程序，虽然我们牺牲了一点效率，但是却实现了多个程序共同执行的效果，这样你就可以在计算机上一边听音乐一边聊qq了。</strong></p><p>　　　　</p><p>　　4.实时系统</p><p>　　　　虽然多道批处理系统和分时系统能获得较令人满意的资源利用率和系统响应时间，但却不能满足实时控制与实时信息处理两个应用领域的需求。于是就产生了实时系统，即系统能够及时响应随机发生的外部事件，并在严格的时间范围内完成对该事件的处理。</p><p>　　　　实时系统在一个特定的应用中常作为一种控制设备来使用。</p><p>　　　　　　实时系统可分成两类：</p><p>　　　　　　（1）实时控制系统。当用于飞机飞行、导弹发射等的自动控制时，要求计算机能尽快处理测量系统测得的数据，及时地对飞机或导弹进行控制，或将有关信息通过显示终端提供给决策人员。当用于轧钢、石化等工业生产过程控制时，也要求计算机能及时处理由各类传感器送来的数据，然后控制相应的执行机构。</p><p>　　　　　　（2）实时信息处理系统。当用于预定飞机票、查询有关航班、航线、票价等事宜时，或当用于银行系统、情报检索系统时，都要求计算机能对终端设备发来的服务请求及时予以正确的回答。此类对响应及时性的要求稍弱于第一类。</p><p>　　　　<strong>实时操作系统的主要特点</strong>：</p><p>　　　　　　（1）及时响应。每一个信息接收、分析处理和发送的过程必须在严格的时间限制内完成。</p><p>　　　　　　（2）高可靠性。需采取冗余措施，双机系统前后台工作，也包括必要的保密措施等。</p><pre><code>分时——现在流行的PC，服务器都是采用这种运行模式，即把CPU的运行分成若干时间片分别处理不同的运算请求 linux系统实时——一般用于单片机上、PLC等，比如电梯的上下控制中，对于按键等动作要求进行实时处理 </code></pre><p> 　　5.通用操作系统</p><p>　　　　操作系统的三种基本类型：多道批处理系统、分时系统、实时系统。</p><p>　　　　<strong>通用操作系统：具有多种类型操作特征的操作系统。可以同时兼有多道批处理、分时、实时处理的功能，或其中两种以上的功能。</strong></p><p>　　　　例如：实时处理+批处理=实时批处理系统。首先保证优先处理实时任务，插空进行批处理作业。常把实时任务称为前台作业，批作业称为后台作业。</p><p>　　　　再如：分时处理+批处理=分时批处理系统。即：时间要求不强的作业放入“后台”（批处理）处理，需频繁交互的作业在“前台”（分时）处理，处理机优先运行“前台”作业。</p><p>　　　　从上世纪60年代中期，国际上开始研制一些大型的通用操作系统。这些系统试图达到功能齐全、可适应各种应用范围和操作方式变化多端的环境的目标。但是，这些系统过于复杂和庞大，不仅付出了巨大的代价，且在解决其可靠性、可维护性和可理解性方面都遇到很大的困难。</p><p>　　　　相比之下，UNIX操作系统却是一个例外。这是一个通用的多用户分时交互型的操作系统。它首先建立的是一个精干的核心，而其功能却足以与许多大型的操作系统相媲美，在核心层以外，可以支持庞大的软件系统。它很快得到应用和推广，并不断完善，对现代操作系统有着重大的影响。</p><p>　　　　至此，操作系统的基本概念、功能、基本结构和组成都已形成并渐趋完善。</p><p><strong>第三代（1980~至今）  现代计算机</strong></p><p> 　　进入20世纪80年代，大规模集成电路工艺技术的飞跃发展，微处理机的出现和发展，掀起了计算机大发展大普及的浪潮。一方面迎来了个人计算机的时代，同时又向计算机网络、分布式处理、巨型计算机和智能化方向发展。于是，操作系统有了进一步的发展，如：个人计算机操作系统、网络操作系统、分布式操作系统等。</p><p>　　1.个人计算机操作系统</p><p>　　　　个人计算机上的操作系统是联机交互的单用户操作系统，它提供的联机交互功能与通用分时系统提供的功能很相似。</p><p>　　　　由于是个人专用，因此一些功能会简单得多。然而，由于个人计算机的应用普及，对于提供更方便友好的用户接口和丰富功能的文件系统的要求会愈来愈迫切。</p><p>　　2.网络操作系统</p><p>　　　　计算机网络：通过通信设施，将地理上分散的、具有自治功能的多个计算机系统互连起来，实现信息交换、资源共享、互操作和协作处理的系统。</p><p>　　　　网络操作系统：在原来各自计算机操作系统上，按照网络体系结构的各个协议标准增加网络管理模块，其中包括：通信、资源共享、系统安全和各种网络应用服务。</p><p> 　　　   就是添加了一些网络方面的功能。</p><p>　　3.分布式操作系统</p><p>　　　　表面上看，分布式系统与计算机网络系统没有多大区别。分布式操作系统也是通过通信网络，将地理上分散的具有自治功能的数据处理系统或计算机系统互连起来，实现信息交换和资源共享，协作完成任务。——硬件连接相同。</p><p>　　　　分布式：将一个大的任务拆分成几个小的任务，分配给不同的任务处理机制，具体怎么分配是由系统中的算法决定的，大家同时来运行自己的任务，然后各自将人物的返回结果再返回给你这个大的任务。</p><p>　　　　但有如下一些明显的区别：</p><p>　　　　　　（1）分布式系统要求一个统一的操作系统，实现系统操作的统一性。</p><p>　　　　　　（2）分布式操作系统管理分布式系统中的所有资源，它负责全系统的资源分配和调度、任务划分、信息传输和控制协调工作，并为用户提供一个统一的界面。</p><p>　　　　　　（3）用户通过这一界面，实现所需要的操作和使用系统资源，至于操作定在哪一台计算机上执行，或使用哪台计算机的资源，则是操作系统完成的，用户不必知道，此谓：系统的透明性。</p><p>　　　　　　（4）分布式系统更强调分布式计算和处理，因此对于多机合作和系统重构、坚强性和容错能力有更高的要求，希望系统有：更短的响应时间、高吞吐量和高可靠性。</p><p>　　　　分布式系统已经很普遍了，一般个人用不到，企业在处理比较大的任务的时候才会使用。</p><h2 id="本篇部分博客摘自：https-blog-csdn-net-yanglingwell-article-details-53745758"><a href="#本篇部分博客摘自：https-blog-csdn-net-yanglingwell-article-details-53745758" class="headerlink" title="本篇部分博客摘自：https://blog.csdn.net/yanglingwell/article/details/53745758"></a>本篇部分博客摘自：<a href="https://blog.csdn.net/yanglingwell/article/details/53745758">https://blog.csdn.net/yanglingwell/article/details/53745758</a></h2><h2 id="五、操作系统原理"><a href="#五、操作系统原理" class="headerlink" title="五、操作系统原理"></a>五、操作系统原理</h2><h3 id="1-操作系统的资源管理技术"><a href="#1-操作系统的资源管理技术" class="headerlink" title="1. 操作系统的资源管理技术"></a>1. 操作系统的资源管理技术</h3><p>　　资源管理解决物理资源数量不足和合理分配资源这两个问题。<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219183259469.png" alt="PM2VM"><br>　　操作系统虚拟机为用户提供了一种简单、清晰、易用、高效的计算机模型。虚拟机的每种资源都是物力资源通过复用、虚拟和抽象而得到的产物。<br>　　虚拟机提供进程运行的逻辑计算环境。从概念上来说，一个进程运行在一台虚拟机上，可以认为一个进程就是一台虚拟机，一台虚拟机就是一个进程。</p><ul><li><p>复用：<em>空分复用共享</em>和<em>时分复用共享</em>。<br>a. 空分复用共享(space-multiplexed sharing): 将资源从“空间”上分割成更小的单位供不同进程使用。在计算机系统中，内存和外存(磁盘)等是空分复用共享的。<br>b. 时分复用共享(time-multiplexed sharing): 将资源从“时间”上分割成更小的单位供不同进程使用。在计算机系统中，处理器和磁盘机等是时分复用共享的。</p></li><li><p>虚拟：对资源进行转化、模拟或整合，把一个物理资源转变成多个逻辑上的对应物，也可以把多个物理资源变成单个逻辑上的对应物，即创建无须共享独占资源的假象，或创建易用且多于实际物理资源的虚拟资源假象，以达到多用户共享一套计算机物理资源的目的。虚拟技术可用于外部设备(外部设备同时联机操作(SPOOLing)),存储资源(虚拟内存)和文件系统(虚拟文件系统(Virtual File System, VFS))中。</p><blockquote><p>复用和虚拟相比较，复用所分割的是实际存在的物理资源，而虚拟则实现假想的同类资源。虚拟技术解决某类物理资源不足的问题，提供易用的虚拟资源和更好的运行环境。</p></blockquote></li><li><p>抽象：通过创建软件来屏蔽硬件资源的物理特性和实现细节，简化对硬件资源的操作、控制和使用。</p><blockquote><p>复用和虚拟的主要目标是解决物理资源数量不足的问题，抽象则用于处理系统复杂性，重点解决资源易用性。</p></blockquote></li></ul><h3 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="2. 系统调用"></a>2. 系统调用</h3><ul><li><p>系统调用： 为给应用程序的运行提供良好环境，内核提供了一系列具有预定功能的服务例程，通过一组称为系统调用（System Call）的接口呈现给用户，系统调用把应用程序的请求传送至内核，调用相应的服务例程完成所需处理，将处理结果返回给应用程序。<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219165735777.png" alt="OS_System_Call"></p><blockquote><p>注：系统调用的编号称为功能号</p></blockquote></li><li><p>系统调用的执行过程： 当CPU执行程序中编写的由访管指令(supervisor, 也称自陷指令(trap)或中断指令(interrupt), 指引起处理器中断的机器指令)实现的系统调用时会产生异常信号，通过陷阱机制(也称异常处理机制，当异常或中断发生时，处理器捕捉到一个执行线程，并且将控制权转移到操作系统中某一个固定地址的机制)，处理器的状态由用户态(user mode, 又称目态或普通态)转变为核心态(kerbel mode, 又称管态或内核态)，进入操作系统并执行相应服务例程，以获得操作系统服务。当系统调用执行完毕时，处理器再次切换状态，控制返回至发出系统调用的程序。</p></li><li><p>系统调用是应用程序获得操作系统服务的唯一途径。</p></li></ul><blockquote><p>系统调用的作用：<br>\1. 内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性。<br>\2. 系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且编程效率大大提高。</p><p>系统调用与函数调用的区别：<br>\1. 调用形式和实现方式不同。功能号 VS 地址； 用户态转换到内核态 VS 用户态。<br>\2. 被调用代码的位置不同。 动态调用 + 操作系统 VS 静态调用 + 用户级程序。<br>\3. 提供方式不同。 操作系统 VS 编程语言。</p></blockquote><h3 id="3-操作系统内核"><a href="#3-操作系统内核" class="headerlink" title="3. 操作系统内核"></a>3. 操作系统内核</h3><ul><li>内核： 是一组程序模块，作为可信软件来提供支持进程并发执行的基本功能和基本操作，通常驻留在内核空间，运行于内核态，具有直接访问硬件设备和所有内存空间的权限，是仅有的能够执行特权指令的程序。</li><li>内核的功能：<br>a. 中断处理。中断处理是内核中最基本的功能，也是操作系统赖以活动的基础。<br>b. 时钟管理。时钟管理是内核的基本功能。<br>c. 短程调度。短程调度的职责是分配处理器，按照一定的策略管理处理器的转让，以及完成保护和恢复现场工作。<br>d. 原语管理。 原语是内核中实现特定功能的不可中断过程。</li></ul><blockquote><p>内核是操作系统对裸机的第一次改造，内核和裸机组成了第一层虚拟机，进程在虚拟机上运行。</p></blockquote><hr><h3 id="4-处理器状态：-内核态和用户态"><a href="#4-处理器状态：-内核态和用户态" class="headerlink" title="4. 处理器状态： 内核态和用户态"></a>4. 处理器状态： 内核态和用户态</h3><ul><li>仅在内核态下才能使用的指令称为特权指令，执行这些指令不仅影响运行程序自身，而且还会干扰其他程序及操作系统。 非特权指令在内核态和和用户态下都能工作。</li></ul><blockquote><p>现代计算机为处理器建立硬件标志位，称处理器状态位，通常是程序状态字(Program Status Word, PSW)中的一位，来将处理器的状态设置为内核态或用户态。</p></blockquote><ul><li>用户态向内核态转换的情况：<br>a. 程序请求操作系统服务， 执行系统调用。<br>b. 在程序运行时产生中断事件(如I/O操作完成)，运行程序被中断，转向中断处理程序处理。<br>c. 在程序运行时产生异常事件(如在目态下执行特权指令)，运行程序被打断，转向异常处理程序工作。</li></ul><blockquote><p>以上三种情况都是通过中断机制发生，可以说中断和异常是用户态到内核态转换的仅有途径。</p></blockquote><ul><li>用户栈和核心栈<br>a. 用户栈是用户进程空间中的一块区域。用于保存应用程序的子程序(函数)间相互调用的参数，返回值，返回点和子程序的局部变量。<br>b. 核心栈是内存中操作系统空间的一块区域。用于保存中断现场和保存操作系统程序(函数)间相互调用的参数，返回值，返回点和程序的局部变量。</li></ul><h3 id="5-中断（Interupt）"><a href="#5-中断（Interupt）" class="headerlink" title="5. 中断（Interupt）"></a>5. 中断（Interupt）</h3><ul><li>中断：程序执行过程中遇到急需处理的事件时，暂时终止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再返回断点或调度其他程序的执行过程。</li><li>中断的分类：<br>a. 外中断(又称中断或异步中断)： 来自处理器之外的中断信号，如，时钟中断、键盘中断等。外中断可分为可屏蔽中断和非可屏蔽中断。<br>b. 内中断(又称异常或同步中断)，来自处理器内部的中断信号，如，访管中断，硬件故障中断，程序性中断等。内中断不能被屏蔽。</li><li>中断和异常的响应： 发现中断源 → 保护现场 → 转向中断/异常事件处理程序执行 → 恢复现场</li></ul><h3 id="6-进程"><a href="#6-进程" class="headerlink" title="6. 进程"></a>6. 进程</h3><ul><li><p>进程：具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。<br>a. 从原理角度看，进程是支持程序执行的一种系统机制，它对处理器上运行程序的活动进行抽象。<br>b. 从实现角度看，进程是一种数据结构，用来准确地刻画运行程序的状态和系统动态变化状况。</p></li><li><p>进程状态的七态模型</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219181305933.png" alt="OS_SEVEN"></p><p>a. 新建态(new): 进程被创建，尚未进入就绪队列。<br>b. 就绪态(ready): 进程具备运行条件，等待系统分配处理器。<br>c. 挂起就绪态(ready suspend)：进程具备运行条件，但目前在外存中。<br>d. 运行态(running): 进程占有处理器正在运行。<br>e. 终止态(exit): 进程达到正常结束点或被其他原因所终止，下一步将被撤销。<br>f. 等待态(wait): 又称阻塞态或休眠态。进程正在等待某个事件完成，目前不具备运行条件。<br>g. 挂起等待态(blocked suspend): 进程正在等待某个事件完成，并且在外存中。</p></li><li><p>程序和数据刻画进程的静态特征，称为进程控制块的一种数据结构刻画进程的动态特征。进程映像(process image)包括进程控制块、进程程序块、进程核心块、进程数据块等要素。</p></li><li><p>进程控制块(Process Control Block, PCB)：进程存在的唯一标识，操作系统掌握进程的唯一资料结构和管理进程的主要依据。包括标识信息、现场信息和控制信息等信息。</p></li><li><p>进程队列(process queue)：处于同一状态的所有进程的PCB链接在一起的数据结构。 有两种队列组织方式：链接方式和索引方式。</p></li><li><p>进程切换必定在内核态而非用户态发生。</p></li><li><p>进程可以分为两部分，资源集合和线程集合。进程要支撑线程运行，为线程提供虚拟地址空间和各种资源。进程封装管理信息，线程封装执行信息。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219181350933.png" alt="OS_MultiThread"></p></li></ul><h3 id="7-处理器调度"><a href="#7-处理器调度" class="headerlink" title="7. 处理器调度"></a>7. 处理器调度</h3><ul><li><p>处理器调度层次：<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219181558617.png" alt="OS_Scheduling"><br>a. 高级调度： 又称作业调度、长程调度。从输入系统的一批作业(job, 用户提交给操作系统计算的一个独立任务)中按照预定的调度策略挑选若干作业进入内存，为其分配所需资源并创建对应作业的用户进程。<br>b. 中级调度： 又称平衡调度，中程调度。根据内存资源情况决定内存所能容纳的进程数目，并完成外存和内存中进程对换工作。<br>c. 低级调度：又称进程调度/线程调度，短程调度。根据某种原则决定就绪队列中那个进程/线程先获得处理器，并将处理器出让给它使用。</p></li><li><p>低级调度算法：<br>a. 先来先服务(First Come First Server, FCFS)算法。<br>b. 最短作业优先(Shortest Job First, SJF)算法。<br>c. 最短剩余时间优先(Shortest Remaining Time First, SRTF)算法： 假设当前某进程/线程正在运行，如果<em>有新进程/线程移入就绪队列</em>，若它所需的CPU运行时间比当前运行的进程/线程所需的剩余CPU时间还短，抢占式最短作业优先算法强行剥夺当前执行者的控制权，调度新进程/线程执行。<br>d. 最高响应比优先(Highest Response Ratio First, HRRF)算法:非剥夺式算法。其中，响应比 = (作业已等待时间 + 作业处理时间) / 作业处理时间。<br>e. 优先级调度算法：优先级高的选择进程/线程优先选择。<br>f. 轮转调度(Round-Robin, RR)算法： 也称时间片调度。就绪队列的进程轮流运行一个时间片。<br>g. 多级反馈队列(Multi-Level Feedback Queue, MLFQ)算法。</p><blockquote><p>衡量调度算法的性能指标：<br>a. 资源利用率: CPU利用率 = CPU有效工作时间/(CPU有效工作时间 + CPU空闲等待时间)<br>b. 吞吐率： 单位时间内CPU处理作业的个数。<br>c. 公平性： 确保每个进程都能获得合理的CPU份额和其他资源份额，不会出现饥饿现象。<br>d. 响应时间： 从交互式进程提交一个请求(命令)直到获得响应之间的时间间隔。<br>e. 周转时间： 批处理用户从向系统提交作业开始到作业完成为止的时间间隔。<br>平均周转时间：T = (∑ni=1ti∑i=1nti ) / n ， 其中 titi 表示作业i的周转时间。<br>平均带权作业周转时间： T = (∑ni=1wi∑i=1nwi) / n, 其中 wi=ti/tkwi=ti/tk ， titi 表示作业i的周转时间。 tktk 表示作业i的运行时间。</p></blockquote></li></ul><h3 id="8-进程的交互"><a href="#8-进程的交互" class="headerlink" title="8. 进程的交互"></a>8. 进程的交互</h3><ul><li><p>进程互斥(Mutual Exclusion): 若干进程因相互抢夺<em>独占型资源</em>而产生的竞争制约关系。</p></li><li><p>进程同步(Synchronization): 为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的先后次序而等待、传递信息或消息所产生的协作制约关系。</p><blockquote><p>资源竞争会引发两个控制问题：<br>a. 死锁： 一组进程因争夺资源陷入永远等待的状态。<br>b. 饥饿： 一个可运行进程由于由于其他进程总是优先于它，而被调度程序无限期地拖延而不能被执行。</p></blockquote></li></ul><h3 id="9-临界区管理"><a href="#9-临界区管理" class="headerlink" title="9. 临界区管理"></a>9. 临界区管理</h3><ul><li><p>并发进程中与共享变量有关的程序段称为临界区(Critical Section)。共享变量所代表的资源称为临界资源(Critical Resource)，即一次仅能供一个进程使用的资源。</p></li><li><p>临界区调度原则：<br>a. 择一而入。 一次之多只有一个进程进入临界区内执行。<br>b. 忙则要等。 如果已有进程在临界区中， 试图进入此临界区的其他进程应等待。<br>c. 有限等待。 进入临界区内的进程应在有限时间内退出。</p></li><li><p>临界区管理的软件算法：Peterson算法。<br>为每个进程设置标志，当标志值为 <code>true</code> 时表示该进程要求进入临界区，另外再设置一个指示器 <code>turn</code> 以指示可以由哪个进程进入临界区，当 <code>turn = i</code> 时则可由 <code>Pi</code> 进入临界区。</p><pre><code> 1 /* Peterson 算法 */ 2  3 bool inside[2]; 4 inside[0] = false; 5 inside[1] = false; 6 enum { 0, 1 } turn; 7  8 /* 进程0 */ 9 process P0(){10     inside[0] = true;               //请求...11     turn = 1;12     while(inside[1] &amp;&amp; turn == 1) ; //等待...13 14     /*临界区 */15 16     inside[0] = false;              //归还...17 }18 19 /* 进程1 */20 process P1(){21     inside[1] = true;               //请求...22     turn = 0;23     while(inside[0] &amp;&amp; turn == 0) ; //等待...24 25     /*临界区 */26 27     inside[1] = false;              //归还...28 }</code></pre></li><li><p>Peterson算法满足临界区管理的三个原则。</p></li><li><p>临界区管理的硬件设施:<br>a. 关中断。 在进程进入临界区时关中断，进程退出临界区时开中断。<br>b. 测试并设置指令。 利用机器指令TS(Test and Set)实现临界区的上锁和开锁原语操作。<br>c. 对换指令。 利用对换指令实现临界区的上锁和开锁原语操作。</p></li></ul><h3 id="10-信号量-samaphore-和PV操作"><a href="#10-信号量-samaphore-和PV操作" class="headerlink" title="10. 信号量(samaphore)和PV操作"></a>10. 信号量(samaphore)和PV操作</h3><blockquote><p>PV操作都是原语操作， 不可中断。</p></blockquote><ul><li><p>信号量和PV操作</p><pre><code> 1 // 信号量 2 typedef struct semaphore { 3     int value;                 // 信号量值 4     struct pcb* list;          // 指向“等待该信号量的进程队列”的指针 5 };   6  7 // P操作 8 void P(semaphore s){ 9     s.value--;                 // 信号量值减一10 11     // 如果信号量值小于0， 执行P操作的进程调用sleep(s.list)阻塞自己，12     // 被置成“等待信号量s”状态，并移入s信号量队列，转向进程调度程序。13     if(s.value &lt; 0) sleep(s.list);14 }15 16 // V操作17 void V(semaphore s){18     s.value++;                 // 信号量值加一19 20     // 如果信号量小于等于0， 则调用wakeup(s.list)释放一个等待信号量s的进程，21     // 并转换成就绪态， 进程则继续执行。22     if(s.value &lt;= 0) wakeup(s.list);23 }</code></pre></li><li><p>a. 若信号量值 <code>s.value</code> 为正值， 此值等于在封锁进程之前对信号量 <code>s</code> 可施行P操作的次数，即，s所代表的实际可用的资源数。<br>b. 若信号量值 <code>s.value</code> 为负值， 其绝对值等于登记在 <code>s</code> 信号量队列中的等待进程的数目。<br>c. 通常P操作意味着请求一个资源，V操作意味着释放一个资源。在一定条件下，P操作也可表示挂起进程的操作，V操作代表唤醒被挂起进程的操作。</p></li><li><p>信号量实现互斥</p><pre><code> 1 semaphore mutex; 2 mutex = 1； 3  4 //进程Pi， i = 1， 2 ...， n 5 process Pi(){ 6     P(mutex); 7  8     /* 临界区 */ 9 10     V(mutex);11 }</code></pre></li></ul><h3 id="11-管程"><a href="#11-管程" class="headerlink" title="11. 管程"></a>11. 管程</h3><ul><li><p>管程(monitor)：代表共享资源的数据结构及并发进程在其上执行的一组构成就构成管程，管程被请求和释放资源的进程锁调用。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182812462.png" alt="OS_manitor"></p><p>a. 条件变量。 管程内的一种数据结构。只有在管程中才能被访问，进程可以在条件变量上等待或被唤醒。只能通过 <code>wait()</code> 和 <code>signal()</code> 原语操作来控制。<br>b. <code>wait()</code> 原语。 挂起调用进程并释放管程，直至另一个进程在条件变量上执行 <code>signal()</code>。<br>c. <code>signal()</code> 原语。如果有其他的进程因对条件变量执行 <code>wait()</code> 而被挂起，便释放之。 如果没有进程在等待，那么相当于空操作，信号不被保存。</p></li></ul><h3 id="12-死锁"><a href="#12-死锁" class="headerlink" title="12. 死锁"></a>12. 死锁</h3><ul><li><p>死锁的主要解决方法： 死锁防止、死锁避免、死锁检测和恢复。</p></li><li><p>死锁产生的必要条件：<br>a. 互斥条件。 临界资源是独占资源，进程应互斥且排他地使用这些资源。<br>b. 占有和等待条件。 进程在请求资源得不到满足而等待时，不释放已占有的资源。<br>c. 不剥夺条件。已获资源只能由进程资源释放，不允许被其他程序剥夺。<br>d. 循环等待条件。 存在循环等待链，其中每个进程都在等待下一个进程所持有的资源。</p><blockquote><p>死锁的防止就是去破坏死锁产生的必要条件。 如，使资源可同时使用(破坏互斥条件)、静态分配资源(破坏占有和等待条件)、剥夺调度(破坏不剥夺条件)、层次分配策略(循环等待条件)等。</p></blockquote></li><li><p>死锁避免： <a href="http://baike.baidu.com/link?url=8bOYnVjs5ya2QcVYp7L2OaIAWkGD1GhtTEQyXhJgbIjtSmLgagTfLCM8Wc1jhlvOJpCwOu7Ddx7ZVclFCdRJ40sjRnMde41J7a5IAWmVMeqzN0WdESisqZI_oblqfC5O34ntmWjsxt8lDV6FoUhDGa">银行家算法</a> (额…自己百度去吧。 = =!)</p></li><li><p>死锁检测和恢复： 进程-资源分配图(额…还是去百度吧。)<br>a. 如果进程-资源分配图中无环路，此时系统没有死锁。<br>b. 如果进程-资源分配图中有环路，且每个资源类中只有一个资源，则系统发生死锁。<br>c. 如果进程-资源分配图中有环路，且所涉及的资源类有多个资源，则不一定会发生死锁。</p></li></ul><h3 id="13-可变分区存储管理"><a href="#13-可变分区存储管理" class="headerlink" title="13. 可变分区存储管理"></a>13. 可变分区存储管理</h3><ul><li>可变分区存储分配算法：<br>a. 最先适应分配算法。从未分配区的<em>开始位置</em>开始扫描，在找到的第一个能满足长度要求的空闲区上分配存储空间。<br>b. 下次适应分配算法。从未分配区<em>上次扫描结束处</em>开始顺序查找，在找到的第一个能满足长度要求的空闲区上分配存储空间。<br>c. 最优适应分配算法。扫描整个未分配区，选择能满足用户进程要求的<em>最小分区</em>分配存储空间。<br>d. 最坏适应分配算法。扫描整个未分配区，选择能满足用户进程要求的<em>最大分区</em>分配存储空间。<br>e. 快速适应分配算法。为经常用到的长度的空闲区设立单独的空闲区链表。</li></ul><h3 id="14-分页存储管理"><a href="#14-分页存储管理" class="headerlink" title="14. 分页存储管理"></a>14. 分页存储管理</h3><ul><li><p>基本概念：<br>a. 页面。 <em>进程逻辑地址空间</em>分成<em>大小相等</em>的区，每个区称为页面或页。(注： 页面的本质是逻辑地址空间)<br>b. 页框(kuàng, 0.0)。 又称页帧。<em>内存物理地址空间</em>分成<em>大小相等</em>的区，其大小和页面大小相等，每个区就是一个页框。(注： 页框的本质是物理地址空间)<br>c. 逻辑地址。分页存储器的逻辑地址由页号和页内偏移两部分组成。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219181753651.png" alt="OS_PageOffset"></p><p>d. 内存页框表。页框表的表项给出物理块使用情况：0为空闲，1为占用。<br>e. 页表。页表是操作系统为进程建立的，是程序页面和内存页框的对照表，页表的每一栏指明程序中的某一页面和分得的页框之间的关系。</p></li><li><p>分页存储管理的地址转换</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182005327.png" alt="OS_PageTable"></p></li><li><p>翻译快表：也称转换后援缓冲(Translation Look_aside Buffer, TLB)。用来存放进程最近访问的部分页表项。(注： 翻译快表之于页表类似于Cache之于存储器)</p></li><li><p>二级页表：把整个页表分割成许多小页表，每个称为页表页，每个页表页含有若干个页表表项。页表页允许分散对应不连续的页框。为了找到页表页，应建立地址索引，称为页目录表，其表项指出页表页起始地址。</p></li><li><p>二级页表实现逻辑地址到物理地址转换的过程： 由硬件“页目录表基址寄存器”指出当前运行进程的页目录表的内存起始地址，加上“页目录位移”作为索引，可找到页表页在内存的起始地址，再以“页目录位移”作为索引，找到页表页在内存的起始位置，再以“页表页位移”作为索引，找到页表页的表项，此表项中包含一个页面对应的页框号，由页框号和页内偏移便可生成物理地址。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182359453.png" alt="OS_TwoLvPageTable"></p><blockquote><p>注： 类比于书的目录，找某一段内容的时候，先在目录上找到对应的章节，再在对应的章节下面找具体的知识点。比如，我要在《操作系统原理》中查“多级页表”。首先我知道它是在存储管理一章的，于是就找到了“第四章 存储管理”（类似于找到了页目录表）。 然后在第四章下面找“多级页表”（类似于在页目录表下面找具体的页表页）。最后找到“多级页表”对应的页码（类似于在页表页中找到其对应的页框）。最后查阅对应的章节页码（类似于读取对应页框的数据）。</p></blockquote></li></ul><h3 id="15-分段存储管理"><a href="#15-分段存储管理" class="headerlink" title="15. 分段存储管理"></a>15. 分段存储管理</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182458829.png" alt="OS_Segment"></p><blockquote><p>分段和分页的比较：<br>a. 分段是信息的<em>逻辑单位</em>，由源程序的逻辑结构及含义所决定，是用户可见的，段长由用户根据需要来确定，段起始地址可以从任何内存地址开始。引入的目的是<em>满足用户模块化程序设计的需要</em>。<br>b. 分页是信息的<em>物理单位</em>，与源程序的逻辑无关，是用户不可见的，页长由系统(硬件)决定，页面只能从页大小的整数倍地址开始。引入目的是<em>实现离散分配并提高内存利用率</em>。</p></blockquote><h3 id="16-虚拟存储管理"><a href="#16-虚拟存储管理" class="headerlink" title="16. 虚拟存储管理"></a>16. 虚拟存储管理</h3><ul><li><p>虚拟存储管理的基本思路：</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182713867.png" alt="OS_VirtualMemory"></p><p>把磁盘空间当做内存的一部分，进程的程序和数据部分放在内存中，部分放在磁盘上。程序运行时，它执行的指令或访问的数据在哪里由存储管理负责判断，并针对情况采取响应的措施。</p></li><li><p>请求分页虚存管理： 将进程信息副本存放在外存中，当它被调度投入运行时，程序和数据没有全部装进内存，仅装入当前使用页面，进程执行过程中访问到不在内存的页面时，产生缺页异常，再由系统自动调入。</p></li><li><p>全局页面替换策略(页面替换算法的作用范围是整个系统，不考虑进程的属主)：<br>a. 最佳页面替换算法(Optimal Replacement， OPT)。 淘汰不再访问的页或者距现在最长时间后才访问的页。<br>b. 先进先出页面替换算法(First in First Out Replacement， FIFO)。淘汰在内存中驻留时间最长的页。<br>c. 最近最少使用页面替换算法(Least Recently Used Replacement, LRU)。 淘汰最近一段时间内最久未被使用的页面。<br>d. 第二次机会页面替换算法(Second Chance Replacement， SCR)。 首先检查FIFO页面队列中的队首，这是最早进入内存的页面，如果其“引用位”为0，那么它最早进入且未被引用，此页被淘汰。如果其“引用位”为1，说明虽然它最早进内存，但最近仍在使用，于是将“引用位”清零，并把这个页面移到队尾，把它看做新调入的页面，再给它一次机会。<br>e. 时钟页面替换算法(Clock Policy Replacement， Clock)。与SCR算法思路一致。只是用循环队列来构造页面队列，队列指针指向可能被淘汰的页面。如果队列指针指向的页的“引用位”为1，则将其置为0，同时队列指针指向下一个页。</p></li><li><p>局部页面替换算法(页面替换算法的作用局限于进程自身，要为进程维护称为工作集的一组页面)：<br>a. 局部最佳页面替换算法(Local Minimum Replacement, MIN)。 在t时刻时，若页面P在未来(t, t+delta)时间段内未被引用，则它被淘汰。<br>b. 工作集置换算法。 在t时刻时，若页面P在未来(t-delta, t)时间段内未被引用，则它被淘汰。<br>c. 模拟工作集替换算法。<br>d. 缺页频率替换算法。</p></li></ul><h3 id="17-请求段页式虚拟内存管理"><a href="#17-请求段页式虚拟内存管理" class="headerlink" title="17. 请求段页式虚拟内存管理"></a>17. 请求段页式虚拟内存管理</h3><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182601897.png" alt="OS_SegmentPage"></p><ul><li>虚地址以程序的逻辑结构划分为段。</li><li>实地址划分为位置固定、大小相等的页框(块)。</li><li>逻辑地址分为三个部分：段号s、段内页号p、页内位移d。对于用户而言，段式虚拟地址应该由段号s和段内位移d’组成，操作系统内部自动把d’解释成段内页号p和页内位移号d。</li></ul><h3 id="18-I-O硬件原理：I-O控制方式"><a href="#18-I-O硬件原理：I-O控制方式" class="headerlink" title="18. I/O硬件原理：I/O控制方式"></a>18. I/O硬件原理：I/O控制方式</h3><ul><li>轮询方式： 又称程序直接控制方式。使用查询指令测试设备控制器的忙闲状态位，确定内存和设备是否能能交换数据。（注：所谓轮询，就好比，老湿依次问每一个童鞋：“有问题没？”， 如果没问题，就继续问下一个童鞋。如果这个童鞋有问题，这个老湿就停下了解决这个问题。然后又继续询问下一个童鞋。）</li><li>中断方式： 要求CPU和设备控制器及设备之间存在中断请求线，设备控制器的状态寄存器有相应的中断允许位。<br>a. 进程发出启动I/O指令。<br>b. 设备控制器检查状态寄存器的内容，执行相应的I/O操作，一旦传输完成，设备控制器通过中断请求线发出I/O中断信号。<br>c. CPU收到并响应I/O中断后，转向设备的I/O中断处理程序执行。<br>d. 中断处理程序执行数据读取操作，将I/O缓冲寄存器的内容写入内存。操作结束后退出中断程序恢复之前的状态。<br>e. 执行中断前之前运行的进程。<br>（注： 类似于老湿在上面讲课，有童鞋问问题时，老湿就记录下自己讲到的位置，然后取回答童鞋的问题，回答完之后，又回到刚刚讲课的地方继续讲课）</li><li>DMA(Direct Memory Access, 直接存储器存取)方式： 内存和设备之间有一条数据通路成块的传输数据，无须CPU干9预，实际数据传输操作由DMA直接完成。</li><li>通道方式： CPU在执行主程序时遇到I/O请求，启动在指定通道上选址的设备，一旦启动成功，通道开始控制设备进行操作，这时CPU就可以执行其他任务并与通道并行工作，直到I/O操作完成；当通道发出I/O操作结束中断时，处理器才响应并停止当前工作，转而处理I/O操作结束时间。</li></ul><h3 id="19-I-O软件原理"><a href="#19-I-O软件原理" class="headerlink" title="19. I/O软件原理"></a>19. I/O软件原理</h3><ul><li>I/O中断处理程序： 通常是设备驱动程序的组成部分之一。检查设备状态寄存器内容，判断产生中断原因，根据I/O操作的完成情况进行相应处理。若数据传输有错，应向上层软件报告设备出错信息，实施重新执行；若正常结束，应唤醒等待传输的进程，使其转换为就绪态；若有等待传输的I/O命令，应通知相关软件启动下一个I/O请求。</li><li>I/O设备驱动程序：设备驱动程序是设备专有的。把用户提交的逻辑I/O请求转化为物理I/O的启动和执行。同时监督设备是否正确执行，管理数据缓冲区，进行必要的纠错处理。</li><li>独立于设备的I/O软件</li><li>用户空间的I/O软件</li></ul><h3 id="20-缓冲技术"><a href="#20-缓冲技术" class="headerlink" title="20. 缓冲技术"></a>20. 缓冲技术</h3><ul><li><p>缓冲技术的基本思想： 当进程执行写操作输出数据时，先向系统申请一个输出缓冲区，然后将数据送至缓冲区，若是顺序写请求，则不断地把数据填入缓冲区，直至装满为止，此后进程可以继续计算，同时，系统将缓冲区的内容写在设备上。当进程执行读操作输入数据时，先向系统申请一个输入缓冲区，系统将设备上的一条物理记录读至缓冲区，根据要求把当前所需要的逻辑记录从缓冲区中选出并传送给进程。</p></li><li><p>单缓冲： 是最简单的缓冲技术，每当有I/O请求时，操作系统就在内存的系统区中开设一个缓冲区。不允许多个进程同时对一个缓冲器操作。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204616794.png" alt="OS_SingleBuffer"></p></li><li><p>双缓冲： CPU可把输出到设备的数据放入其中一个缓冲器(区)、让设备慢慢处理；然后，它又可以从另一个为终端设置的缓冲器(区)中读取所需要的输入数据。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204731068.png" alt="OS_TwoBuffer"></p></li><li><p>多缓冲： 是把多个缓冲区连接起来组成两部分，一部分专门用于输入，另一部分专门用于输出的缓冲结构。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204816679.png" alt="OS_MultiBuffer"></p></li></ul><h3 id="21-驱动调度技术"><a href="#21-驱动调度技术" class="headerlink" title="21. 驱动调度技术"></a>21. 驱动调度技术</h3><ul><li>磁盘的物理结构：<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161224212641212.png" alt="OS_DISK"><br>磁盘包括多个盘面，每个盘面有一个读写磁头，所有的磁头都固定在唯一的移动臂上同时移动。一个盘面上的读写磁头的轨迹称为磁道，读写磁头下的所有磁道形成柱面，一个磁道又可以划分为多个扇区。在磁盘上定位某个物理记录需要知道其柱面号、磁头号以及扇区号。定位物理记录时，磁头到达指定扇区的时间称为查找时间， 选择磁头号并旋转至指定扇区的时间称为搜索延迟。</li><li>磁道(柱面)的搜索定位算法：<br>a. 先来先服务算法(First Come First Server algorithm, FCFS)。<br>b. 最短查找时间优先算法： 总是执行查找时间最短的请求。<br>c. 扫描算法： 移动臂来回的扫过所有柱面，扫描处遇到I/O请求便进行处理。<br>d. 分步扫描算法： 将I/O请求分为长度为N的子队列，按FIFO算法依次处理每个队列，而每个子队列采用扫描算法，处理完一个后再服务下一个队列。<br>e. 电梯调度算法： 又称LOOK算法。<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204846592.jpg" alt="OS_Elevator"><br>磁头号由外向内递增。<br>f. 循环扫描算法： 移动臂总是从0号柱面至最大号柱面顺序扫描，然后直接返回0号柱面重复进行，归途中不提供服务(而扫描算法归途是要提供服务的)。</li></ul><h3 id="22-设备独立性"><a href="#22-设备独立性" class="headerlink" title="22. 设备独立性"></a>22. 设备独立性</h3><ul><li>设备独立性： 用户通常不指定物理设备，而是指定逻辑设备，使得用户作业和物理设备分离开来，再通过其他途径建立逻辑设备和物理设备之间的映射，设备的这种特性称为设备独立性。</li></ul><h3 id="23-虚拟设备"><a href="#23-虚拟设备" class="headerlink" title="23. 虚拟设备"></a>23. 虚拟设备</h3><ul><li><p>外部设备同时联机操作(Simultaneous Peripheral Operations On Line, SPPPLing)：<br><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161220204916946.png" alt="OS_SPOOLing"></p><p>a. 预输入程序。 控制信息从输入设备至输入井，填写预输入表以便在作业执行过程中要求输入信息时可以随时找到其存放位置。<br>b. 井管理程序。 作业执行过程中要求启动某台设备进程I/O操作时，作业控制程序截获这个要求并调用井管理程序控制从相应输入井读取信息，或将信息送至输出井。<br>c. 缓输出程序。 当处理器空闲时，操作系统调用缓输出程序执行缓输出，它查看缓输出表是否有输出打印的文件，文件打印前还可能组织作业或文件标题，也可能对从输出井中读出的信息进行格式加工。</p></li></ul><h3 id="24-文件逻辑结构"><a href="#24-文件逻辑结构" class="headerlink" title="24. 文件逻辑结构"></a>24. 文件逻辑结构</h3><ul><li>文件的逻辑结构的两种形式：<br>a. 流式文件。 一种无结构的文件，文件内的数据不再组成记录，只是一串顺序的信息集合，称为字节流文件。<br>b. 记录式文件。 一种有结构的文件，包含若干逻辑记录，逻辑记录是文件中按信息在逻辑上独立含义所划分的信息单位。</li></ul><h3 id="25-文件物理结构"><a href="#25-文件物理结构" class="headerlink" title="25. 文件物理结构"></a>25. 文件物理结构</h3><ul><li>文件物理结构： 文件的物理结构和组织是指逻辑文件在物理存储空间中的存放方法和组织关系。</li><li>常见组织方式：顺序文件、连接文件、直接文件和索引文件。</li></ul><h2 id="二、Q-amp-A"><a href="#二、Q-amp-A" class="headerlink" title="二、Q&amp;A"></a>二、Q&amp;A</h2><h3 id="1-什么是操作系统？操作系统在计算机系统中的主要作用是什么？"><a href="#1-什么是操作系统？操作系统在计算机系统中的主要作用是什么？" class="headerlink" title="1. 什么是操作系统？操作系统在计算机系统中的主要作用是什么？"></a>1. 什么是操作系统？操作系统在计算机系统中的主要作用是什么？</h3><ul><li>定义： 操作系统尚无严格的定义。 一般可把操作系统定义为： 管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便有效地使用计算机提供良好的运行环境的一种软件系统。</li><li>作用：<br>a. 服务用户。 操作系统作为用户接口和公共服务程序。<br>b. 进程交互。 操作系统作为进程执行的控制者和协调者。<br>c. 系统实现。 操作系统作为扩展机或虚拟机。<br>d. 资源管理。 操作系统作为资源的管理者和控制者。</li></ul><h3 id="2-什么是多道程序设计？多道程序设计有什么特点？"><a href="#2-什么是多道程序设计？多道程序设计有什么特点？" class="headerlink" title="2. 什么是多道程序设计？多道程序设计有什么特点？"></a>2. 什么是多道程序设计？多道程序设计有什么特点？</h3><ul><li>多道程序设计(multiprogramming)： 允许多个作业(程序)同时进入计算机系统的内存并启动交替计算的方法。</li><li>多道程序设计的特点： 从宏观上看是并行的，从微观上看是串行的。</li></ul><h3 id="3-计算机操作系统为什么引入进程？"><a href="#3-计算机操作系统为什么引入进程？" class="headerlink" title="3. 计算机操作系统为什么引入进程？"></a>3. 计算机操作系统为什么引入进程？</h3><ul><li>刻画程序的并发性。</li><li>解决资源的共享性。</li></ul><h3 id="4-在分时系统中，什么是响应时间？它与哪些因素有关？"><a href="#4-在分时系统中，什么是响应时间？它与哪些因素有关？" class="headerlink" title="4. 在分时系统中，什么是响应时间？它与哪些因素有关？"></a>4. 在分时系统中，什么是响应时间？它与哪些因素有关？</h3><ul><li>从交互式进程提交一个请求(命令)直到获得响应之间的时间间隔称为响应时间。</li><li>影响分时操作系统的响应时间的因素很多，如，CPU的处理速度、联机终端的数目、所用时间片的大小、系统调度开销和对换信息量的多少等。</li></ul><h3 id="5-解释并发性与并行性"><a href="#5-解释并发性与并行性" class="headerlink" title="5. 解释并发性与并行性"></a>5. 解释并发性与并行性</h3><ul><li>计算机操作系统中把并行性和并发性明显区分开，主要是从微观的角度来说的，具体是指进程的并行性（多处理机的情况下，多个进程同时运行）和并发性（单处理机的情况下，多个进程在同一时间间隔运行的）。</li><li>并行性是指硬件的并行性，两个或多个事件在同一时刻发生。</li><li>并发性是指进程的并发性，两个或多个事件在同一时间段内发生。</li></ul><h3 id="6-试述存储管理的基本功能。"><a href="#6-试述存储管理的基本功能。" class="headerlink" title="6. 试述存储管理的基本功能。"></a>6. 试述存储管理的基本功能。</h3><ul><li>存储分配。</li><li>地址映射。</li><li>存储保护。</li><li>存储共享。</li><li>存储扩充。</li></ul><h3 id="7-何谓地址转换-重定向-？哪些方法可以实现地址转换？"><a href="#7-何谓地址转换-重定向-？哪些方法可以实现地址转换？" class="headerlink" title="7. 何谓地址转换(重定向)？哪些方法可以实现地址转换？"></a>7. 何谓地址转换(重定向)？哪些方法可以实现地址转换？</h3><ul><li><p>地址重定位： 又称地址转换，地址映射。 可执行程序逻辑地址转换(绑定)为物理地址的过程。</p></li><li><p>实现方法：<br>a. 静态地址重定位。 由装载程序实现装载代码模块的加载和地址转换，把它装入分配给进程的内存指定区域，其中的所有逻辑地址修改成内存物理地址。<br>b. 动态地址重定位。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.04/wlbc/20161219182644798.png" alt="OS_Dynamic"></p><p>由装载程序实现装载代码模块的加载和地址转换，把它装入分配给进程的内存指定区域，但对链接程序处理过的应用程序的逻辑地址则不做任何修改，程序内存起始地址被置于硬件专用寄存器 —— 重定位寄存器。程序执行过程中，每当CPU引用内存地址(访问程序和数据)时，由硬件截取此逻辑地址，并在它被发送到内存之前加上重定位寄存器的值，以便实现地址转换。<br>c. 运行时链接地址重定位</p><blockquote><p>程序链接的三种方式：<br>a. 静态链接。在程序装载到内存和运行前，就已将它的所有目标模块及所需要的库函数进行链接和装配成一个完整的可执行程序且此后不可拆分。<br>b. 动态链接。在程序装入内存前<em>并未</em>事先进行程序各目标模块的链接，而是在程序装载时一边装载一边链接，生成一个可执行文件。<br>c. 运行时链接。 将某些目标模块或库函数的链接 推迟到执行时才进行。</p></blockquote></li></ul><h3 id="8-什么是文件的共享？介绍文件共享的分类和实现思想。"><a href="#8-什么是文件的共享？介绍文件共享的分类和实现思想。" class="headerlink" title="8. 什么是文件的共享？介绍文件共享的分类和实现思想。"></a>8. 什么是文件的共享？介绍文件共享的分类和实现思想。</h3><ul><li><ul><li>文件共享： 不同进程共同使用同一个文件。</li><li>文件共享的分类：<br>a. 静态共享。 两个或多个进程通过文件链接(一个文件同时属于多个目录，但实际上仅有一处物理存储)达到共享同一个文件的目的，无论进程是否运行，其文件的链接关系都是存在的，因此称为静态共享。<br>b. 动态共享。 系统不同的应用程序或同一用户的不同进程并发地访问同一文件，这种共享关系只有当进程存在时才可能出现，一旦进程消亡，其共享关系也就随之消失。<br>c. 符号链接共享。</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二十五.模块和包</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/25.%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/25.%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>一. 回顾<br>    1. 正则表达式. 匹配字符串<br>        简单元字符:<br>           . 除了换行外的其他内容<br>           \w  数字, 字母, 下划线<br>           \d  数字<br>           \s  空白符<br>           \t<br>           \n<br>           \b<br>           ^    开始<br>           $    结束<br>           []   字符组<br>           [^]<br>           ()   分组<br>           |    或者<br>           \W<br>           \D<br>           \S<br>        量词:<br>            *   0-&gt;多<br>            +   1-&gt;多<br>                ?   0-&gt;1</p><pre><code>        {n} n次        {n,} n到多次        {n,m} n到m次    贪婪和惰性    贪婪: *  +  {}    惰性: .*?x    分组 ()    转义: \re模块    findall()  查找所有结果    finditer() 查找结果返回迭代器. group() 获取结果    search()   搜索. 得到第一个结果就返回    match()    匹配. 从头匹配. 得到第一个结果就返回    compile()  编译    split    sub    subn</code></pre><p>二. 作业</p><p>三. 今日内容<br>    import<br>    from xxx import xxxx<br>    金庸<br>    1. 导入模块的执行的步骤<br>    2. 自定义模块<br>    3. 自定义包(难点)<br>        一个表达式 -&gt; 一条语句  -&gt; 语句块  -&gt; 函数 -&gt; 类  -&gt; 模块  -&gt; 包  -&gt; 项目<br>        包就是我们的文件夹, 包内可以写很多个模块.</p><pre><code>    查找路径是:sys.path, 随动. 跟着你的启动文件所在的位置变化    不论使用绝对导入. 还是相对导入. 启动文件一定在最外面</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二十四.re模块</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/24.re%E6%A8%A1%E5%9D%97/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/24.re%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    1. namedtuple 命名元组<br>        namedtuple(“名字”, [属性, 属性])<br>        2. os模块, 主要封装的是关于操作系统的内容<br>        os.makedirs() 创建多级目录<br>        os.rmdir() 删除文件夹<br>        os.path.dirname() 返回当前路径的文件夹<br>        os.path.exists() 判断文件是否存在<br>        isfile<br>        isdir</p><pre><code>    os.popen()3. sys模块    sys.path 模快的搜索路径4. pickle    pickle.dumps()    把对象序列化成字节    pickle.loads()    把字节反序列化成对象    pickle.dump()    pickle.load()5. json    json.dumps() 字典 -&gt; 字符串    json.loads() 字符串-&gt; 字典    # 跟文件相关的    json.dump()    json.load()</code></pre><p>二. 作业<br>三. 今日主要内容<br>    1. 正则表达式 匹配字符串<br>        元字符<br>            .   除了换行<br>            \w  数字, 字母, 下划线<br>            \d  数字<br>            \s  空白符<br>            \n<br>            \t<br>            \b  单词的边界<br>            \W  非xxx<br>            \D<br>            \S<br>            []  字符组<br>            [^xxx] 非xxxx<br>            ^ 字符串的开始<br>            $ 字符串的结束<br>            |  或者<br>        量词<br>            * 0-&gt;n<br>            + 1-&gt;n<br>            ? 0-&gt;1<br>            {p} p次<br>            {p,q} p-&gt;q次<br>            {p,} 至少p次</p><pre><code>    贪婪和惰性        .*        .+        惰性:        .*?宝宝  尽可能少的匹配    转义 \\\\n =&gt; \\n  =&gt; \n        正则前面加r    分组 ()2. 在python中使用正则. re    (?P&lt;name&gt;正则)    1. search() 搜索. 搜索到第一个结果返回    2. match() 匹配. 收到一个结果返回. 从头开始匹配    3. findall() 查找所有匹配结果    4. finditer() 返回迭代器.    5. compile() 编译    6. group("name") 获取数据    7. re.S 干掉 . 的换行    sub    subn    split作业:    https://www.dytt8.net/    爬取电影天堂. 2018新片精品 所有电影的信息(名字, 主演, 下载链接) =&gt; 写入到文件中(json)预习:    模块的语法(自定义模块)    包的语法(自定义包)    sys.path</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二十三.模块</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/23.%E6%A8%A1%E5%9D%97/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/23.%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    模块: 你写的py文件<br>    引入其他模块<br>    1. import 模块<br>        2. from 模块 import 功能, 类, 变量, 函数</p><pre><code>1. random   random.random()   0-1   random.uniform(a,b)  a-b随机小数   random.randint(a,b) a-b随机整数   random.choice() 随机选择一个   random.sample() 随机选择多个2. time    时间模块        1. 时间戳(数字形式的时间) time.time()        2. 格式化时间  time.strftime("%Y-%m-%d %H:%M:%S")        3. 结构化时间  time.localtime()        数字 -&gt; 格式化时间        struct_time = time.localtime(num)        time.strftime("%Y-%m-%d %H:%M:%S", struct_time)        格式化时间 -&gt; 数字        struct_time = time.strptime(str, "%Y-%m-%d %H:%M:%S")        time.mktime(struct_time)3. collections    1. defaultdict 默认值字典    2. OrderedDict 排序字典    3. Counter计数器    4. deque  双向队列    Stack 栈        先进后出(FILO)    Queue 队列        先进先出(FIFO)    import queue    queue.Queue()    Iterable    Iterator4. functools    1. wraps        装饰器. 给inner改名字.    2. reduce        归纳    3. 偏函数(partial)        固定函数的参数    map -&gt; reduce    大数据       1024TB -&gt; 1PB       百万级 -&gt; 单机</code></pre><p>二. 作业</p><p>三. 今日主要内容<br>    1. namedtuple<br>        命名元组-&gt;类似创建了一个类</p><pre><code>2. os    主要是针对操作系统的    一般用来操作文件系统    os.makedirs()可以一次性创建多级目录    os.rmdir()删除一个文件夹    os.path.dirname() 获取到文件的文件夹3. sys    主要针对的是我们的python解释器    sys.path(重点中的重点)  模块的查找路径4. 序列化    把一个对象拍散 叫序列化    把拍散的内容整合回对象. 反序列化5. pickle(重点)    把一个对象进行序列化操作    1. dumps()  把对象序列化成字节    2. loads()  把字节反序列化成对象    3. dump()  把对象序列化写入文件    4. load()  把文件中的内容反序列化成对象6. json(重点中的重点)    json你可以认为是python中的字典. 有一点点的不一样    python: True, False, None    json: true, false, null    1. dumps()  把对象序列化成json    2. loads()  把json反序列化成对象    3. dump()  把对象序列化写入文件    4. load()  把文件中的内容反序列化成对象明天预习:    正则表达式    RE模块    看看模块和包的语法</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二十二.模块</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/22.%E6%A8%A1%E5%9D%97/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/22.%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>一. 上次课内容回顾<br>    面向对象中的继承关系<br>        1. 经典类<br>            py2: 不继承任何类</p><pre><code>    2. 新式类        py2: 手动继承object        py3: 所有的类都是object的子类    经典类的MRO: 树的深度优先遍历        从左到右, 一条路跑到黑    新式类的MRO: C3算法        1. 拆分            L(H) = H + L(H的父类)... + 父类父类父类        2. 合并(merge)            用每一项的头和其他项的身体比较            如果第一项的头没有在其他身体中出现. 此时第一项的头被算出            如果第一项的头出现在其他身体中. 继续下一项的头..... 下一项的头计算完成需要重新返回第一项继续执行判断</code></pre><p>二. 今日主要内容<br>    1. 简单了解模块<br>        你写的每一个py文件都是一个模块.<br>        还有一些我们一直在使用的模块<br>        buildins 内置模块. print, input</p><pre><code>    random 主要是和随机相关的内容        random()    随机小数        uninform(a,b) 随机小数        randint(a,b)  随机整数        choice() 随机选择一个        sample() 随机选择多个        shuffle() 打乱2. Collections    1. Counter 计数器    2. defaultdict 默认值字典    3. OrderedDict 有序字典    数据结构(队列, 栈(重点))        栈:先进后出            Stack        队列: 先进先出         Queue3. Time模块    时间有三种:        结构化时间 gmtime() localtime()        时间戳  time.time()  time.mktime()        格式化时间 time.strftime() time.strptime()        时间转化:            数字 -&gt; 字符串            struct_time = time.localtime(数字)            str = time.strftime("格式", struct_time)            字符串 -&gt; 数字            struct_time = time.strptime(字符串, "格式")            num = time.mktime(struct_time)4. functools    wraps   给装饰器中的inner改名字    reduce  归纳.    偏函数   把函数的参数固定.明天:    1. namedtuple 命名字典    2. os模块    3. sys模块    # 序列化    4. json(重点)    5. pickle(次重点)可以开始复习了.</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二十一.MRO C3算法</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/21.MRO%20C3%E7%AE%97%E6%B3%95/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/21.MRO%20C3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>面向对象:<br>        1. 写明白类<br>            类是一个对某一事务的描述, 对属性和方法的归类<br>            class 类名:<br>                var = 123 # 类变量<br>                def <strong>init</strong>(self, x,x, x, x, x):<br>                    # 实例变量<br>            ​        self.xxx = xxx<br>            ​        self.xxx = xxx<br>            ​        self.xxx = xxx<br>            ​        self.xxx = xxx<br>            ​        self.xxx = xxx</p><pre><code>            # 实例方法: 给对象用的.            def method(self):                pass            @staticmethod  -&gt; 函数            def stamethod():                pass            @classmethod   -&gt; 方法            def clsmethod(cls):                pass            @property            def age(self): # 把一个方法变成属性                return 10            def __privatemethod(self): # 私有方法                pass        类可以互相继承            class Base:  # 超类, 基类                pass            class Person(Base, Base2, Base3): # 派生类                pass        1. 依赖 -&gt; 在执行某个方法的时候把另一个类的对象作为参数传递进来        2. 关联关系  -&gt; 在一个对象中绑定另外一个类的对象. 解耦            两个对象之间如果是紧密联系的. 耦合性强        约束            1. 写一个父类. 在父类中写出要被约束的方法. 在该方法中写 raise NotImplmentedError()            2. 写一个抽象类. 子类重写抽象类中的抽象方法                from abc import ABCMeta, abstractmethod                class Foo(metaclass = ABCMeta):                    @abstractmethod                    def 抽象方法(self):                        pass        反射            getattr(对象, str)            hasattr(对象, str)            setattr(对象, str, value)            delattr(对象, str)    2. 明白对象是什么        什么是对象, 什么都是对象.        在编程的世界里. 对象是由类创建.        类名()  -&gt;  创建对象, 实例化        此时会默认的调用两个方法 -&gt; __new__()开辟内存 -&gt; __init__()        对象能够执行的方法都写在类中. 对象的属性一般都写在__init__()        对象最主要的意义就是对数据进行封装.        class Stu:            def __init__(self, name, sno, age):                self.name = name                self.sno = sno                self.age = age        bb = Stu("宝宝", "1", 18)</code></pre><p>今日内容大纲:<br>    1. 了解python2和python3类的区别<br>        python2在2.4之前使用的是经典类, 2.4之后, 使用的是新式类</p><pre><code>    class Foo:        pass    class Foo(object):        pass    MRO: method resolution order 方法的查找顺序    class Base:        pass    class Base1:        def chi():            pass    class Bar(Base, Base1):        pass    b = Bar() # Bar -&gt; Base -&gt; Base1    b.chi()2. 经典类的MRO 树形结构的深度优先遍历 -&gt; 树形结构遍历3. 新式类的MRO C3算法(难点, 重点)    1. 拆分    2. 合并    用头和身体比较4. super() 找MRO顺序的下一个5. 一道面试题# 今天作业: 没有.继续做周末作业-&gt; 明天晚上之前. 交上来.# 明天休息.# 周三. 模块应用# 周四. 序列化# 周五. RE# 周六. 模块和包# 考试范围: 头-&gt;尾.</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二十.类的约束</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/20.%E7%B1%BB%E7%9A%84%E7%BA%A6%E6%9D%9F/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/20.%E7%B1%BB%E7%9A%84%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    1.<br>        isinstance: 判断xxx是否是xxx类型的(向上判断)<br>        type: 返回xx对象的数据类型<br>        issubclass: 判断xxx类是否是xxx类的子类</p><pre><code>2.    区分函数和方法    from types import FunctionType, MethodType    得到的结论, 在类中:        实例方法:            1. 类.方法    函数            2. 对象.方法  方法        类方法:            都是方法        静态方法:            都是函数3. 反射    1. hasattr(对象, str) 判断对象中是否包含str属性    2. getattr(对象, str) 从对象中获取到str属性的值    3. setattr(对象, str, value) 把对象中的str属性设置为value    4. delattr(对象, str) 把str属性从对象中删除</code></pre><p>二. 作业<br>三. 今日主要内容<br>    1. 类的约束<br>        1. 写一个父类. 父类中的某个方法要抛出一个异常 NotImplementedError (重点)<br>        2. 抽象类和抽象方法<br>            from abc import ABCMeta, abstractmethod<br>            class Base(metaclass = ABCMeta):<br>                @abstractmethod<br>                def fangfa(self):<br>                    pass</p><pre><code>2. 异常处理. try except raise    try:        代码    except 异常类:        除了错, 如何处理异常    except 异常类:        除了错, 如何处理异常    except 异常类:        除了错, 如何处理异常    else:        当程序不出错    finally:        不管出不出错, 都要执行    raise 异常类("信息")    如何自己定义异常    class 类(Exception):        pass    堆栈    import traceback    traceback.format_exc()3. MD5加密    import hashlib    obj = hashlib.md5(b'盐')    obj.update(b"要加密的内容")    print(obj.hexdigest())4. 日志处理 (不要记, 留一份, 侧重点在用)    等级:        critical: 50        error:40        warning:30        info:20        debug:10下周一预习:    继承体系中的MRO, C3算法.    python2的继承 -&gt; 经典类    python3的继承 -&gt; 新式类(重点)    super() MRO的下一个周末把面向对象的东西好好复习. 尤其第三天的代码. 重新敲一遍. 第四天上午的代码</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十九.反射</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/19.%E5%8F%8D%E5%B0%84/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/19.%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    类与类之间的关系: 昨日目的就是写代码<br>        1. 依赖关系<br>            在方法的参数位置把另一个类的对象作为参数进行传递<br>                2. 组合, 关联, 聚合<br>            self.属性 = 对象<br>            self.phone = 苹果</p><pre><code>        self.phone.play()        一对一关系        一对多关系        多对多关系    3. 继承        父类: 基类, 超类        子类: 派生类        self是谁?  谁调用的就是谁特殊成员:    __init__ 初始化操作    __call__ 对象()    __getitem__ 对象[]    __setitem__ 对象[] = 值    __delitem__ del 对象    __new__  开辟内存.    __hash__ 可哈希. hash()    __enter__ with 对象:    __exit__  with 对象:结束的时候自动调用    __iter__ iter(对象), for</code></pre><p>二. 作业<br>三. 今日主要内容</p><pre><code>1. isinstance, type, issubclass    isinstance: 判断你给对象是否是xx类型的. (向上判断)    type: 返回xxx对象的数据类型    issubclass: 判断xxx类是否xxx的子类2. 如何区分方法和函数(代码)    在类中:        实例方法            如果是类名.方法  函数            如果是对象.方法  方法        类方法: 都是方法        静态方法: 都是函数    from types import MethodType, FunctionType    isinstance()3. 反射(重要)    一共就4个函数    attr: attribute    getattr()        从xxx对象中获取到xxx属性值    hasattr()        判断xxx对象中是否有xxx属性值    delattr()        从xxx对象中删除xxx属性    setattr()        设置xxx对象中的xxx属性为xxxx值预习:    约束(固定套路)    类 -&gt; 对象 -&gt; 嘎嘎叫    def func(duck):        duck.gagajiao()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十八.类于类之间的关系</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/18.%E7%B1%BB%E4%BA%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/18.%E7%B1%BB%E4%BA%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    类的成员:<br>        变量:<br>            实例变量    对象.属性=xxxx<br>            类变量   共享给所有的该类的对象     类.变量<br>        方法:<br>            实例方法,  对象.方法()<br>                def method(self):<br>                    pass</p><pre><code>        类方法, 一般使用类名.方法()            @classmethod            def method(cls):                pass        静态方法, 写在类里的函数. 一般使用类名.方法()            @staticmethod            def method():                pass        class Foo:            def m1(self):                pass            @classmethod            def m2(cls):                pass            @staticmethod            def m3():                pass        f = Foo()        f.m1()        Foo.m2()        Foo.m3()属性:    @property    作用:把一个方法变成属性.    有些属性必须经过计算而得到    @property    def age(self):        return 2018-self.birth私有:    __开头的东西就是私有的.    只能在自己类中使用.</code></pre><p>二. 作业<br>三. 今日主要内容<br>    类与类之间的关系<br>        在我们的世界中事物和事物之间总会有一些联系.<br>        在面向对象中. 类和类之间也可以产生相关的关系<br>        1. 依赖关系<br>            执行某个动作的时候. 需要xxx来帮助你完成这个操作. 此时的关系是最轻的.<br>            随时可以更换另外一个东西来完成此操作</p><pre><code>    2. 关联关系        在对象里面埋对象        self.girlFriend = girl        1. 一对一关系            你和你的女朋友        self.teach_list = [t1,t2,t3]        2. 一对多关系             一个学校. 一堆老师    类中的关系: 依赖关系是最轻的. 最重的是继承关系. 关联关系是比较微妙的.self到底是谁?    self:谁调用的就是谁. 类型是根据调用方的对象来进行变换的    super:表示的是父类特殊成员:    __init__() # 创建对象的时候初始化操作    __call__() # 对象()    __getitem__() # 对象[哈哈]    __setitem__() # 对象[哈哈] = 值    __new__() # 创建对象的时候.开辟内存    __enter__() # with 对象    __exit__() #结束with的时候    __hash__() # 可哈希 hash()预习:    反射(简单)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十七.面向对象成员</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/17.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/17.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    1. 初识面向对象<br>        面向过程: 侧重在过程. 侧重的是事务发展的流程<br>        面向对象: 以对象为中心. 在Python中所有的内容都是对象.</p><pre><code>    面向对象比一定比面向过程好用    当程序比较小. 任务量不大. 更适合用面向过程    当程序比较大. 任务比较大. 后期维护成本高. 需要面向对象    面向对象    优点: 超强的可扩展性. 开发成本低. 后期维护相对容易    缺点: 上手难. 入门难.2. 神马是对象, 对象和类    什么是对象? 什么都是对象    什么是类? 类是对某一种事物的描述.    在类中一般我们是写属性和方法    class 类:        def __init__(self): 初始化方法. 构造方法            self.xxx = xxxx  属性        def 方法(self):            方法体    变量 = 类()    变量.属性   # 操作属性    变量.方法   # 调用方法3. 面向对象的三大特征:    封装:对属性的封装, 对功能的封装    继承:子类自动拥有父类中除了私有内容外的其他所有内容    多态:同一个对象多种形态. python中支持的是鸭子模型.</code></pre><p>二. 作业<br>三. 今日主要内容<br>    1. 成员<br>        在类中你能写的所有内容都是类的成员</p><pre><code>2. 变量    1. 实例变量: 昨天写的就是实力变量, 由对象去访问的变量.    2. 类变量. 此时. 这个变量属于类. 但是对象也可以访问.3. 方法    1. 实例方法: 昨天写的就是实例方法. 使用    对象.方法()        特点: 在声明的时候. 需要给出self, self必须放在第一个位置              在调用的时候. 自动的会把对象传递给形参的self    2. 类方法(@classmethod): 类方法是属于类的.        特点:在声明的时候需要给出一个能够接受类名的参数, cls , 也必须放在参数的第一个             在调用的时候. 自动得把xx对象的类传递给cls    3. 静态方法(@staticmethod): 静态方法也是属于类的. 静态方法就好比. 我们在类中定义了一个函数        静态方法一般和类方法差不多. 使用类名去访问4. 属性    在方法上添加一个@property. 可以把一个方法变成一个属性. 但是这个属性不可以被赋值    当我们某一个属性必须经过计算才能得到结果的时候.5. 私有    所有以双下划线开头的方法, 变量都是私有内容. 外界无法访问. 除非你主动暴露这些内容总结: 强化面向对象预习:    类与类之间的关系</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十六.初识面向对象</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/16%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/16%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>一. 装饰器回顾<br>    1. 通用装饰器的写法<br>        def wrapper(fn):<br>            def inner(<em>args, **kwargs):<br>                ‘’’在目标函数之前’’’<br>                ret = fn(*args, *</em>kwargs)<br>                ‘’’在目标函数之后’’’<br>                return ret<br>            return inner</p><pre><code>    @wrapper # func = wrapper(func)    def func():        pass    func() # 此时执行的是inner2. 带参数的装饰器    def wrapper_out(flag):        def wrapper(fn):            def inner(*args, **kwargs):                '''在目标函数之前'''                ret = fn(*args, **kwargs)                '''在目标函数之后'''                return ret            return inner        return wrapper    @wrapper_out(1)3. 同一个函数被多个装饰器装饰    @hehe    @haha    @houhou    def func():        pass</code></pre><p>二. 作业</p><p>三. 今日主要内容<br>    1. 初识面向对象<br>        面向过程:<br>            一切以事务的发展流程为中心.<br>        面向对象:<br>            一切以对象为中心. 一切皆为对象. 具体的某一个事务就是对象</p><pre><code>    打比方:        大象进冰箱            步骤: 第一步, 开门, 第二步, 装大象, 第三步, 关门            面向对象:大象, 你进冰箱.                此时主语是大象. 我操纵的是大象. 此时的大象就是对象2. 类. 对象    类: 就是图纸. 创建对象的第一步. 先画图纸. 先写类.    对象: 对象就是车. 通过图纸造出来的具体的东西. 通过类来创建对象    类与对象的关系:        类是对xxx事物的归类.            写:                __init__(self, 参数)  参数一般作为属性设置给对象. 对象就是self, 对属性的封装.                def 方法(self, 参数): 方法. 第一个参数一般是固定的self. 当前类的对象.                    pass        对象是xx类型的一个具体            创建对象: 类名()    创建类:    class 类名:        def __init__(self): # 初始化方法. 又被成为构造方法            self.属性 = 值            self.属性 = 值            self.属性 = 值        def fangfa(self):            方法体(函数体,  return)    创建对象:        变量 = 类名() # 实例化 &lt;-&gt; 创建对象        变量.属性 # 访问对象的属性信息        变量.方法() # 访问类中的方法3. 面向对象和面向过程的对比    如果写一些比较小的程序用面向过程.    程序很复杂. 很庞大建议用面向对象.4. 面向对象的三大特征    封装:        1. 对属性的封装(__init__())            self.xxx = xxx        2. 对方法和功能的封装    继承        子类自动拥有父类中除了私有内容外的其他所有内容        class Bar(Foo):  Bar对Foo进行了扩展            pass        当出现x是一种y的时候. 推荐使用继承关系        python支持多继承. 查找顺序: 先找离他近的.    多态(python原生直接就是多态)        python更多的支持的是鸭子模型, 只要会嘎嘎叫就是好鸭子预习:    类的成员        属性和方法</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十五.装饰器</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/15.%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/15.%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    1. 内置函数的补充.<br>        chr<br>        ord<br>        repr() 字符串的官方显示效果<br>        format(123, “.2f”) 格式化<br>        2. 递归<br>        本质是函数自己调用自己<br>        递归的最大深度. 官方是1000, 实测997</p><pre><code>    递归的入口(参数)和出口(return)3. 二分查找    掐头结尾取中间.</code></pre><p>二. 没作业<br>三. 今日主要内容<br>    关于函数的装饰器.<br>    1. 装饰器(重点, 难点)<br>        开闭原则:<br>            对功能的扩展开放<br>            对代码的修改是封闭</p><pre><code>    通用装饰器语法:    def wrapper(fn):        def inner(*args, **kwargs): # 聚合            在目标函数之前            ret = fn(*arg, **kwargs) # 打散            在目标函数之后            return ret        return inner    @wrapper    def func():        pass    func()2. 同一个函数被多个装饰器装饰    @wrapper1    @wrapper2    @wrapper3    def func():        pass   1  2  3  func 3  2  13. 带参数的装饰器(难受)    def wrapper_out(参数):        def wrapper(fn):            def inner(*args, **kwargs): # 聚合                在目标函数之前                ret = fn(*arg, **kwargs) # 打散                在目标函数之后                return ret            return inner        return wrapper    @wrapper_out(实参)  # 执行的时候. 先执行函数的调用然后使用返回值和前面的@组合成装饰器语法糖    def func():        passeval  =&gt;  文件操作装饰器函数复习: 三大器(迭代器, 生成器, 装饰器)预习:    下周, 面向对象(要把大象装冰箱, 总共分几步.)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十四.递归、二分法查找</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/14.%E9%80%92%E5%BD%92%E3%80%81%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/14.%E9%80%92%E5%BD%92%E3%80%81%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    一堆内置函数</p><pre><code>exec 没有返回值eval 有返回值compile 编译代码sorted(iterable, key=function排序规则, reverse=翻转)map(function, iterable)filter(function, iterable)匿名函数 :    lambda 参数: 返回值</code></pre><p>二. 作业<br>三. 今日主要内容<br>    1. 昨日补充<br>        repr() 显示出字符串的官方表示形式<br>        chr()<br>        ord()</p><pre><code>2. 递归    自己调用自己    递归的入口(参数)     和   出口(return)    树形结构的遍历3. 二分法    掐头结尾取中间    查找效率非常的高明天:    装饰器    复习: 第一类对象, 函数名当参数, 函数名当返回值    函数的嵌套    闭包:</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十三.内置函数</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/13.%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/13.%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    生成器, 本质就是迭代器. 使用和迭代器是一样.  <strong>next</strong>()<br>    生成器函数<br>        函数中包含了yield.<br>        在执行生成器函数的时候. 实际上没有运行这个函数. 而是创建了一个生成器</p><pre><code>    def func():        yield    func() # 创建了生成器    从生成器获取数据.        __next__(), 下一个        send(), 给上一个yield传值        for, __next__()        list(), for推导式-&gt; 快速创建列表, 字典, 集合    列表推导式 [结果 for循环 if条件]    字典推导式 {结果(k:v) for循环 if条件}    集合推导式 {结果(k) for循环 if条件}生成器表达式    (结果 for循环 if条件)</code></pre><p>二. 作业</p><p>三. 今日主要内容<br>    内置函数<br>    匿名函数<br>    sorted<br>    map<br>    filter</p><pre><code>预习:    递归,    二分法,    一对内置函数(漏掉的),    装饰器</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二.生成器和各种推导式</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/12.%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%90%84%E7%A7%8D%E6%8E%A8%E5%AF%BC%E5%BC%8F/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/12.%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%90%84%E7%A7%8D%E6%8E%A8%E5%AF%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    1. 函数名 -&gt; 第一类对象<br>        函数名就是变量名.<br>        函数可以赋值<br>        函数可以作为集合类的元素<br>        函数可以作为参数传递<br>        函数可以作为返回值返回<br>        2. 闭包<br>        语法: 内层函数对外层函数的局部变量的使用<br>        def wrapper():<br>                name = “”<br>                def inner():<br>                return name<br>                return inner</p><pre><code>    如何查看一个函数是否是闭包    函数名.__closure__  有值就是闭包. None就不是闭包    优点:        1. 保护变量不被侵害 (javascript)        2. 可以让一个变量常驻内存3. 迭代器    在数据中包含了__iter__是一个可迭代对象.    for循环内部    it = lst.__iter__()    while 1:        try:            it.__next__()        except StopIteration:            break    特点:        1. 节省内存        2. 惰性机制        3. 只能向前, 不能反复    意义: 统一数据类型的遍历工作    官方查看xxx是迭代器, 可迭代对象    from collections import Iterable, Iterator    isinstance(对象, Iterable)    isinstance(对象, Iterator)    迭代器一定可迭代   -&gt;   for循环    可迭代的不一定是迭代器</code></pre><p>二. 作业<br>三. 今日主要内容<br>    1. 生成器<br>        本质就是迭代器.<br>        一个一个的创建对象<br>        创建生成器的方式:<br>            1. 生成器函数<br>            2. 通过生成器表达式来获取生成器<br>            3. 类型转换(看不到)<br>    2. 生成器函数 (重点)<br>        生成器函数中包含 yield , 返回数据和return差不多.<br>        return会立即结束这个函数的执行<br>        yield 可以分段的执行一个函数</p><pre><code>    生成器函数在执行的时候返回生成器. 而不是直接执行此函数    能向下执行的两个条件:        __next__(), 执行到下一个yield        send(), 执行到下一个yield, 给上一个yield位置传值    所有的生成器都是迭代器都可以直接使用for循环    都可以使用list()函数来获取到生成器内所有的数据    生成器中记录的是代码而不是函数的运行    def func():        print("我的天哪 ")        yield "宝宝"    gen = func() # 创建生成器.  此时运行会把生成器函数中的代码记录在内存    当执行到__next__(), 运行此空间中的代码, 运行到yield结束.    优点: 节省内存, 生成器本身就是代码. 几乎不占用内存    特点: 惰性机制, 只能向前. 不能反复3. 各种推导式 (诡异)    列表推导式  [结果 for循环 if]    字典推导式 {结果(k:v) for循环 if}    集合推导式 {结果(k) for循环 if}4. 生成器表达式 (重点)    (结果 for循环 if)明天:    1. 内置函数    2. 递归    3. 二分法查找, 掐头结尾取中间</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一.第一类对象、闭包、迭代器</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/11.%E7%AC%AC%E4%B8%80%E7%B1%BB%E5%AF%B9%E8%B1%A1%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/11.%E7%AC%AC%E4%B8%80%E7%B1%BB%E5%AF%B9%E8%B1%A1%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>一. 上次课内容回顾<br>    函数的定义<br>        对功能或者动作的封装.<br>        语法:<br>            def 函数名(形参):<br>                函数体(return)</p><pre><code>        函数名(实参)    return:        返回. 谁调用就返回到哪里        1. 函数中不写return, 返回None.        2, 只写了return, 也是返回None. 结束一个函数的运行        3, return 值 返回一个值        4, return 值1, 值2, 值3.... 一次返回多个结果. 打包成元组返回    参数        1.形参: 在函数声明的位置写的变量            1. 位置参数            2. 默认值参数            3. 动态传参                *   聚合. 接收位置参数的动态传参                **  聚合. 接收关键字参数的动态传参            参数列表顺序:                位置 &gt; *args &gt; 默认值 &gt; **kwargs        2.实参: 函数调用的地方写的具体的值            1. 位置参数            2. 关键字参数            3. 混合参数:  位置 &gt; 关键字                *  把列表, 字符串, 元组打散成位置参数                ** 把字典打散成关键字参数    名称空间:        1. 内置名称空间        2. 全局名称空间        3. 局部名称空间    作用域:        1. 全局作用域: 全局名称空间 + 内置名称空间        2. 局部作用域: 局部名称空间    globals()  查看全局作用域中的名字    locals()   查看当前作用域中的名字    global   在局部引入全局作用域中的内容    nonlocal 在局部, 在内层函数中引入离他最近的那一层的变量</code></pre><p>二. 作业<br>三. 今日主要内容</p><pre><code>第一类对象-&gt; 函数名 -&gt; 变量名    函数对象对象可以像变量一样进行赋值    还可以作为列表的元素进行使用    可以作为返回值返回    可以作为参数进行传递闭包 -&gt; 函数的嵌套    内层函数对外层函数中的变量的使用    好处:        1. 保护变量不被侵害        2. 让一个变量常驻内存    如何通过代码查看一个闭包    __closure__: 有东西就是闭包. 没东西就不是闭包迭代器 -&gt; 固定的思路. for循环    一个数据类型中包含了__iter__函数表示这个数据是可迭代的    dir(数据): 返回这个数据可以执行的所有操作    判断迭代器和可迭代对象的方案(野路子)    __iter__            可迭代的    __iter__  __next__  迭代器    判断迭代器和可迭代对象的方案(官方)    from collections import Iterable, Iterator    isinstance(对象, Iterable) 是否是可迭代的    isinstance(对象, Iterator) 是否是迭代器    模拟for循环    lst= []    # 拿迭代器    it = lst.__iter__()    while 1:        try:            it.__next__()        except StopIteration:            break    特征:        1. 省内存(生成器)        2. 惰性机制        3. 只能向前. 不能后退    作用:统一了各种数据类型的遍历明天:    生成器    生成器函数(重点难点)    生成器表达式和各种推导式下午    三点-六点</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十.函数进阶</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/10.%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/10.%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    初识函数<br>        定义: 对动作或者功能的封装.<br>        语法:<br>            def 函数名(形参):<br>                函数体(return)</p><pre><code>        函数名(实参)        形参: 在函数声明的位置写的变量            1. 位置参数            2. 默认值参数.        实参: 在函数调用的位置给出的具体的值            1. 位置参数            2. 关键字参数            3. 混合   位置, 关键字        传参: 把实参传递给形参的过程        return: 返回, 程序如果运行到return, 函数结束运行.            1. 当我的函数不写return, 表示默认返回None            2. 函数中写return, 返回None            3. return 值, 有一个返回值            4. return 值1, 值2, 值3   多个返回值, 返回的是元组</code></pre><p>二. 作业讲解<br>三. 今日主要内容<br>    1. 动态传参(重点)  <em>, **<br>        *, *</em> :<br>            形参: 聚合<br>                位置参数* -&gt; 元组<br>                关键字** -&gt; 字典<br>            实参: 打散<br>                列表, 字符串, 元素 -&gt; *<br>                字典 -&gt; **<br>        形参顺序(重点):<br>            位置, *args, 默认值, **kwargs</p><pre><code>    无敌传参    def func(*args, **kwargs): arguments参数  keyword-arguments关键字参数        pass2. 作用域和名称空间    名称空间: 用来存放名字(变量, 函数名, 类名, 引入的模块名)的    1. 全局名称空间: 我们在py文件中自己写的变量, 函数.....    2. 内置名称空间: 我们python解释器提供好的一些内置内容(print, input....)    3. 局部名称空间: 在我们执行函数的时候.会产生一个局部名称空间. 放的是: 函数内部的内容(变量, 函数,类...)    名称空间可能会有无数个, 局部名称空间而言. 相对是独立的.一般互不干扰    作用域:        1. 全局作用域: 内置+全局        2. 局部作用域: 局部    globals() 查看全局作用域    locals() 查看当前作用域3. 函数的嵌套    在函数中声明函数    在内部函数中使用变量的时候, 查找顺序: 先找自己 -&gt; 上一层 -&gt; 上一层..全局 -&gt; 内置4. nonlocal和global关键字(重点)    global: 在局部引入全局变量    nonlocal: 在局部...内层函数引入外层离他最近的那个变量.下周预习:    第一类对象(函数名, 他就是个变量名), 闭包, 迭代器    生成器, 各种推导式    内置函数一, 内置函数二    装饰器(头疼), 装饰器进阶    模块    面向对象</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九.初识函数</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/9.%E5%88%9D%E8%AF%86%E5%87%BD%E6%95%B0/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/9.%E5%88%9D%E8%AF%86%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    文件操作<br>        f = open(文件路径, mode=”模式”, encoding=”编码”)<br>        f: 文件句柄<br>        文件的路径:<br>            相对路径<br>                相对于当前程序所在的文件夹<br>                ../ 上一层文件夹<br>                文件夹/  进入文件夹<br>            绝对路径<br>                从磁盘根目录寻找<br>        模式:<br>            r<br>                f.read() 读取文件中全部内容<br>                f.read(n) 读取n个字符<br>                f.readline() 读取一行<br>                f.readlines() 读取全部, 返回列表</p><pre><code>            for line in f:                每次读取一行内容. 读完为止        w            f.write() 写        a        r+        w+        a+        处理非文本文件 bytes        rb        wb        ab    光标 (字节)        seek(0) 移动到开头        seek(0,2)  移动到末尾        tell()  返回光标的位置        truncate(can)            1. 如果给了参数, 从头截取到参数位置            2. 如果不给参数, 从头截取到光标    文件的修改    import os    with open("原文件", mode="r", encoding="utf-8") as f1, \         open("文件_副本" mode="w", encoding="utf-8") as f2:         for line in f1:            # 修改            f2.write(line)    os.remove("原文件")    os.rename("文件_副本", "原文件")</code></pre><p>二. 作业<br>三. 今日主要内容(重点)<br>    1. 什么是函数?<br>        f(x) = x + 1<br>        y = x + 1<br>        函数是对功能或者动作的封装<br>    2. 函数的语法和定义<br>        def 函数名():<br>            函数体<br>        调用:<br>            函数名()<br>    3. 关于函数的返回值<br>        return : 返回<br>        1. 当程序没写过return, 不返回任何结果. 如果你非要接收. 接受到的是None<br>        2. 当函数写return 值, 有一个返回值.<br>        3. 当函数写了return 值1, 值2, 值3….  返回多个结果. 多个结果打包成元组<br>        4. 当程序执行到return, 函数结束执行</p><pre><code>4. 函数的参数(部分)    小括号是什么, 小括号表示调用, 传参    1. 什么是参数: 参数是给函数传递的信息        形参: 在函数声明的位置写的变量            1. 位置参数            2. 默认值            3. 动态传参(明天)  *, **        实参: 在函数调用的时候给函数传递的具体的值            1. 位置参数            2. 关键字参数            3. 混合: 位置, 关键字        传参: 把实参给形参的过程明天:    动态传参.    函数与函数嵌套. 调用复习: 第一天 -&gt; 文件操作.时间:    下周一 下午考试    不及格 -&gt; 下期</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八.文件操作</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/8.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/8.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    1. 基本数据类型补充<br>        join() 把传递进去的参数进行迭代然后和前面的字符串进行拼接, 返回字符串<br>        split() 把字符串切割成列表</p><pre><code>    关于删除:        列表在循环的时候不能直接删除. 因为索引会发生改变. 把要删除的内容保存在新列表中,        然后循环这个新列表. 删除老列表        字典在循环的时候也不能直接删除. 如果删除会报错    fromkeys() 创建字典    坑1: 返回新字典, 对原来的字典没有影响    坑2: 如果给的value是可变的数据类型. 多个key共享同一个value.2. 深浅拷贝    1. = 没有创建新的对象.    2. lst.copy()  lst[:] 浅拷贝, 拷贝第一层内容    3. import  copy        copy.deepcopy()  深拷贝.        把列表内的所有内容进行拷贝和复制</code></pre><p>二. 作业<br>三. 今日主要内容<br>    1. 文件操作<br>        open 打开<br>        f = open(文件路径, mode=”模式”, encoding=”编码格式”) 最最底层操作的就是bytes<br>        打开一个文件的时候获取到的是一个文件句柄.</p><pre><code>    绝对路径        从磁盘根目录开始寻找    相对路径        相对于当前程序所在的文件夹        ../ 上一层文件        文件夹/ 进入xxx文件夹2. mode:    r: 读取,只读.        读取文件的相关操作            1. read()                默认: 读取文件内容(全部)                read(n) 读取n个字符            2. readline()  读取一行            3. readlines() 读取全部. 返回列表            (最重要)4. for line in f: 每次读取一行内容    w:        写入. 只写        创建文件        会清空文件    a:        也可以创建文件        追加写    r+:  对于文件而言. 应该有的操作就两个:读, 写        读写操作    w+:        写读操作    a+:        追加写读    所有带b的表示直接操作的是bytes, 当处理非文本文件的时候.    rb    wb    ab: 断点续传    r+b    w+b    a+b3. 文件操作中关于文件句柄的相关操作    seek() 移动光标    f.seek(0) 移动到开头(最多)    f.seek(0, 2) 移动到末尾        seek:两个参数            1. 表示偏移量            2. 从xxx开始偏移, 默认0, 开头   1, 当前位置    2, 末尾    tell        返回光标所在的位置4. 文件修改, 实际操作(重点)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七.深浅拷贝</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/7.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/7.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    小数据池<br>        针对的数据类型: int, str, bool<br>        小数据池可以帮我们缓存一个对象.<br>        当重复使用的时候可以快速的响应. 直接把对象返回.<br>        优点: 快速拿到对象, 节省内存<br>        缺点: 当小数据池中的内容太多的时候. 程序响应速度是很慢的.<br>    is和==<br>        is 比较的是内存地址.<br>        == 比较的是内容</p><pre><code>encode() : 可以帮我们把字符串转换成bytes类型decode() : 把bytes类型还原回字符串类型bytes是字节. 是python中最小的数据单元</code></pre><p>二. 作业讲解</p><p>三. 今日主要内容<br>    1. 基础数据类型补充<br>        大多数的基本数据类型的知识.已经学完了<br>        join()<br>        “<em>“.join(“马虎疼”) # 马</em>虎<em>疼 把传递进去的参数进行迭代. 获取到的每个元素和前面的</em>进行拼接. 得到的是字符串<br>        split() 切割. 切割的结果是列表</p><pre><code>    列表和字典: 都不能在循环的时候直接删除    把要删除的内容记录在新列表中然后循环这个新列表. 删除列表(字典)    fromkeys()    坑1: 返回新字典. 不会更改老字典    坑2: 当value是可变的数据类型. 各个key共享同一个可变的数据类型. 其中一个被改变了. 其他都跟着变    # 程序员找工作和菜市场大妈买白菜是一样的2. 深浅拷贝(重点, 难点)    1. = 没有创建新对象, 只是把内存地址进行了复制    2. 浅拷贝  lst.copy() 只拷贝第一层.    3. 深拷贝        import copy        copy.deepcopy() 会把对象内部的所有内容进行拷贝预习:    文件操作(本身简单, 联合其他知识进行操作. 会很烦)    open()    read    write    append</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六.小数据池</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/6.%E5%B0%8F%E6%95%B0%E6%8D%AE%E6%B1%A0/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/6.%E5%B0%8F%E6%95%B0%E6%8D%AE%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>一. 上节课内容回顾<br>    1. 字典<br>        {key:value, key:value…..}<br>        成对的保存数据</p><pre><code>    字典没有索引. 不能切片, 字典的key必须是可哈希的.不可变的    1. 增加:        dic[新key] = 值        dic.setdefault(key, value) 新增, 查询    2. 修改:        dic[老key] = 值        dic.update(d) 把d更新到dic中    3. 删除;        pop(key)        popitem() 随机删除        del dic[key]        clear() 清空    4. 查询        for k in dic:            k            dic[k]        get(key) 如果key不存在, 返回None        dic[key] 如果key不存在, 报错        setdefault(key, value)        根据key查询出value    5. 相关操作        1. keys()     所有的key        2. values()     所有的value        3. items()      所有的key和value        for k, v in dic.items(): # 自动解包            k            vset集合    内部元素必须可哈希. 不可变    内部元素不重复    add() 添加    frozenset() 冻结集合. 不可变的.</code></pre><p>二. 作业</p><p>三. 今日主要内容<br>        1. 小数据池, id()<br>            小数据池针对的是: int, str, bool<br>            在py文件中几乎所有的字符串都会缓存.<br>            id() 查看变量的内存地址<br>        2. is和==的区别<br>            is 比较的是内存地址<br>            == 比较的是内容<br>            当两个变量指向同一个对象的时候. is是True, ==也是True</p><pre><code>    3. 再谈编码        回顾:            1. ascii. 有: 数字, 字母, 特殊字符. 8bit  1byte 128  最前面是0            2. gbk. 包含: ascii, 中文(主要), 日文, 韩文, 繁体文字. 16bit, 2byte.            3. unicode. 包含gbk,ascii,big5... 32bit, 4byte            4. utf-8. 可变长度的unicode.                1. 英文: 8bit,1byte                2. 欧洲文字: 16bit 2byte                3. 中文: 24bit 3byte        不同的编码之间不能随意转换. 中国人gbk和德国人utf-8骂 想要沟通必须通过英文(unicode)(媒介)        在python3中. 默认的编码是unicode,我们的字符串就是unicode        在python2中. 默认的编码是ASCII.  Cpython.c语言的默认编码是ASCII        unicode弊端:在存储和传输的时候. 是很浪费的        在存储和传输的时候不能直接使用unicode. 必须要对字符串进行编码. 编码成bytes类型        bytes: 字节形式的字符串            1. encode(编码格式) 编码            2. decode(编码格式) 解码        bytes是一种另类的字符串表示形式        "哈哈哈" =&gt; \xee\xab\x13\xee\xab\x13\xee\xab\x13    预习:        深浅拷贝(难)        基本数据类型的知识点补充(join)        关于字典和列表的删除        周末作业(zip, day5)        质数        数字的长度</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五.字典</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/5.%E5%AD%97%E5%85%B8/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/5.%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<p>一. 昨日内容回顾<br>    1. list列表<br>        写法:[元素, 元素]<br>        对元素的数据类型没有要求<br>        也有索引和切片<br>        索引从0开始<br>        切片<br>        lst[start: end: step]<br>            从start到end. 每隔step取一个</p><pre><code>    增删改查        1. 增加:            1. append() 追加. 在列表的末尾添加            2. insert(index, 元素) 在index位置插入元素        2. 删除:            1. pop(i) 默认从末尾删除, 还可以指定位置删除            2. remove(元素) 删除指定元素        3. 修改:            通过索引去修改元素            lst[3] = "胡辣汤"        4. 查询:            for item in lst: # 拿不到索引                print(item)    range(m) 从0到m    range(m, n) 从m到n    range(m, n, p) 从m到n. 每P个取一个    for i in range(len(lst)):        i  索引        lst[i] 元素    元组: 不可变的. 只读列表. 有索引. 有下标, 有切片.        不可变: 内部指向    可变的: list    不可变的:str, int, bool, tuple</code></pre><p>二. 作业讲解<br>三. 今日主要内容<br>    1. 什么是字典<br>        字典是以key:value的形式来保存数据<br>        用{}表示. 存储的是key:value<br>    2. 字典的增删改查(重点)<br>        1. 添加<br>            dic[新key] = 值</p><pre><code>        setdefault()    2. 删除        pop(key)    3. 修改        dic[老key] = 值        update() 跟新字典    4. 查询        dic[key]        get(key, 值)        setdefault(key, value)    5. 遍历,字典是一个可迭代对象3. 字典的相关操作    1. keys() 获取到所有的键    2. values() 获取到所有的值    3. items() 拿到所有的键值对4. 字典的嵌套    字典的嵌套. 字典套字典5. 集合(不重要). 去重复    集合中的元素是不重复的. 必须是可哈希的(不可变), 字典中的key    空集合:set()    空元组:tuple()    空列表:list()    非空集合: {123}集合, 集合其实就是不存value的字典预习:    深浅拷贝    小数据池    文件操作(带来的作业)    函数# 关于set集合作业: 写一个彩票开奖(36选7)from random import randintrandint(1,36)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四.列表</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/4.%E5%88%97%E8%A1%A8/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/4.%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<pre><code>1. 什么是列表    定义: 能装对象的对象    在python中使用[]来描述列表, 内部元素用逗号隔开. 对数据类型没有要求</code></pre><p>​    列表存在索引和切片. 和字符串是一样的.</p><ol><li><p>相关的增删改查操作(重点)<br> 添加:</p><pre><code> 1. append() 追加     2. insert(位置, 元素) 插入指定元素到指定位置</code></pre><p> 删除:</p><pre><code>     1. pop(index) 根据索引删除     2. remove(元素)  根据元素删除</code></pre><p> 修改:</p><pre><code>     索引修改     lst[索引] = 元素</code></pre><p> 查询:</p><pre><code>     for循环.</code></pre></li><li><p>列表的嵌套<br> 多个列表互相嵌套</p></li><li><p>列表的其他操作</p><ol><li>count()  计数</li><li>sort() 排序  reverse = True</li><li>reverse() 翻转</li><li>len() 求长度</li></ol></li><li><p>什么是元组<br> 能装对象的对象. 不可变. 一旦确认好. 不可更改<br> 只读列表<br> 可以迭代</p></li><li><p>元组的嵌套<br> 和列表一样.都可以互相嵌套.<br> 元组的不可变: 指向不变</p></li><li><p>range(重点, 难点)<br> 数数<br> range(n) [0, n)<br> range(m,n) [m, n)<br> range(m,n,p) [m,n) 每隔p取一个</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><p> for i in range(len(lst)):</p><pre><code> i 索引 lst[i] 元素</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三.数和字符串</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/3.%E6%95%B0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/3.%E6%95%B0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>三.数和字符串</p><p>​    ①基本类型介绍</p><p>​        python基本数据类型</p><p>​        1.int ==&gt;  整数. 主要⽤用来进⾏行行数学运算</p><p>​        2.str ==&gt; 字符串串, 可以保存少量量数据并进⾏行行相应的操作</p><p>​        3.bool==&gt;判断真假, True, False</p><p>​        4.list==&gt; 存储⼤大量量数据.⽤用[ ]表⽰示</p><p>​        5.tuple=&gt; 元组, 不可以发⽣生改变 ⽤用( )表⽰示</p><p>​        6.dict==&gt; 字典, 保存键值对, 一样可以保存⼤大量量数据</p><p>​        7.set==&gt; 集合, 保存⼤大量量数据.  不可以重复. 其实就是不保存value的dict</p><p>​    ②int</p><p>​         在python3中所有的整数都是int类型. 但在python2中如果数据量量比较⼤大. 会使⽤用long类型.</p><p>​        在python3中不存在long类型</p><p>​        整数可以进行的操作:</p><p>​        bit_length(). 计算整数在内存中占⽤的二进制码的长度</p><p>​        布尔值(bool)</p><p>​        取值只有True, False. bool值没有操作.</p><p>​    ③类型转换</p><p>​        转换问题:</p><p>​        str =&gt; int        int(str)</p><p>​        int =&gt; str        str(int)</p><p>​        int =&gt; bool     bool(int). 0是False 非0是True bool=&gt;int   int(bool) True是1, False是0</p><p>​        str =&gt; bool     bool(str) 空字符串串是False, 不空是True bool =&gt; str     str(bool) 把bool值转换成相应的”值”</p><p>​    ④字符串</p><p>​        把字符连成串. 在python中用’, “, ‘’’, “””引起来的内容被称为字符串</p><p>​    ⑤索引和切片</p><p>​        切片和索引</p><p>​        s1 = “python最⽜牛B”</p><p>​        print(s1[0])     # 获取第0个</p><p>​        …</p><p>​        <code>#  print(s1[9])    # 没有9, 越界了了. 会报错</code></p><p>​        print(s1[-1])        # -1 表示倒数.</p><p>​        print(s1[-2])        # 倒数第二个 </p><p>​        切片, 我们可以使⽤用下标来截取部分字符串串的内容</p><p>​        语法: str[start: end,step]</p><p>​        规则: 顾头不顾腚, 从start开始截取. 截取到end位置. 但不包括end</p><p>​    ⑥字符串操作</p><p>​        s1.capitalize()</p><p>​        print(s1)   # 输出发现并没有任何的变化. 因为这⾥里里的字符串串本身是不不会发⽣生改变的. 需要我们重新获取</p><p>​        ret1 = s1.capitalize() print(ret1)</p><p>​        # ⼤小写的转换</p><p>​        ret = s1.lower()  # 全部转换成小写</p><p>​        print(ret)</p><p>​        ret = s1.upper()  # 全部转换成大写</p><p>​        print(ret)</p><p>​        ret = s1.swapcase()  # 大小写互相转换</p><p>​        print(ret)</p><pre><code>    一大波操作.    字符串是不可变的数据类型. 不论如何操作.对原来的字符串是不会有影响的        1, upper() 转换成大写. 忽略大小写        2, strip() 去掉左右两端的空白 空格, \t \n.  所有用户输入的内容都要去空白        3, replace(old, new) 把old替换成new        4, split() 字符串切割        5, startswith() 判断是否以xxx开头        6, find() 查找, 找不到返回-1        7, isdigit() 判断是否是数字组成        8, len() 求长度    for循环遍历字符串    for 变量 in 可迭代对象:        循环体    for c in s: # c: charactor(字符) s: string        print(c)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二.运算符和编码</title>
      <link href="2019/11/15/%E5%9F%BA%E7%A1%80/2.%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%BC%96%E7%A0%81/"/>
      <url>2019/11/15/%E5%9F%BA%E7%A1%80/2.%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>二.运算符和编码</p><p>​    ①运算符</p><p>​    算术运算以下假设变量: a=10,b=20</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.02/1573784921065.png" alt="1573784921065"></p><p>​    比较运算:以下假设变量: a = 10,b = 20 </p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.02/1573784927915.png" alt="1573784927915"></p><p>​    赋值运算</p><p>​    以下假设变量量：a=10，b=20</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.02/1573784945226.png" alt="1573784945226"></p><p>​    算逻辑运</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.02/1573784954125.png" alt="1573784954125"></p><p>​    针对逻辑运算的进一步研究：</p><p>　　1, 在没有()的情况下not 优先级⾼高于 and，and优先级⾼高于or，即优先级关系为( )&gt;not&gt;and&gt;or，同一优先级从左往 右计算。</p><p>​        () &gt; not &gt; and &gt; or</p><p>​    例例题：</p><p>​    判断下列列逻辑语句句的True，False。</p><p>​    3&gt;4 or 4&lt;3 and 1==1</p><p>​    1 &lt; 2 and 3 &lt; 4 or 1&gt;2 </p><p>​    2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &lt; 1</p><p>​    1 &gt; 2 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 or 9 &lt; 8</p><p>​    1 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6 **not** 2 &gt; 1 <strong>and</strong> 3 &lt; 4 **or** 4 &gt; 5 <strong>and</strong> 2 &gt; 1 <strong>and</strong> 9 &gt; 8 <strong>or</strong> 7 &lt; 6</p><p>​    x or y , x为真，值就是x，x为假，值是y；</p><p>​    x and y, x为真，值是y,x为假，值是x。</p><p><img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.02/1573784963185.png" alt="1573784963185"></p><p>​    ②编码</p><p>​        python2解释器器在加载 .py ⽂文件中的代码时，会对内容进⾏行行编码（默认ascill）,⽽而python3对内容进⾏行行编码的默认为utf-8。</p><p>​        早期. 计算机是美国发明的. 普及率不不⾼高, 一般只是在美国使用. 所以. 最早的编码结构就是按照美国⼈人的习惯来编码的. 对应数字+字⺟母+特殊字符一共也没多少. 所以就形成了了最早的编码ASCII码. 直到今天ASCII依然深深的影响着我们.</p><p>​        ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字⺟母的一套电 脑编码系统，主要⽤用于显示现代英语和其他⻄西欧语”，其最多只能⽤用 8 位来表示（一个字节），即：2**8 = 256，所 以，ASCII码最多只能表示 256 个符号。</p><p>​        随着计算机的发展. 以及普及率的提高. 流⾏到欧洲和亚洲. 这时ASCII码就不不合适了. ⽐如: 中⽂文汉字有几万个. 而ASCII 最多也就256个位置. 所以ASCII不行了. 怎么办呢? 这时, 不同的国家就提出了不同的编码用来适用于各自的语”环境. 比如, 中国的GBK, GB2312, BIG5, ISO-8859-1等等. 这时各个国家都可以使⽤用计算机了. </p><p>​        GBK, 国标码占⽤用2个字节. 对应ASCII码 GBK直接兼容. 因为计算机底层是⽤用英⽂文写的. 你不不⽀持英⽂文肯定不行. 而英文已经使用了了ASCII码. 所以GBK要兼容ASCII. </p><p>​        这里GBK国标码. 前面的ASCII码部分. 由于使⽤用两个字节. 所以对于ASCII码⽽而”. 前9位都是0</p><p>字⺟母A:0100 0001        # ASCII</p><p>字⺟母A:0000 0000 0100 0001 # 国标码</p><p>​    国标码的弊端: 只能中国⽤. 日本就垮了. 所以国标码不满足我们的使用. 这时提出了一个万国码Unicode. unicode一 开始设计是每个字符两个字节. 设计完了. 发现我大中国汉字依然无法进行编码. 只能进行扩充. 扩充成32位也就是4个字 节. 这回够了. 但是. 问题来了. 中国字9万多. ⽽而unicode可以表⽰示40多亿. 根本用不了. 太浪费了. 于是乎, 就提出了新的 UTF编码.可变长度编码</p><p>​    UTF-8: 每个字符最少占8位. 每个字符占用的字节数不定.根据文字内容进行具体编码. 比如. 英文. 就一个字节就够了了. 汉字占3个字节. 这时即满足了了中文. 也满足了节约. 也是⽬目前使用频率最高的一种编码</p><p>​    UTF-16: 每个字符最少占16位. </p><p>​    GBK: 每个字符占2个字节, 16位.</p><p>单位转换:</p><p>8bit = 1byte </p><p>1024byte = 1KB </p><p>1024KB = 1MB </p><p>1024MB = 1GB </p><p>1024GB = 1TB </p><p>1024TB = 1PB </p><p>1024TB = 1EB </p><p>1024EB = 1ZB</p><p>1024ZB = 1YB </p><p>1024YB = 1NB</p><p>1024NB = 1DB</p><p>常常用到TB就够了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一.初识Python</title>
      <link href="2019/11/14/%E5%9F%BA%E7%A1%80/1.%E5%88%9D%E8%AF%86Python/"/>
      <url>2019/11/14/%E5%9F%BA%E7%A1%80/1.%E5%88%9D%E8%AF%86Python/</url>
      
        <content type="html"><![CDATA[<h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><p>一.初识Python</p><p>​    ①对计算机基本认识</p><p>​        计算机是一个高度集成的电子电路</p><p>​        计算机由CPU,内存,主板,电源,显示器,键盘,鼠标,显卡,硬盘组成.</p><p>​        计算机通过高低电平来表示二进制进行运算</p><p>​            进制: 二进制没有2  &gt;&gt; 0 1</p><p>​                      八进制没有8  &gt;&gt; 0-7</p><p>​                      十进制没有10  &gt;&gt;  0-9</p><p>​                      十六进制没有16  &gt;&gt;  0-9 A-F</p><p>​    ②了解Python发展史        <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.00/pythonpaixing.png" alt="Tiobe排行榜"></p><p>​        最新的TIOBE排行榜,Python已经占据了世界第三的位置,Python崇尚优美、清晰、简单,是一个优秀并惯犯使用的语言.</p><p>​        Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。并且在他去谷歌面试的时候简历只写了一句话，就是我创造了Python,可见能力确实不一般。</p><p>​        目前Python主要应⽤用领域：</p><p>​            云计算:云计算最火的语言,典型应用 Open stack    </p><p>​            WEB开发:众多优秀的WEB框架,众多大型网站均为 Python开发, Youtube,    Dropbox,豆瓣。。。,典型WEB框架有 Django    </p><p>​            科学运算、人工智能:典型库 NumPy,ScPy, Matplotlib, Enthought    librarys, pandas    </p><p>​            系统运维:运维人员必备语言</p><p>​            金融：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。原因：作为动态语言的Python，语言结构清晰简单，库丰富，成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c,c++,java，尤其擅长策略回测</p><p>​            图形GUI:PyQT,WxPython,TkInter</p><p>​    ③”hello word”</p><p>​        print(“hello word!!”)</p><p>​        好了,我已经精通python了…</p><p>​        python是一门什么样的语言?</p><p>​        编程语言主要从以下几个角度为进行分类，编译型和解释型、静态语言和动态语言、强类型定义语言和弱类型定义语言，我们先看编译型语言和解释型语言。稍后再说强类型和弱类型</p><p>​        编译和解释的区别是什么?</p><p>​        编译器是把源程序的每一条语句都编译成机器语言，并保存成二进制文件，这样运行时计算机可以直接以机器语言来运行此程序，速度很快；</p><p>​        而解释器则是只在执行程序时，才一条一条的解释成机器语言给计算机来执行，所以运行速度是不如编译后的程序运行的快的.</p><p>​        这是因为计算机不能直接认识并执行我们写的语句，它只能认识机器语言（是二进制的形式）</p><p>​        <img src="https://cdn.jsdelivr.net/gh/1420566605wl/new_cdn@1.01/clip_image001.jpg" alt="解释型语言和编译型语言"></p><p>​        python的优缺点:</p><p>​            优点:Python的定位是优雅,明确,简单,所以Python程序看上去总是简单易懂,对初学者很友好</p><p>​                     开发效率高,高级语言,可移植,可扩展,可嵌入</p><p>​            缺点:python是有C语言开发的,因此速度肯定慢了</p><p>​                    代码不能加密</p><p>​                    GIL(全局解释器锁)python在同一时间只能有一个线程在解释器上执行这就使得python无法多线程并行执行,无法应用多核的优势</p><p>​            当然，Python还有一些其它的小缺点，在这就不一一列举了，我想说的是，任何一门语言都不是完美的，都有擅长和不擅长做的事情，建议各位不要拿一个语言的劣势去跟另一个语言的优势来去比较，语言只是一个工具，是实现程序设计师思想的工具，就像我们之前中学学几何时，有的时候需要要圆规，有的时候需要用三角尺一样，拿相应的工具去做它最擅长的事才是正确的选择。之前很多人问我Shell和Python到底哪个好？我回答说Shell是个脚本语言，但Python不只是个脚本语言，能做的事情更多，然后又有钻牛角尖的人说完全没必要学Python，Python能做的事情Shell都可以做，只要你足够牛B，然后又举了用Shell可以写俄罗斯方块这样的游戏，对此我能说表达只能是，不要跟SB理论，SB会把你拉到跟他一样的高度，然后用充分的经验把你打倒。</p><p>​            python解释器:</p><p>​                Cpython python官方默认的解释器</p><p>​                Ipython CPython的改进加强了交互方式</p><p>​                PyPy python采用JIT技术 将python代码进行动态编译 显著提高python代码执行速度 这很矛盾</p><p>​                Jython 是运行在JAVA平台上的python解释器 可以吧python代码编译成java字节码</p><p>​                IronPython 和 Jython类似 是运行在 微软.Net平台上的 Python解释器</p><p>​        python2.x的版本好像一直不在维护了,用3.x的版本吧</p><p>​        编辑工具pycharm</p><p>​        附激活码:<a href="http://lookdiv.com/">http://lookdiv.com</a> 里面有，钥匙：1211268069</p><p>​        记得path下打钩 或自行添加环境变量</p><p>​        命令行模式运行Python python hello.py (注意切换到文件目录)</p><p>​    ④变量</p><p>​        概念:程序运行过程中产生的中间值保存在内存中方便以后调用.</p><p>​        命名规范:</p><p>​            1.数字,字母下划线组成</p><p>​            2.不能用数字彩头,更不能用纯数字</p><p>​            3.不能用python关键字</p><p>​            4.不要用中文(low)</p><p>​            5.要有意义</p><p>​            6.不要太长</p><p>​            7.区分大小写</p><p>​            8.驼峰或者下划线命名</p><p>​    ⑤常量</p><p>​        本质就是变量,所有字母大写就是常量,在python中没有绝对的常量</p><p>​        from math import PI</p><p>​        PI = 3.141592653 (注意大写)</p><p>​    ⑥Python基本数据类型</p><p>​        1.int 整数 +-*/ % // **</p><p>​        2.str 字符串 ‘ ‘,” “,””” “””括起来的内容 +拼接 *重复  很多在字符串中的\ 都会被转义 r”” 防止转义 字符串不可变</p><p>​        3.bool 布尔值 True False</p><p>​        4.float 浮点数 1.8e8 (e8是10的8次方) </p><p>​        5.空值 None 不是0</p><p>​    ⑦用户交互</p><p>​        变量 = input(提示语)</p><p>​        所有的输入内容都是字符串</p><p>​        int(变量) 把变量转化为数字</p><p>​    ⑧流程控制</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> 条件<span class="token number">1</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> 语句块 <span class="token punctuation">(</span>注意缩进<span class="token punctuation">)</span><span class="token keyword">elif</span> 条件<span class="token number">2</span><span class="token punctuation">:</span>    <span class="token keyword">if</span>语句块<span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">else</span>语句块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    ⑨while循环</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> 条件<span class="token punctuation">:</span>        结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        如果条件是真,则直接执行结果,然后在次判断条件,直到条件为假,停滞循环</p><p>​        break  结束(全部)循环</p><p>​        continue 跳出(本次)循环 继续执行下一次循环</p><p>​    ⑩格式化输出</p><p>​        “%s %d %.2f “ % ()</p><p>​        .format()</p><p>​        f”{name}”</p><p>​        注释:养成好习惯 </p><p>​        单行注释:  #被注释的内容</p><p>​        多行注释: “””被注释的内容”””</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python解释执行原理</title>
      <link href="2019/11/14/%E5%9F%BA%E7%A1%80/python%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>2019/11/14/%E5%9F%BA%E7%A1%80/python%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="python解释执行原理-转载"><a href="#python解释执行原理-转载" class="headerlink" title="python解释执行原理(转载)"></a><a href="https://www.cnblogs.com/dj0325/p/7966182.html">python解释执行原理(转载)</a></h1><h2 id="Python解释执行原理"><a href="#Python解释执行原理" class="headerlink" title="Python解释执行原理"></a>Python解释执行原理</h2><p> 　　转自：<a href="http://l62s.iteye.com/blog/1481421">http://l62s.iteye.com/blog/1481421</a></p><p>​      这里的解释执行是相对于编译执行而言的。我们都知道，使用C/C++之类的编译性语言编写的程序，是需要从源文件转换成计算机使用的机器语言，经过链接器链接之后形成了二进制的可执行文件。运行该程序的时候，就可以把二进制程序从硬盘载入到内存中并运行。</p><p>​      但是对于Python而言，python源码不需要编译成二进制代码，它可以直接从源代码运行程序。当我们运行python文件程序的时候，<strong>python解释器</strong>将源代码转换为字节码，然后再由<strong>python解释器</strong>来执行这些字节码。这样，python就不用担心程序的编译,库的链接加载等问题了。</p><p>​      对于python解释语言，有以下3方面的特性：</p><ol><li>每次运行都要进行转换成字节码，然后再有虚拟机把字节码转换成机器语言，最后才能在硬件上运行。与编译性语言相比，每次多出了编译和链接的过程，性能肯定会受到影响。</li><li>由于不用关心程序的编译和库的链接等问题，开发的工作也就更加轻松啦。</li><li>python代码与机器底层更远了，python程序更加易于移植，基本上无需改动就能在多平台上运行。</li></ol><p>​      在具体计算机上实现一种语言，首先要确定的是表示该语言语义解释的虚拟计算机，一个关键的问题是程序执行时的基本表示是<strong>实际计算机上的机器语言还是虚拟机的机器语言</strong>。这个问题决定了语言的实现。根据这个问题的回答，可以将程序设计语言划分为两大类：<strong>编译型语言和解释型语言</strong>。</p><ol><li><strong>编译实现的语言</strong>，如：C、C++、Fortran、Pascal、Ada。由编译型语言编写的源程序需要经过编译,汇编和链接才能输出目标代码，然后由机器执行目标代码。目标代码是有机器指令组成，不能独立运行，因为源程序中可能使用了一些汇编程序不能解释引用的库函数，而库函数又不在源程序中，此时还需要链接程序完成外部引用和目标模板调用的链接任务，最后才能输出可执行代码。</li><li><strong>解释型语言</strong>，解释器不产生目标机器代码，而是产生中间代码，这种中间代码与机器代码不同，中间代码的解释是由软件支持的，不能直接使用在硬件上。该软件解释器通常会导致执行效率较低，用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。和编译的程序不同的是, 解释程序的任务是逐一将源代码的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。对于解释型语言，需要一个专门的解释器来执行该程序，每条语句只有在执行是才能被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。</li><li><strong>Java解释器</strong>，java很特殊，java是需要编译的，但是没有直接编译成机器语言，而是编译成字节码，然后在Java虚拟机上用解释的方式执行字节码。Python也使用了类似的方式，先将python编译成python字节码，然后由一个专门的python字节码解释器负责解释执行字节码。</li><li><strong>python是一门解释语言</strong>，但是出于效率的考虑，提供了一种编译的方法。编译之后就得到pyc文件，存储了字节码。python这点和java很类似，但是java与python不同的是，python是一个解释型的语言，所以编译字节码不是一个强制的操作，事实上，编译是一个自动的过程，一般不会在意它的存在。编译成字节码可以节省加载模块的时间，提高效率。</li><li><strong>除了效率之外</strong>，字节码的形式也增加了反向工程的难度，可以保护源代码。这个只是一定程度上的保护，反编译还是可以的。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习记录</title>
      <link href="2019/11/14/%E5%9F%BA%E7%A1%80/Python%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB/"/>
      <url>2019/11/14/%E5%9F%BA%E7%A1%80/Python%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="python学习路线"><a href="#python学习路线" class="headerlink" title="python学习路线"></a>python学习路线</h2><h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><p>一.<a href="http://127.0.0.1:4000/2019/11/14/%E4%B8%80.%E5%88%9D%E8%AF%86Python/">初识Python</a></p><p>​    ①对计算机基本认识</p><p>​    ②了解Python发展史</p><p>​    ③”hello word”</p><p>​    ④变量</p><p>​    ⑤常量</p><p>​    ⑥Python基本数据类型</p><p>​    ⑦用户交互</p><p>​    ⑧流程控制</p><p>​    ⑨while循环</p><p>​    ⑩格式化输出</p><p>二.<a href="http://127.0.0.1:4000/2019/11/15/%E4%BA%8C.%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%BC%96%E7%A0%81/">运算符和编码</a></p><p>​    ①运算符</p><p>​    ②编码</p><p>三.<a href="http://127.0.0.1:4000/2019/11/15/%E4%B8%89.%E6%95%B0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/">数和字符串</a></p><p>​    ①基本类型介绍</p><p>​    ②int</p><p>​    ③类型转换</p><p>​    ④字符串</p><p>​    ⑤索引和切片</p><p>​    ⑥字符串操作</p><p>四.<a href="http://127.0.0.1:4000/2019/11/15/%E5%9B%9B.%E5%88%97%E8%A1%A8/">列表</a></p><p>​    ①初识列表</p><p>​    ②列表添加</p><p>​    ③列表删除</p><p>​    ④列表修改和查询</p><p>​    ⑤列表的嵌套</p><p>​    ⑥元组</p><p>​    ⑦range</p><p>五.<a href="http://127.0.0.1:4000/2019/11/15/%E4%BA%94.%E5%AD%97%E5%85%B8/">字典</a></p><p>​    ①初始字典</p><p>​    ②字典的添加</p><p>​    ③字典的删除</p><p>​    ④字典的修改和删除</p><p>​    ⑤遍历字典</p><p>​    ⑥keys,values,items</p><p>​    ⑦字典嵌套</p><p>​    ⑧set集合</p><p>六.<a href="http://127.0.0.1:4000/2019/11/15/%E5%9F%BA%E7%A1%80/6.%E5%B0%8F%E6%95%B0%E6%8D%AE%E6%B1%A0/">小数据池</a></p><p>​    ①小数据池</p><p>​    ②is和==区别</p><p>​    ③decode和encode</p><p>七.<a href="http://127.0.0.1:4000/2019/11/15/%E5%9F%BA%E7%A1%80/7.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/">深浅拷贝</a></p><p>​    ①基本数据类型补充</p><p>​    ②深浅拷贝</p><p>八.<a href="http://127.0.0.1:4000/2019/11/15/%E5%9F%BA%E7%A1%80/8.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">文件操作</a></p><p>​    ①文件基本操作</p><p>​    ②文件的实际操作</p><p>九.初识函数</p><p>​    ①初始函数</p><p>​    ②函数的返回值</p><p>​    ③函数的形参实参</p><p>十.函数进阶</p><p>​    ①动态传参</p><p>​    ②作用域和名称空间</p><p>​    ③函数嵌套</p><p>​    ④nonlocal和global</p><p>十一.第一类对象、闭包、迭代器</p><p>​    ①第一类对象</p><p>​    ②闭包</p><p>​    ③迭代器</p><p>十二.生成器和各种推导式</p><p>​    ①生成器函数</p><p>​    ②推导式和生成器表达式</p><p>十三.内置函数</p><p>​    ①内置函数</p><p>十四.递归、二分法查找</p><p>​    ①递归</p><p>​    ②二分法查找</p><p>十五.装饰器</p><p>​    ①装饰器</p><p>​    ②带参数的装饰器</p><p>​    ③装饰器的应用</p><p>十六.初识面向对象</p><p>​    ①类与对象</p><p>十七.面向对象成员</p><p>​    ①类变量</p><p>​    ②属性</p><p>十八.类于类之间的关系</p><p>​    ①依赖关系</p><p>十九.反射</p><p>​    ①isinstance type issubclass</p><p>​    ②反射</p><p>二十.类的约束</p><p>​    ①类的约束</p><p>二十一.MRO C3算法</p><p>​    ①继承</p><p>二十二.模块</p><p>​    ①栈和队列</p><p>​    ②时间</p><p>二十三.模块</p><p>二十四.re模块</p><p>二十五.模块和包</p><hr><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>二十六.socket</p><p>二十七.网络通信协议 tcp udp区别</p><p>二十八.黏包及黏包解决方案</p><p>二十九.socketserver ftp功能简单讲解</p><hr><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>三十.操作系统介绍 进程的创建</p><p>三十一.锁 队列 前面课程重点总结</p><p>三十二.信号量 事件 管道 进程池</p><p>三十三.线程的创建 验证线程之间共享数据 守护线程 线程进程效率对比 锁 死锁 递归锁</p><p>三十四.线程池 协程</p><hr><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>三十五.数据库介绍和初识sql</p><p>三十六.数据库表操作 数据类型 完整性约束</p><p>三十七.行记录的操作</p><p>三十八.多表操作 navicat pymysql</p><p>三十九.数据库索引</p><p>四十.数据库索引补充 存储过程 事务等</p><hr><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>四十一.前端HTML CSS基本选择器</p><p>四十二.前端CSS选择器</p><p>四十三.前端css样式</p><p>四十四.cssy其他样式 js初识</p><p>四十五.js补充 bom dom操作</p><p>四十六.js事件和小米商城作业讲解</p><p>四十七.jquery 选择器 筛选器 样式操作 属性操作等</p><p>四十八.jquery 事件 动画效果 each循环 data 插件</p><p>四十九.jquery作业讲解 bootstrap框架学习</p><hr><h3 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h3><ol start="50"><li><p>django第一天 自定义框架</p></li><li><p>django第二天 django初识</p></li><li><p>django第三天 url和视图</p></li><li><p>url反向解析图解 模板渲染</p></li><li><p>组件 CBV FBV 装饰器 ORM增删改查</p></li><li><p>CBV FBV演示 单表查询的其他方法</p></li><li><p>多表增加和查询</p></li><li><p>基于对象和基于双下划线的多表查询</p></li><li><p>聚合 分组查询 自定义标签过滤器 外部调 用django环境 事务和锁</p></li><li><p>ajax初识 登录认证练习</p></li><li><p>form和ajax上传文件 contentType</p></li><li><p>cookie和session</p></li><li><p>中间件</p></li><li><p>form组件 io 多路复用</p></li></ol><hr><h3 id="CRM"><a href="#CRM" class="headerlink" title="CRM"></a>CRM</h3><ol start="64"><li><p>rm 登录注册 modelform</p></li><li><p>展示客户信息 分页</p></li><li><p>添加客户 编辑客户 私户公户转化</p></li><li><p>模糊查询 分页保留搜索条件 编辑后跳转原页面  跟进记录管理 报名表管理</p></li><li><p>公私户转化加行级锁事务 get_or_create update_or_create 批量插入 modelformset</p></li><li><p>权限管理 表结构 简单实现</p></li><li><p>动态左侧菜单</p></li><li><p>权限菜单排序 面包条导航栏 按钮粒度权限控制</p></li><li><p>权限控制组件流程 角色管理 删除合并 权限展示</p></li><li><p>权限组件的应用 批量操作 + 权限分配</p></li></ol><hr><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol start="74"><li>linux 命令学习</li><li>linux 安装python</li><li>linux 命令</li><li>虚拟环境 尝试部署crm</li><li>nginx 压力测试 反向代理</li><li>nginx集群 项目部署</li><li>supervisor 项目部署练习</li><li>mysql 主从复制 redis哨兵集群</li><li>docker容器 linux图形界面安装pycharm</li></ol><hr><h3 id="前后端分离项目"><a href="#前后端分离项目" class="headerlink" title="前后端分离项目"></a>前后端分离项目</h3><p>djangorestframework </p><ol start="83"><li><p>ES6 vue介绍基本语法 指令系统</p></li><li><p>vue组件 过滤器s</p></li><li><p>生命周期 为啥做单页 vue-router vue-cli脚手架</p></li><li><p>动态路由 登录注册gt vue-cookie</p></li><li><p>vue内容回顾</p></li><li><p>djangorestframework 解析器组件 APIView</p></li><li><p>djangorestframework 序列化组件 serializers</p></li><li><p>视图组件 坑readonly 和csrf 合法性验证</p></li><li><p>认证 权限 访问频率 url注册器 响应器</p></li><li><p>分页组件 简单复杂同源问题 django自带contentType表</p></li><li><p>redis操作 课程信息展示 登录验证 redis存放token</p></li><li><p>购物车redis使用 接口设计</p></li><li><p>支付验证 计算 订单生成 RSA数字签名公匙私匙 支付宝接口跳转</p></li><li><p>getest滑动验证 前后端联调</p></li></ol><p>flask</p><p>第一篇 你好,我叫Flask</p><p>第二篇 Flask 中的 Render Redirect HttpResponse</p><p>第三篇 Flask 中的 request 之 先知道有这么个东西</p><p>第四篇 Flask 中的模板语言 Jinja2 及 render_template 的深度用法</p><p>第五篇 做一个用户登录之后查看学员信息的小例子</p><p>第六篇 Flask 中内置的 Session</p><p>第七篇 Flask 中路由系统</p><p>第八篇 实例化Flask的参数 及 对app的配置</p><p>第九篇 Flask 中的蓝图(BluePrint)</p><p>第十篇 before_request after_request</p><p>第十一篇 Celery - 一个懂得 异步任务 , 定时任务 , 周期任务</p><p>第十二篇 DBUtils - Python数据库连接池</p><p>第十三篇 SQLAlchemy 增删改查 一对多 多对多</p><p>第十四篇 Flask-SQLAlchemy</p><p>第十五篇 Flask-Script</p><p>第十六篇 Flask-Migrate</p><p>人工智能应用</p><p>第一篇 _ 你得会点儿Python基础</p><p>第二篇 _ 算法实在太难了有现成的直接用吧</p><p>第三篇 _ PyAudio 实现录音 自动化交互实现问答</p><p>第四篇 _ jieba gensim 最好别分家之最简单的相似度实现</p><hr><h3 id="自动化运维-devops"><a href="#自动化运维-devops" class="headerlink" title="自动化运维(devops)"></a>自动化运维(devops)</h3><p>git</p><p>celery</p><p>ansible</p><hr><h3 id="elasticsearch-kibana"><a href="#elasticsearch-kibana" class="headerlink" title="elasticsearch kibana"></a>elasticsearch kibana</h3><hr><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><hr><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><hr><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
